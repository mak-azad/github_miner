Project Name,Commit Hash,Message,Commit Date,Author Name,Additions,Deletions,Lines changed,Files Changed,Modified files,Original Code,Modified Code,Methods Before,Methods After
thefuck,71f1f4224b267711bd9cc372a2ec69902f423a01,Initial commit,2015-04-08 18:15:49+02:00,nvbn,362,0,362,11,"['.gitignore', 'README.md', 'requirements.txt', 'setup.cfg', 'setup.py', 'test_git_push.py', 'test_sudo.py', 'test_main.py', 'main.py', 'git_push.py', 'sudo.py']","[None, None, None, None, None, None, None, None, None, None, None]","['# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nenv/\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\n*.egg-info/\n.installed.cfg\n*.egg\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*,cover\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\ntarget/\n\n.env\n.idea\n', ""# The Fuck\n\nMagnificent app which corrects your previous console command.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip3 install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip3 install -r requirements.txt\npython3 setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'pytest\n', '[egg_info]\ntag_build = dev\ntag_svn_revision = true\n', 'from setuptools import setup, find_packages\n\n\nversion = \'1\'\n\nsetup(name=\'thefuck\',\n      version=version,\n      description="""",\n      long_description=""""""\\\n"""""",\n      classifiers=[],  # Get strings from http://pypi.python.org/pypi?%3Aaction=list_classifiers\n      keywords=\'\',\n      author=\'\',\n      author_email=\'\',\n      url=\'\',\n      license=\'\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\n          # -*- Extra requirements: -*-\n      ],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\',\n      ]},\n      )\n', 'import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.git_push import match, get_new_command\n\n\n@pytest.fixture\ndef stderr():\n    return \'\'\'fatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\'\'\'\n\n\ndef test_match(stderr):\n    assert match(Command(\'git push master\', \'\', stderr))\n    assert not match(Command(\'git push master\', \'\', \'\'))\n    assert not match(Command(\'ls\', \'\', stderr))\n\n\ndef test_get_new_command(stderr):\n    assert get_new_command(Command(\'\', \'\', stderr))\\\n        == ""git push --set-upstream origin master""\n', ""from thefuck.main import Command\nfrom thefuck.rules.sudo import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('', '', 'Permission denied'))\n    assert match(Command('', '', 'permission denied'))\n    assert not match(Command('', '', ''))\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('ls', '', '')) == 'sudo ls'\n"", ""from unittest.mock import patch, Mock\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom thefuck import main\n\n\ndef test_setup_user_dir():\n    with patch('thefuck.main.Path.is_dir', return_value=False), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 2\n        assert touch.call_count == 1\n    with patch('thefuck.main.Path.is_dir', return_value=True), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 0\n        assert touch.call_count == 0\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(main.Settings(None), Path('bash.py'))\n    assert main.is_rule_enabled(main.Settings(['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(main.Settings(['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            main.Settings(None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            main.Settings(['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x: x.script == 'cd ..', None),\n             main.Rule(lambda _: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nSettings = namedtuple(\'Settings\', (\'rules\',))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir() -> Path:\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir: Path) -> Settings:\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    return Settings(getattr(settings, \'rules\', None))\n\n\ndef is_rule_enabled(settings: Settings, rule: Path) -> bool:\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule: Path) -> Rule:\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir: Path, settings: Settings) -> [Rule]:\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if is_rule_enabled(settings, rule)]\n\n\ndef get_command(args: [str]) -> Command:\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command: Command, rules: [Rule]) -> Rule:\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command):\n            return rule\n\n\ndef run_rule(rule: Rule, command: Command):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command)\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules)\n    if matched_rule:\n        run_rule(matched_rule, command)\n    else:\n        print(\'echo No fuck given\')\n', ""def match(command):\n    return ('git' in command.script\n            and 'push' in command.script\n            and 'set-upstream' in command.stderr)\n\n\ndef get_new_command(command):\n    return command.stderr.split('\\n')[-3].strip()\n"", ""def match(command):\n    return 'permission denied' in command.stderr.lower()\n\n\ndef get_new_command(command):\n    return 'sudo {}'.format(command.script)\n""]","[[], [], [], [], [], [], [], [], [], [], []]","[[], [], [], [], [], [<pydriller.domain.commit.Method object at 0x7f1983cccc10>, <pydriller.domain.commit.Method object at 0x7f1983cccac0>, <pydriller.domain.commit.Method object at 0x7f1983ccc940>], [<pydriller.domain.commit.Method object at 0x7f1983d45e80>, <pydriller.domain.commit.Method object at 0x7f1983d45fd0>], [<pydriller.domain.commit.Method object at 0x7f1983d452b0>, <pydriller.domain.commit.Method object at 0x7f1983ce9be0>, <pydriller.domain.commit.Method object at 0x7f1983ce9c10>, <pydriller.domain.commit.Method object at 0x7f1983d45400>, <pydriller.domain.commit.Method object at 0x7f1983d452e0>, <pydriller.domain.commit.Method object at 0x7f1983ce9d60>, <pydriller.domain.commit.Method object at 0x7f1983d45160>], [<pydriller.domain.commit.Method object at 0x7f1983cf02e0>, <pydriller.domain.commit.Method object at 0x7f1983ce92e0>, <pydriller.domain.commit.Method object at 0x7f1983cf0970>, <pydriller.domain.commit.Method object at 0x7f1983ce9430>, <pydriller.domain.commit.Method object at 0x7f1983cf0940>, <pydriller.domain.commit.Method object at 0x7f1983ce9190>, <pydriller.domain.commit.Method object at 0x7f1983cf0a90>, <pydriller.domain.commit.Method object at 0x7f1983cf0d60>, <pydriller.domain.commit.Method object at 0x7f1983ce9160>], [<pydriller.domain.commit.Method object at 0x7f1983cdd430>, <pydriller.domain.commit.Method object at 0x7f1983cdd2e0>], [<pydriller.domain.commit.Method object at 0x7f1983cd1400>, <pydriller.domain.commit.Method object at 0x7f1983cd1940>]]"
thefuck,327c3a0cf5647ef6ae7a8fc273f7db70a3c4ee90,Fill setup.py,2015-04-08 18:19:01+02:00,nvbn,7,21,28,2,"['setup.cfg', 'setup.py']","['[egg_info]\ntag_build = dev\ntag_svn_revision = true\n', 'from setuptools import setup, find_packages\n\n\nversion = \'1\'\n\nsetup(name=\'thefuck\',\n      version=version,\n      description="""",\n      long_description=""""""\\\n"""""",\n      classifiers=[],  # Get strings from http://pypi.python.org/pypi?%3Aaction=list_classifiers\n      keywords=\'\',\n      author=\'\',\n      author_email=\'\',\n      url=\'\',\n      license=\'\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\n          # -*- Extra requirements: -*-\n      ],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\',\n      ]},\n      )\n']","[None, 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.0,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","[[], []]","[[], []]"
thefuck,8e5cc9d73a08acafef64848a81fd63cbc89e8490,Add command not found handler,2015-04-08 19:00:03+02:00,nvbn,79,1,80,5,"['README.md', 'setup.py', 'test_no_command.py', 'main.py', 'no_command.py']","[""# The Fuck\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip3 install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip3 install -r requirements.txt\npython3 setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.0,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', None, 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nSettings = namedtuple(\'Settings\', (\'rules\',))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir() -> Path:\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir: Path) -> Settings:\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    return Settings(getattr(settings, \'rules\', None))\n\n\ndef is_rule_enabled(settings: Settings, rule: Path) -> bool:\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule: Path) -> Rule:\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir: Path, settings: Settings) -> [Rule]:\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if is_rule_enabled(settings, rule)]\n\n\ndef get_command(args: [str]) -> Command:\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command: Command, rules: [Rule]) -> Rule:\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command):\n            return rule\n\n\ndef run_rule(rule: Rule, command: Command):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command)\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules)\n    if matched_rule:\n        run_rule(matched_rule, command)\n    else:\n        print(\'echo No fuck given\')\n', None]","[""# The Fuck\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip3 install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip3 install -r requirements.txt\npython3 setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.1,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from unittest.mock import patch\nimport pytest\nfrom subprocess import PIPE\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\ndef test_match(command_found, command_not_found):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''))\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''))\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''))\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n\n\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''))\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', '')) \\\n            == 'sudo apt-get install vim'\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom os import environ\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nSettings = namedtuple(\'Settings\', (\'rules\',))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir() -> Path:\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir: Path) -> Settings:\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    return Settings(getattr(settings, \'rules\', None))\n\n\ndef is_rule_enabled(settings: Settings, rule: Path) -> bool:\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule: Path) -> Rule:\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir: Path, settings: Settings) -> [Rule]:\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if is_rule_enabled(settings, rule)]\n\n\ndef get_command(args: [str]) -> Command:\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command: Command, rules: [Rule]) -> Rule:\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command):\n            return rule\n\n\ndef run_rule(rule: Rule, command: Command):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command)\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules)\n    if matched_rule:\n        run_rule(matched_rule, command)\n    else:\n        print(\'echo No fuck given\')\n', 'from subprocess import Popen, PIPE\nimport re\n\n\ndef _get_output(command):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'/usr/lib/command-not-found {}\'.format(name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\ndef match(command):\n    output = _get_output(command)\n    return ""No command"" in output and ""from package"" in output\n\n\ndef get_new_command(command):\n    output = _get_output(command)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name)\n']","[[], [], [], [<pydriller.domain.commit.Method object at 0x7f1983d35fd0>, <pydriller.domain.commit.Method object at 0x7f1983d35e80>, <pydriller.domain.commit.Method object at 0x7f1983d35eb0>, <pydriller.domain.commit.Method object at 0x7f1983d35d30>, <pydriller.domain.commit.Method object at 0x7f1983d356a0>, <pydriller.domain.commit.Method object at 0x7f1983d356d0>, <pydriller.domain.commit.Method object at 0x7f1983d35550>, <pydriller.domain.commit.Method object at 0x7f1983d35580>, <pydriller.domain.commit.Method object at 0x7f1983d35400>], []]","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983cd76d0>, <pydriller.domain.commit.Method object at 0x7f1983cd7580>, <pydriller.domain.commit.Method object at 0x7f1983d41fd0>, <pydriller.domain.commit.Method object at 0x7f1983cd7400>], [], [<pydriller.domain.commit.Method object at 0x7f1983d2ebe0>, <pydriller.domain.commit.Method object at 0x7f1983d2eeb0>, <pydriller.domain.commit.Method object at 0x7f1983d2ed60>]]"
thefuck,173a4300b40653458614c9fdf73ed740289d7357,Fix sudo after npm errors,2015-04-08 19:16:15+02:00,nvbn,4,2,6,3,"['setup.py', 'test_sudo.py', 'sudo.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.1,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from thefuck.main import Command\nfrom thefuck.rules.sudo import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('', '', 'Permission denied'))\n    assert match(Command('', '', 'permission denied'))\n    assert not match(Command('', '', ''))\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('ls', '', '')) == 'sudo ls'\n"", ""def match(command):\n    return 'permission denied' in command.stderr.lower()\n\n\ndef get_new_command(command):\n    return 'sudo {}'.format(command.script)\n""]","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.2,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', 'from thefuck.main import Command\nfrom thefuck.rules.sudo import match, get_new_command\n\n\ndef test_match():\n    assert match(Command(\'\', \'\', \'Permission denied\'))\n    assert match(Command(\'\', \'\', \'permission denied\'))\n    assert match(Command(\'\', \'\', ""npm ERR! Error: EACCES, unlink""))\n    assert not match(Command(\'\', \'\', \'\'))\n\n\ndef test_get_new_command():\n    assert get_new_command(Command(\'ls\', \'\', \'\')) == \'sudo ls\'\n', ""def match(command):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command):\n    return 'sudo {}'.format(command.script)\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983ce3190>, <pydriller.domain.commit.Method object at 0x7f1983ce3940>], [<pydriller.domain.commit.Method object at 0x7f1983ccca90>, <pydriller.domain.commit.Method object at 0x7f1983ccce80>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d41be0>], [<pydriller.domain.commit.Method object at 0x7f1983ce3040>]]"
thefuck,9ed022d67f451331f4ac3535cd7f4041cf43a863,Pass settings to the rules,2015-04-08 21:08:35+02:00,nvbn,50,47,97,8,"['test_git_push.py', 'test_no_command.py', 'test_sudo.py', 'test_main.py', 'main.py', 'git_push.py', 'no_command.py', 'sudo.py']","['import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.git_push import match, get_new_command\n\n\n@pytest.fixture\ndef stderr():\n    return \'\'\'fatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\'\'\'\n\n\ndef test_match(stderr):\n    assert match(Command(\'git push master\', \'\', stderr))\n    assert not match(Command(\'git push master\', \'\', \'\'))\n    assert not match(Command(\'ls\', \'\', stderr))\n\n\ndef test_get_new_command(stderr):\n    assert get_new_command(Command(\'\', \'\', stderr))\\\n        == ""git push --set-upstream origin master""\n', ""from unittest.mock import patch\nimport pytest\nfrom subprocess import PIPE\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\ndef test_match(command_found, command_not_found):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''))\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''))\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''))\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n\n\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''))\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', '')) \\\n            == 'sudo apt-get install vim'\n"", 'from thefuck.main import Command\nfrom thefuck.rules.sudo import match, get_new_command\n\n\ndef test_match():\n    assert match(Command(\'\', \'\', \'Permission denied\'))\n    assert match(Command(\'\', \'\', \'permission denied\'))\n    assert match(Command(\'\', \'\', ""npm ERR! Error: EACCES, unlink""))\n    assert not match(Command(\'\', \'\', \'\'))\n\n\ndef test_get_new_command():\n    assert get_new_command(Command(\'ls\', \'\', \'\')) == \'sudo ls\'\n', ""from unittest.mock import patch, Mock\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom thefuck import main\n\n\ndef test_setup_user_dir():\n    with patch('thefuck.main.Path.is_dir', return_value=False), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 2\n        assert touch.call_count == 1\n    with patch('thefuck.main.Path.is_dir', return_value=True), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 0\n        assert touch.call_count == 0\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(main.Settings(None), Path('bash.py'))\n    assert main.is_rule_enabled(main.Settings(['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(main.Settings(['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            main.Settings(None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            main.Settings(['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x: x.script == 'cd ..', None),\n             main.Rule(lambda _: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom os import environ\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nSettings = namedtuple(\'Settings\', (\'rules\',))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir() -> Path:\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir: Path) -> Settings:\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    return Settings(getattr(settings, \'rules\', None))\n\n\ndef is_rule_enabled(settings: Settings, rule: Path) -> bool:\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule: Path) -> Rule:\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir: Path, settings: Settings) -> [Rule]:\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if is_rule_enabled(settings, rule)]\n\n\ndef get_command(args: [str]) -> Command:\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command: Command, rules: [Rule]) -> Rule:\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command):\n            return rule\n\n\ndef run_rule(rule: Rule, command: Command):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command)\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules)\n    if matched_rule:\n        run_rule(matched_rule, command)\n    else:\n        print(\'echo No fuck given\')\n', ""def match(command):\n    return ('git' in command.script\n            and 'push' in command.script\n            and 'set-upstream' in command.stderr)\n\n\ndef get_new_command(command):\n    return command.stderr.split('\\n')[-3].strip()\n"", 'from subprocess import Popen, PIPE\nimport re\n\n\ndef _get_output(command):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'/usr/lib/command-not-found {}\'.format(name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\ndef match(command):\n    output = _get_output(command)\n    return ""No command"" in output and ""from package"" in output\n\n\ndef get_new_command(command):\n    output = _get_output(command)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name)\n', ""def match(command):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command):\n    return 'sudo {}'.format(command.script)\n""]","['import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.git_push import match, get_new_command\n\n\n@pytest.fixture\ndef stderr():\n    return \'\'\'fatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\'\'\'\n\n\ndef test_match(stderr):\n    assert match(Command(\'git push master\', \'\', stderr), None)\n    assert not match(Command(\'git push master\', \'\', \'\'), None)\n    assert not match(Command(\'ls\', \'\', stderr), None)\n\n\ndef test_get_new_command(stderr):\n    assert get_new_command(Command(\'\', \'\', stderr), None)\\\n        == ""git push --set-upstream origin master""\n', ""from unittest.mock import patch, Mock\nimport pytest\nfrom subprocess import PIPE\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\ndef test_match(command_found, command_not_found):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), None)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), None)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), None)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), None) \\\n            == 'sudo apt-get install vim'\n"", 'from thefuck.main import Command\nfrom thefuck.rules.sudo import match, get_new_command\n\n\ndef test_match():\n    assert match(Command(\'\', \'\', \'Permission denied\'), None)\n    assert match(Command(\'\', \'\', \'permission denied\'), None)\n    assert match(Command(\'\', \'\', ""npm ERR! Error: EACCES, unlink""), None)\n    assert not match(Command(\'\', \'\', \'\'), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command(\'ls\', \'\', \'\'), None) == \'sudo ls\'\n', ""from unittest.mock import patch, Mock\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom thefuck import main\n\n\ndef test_setup_user_dir():\n    with patch('thefuck.main.Path.is_dir', return_value=False), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 2\n        assert touch.call_count == 1\n    with patch('thefuck.main.Path.is_dir', return_value=True), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 0\n        assert touch.call_count == 0\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda _, _: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir() -> Path:\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir: Path):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule: Path) -> bool:\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule: Path) -> Rule:\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir: Path, settings) -> [Rule]:\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if is_rule_enabled(settings, rule)]\n\n\ndef get_command(args: [str]) -> Command:\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command: Command, rules: [Rule], settings) -> Rule:\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule: Rule, command: Command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules, settings)\n    if matched_rule:\n        run_rule(matched_rule, command, settings)\n    else:\n        print(\'echo No fuck given\')\n', ""def match(command, settings):\n    return ('git' in command.script\n            and 'push' in command.script\n            and 'set-upstream' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return command.stderr.split('\\n')[-3].strip()\n"", 'from subprocess import Popen, PIPE\nimport re\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(getattr(settings, \'command_not_found\',\n                                          \'/usr/lib/command-not-found\'),\n                                  name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\ndef match(command, settings):\n    output = _get_output(command, settings)\n    return ""No command"" in output and ""from package"" in output\n\n\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name)\n', ""def match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983cdd400>, <pydriller.domain.commit.Method object at 0x7f1983cdd550>, <pydriller.domain.commit.Method object at 0x7f1983d28430>], [<pydriller.domain.commit.Method object at 0x7f1983cdd040>, <pydriller.domain.commit.Method object at 0x7f1983cdd2b0>, <pydriller.domain.commit.Method object at 0x7f1983cddd30>, <pydriller.domain.commit.Method object at 0x7f1983cd17f0>], [<pydriller.domain.commit.Method object at 0x7f1983cf07f0>, <pydriller.domain.commit.Method object at 0x7f1983ce92b0>], [<pydriller.domain.commit.Method object at 0x7f1983d45d30>, <pydriller.domain.commit.Method object at 0x7f1983d45550>, <pydriller.domain.commit.Method object at 0x7f1983d456d0>, <pydriller.domain.commit.Method object at 0x7f1983d45580>, <pydriller.domain.commit.Method object at 0x7f1983cd7d30>, <pydriller.domain.commit.Method object at 0x7f1983cd7fd0>, <pydriller.domain.commit.Method object at 0x7f1983cd7be0>], [<pydriller.domain.commit.Method object at 0x7f1983ce37f0>, <pydriller.domain.commit.Method object at 0x7f1983ce3e80>, <pydriller.domain.commit.Method object at 0x7f1983ce3400>, <pydriller.domain.commit.Method object at 0x7f1983d41a90>, <pydriller.domain.commit.Method object at 0x7f1983d41190>, <pydriller.domain.commit.Method object at 0x7f1983d41eb0>, <pydriller.domain.commit.Method object at 0x7f1983d41d30>, <pydriller.domain.commit.Method object at 0x7f1983d3be80>, <pydriller.domain.commit.Method object at 0x7f1983d3b2e0>], [<pydriller.domain.commit.Method object at 0x7f1983d35d60>, <pydriller.domain.commit.Method object at 0x7f1983d35a90>], [<pydriller.domain.commit.Method object at 0x7f1983d17c10>, <pydriller.domain.commit.Method object at 0x7f1983d17d60>, <pydriller.domain.commit.Method object at 0x7f1983d17a90>], [<pydriller.domain.commit.Method object at 0x7f1983d10400>, <pydriller.domain.commit.Method object at 0x7f1983d10550>]]","[[<pydriller.domain.commit.Method object at 0x7f1983cd16a0>, <pydriller.domain.commit.Method object at 0x7f1983cd12e0>], [<pydriller.domain.commit.Method object at 0x7f1983d1cfd0>, <pydriller.domain.commit.Method object at 0x7f1983d1ce80>], [<pydriller.domain.commit.Method object at 0x7f1983d23400>, <pydriller.domain.commit.Method object at 0x7f1983d23190>], [<pydriller.domain.commit.Method object at 0x7f1983d28be0>, <pydriller.domain.commit.Method object at 0x7f1983d28580>, <pydriller.domain.commit.Method object at 0x7f1983d28820>], [<pydriller.domain.commit.Method object at 0x7f1983d41190>, <pydriller.domain.commit.Method object at 0x7f1983ce3d30>, <pydriller.domain.commit.Method object at 0x7f1983ce32e0>, <pydriller.domain.commit.Method object at 0x7f1983ce3430>, <pydriller.domain.commit.Method object at 0x7f1983ccc6d0>, <pydriller.domain.commit.Method object at 0x7f1983ce3820>, <pydriller.domain.commit.Method object at 0x7f1983d3be80>, <pydriller.domain.commit.Method object at 0x7f1983d41d30>, <pydriller.domain.commit.Method object at 0x7f1983ce3400>, <pydriller.domain.commit.Method object at 0x7f1983cccfd0>], [<pydriller.domain.commit.Method object at 0x7f1983d3b550>, <pydriller.domain.commit.Method object at 0x7f1983d3b160>, <pydriller.domain.commit.Method object at 0x7f1983d35d60>, <pydriller.domain.commit.Method object at 0x7f1983d35a90>], [<pydriller.domain.commit.Method object at 0x7f1983d1c580>, <pydriller.domain.commit.Method object at 0x7f1983d17d60>, <pydriller.domain.commit.Method object at 0x7f1983d17c10>, <pydriller.domain.commit.Method object at 0x7f1983d1cd60>, <pydriller.domain.commit.Method object at 0x7f1983d1c550>, <pydriller.domain.commit.Method object at 0x7f1983d17a90>], [<pydriller.domain.commit.Method object at 0x7f1983d10eb0>, <pydriller.domain.commit.Method object at 0x7f1983d10d60>, <pydriller.domain.commit.Method object at 0x7f1983d10400>, <pydriller.domain.commit.Method object at 0x7f1983d10550>]]"
thefuck,e7b377a3105d1b3d59e5e8b4882a325b9909fe21,"Add handler for ""is not a git command""",2015-04-08 21:20:11+02:00,nvbn,55,2,57,5,"['README.md', 'setup.py', 'test_git_not_command.py', 'git_not_command.py', 'no_command.py']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip3 install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip3 install -r requirements.txt\npython3 setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.2,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', None, None, 'from subprocess import Popen, PIPE\nimport re\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(getattr(settings, \'command_not_found\',\n                                          \'/usr/lib/command-not-found\'),\n                                  name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\ndef match(command, settings):\n    output = _get_output(command, settings)\n    return ""No command"" in output and ""from package"" in output\n\n\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name)\n']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\n* master\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip3 install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip3 install -r requirements.txt\npython3 setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.3,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', 'import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.git_not_command import match, get_new_command\n\n\n@pytest.fixture\ndef git_not_command():\n    return """"""git: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\nbranch\n""""""\n\n\n@pytest.fixture\ndef git_command():\n    return ""* master""\n\n\ndef test_match(git_not_command, git_command):\n    assert match(Command(\'git brnch\', \'\', git_not_command), None)\n    assert not match(Command(\'ls brnch\', \'\', git_not_command), None)\n    assert not match(Command(\'git branch\', \'\', git_command), None)\n\n\ndef test_get_new_command(git_not_command):\n    assert get_new_command(Command(\'git brnch\', \'\', git_not_command), None)\\\n        == \'git branch\'\n', 'import re\n\n\ndef match(command, settings):\n    return (\'git\' in command.script\n            and "" is not a git command. See \'git --help\'."" in command.stderr\n            and \'Did you mean this?\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r""git: \'([^\']*)\' is not a git command"",\n                            command.stderr)[0]\n    new_cmd = re.findall(r\'Did you mean this\\?\\n\\s*([^\\n]*)\',\n                         command.stderr)[0]\n    return command.script.replace(broken_cmd, new_cmd, 1)\n\n', 'from subprocess import Popen, PIPE\nimport re\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(getattr(settings, \'command_not_found\',\n                                          \'/usr/lib/command-not-found\'),\n                                  name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\ndef match(command, settings):\n    output = _get_output(command, settings)\n    return ""No command"" in output and ""from package"" in output\n\n\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n']","[[], [], [], [], [<pydriller.domain.commit.Method object at 0x7f1983d85400>, <pydriller.domain.commit.Method object at 0x7f1983d85430>, <pydriller.domain.commit.Method object at 0x7f1983d85970>]]","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983d7fc10>, <pydriller.domain.commit.Method object at 0x7f1983d7fbe0>, <pydriller.domain.commit.Method object at 0x7f1983d7feb0>, <pydriller.domain.commit.Method object at 0x7f1983d7fd60>], [<pydriller.domain.commit.Method object at 0x7f1983d7afd0>, <pydriller.domain.commit.Method object at 0x7f1983d7f190>], [<pydriller.domain.commit.Method object at 0x7f1983d7fa90>]]"
thefuck,282217fd02322229d918682e9152afe79ab43a5a,Fix tests,2015-04-08 21:22:59+02:00,nvbn,1,1,2,1,['test_main.py'],"[""from unittest.mock import patch, Mock\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom thefuck import main\n\n\ndef test_setup_user_dir():\n    with patch('thefuck.main.Path.is_dir', return_value=False), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 2\n        assert touch.call_count == 1\n    with patch('thefuck.main.Path.is_dir', return_value=True), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 0\n        assert touch.call_count == 0\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda _, _: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n""]","[""from unittest.mock import patch, Mock\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom thefuck import main\n\n\ndef test_setup_user_dir():\n    with patch('thefuck.main.Path.is_dir', return_value=False), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 2\n        assert touch.call_count == 1\n    with patch('thefuck.main.Path.is_dir', return_value=True), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 0\n        assert touch.call_count == 0\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983d10e80>, <pydriller.domain.commit.Method object at 0x7f1983d102e0>, <pydriller.domain.commit.Method object at 0x7f1983d10fd0>, <pydriller.domain.commit.Method object at 0x7f1983d10a90>, <pydriller.domain.commit.Method object at 0x7f1983d176a0>, <pydriller.domain.commit.Method object at 0x7f1983d17d30>, <pydriller.domain.commit.Method object at 0x7f1983d17e80>]]",[[<pydriller.domain.commit.Method object at 0x7f1983d102b0>]]
thefuck,2eb777a5bb41527b627ed0826eca3e16890ef83a,Add python 2 support,2015-04-17 16:24:03+02:00,nvbn,19,15,34,9,"['.travis.yml', 'README.md', 'requirements.txt', 'setup.py', 'test_no_command.py', 'test_main.py', '__init__.py', 'main.py', '__init__.py']","['language: python\npython:\n  - ""3.4""\ninstall:\n  - python setup.py develop\n  - pip install -r requirements.txt\nscript: py.test\n', ""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\n* master\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip3 install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip3 install -r requirements.txt\npython3 setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'pytest\n', 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.3,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from unittest.mock import patch, Mock\nimport pytest\nfrom subprocess import PIPE\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\ndef test_match(command_found, command_not_found):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), None)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), None)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), None)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), None) \\\n            == 'sudo apt-get install vim'\n"", ""from unittest.mock import patch, Mock\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom thefuck import main\n\n\ndef test_setup_user_dir():\n    with patch('thefuck.main.Path.is_dir', return_value=False), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 2\n        assert touch.call_count == 1\n    with patch('thefuck.main.Path.is_dir', return_value=True), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 0\n        assert touch.call_count == 0\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", None, 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir() -> Path:\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir: Path):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule: Path) -> bool:\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule: Path) -> Rule:\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir: Path, settings) -> [Rule]:\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if is_rule_enabled(settings, rule)]\n\n\ndef get_command(args: [str]) -> Command:\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command: Command, rules: [Rule], settings) -> Rule:\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule: Rule, command: Command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules, settings)\n    if matched_rule:\n        run_rule(matched_rule, command, settings)\n    else:\n        print(\'echo No fuck given\')\n', None]","['language: python\npython:\n  - ""3.4""\n  - ""3.3""\n  - ""2.7""\ninstall:\n  - python setup.py develop\n  - pip install -r requirements.txt\nscript: py.test\n', ""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\n* master\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'pytest\nmock\n', 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.3,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\ndef test_match(command_found, command_not_found):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), None)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), None)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), None)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), None) \\\n            == 'sudo apt-get install vim'\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_setup_user_dir():\n    with patch('thefuck.main.Path.is_dir', return_value=False), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 2\n        assert touch.call_count == 1\n    with patch('thefuck.main.Path.is_dir', return_value=True), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 0\n        assert touch.call_count == 0\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", None, 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules, settings)\n    if matched_rule:\n        run_rule(matched_rule, command, settings)\n    else:\n        print(\'echo No fuck given\')\n', None]","[[], [], [], [], [<pydriller.domain.commit.Method object at 0x7f1983cd16d0>, <pydriller.domain.commit.Method object at 0x7f1983cd1a90>, <pydriller.domain.commit.Method object at 0x7f1983cd1430>, <pydriller.domain.commit.Method object at 0x7f1983d23820>], [<pydriller.domain.commit.Method object at 0x7f1983cf0160>, <pydriller.domain.commit.Method object at 0x7f1983cf0d30>, <pydriller.domain.commit.Method object at 0x7f1983cf0400>, <pydriller.domain.commit.Method object at 0x7f1983cf0be0>, <pydriller.domain.commit.Method object at 0x7f1983d28190>, <pydriller.domain.commit.Method object at 0x7f1983d282b0>, <pydriller.domain.commit.Method object at 0x7f1983d28160>], [], [<pydriller.domain.commit.Method object at 0x7f1983d45d60>, <pydriller.domain.commit.Method object at 0x7f1983d45ac0>, <pydriller.domain.commit.Method object at 0x7f1983d45940>, <pydriller.domain.commit.Method object at 0x7f1985075fa0>, <pydriller.domain.commit.Method object at 0x7f1983ce3be0>, <pydriller.domain.commit.Method object at 0x7f1983ce36a0>, <pydriller.domain.commit.Method object at 0x7f1983ce3c10>, <pydriller.domain.commit.Method object at 0x7f1983ce3d60>, <pydriller.domain.commit.Method object at 0x7f1983ce3ac0>], []]","[[], [], [], [], [], [], [], [<pydriller.domain.commit.Method object at 0x7f1983cd7190>, <pydriller.domain.commit.Method object at 0x7f1983d41430>, <pydriller.domain.commit.Method object at 0x7f1983d41400>, <pydriller.domain.commit.Method object at 0x7f1983ce3be0>, <pydriller.domain.commit.Method object at 0x7f1983ce3c10>, <pydriller.domain.commit.Method object at 0x7f1983cd7eb0>, <pydriller.domain.commit.Method object at 0x7f1983d45ac0>, <pydriller.domain.commit.Method object at 0x7f1983d41160>, <pydriller.domain.commit.Method object at 0x7f1983ce3d60>, <pydriller.domain.commit.Method object at 0x7f1983d41580>, <pydriller.domain.commit.Method object at 0x7f1985075fa0>, <pydriller.domain.commit.Method object at 0x7f1983cd7940>, <pydriller.domain.commit.Method object at 0x7f1983cd7a90>, <pydriller.domain.commit.Method object at 0x7f1983ce36a0>, <pydriller.domain.commit.Method object at 0x7f1983d45940>], []]"
thefuck,1503dcf294cd59f345b1ded6d24e0691f9414d32,Make `no_command` work only when apt available,2015-04-17 16:36:38+02:00,nvbn,42,9,51,3,"['test_no_command_apt.py', 'no_command_apt.py', 'utils.py']","[""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\ndef test_match(command_found, command_not_found):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), None)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), None)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), None)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), None) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(getattr(settings, \'command_not_found\',\n                                          \'/usr/lib/command-not-found\'),\n                                  name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\ndef match(command, settings):\n    output = _get_output(command, settings)\n    return ""No command"" in output and ""from package"" in output\n\n\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n', None]","[""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command_apt import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command_apt.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_match(command_found, command_not_found):\n    with patch('thefuck.rules.no_command_apt.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), None)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), None)\n\n    with patch('thefuck.rules.no_command_apt.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command_apt._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), None)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), None) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which\n\n\ndef _get_bin(settings):\n    return getattr(settings, \'command_not_found\', \'/usr/lib/command-not-found\')\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(_get_bin(settings), name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\ndef match(command, settings):\n    if which(\'apt-get\') and which(_get_bin(settings)):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n', 'import os\n\n\ndef which(program):\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n']","[[<pydriller.domain.commit.Method object at 0x7f1983d17be0>, <pydriller.domain.commit.Method object at 0x7f1983d17970>, <pydriller.domain.commit.Method object at 0x7f1983d172e0>, <pydriller.domain.commit.Method object at 0x7f1983d17190>], [<pydriller.domain.commit.Method object at 0x7f1983d7ffd0>, <pydriller.domain.commit.Method object at 0x7f1983d7f820>, <pydriller.domain.commit.Method object at 0x7f1983d7fe80>], []]","[[<pydriller.domain.commit.Method object at 0x7f1983cf0580>, <pydriller.domain.commit.Method object at 0x7f1983d1c2e0>, <pydriller.domain.commit.Method object at 0x7f1983d10be0>], [<pydriller.domain.commit.Method object at 0x7f1983d0bd60>, <pydriller.domain.commit.Method object at 0x7f1983d0b190>, <pydriller.domain.commit.Method object at 0x7f1983d0b940>], [<pydriller.domain.commit.Method object at 0x7f1983d85160>, <pydriller.domain.commit.Method object at 0x7f1983d85820>]]"
thefuck,1de9c5f77b4eab61f55d421e8baee07c0dc6f88d,"Add information about writting yourself rules, revert no_command changes",2015-04-17 17:01:30+02:00,nvbn,82,16,98,5,"['README.md', 'setup.py', 'test_no_command.py', 'no_command.py', 'utils.py']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\n* master\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.3,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command_apt import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command_apt.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_match(command_found, command_not_found):\n    with patch('thefuck.rules.no_command_apt.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), None)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), None)\n\n    with patch('thefuck.rules.no_command_apt.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command_apt._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), None)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), None) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which\n\n\ndef _get_bin(settings):\n    return getattr(settings, \'command_not_found\', \'/usr/lib/command-not-found\')\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(_get_bin(settings), name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\ndef match(command, settings):\n    if which(\'apt-get\') and which(_get_bin(settings)):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n', 'import os\n\n\ndef which(program):\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\n* master\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` have three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules]((https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py)).\n\n## Settings\n\nThe Fuck have a few settings parameters:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.4,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_match(command_found, command_not_found, settings):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), settings)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), settings)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), settings)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), settings) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n', 'from functools import wraps\nimport os\n\n\ndef which(program):\n    """"""Returns `program` path or `None`.""""""\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef wrap_settings(params):\n    """"""Adds default values to settings if it not presented.\n\n    Usage:\n\n        @wrap_settings({\'apt\': \'/usr/bin/apt\'})\n        def match(command, settings):\n            print(settings.apt)\n\n    """"""\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(command, settings):\n            for key, val in params.items():\n                if not hasattr(settings, key):\n                    setattr(settings, key, val)\n            return fn(command, settings)\n        return wrapper\n    return decorator\n']","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983d67eb0>, <pydriller.domain.commit.Method object at 0x7f1983d67940>, <pydriller.domain.commit.Method object at 0x7f1983d67d30>, <pydriller.domain.commit.Method object at 0x7f1983d67fd0>, <pydriller.domain.commit.Method object at 0x7f1983d6e550>], [<pydriller.domain.commit.Method object at 0x7f1983d85d30>, <pydriller.domain.commit.Method object at 0x7f1983d85040>, <pydriller.domain.commit.Method object at 0x7f1983d856a0>, <pydriller.domain.commit.Method object at 0x7f1983d7f940>], [<pydriller.domain.commit.Method object at 0x7f1983d106a0>, <pydriller.domain.commit.Method object at 0x7f1983d10190>]]","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983d67160>, <pydriller.domain.commit.Method object at 0x7f1983d67fd0>, <pydriller.domain.commit.Method object at 0x7f1983d67400>, <pydriller.domain.commit.Method object at 0x7f1983d676d0>, <pydriller.domain.commit.Method object at 0x7f1983d672b0>], [<pydriller.domain.commit.Method object at 0x7f1983d85d30>, <pydriller.domain.commit.Method object at 0x7f1983d74be0>, <pydriller.domain.commit.Method object at 0x7f1983d74400>], [<pydriller.domain.commit.Method object at 0x7f1983d0b550>, <pydriller.domain.commit.Method object at 0x7f1983d0b7f0>, <pydriller.domain.commit.Method object at 0x7f1983d0b2b0>, <pydriller.domain.commit.Method object at 0x7f1983d0bd30>]]"
thefuck,11cbb9e1f7c0009b9272426bf2c0f1b481a2dc3e,Print out the fucking command before running it,2015-04-17 16:07:50-04:00,Ford Hurley,6,1,7,2,"['README.md', 'main.py']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\n* master\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` have three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck have a few settings parameters:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules, settings)\n    if matched_rule:\n        run_rule(matched_rule, command, settings)\n    else:\n        print(\'echo No fuck given\')\n']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` have three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck have a few settings parameters:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules, settings)\n    if matched_rule:\n        run_rule(matched_rule, command, settings)\n    else:\n        print(\'echo No fuck given\')\n']","[[], [<pydriller.domain.commit.Method object at 0x7f1983d2eac0>, <pydriller.domain.commit.Method object at 0x7f1983d2ee80>, <pydriller.domain.commit.Method object at 0x7f1983d2ed30>, <pydriller.domain.commit.Method object at 0x7f1983d2e970>, <pydriller.domain.commit.Method object at 0x7f1983d1c7f0>, <pydriller.domain.commit.Method object at 0x7f1983d1c820>, <pydriller.domain.commit.Method object at 0x7f1983d1c940>, <pydriller.domain.commit.Method object at 0x7f1983d1c970>, <pydriller.domain.commit.Method object at 0x7f1983d1cac0>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983ce96a0>]]"
thefuck,48831fa850307d79b786076195ece1d387a4db5f,#1 Don't fuck twice,2015-04-17 22:09:46+02:00,nvbn,16,8,24,2,"['setup.py', 'main.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.4,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules, settings)\n    if matched_rule:\n        run_rule(matched_rule, command, settings)\n    else:\n        print(\'echo No fuck given\')\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.5,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    command = get_command(sys.argv)\n    if is_second_run(command):\n        print(""echo Can\'t fuck twice"")\n    else:\n        user_dir = setup_user_dir()\n        settings = get_settings(user_dir)\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n        else:\n            print(\'echo No fuck given\')\n']","[[], [<pydriller.domain.commit.Method object at 0x7f1983d562e0>, <pydriller.domain.commit.Method object at 0x7f1983d56430>, <pydriller.domain.commit.Method object at 0x7f1983d56160>, <pydriller.domain.commit.Method object at 0x7f1983d56190>, <pydriller.domain.commit.Method object at 0x7f1983d51ac0>, <pydriller.domain.commit.Method object at 0x7f1983d51940>, <pydriller.domain.commit.Method object at 0x7f1983d51970>, <pydriller.domain.commit.Method object at 0x7f1983d517f0>, <pydriller.domain.commit.Method object at 0x7f1983d51820>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d56ac0>, <pydriller.domain.commit.Method object at 0x7f1983d56940>]]"
thefuck,99e418f852f5e6e5269cbe31cf6e7329feba379c,Added rule for misspelled cd.. command,2015-04-17 22:14:01+02:00,Lars Michelsen,14,0,14,1,['cd_parent.py'],[None],"[""# Adds the missing space between the cd command and the target directory\n# when trying to cd to the parent directory.\n#\n# Does not really save chars, but is fun :D\n#\n# Example:\n# > cd..\n# cd..: command not found\n\ndef match(command, settings):\n    return command.script == 'cd..'\n\ndef get_new_command(command, settings):\n    return 'cd ..'\n""]",[[]],"[[<pydriller.domain.commit.Method object at 0x7f1983d56d60>, <pydriller.domain.commit.Method object at 0x7f1983d516a0>]]"
thefuck,2e91158091a9deb506fc369d46ca7f34119371f2,Fixed UnicodeDecodeError,2015-04-17 16:30:46-04:00,Alex Nastetsky,2,2,4,1,['main.py'],"['from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    command = get_command(sys.argv)\n    if is_second_run(command):\n        print(""echo Can\'t fuck twice"")\n    else:\n        user_dir = setup_user_dir()\n        settings = get_settings(user_dir)\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n        else:\n            print(\'echo No fuck given\')\n']","['from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(\'utf-8\'),\n                   result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    command = get_command(sys.argv)\n    if is_second_run(command):\n        print(""echo Can\'t fuck twice"")\n    else:\n        user_dir = setup_user_dir()\n        settings = get_settings(user_dir)\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n        else:\n            print(\'echo No fuck given\')\n']","[[<pydriller.domain.commit.Method object at 0x7f1983d62400>, <pydriller.domain.commit.Method object at 0x7f1983d622b0>, <pydriller.domain.commit.Method object at 0x7f1983d28c10>, <pydriller.domain.commit.Method object at 0x7f1983d28940>, <pydriller.domain.commit.Method object at 0x7f1983d7a820>, <pydriller.domain.commit.Method object at 0x7f1983d7a7f0>, <pydriller.domain.commit.Method object at 0x7f1983d7a970>, <pydriller.domain.commit.Method object at 0x7f1983d7aeb0>, <pydriller.domain.commit.Method object at 0x7f1983d7a2e0>, <pydriller.domain.commit.Method object at 0x7f1983d7aac0>]]",[[<pydriller.domain.commit.Method object at 0x7f1983d62580>]]
thefuck,73a893dc749a9430d2976c7350b7843943411d8f,Bump version,2015-04-17 22:31:10+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.5,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.6,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,bfbb8cd7d0ce90efb4178dcd0b6fda44d1a162af,Bump version,2015-04-17 22:42:18+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.6,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.7,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,14f0817a9920196019990eb5f079d23d43059494,added support for FreeBSD/PCBSD 'pkg' to sudo rule,2015-04-18 08:45:48+02:00,tpltnt,2,1,3,1,['sudo.py'],"[""def match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[""def match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr\n            or 'pkg: Insufficient privileges' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983d67d60>, <pydriller.domain.commit.Method object at 0x7f1983d67970>]]",[[<pydriller.domain.commit.Method object at 0x7f1983d74970>]]
thefuck,de343b84c1a58831fd711b1d70405aa574ae180a,improve no_command rule,2015-04-18 10:52:00-05:00,Jon Mason,22,7,29,2,"['test_no_command.py', 'no_command.py']","[""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_match(command_found, command_not_found, settings):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), settings)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), settings)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), settings)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), settings) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n']","[""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_match(command_found, command_not_found, settings):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), settings)\n        Popen.assert_called_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), settings)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), settings)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), settings) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\ndef _count_history_uses(name):\n    script = \'history | grep {}\'.format(name)\n    result = Popen(script, shell=True, stdout=PIPE)\n    return len(list(result.stdout))\n\ndef _get_candidate_commands(command, settings):\n    output = _get_output(command, settings)\n    if ""No command"" in output and ""from package"" in output:\n        fixed_names = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)\n        return filter(which, fixed_names)\n    return []\n        \n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return len(_get_candidate_commands(command, settings)) != 0\n\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    candidates = _get_candidate_commands(command, settings)\n    fixed_name = sorted(candidates, key=_count_history_uses)[0]\n    return command.script.replace(broken_name, fixed_name)\n     \n']","[[<pydriller.domain.commit.Method object at 0x7f1983dc5940>, <pydriller.domain.commit.Method object at 0x7f1983dc5a90>, <pydriller.domain.commit.Method object at 0x7f1983dc5970>, <pydriller.domain.commit.Method object at 0x7f1983dc57f0>, <pydriller.domain.commit.Method object at 0x7f1983dc5430>, <pydriller.domain.commit.Method object at 0x7f1983dc52b0>], [<pydriller.domain.commit.Method object at 0x7f1983db9fd0>, <pydriller.domain.commit.Method object at 0x7f1983db9e80>, <pydriller.domain.commit.Method object at 0x7f1983db9eb0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983d4a820>], [<pydriller.domain.commit.Method object at 0x7f1983dbe6d0>, <pydriller.domain.commit.Method object at 0x7f1983dbea90>, <pydriller.domain.commit.Method object at 0x7f1983dbed60>, <pydriller.domain.commit.Method object at 0x7f1983dbeac0>]]"
thefuck,34015ef27c59189d3c1191440c245188dc90741d,make sudo rule work with pacman,2015-04-18 15:16:15-04:00,Viktor Stanchev,1,0,1,1,['sudo.py'],"[""def match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr\n            or 'pkg: Insufficient privileges' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[""def match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr\n            or 'error: you cannot perform this operation unless you are root.' in command.stderr\n            or 'pkg: Insufficient privileges' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983d4aa90>, <pydriller.domain.commit.Method object at 0x7f1983d4a940>]]",[[<pydriller.domain.commit.Method object at 0x7f1983dc5400>]]
thefuck,9518416a2faf52c17d910726d4186068c50e96fd,#17 Fix creating configuration files/dirs,2015-04-18 21:16:49+02:00,nvbn,5,20,25,3,"['setup.py', 'test_main.py', 'main.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.7,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_setup_user_dir():\n    with patch('thefuck.main.Path.is_dir', return_value=False), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 2\n        assert touch.call_count == 1\n    with patch('thefuck.main.Path.is_dir', return_value=True), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 0\n        assert touch.call_count == 0\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(\'utf-8\'),\n                   result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    command = get_command(sys.argv)\n    if is_second_run(command):\n        print(""echo Can\'t fuck twice"")\n    else:\n        user_dir = setup_user_dir()\n        settings = get_settings(user_dir)\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n        else:\n            print(\'echo No fuck given\')\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.8,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(\'utf-8\'),\n                   result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    command = get_command(sys.argv)\n    if is_second_run(command):\n        print(""echo Can\'t fuck twice"")\n    else:\n        user_dir = setup_user_dir()\n        settings = get_settings(user_dir)\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n        else:\n            print(\'echo No fuck given\')\n']","[[], [<pydriller.domain.commit.Method object at 0x7f1983ccc190>, <pydriller.domain.commit.Method object at 0x7f1983cccd60>, <pydriller.domain.commit.Method object at 0x7f1983ccc580>, <pydriller.domain.commit.Method object at 0x7f1983ccc430>, <pydriller.domain.commit.Method object at 0x7f1983ce9eb0>, <pydriller.domain.commit.Method object at 0x7f1983ce9580>, <pydriller.domain.commit.Method object at 0x7f1983ce9820>], [<pydriller.domain.commit.Method object at 0x7f1983d286a0>, <pydriller.domain.commit.Method object at 0x7f1983d28040>, <pydriller.domain.commit.Method object at 0x7f1983d286d0>, <pydriller.domain.commit.Method object at 0x7f1983d28d30>, <pydriller.domain.commit.Method object at 0x7f1983d5c820>, <pydriller.domain.commit.Method object at 0x7f1983d5c430>, <pydriller.domain.commit.Method object at 0x7f1983d5cc10>, <pydriller.domain.commit.Method object at 0x7f1983d5c940>, <pydriller.domain.commit.Method object at 0x7f1983d5cd60>, <pydriller.domain.commit.Method object at 0x7f1983d5cac0>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983ccc190>], [<pydriller.domain.commit.Method object at 0x7f1983d232b0>]]"
thefuck,235b31e176405cf8f58349580def4db198251909,#22 Get stderr and stdout with `LANG=C`,2015-04-18 21:27:43+02:00,nvbn,8,3,11,2,"['test_main.py', 'main.py']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(\'utf-8\'),\n                   result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    command = get_command(sys.argv)\n    if is_second_run(command):\n        print(""echo Can\'t fuck twice"")\n    else:\n        user_dir = setup_user_dir()\n        settings = get_settings(user_dir)\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n        else:\n            print(\'echo No fuck given\')\n']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen,\\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    return Command(script, result.stdout.read().decode(\'utf-8\'),\n                   result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    command = get_command(sys.argv)\n    if is_second_run(command):\n        print(""echo Can\'t fuck twice"")\n    else:\n        user_dir = setup_user_dir()\n        settings = get_settings(user_dir)\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n        else:\n            print(\'echo No fuck given\')\n']","[[<pydriller.domain.commit.Method object at 0x7f1983d5c550>, <pydriller.domain.commit.Method object at 0x7f1983d5c6a0>, <pydriller.domain.commit.Method object at 0x7f1983d5cbe0>, <pydriller.domain.commit.Method object at 0x7f1983d5ca90>, <pydriller.domain.commit.Method object at 0x7f1983db9c10>, <pydriller.domain.commit.Method object at 0x7f1983db96d0>], [<pydriller.domain.commit.Method object at 0x7f1983db9a90>, <pydriller.domain.commit.Method object at 0x7f1983db9ac0>, <pydriller.domain.commit.Method object at 0x7f1983db96a0>, <pydriller.domain.commit.Method object at 0x7f1983db9d60>, <pydriller.domain.commit.Method object at 0x7f1983db9be0>, <pydriller.domain.commit.Method object at 0x7f1983d41550>, <pydriller.domain.commit.Method object at 0x7f1983cf0ac0>, <pydriller.domain.commit.Method object at 0x7f1983d566d0>, <pydriller.domain.commit.Method object at 0x7f1983d56e80>, <pydriller.domain.commit.Method object at 0x7f1983d56fd0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983d56a90>], [<pydriller.domain.commit.Method object at 0x7f1983db1550>]]"
thefuck,b0d353c699df50c0a40d21d1d0a708046af6bb9c,#22 Simplify adding patterns for the `sudo` rule,2015-04-18 21:30:48+02:00,nvbn,11,4,15,2,"['setup.py', 'sudo.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.8,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""def match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr\n            or 'pkg: Insufficient privileges' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.9,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d1cc10>, <pydriller.domain.commit.Method object at 0x7f1983d1c6d0>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d5c2b0>]]"
thefuck,a84671dd3b7505d4d73f11ee9c7d057429542e24,#20 Fix `UnicodeDecodeError` in `no_command`,2015-04-18 21:46:17+02:00,nvbn,2,2,4,2,"['setup.py', 'no_command.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.9,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.10,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode(\'utf-8\')\n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n']","[[], [<pydriller.domain.commit.Method object at 0x7f1983d74c10>, <pydriller.domain.commit.Method object at 0x7f1983d74ac0>, <pydriller.domain.commit.Method object at 0x7f1983d74a90>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d7f6a0>]]"
thefuck,e745f3d4a95ad8c8479955a45e624c1081ff2c86,#21 Add timeout for getting previous command output,2015-04-18 22:50:18+02:00,nvbn,50,22,72,4,"['README.md', 'setup.py', 'test_main.py', 'main.py']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_intall thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n# You can use wahtever you want for as an alias, like for mondays:\nalias FUCK='fuck'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions.  \n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` have three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck have a few settings parameters:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.10,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen,\\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    return Command(script, result.stdout.read().decode(\'utf-8\'),\n                   result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    command = get_command(sys.argv)\n    if is_second_run(command):\n        print(""echo Can\'t fuck twice"")\n    else:\n        user_dir = setup_user_dir()\n        settings = get_settings(user_dir)\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n        else:\n            print(\'echo No fuck given\')\n']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_intall thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n# You can use wahtever you want for as an alias, like for mondays:\nalias FUCK='fuck'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions.  \n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` have three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck have a few settings parameters:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.11,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983da8190>, <pydriller.domain.commit.Method object at 0x7f1983da82e0>, <pydriller.domain.commit.Method object at 0x7f1983da8040>, <pydriller.domain.commit.Method object at 0x7f1983da1fd0>, <pydriller.domain.commit.Method object at 0x7f1983da1a90>, <pydriller.domain.commit.Method object at 0x7f1983da1ac0>], [<pydriller.domain.commit.Method object at 0x7f1983da1c10>, <pydriller.domain.commit.Method object at 0x7f1983da1d60>, <pydriller.domain.commit.Method object at 0x7f19867bfd90>, <pydriller.domain.commit.Method object at 0x7f1983da8160>, <pydriller.domain.commit.Method object at 0x7f1983da8c10>, <pydriller.domain.commit.Method object at 0x7f1983da8a90>, <pydriller.domain.commit.Method object at 0x7f1983da8ac0>, <pydriller.domain.commit.Method object at 0x7f1983da8940>, <pydriller.domain.commit.Method object at 0x7f1983dac190>, <pydriller.domain.commit.Method object at 0x7f1983dac040>]]","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983da8d30>, <pydriller.domain.commit.Method object at 0x7f1983da8970>], [<pydriller.domain.commit.Method object at 0x7f1983da8a90>, <pydriller.domain.commit.Method object at 0x7f1983d9c970>, <pydriller.domain.commit.Method object at 0x7f1983d9c7f0>, <pydriller.domain.commit.Method object at 0x7f1983da1580>, <pydriller.domain.commit.Method object at 0x7f1983da1400>]]"
thefuck,8b2ba5762c6fa3ef9b40d1624d4c76accb40bfb1,"Add support of `lein` ""is not task""",2015-04-18 23:19:34+02:00,nvbn,49,1,50,4,"['README.md', 'setup.py', 'test_lein_not_task.py', 'lein_not_task.py']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_intall thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK='fuck'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions.  \n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` have three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck have a few settings parameters:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.11,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', None, None]","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n\n➜ lein rpl\n'rpl' is not a task. See 'lein help'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_intall thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK='fuck'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions.  \n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` have three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck have a few settings parameters:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.12,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""import pytest\nfrom mock import Mock\nfrom thefuck.rules.lein_not_task import match, get_new_command\n\n\n@pytest.fixture\ndef is_not_task():\n    return ''''rpl' is not a task. See 'lein help'.\n\nDid you mean this?\n         repl\n'''\n\n\ndef test_match(is_not_task):\n    assert match(Mock(script='lein rpl', stderr=is_not_task), None)\n    assert not match(Mock(script='ls', stderr=is_not_task), None)\n\n\ndef test_get_new_command(is_not_task):\n    assert get_new_command(Mock(script='lein rpl --help', stderr=is_not_task),\n                           None) == 'lein repl --help'\n"", 'import re\n\n\ndef match(command, settings):\n    return (command.script.startswith(\'lein\')\n            and ""is not a task. See \'lein help\'"" in command.stderr\n            and \'Did you mean this?\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r""\'([^\']*)\' is not a task"",\n                            command.stderr)[0]\n    new_cmd = re.findall(r\'Did you mean this\\?\\n\\s*([^\\n]*)\',\n                         command.stderr)[0]\n    return command.script.replace(broken_cmd, new_cmd, 1)\n']","[[], [], [], []]","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983d677f0>, <pydriller.domain.commit.Method object at 0x7f1983d67ac0>, <pydriller.domain.commit.Method object at 0x7f1983d67e80>], [<pydriller.domain.commit.Method object at 0x7f1983d747f0>, <pydriller.domain.commit.Method object at 0x7f1983d74820>]]"
thefuck,ac545c6f0ae6012460b4bcc45e37ad604ee60b7e,"improve no_comamnd rule, test it",2015-04-18 16:32:50-05:00,Jon Mason,44,8,52,2,"['test_no_command.py', 'no_command.py']","[""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_match(command_found, command_not_found, settings):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), settings)\n        Popen.assert_called_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), settings)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), settings)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), settings) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\ndef _count_history_uses(name):\n    script = \'history | grep {}\'.format(name)\n    result = Popen(script, shell=True, stdout=PIPE)\n    return len(list(result.stdout))\n\ndef _get_candidate_commands(command, settings):\n    output = _get_output(command, settings)\n    if ""No command"" in output and ""from package"" in output:\n        fixed_names = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)\n        return filter(which, fixed_names)\n    return []\n        \n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return len(_get_candidate_commands(command, settings)) != 0\n\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    candidates = _get_candidate_commands(command, settings)\n    fixed_name = sorted(candidates, key=_count_history_uses)[0]\n    return command.script.replace(broken_name, fixed_name)\n     \n']","['from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b\'\'\'No command \'aptget\' found, did you mean:\n Command \'apt-get\' from package \'apt\' (main)\n Command \'not-installed\' from package \'derp\' (main)\n Command \'not-really-used\' from package \'whatever\' (main)\naptget: command not found\n\'\'\'\n\n@pytest.fixture\ndef uninstalled_command_found():\n    return b\'\'\'No command \'pish\' found, did you mean:\n Command \'vish\' from package \'vish\' (universe)\n Command \'wish\' from package \'tk\' (main)\n Command \'fish\' from package \'fish\' (universe)\n Command \'pdsh\' from package \'pdsh\' (universe)\npish: command not found\n\'\'\'\n\n@pytest.fixture\ndef command_not_found():\n    return b\'\'\'No command \'vom\' found, but there are 19 similar ones\nvom: command not found\n\'\'\'\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch(\'thefuck.rules.no_command.which\',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n@pytest.fixture\ndef bin_might_exist(request):\n    def side_effect(name):\n        return name in [\'not-really-used\', \'apt-get\', \'/usr/lib/command-not-found\', \'test\']\n    p = patch(\'thefuck.rules.no_command.which\',\n              side_effect = side_effect)\n    p.start()\n    request.addfinalizer(p.stop)\n            \n\n@pytest.fixture\ndef patch_history(request):\n    def side_effect(name):\n        print(""history(\'{}\')"".format(name))\n        count = 2 if name == \'not-really-used\' else 12\n    p = patch(\'thefuck.rules.no_command._count_history_uses\',\n              side_effect = side_effect)\n    p.start()\n    request.addfinalizer(p.stop)\n    \n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures(\'bin_might_exist\', \'patch_history\')\ndef test_match(command_found, command_not_found, uninstalled_command_found, settings):\n    with patch(\'thefuck.rules.no_command.Popen\') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command(\'aptget install vim\', \'\', \'\'), settings)\n        Popen.assert_called_with(\'/usr/lib/command-not-found aptget\',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command(\'ls\', \'\', \'\'), settings)\n\n    with patch(\'thefuck.rules.no_command.Popen\') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command(\'sudo aptget install vim\', \'\', \'\'),\n                     Mock(command_not_found=\'test\'))\n        Popen.assert_called_with(\'test aptget\',\n                                      shell=True, stderr=PIPE)\n\n    with patch(\'thefuck.rules.no_command.Popen\') as Popen:\n        Popen.return_value.stderr.read.return_value = uninstalled_command_found\n        assert not match(Command(\'pish bla blah\', \'\', \'\'), settings)\n\n@pytest.mark.usefixtures(\'bin_might_exist\', \'patch_history\')\ndef test_get_new_command(command_found):\n    with patch(\'thefuck.rules.no_command._get_output\',\n               return_value=command_found.decode()):\n        assert get_new_command(Command(\'aptget install vim\', \'\', \'\'), settings)\\\n            == \'apt-get install vim\'\n        assert get_new_command(Command(\'sudo aptget install vim\', \'\', \'\'), settings) \\\n            == \'sudo apt-get install vim\'\n', 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\ndef _count_history_uses(name):\n    script = ""history | egrep \'\\\\b{}\\\\b\' | wc -l"".format(name)\n    result = Popen(script, shell=True,\n                   stdout=PIPE)\n    return int(result.stdout.read())\n\ndef _get_candidate_commands(command, settings):\n    output = _get_output(command, settings)\n    if ""No command"" in output and ""from package"" in output:\n        fixed_names = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)\n        return filter(which, fixed_names)\n    return []\n        \n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return len(_get_candidate_commands(command, settings)) != 0\n\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    candidates = _get_candidate_commands(command, settings)\n    fixed_name = sorted(candidates, key=_count_history_uses, reverse=True)[0]\n    return command.script.replace(broken_name, fixed_name)\n     \n']","[[<pydriller.domain.commit.Method object at 0x7f1983d5c7f0>, <pydriller.domain.commit.Method object at 0x7f1983d5c190>, <pydriller.domain.commit.Method object at 0x7f1983d5c040>, <pydriller.domain.commit.Method object at 0x7f1983d5ceb0>, <pydriller.domain.commit.Method object at 0x7f1983cdd160>, <pydriller.domain.commit.Method object at 0x7f1983cdd6a0>], [<pydriller.domain.commit.Method object at 0x7f1983db1580>, <pydriller.domain.commit.Method object at 0x7f1983db1430>, <pydriller.domain.commit.Method object at 0x7f1983db1d30>, <pydriller.domain.commit.Method object at 0x7f1983db1e80>, <pydriller.domain.commit.Method object at 0x7f1983d9c820>]]","[[<pydriller.domain.commit.Method object at 0x7f1983d0bbe0>, <pydriller.domain.commit.Method object at 0x7f1983d0beb0>, <pydriller.domain.commit.Method object at 0x7f1983ce32b0>, <pydriller.domain.commit.Method object at 0x7f1983d0ba90>, <pydriller.domain.commit.Method object at 0x7f1983d0b160>, <pydriller.domain.commit.Method object at 0x7f1983d74580>, <pydriller.domain.commit.Method object at 0x7f1983d0b400>, <pydriller.domain.commit.Method object at 0x7f1983cdd160>], [<pydriller.domain.commit.Method object at 0x7f1983d56820>, <pydriller.domain.commit.Method object at 0x7f1983d62040>]]"
thefuck,8a2bc75e555cec399f02f51fcc04e0f4a88f8bdb,make it python 3 friendly,2015-04-18 16:46:02-05:00,Jon Mason,1,1,2,1,['no_command.py'],"['from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\ndef _count_history_uses(name):\n    script = ""history | egrep \'\\\\b{}\\\\b\' | wc -l"".format(name)\n    result = Popen(script, shell=True,\n                   stdout=PIPE)\n    return int(result.stdout.read())\n\ndef _get_candidate_commands(command, settings):\n    output = _get_output(command, settings)\n    if ""No command"" in output and ""from package"" in output:\n        fixed_names = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)\n        return filter(which, fixed_names)\n    return []\n        \n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return len(_get_candidate_commands(command, settings)) != 0\n\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    candidates = _get_candidate_commands(command, settings)\n    fixed_name = sorted(candidates, key=_count_history_uses, reverse=True)[0]\n    return command.script.replace(broken_name, fixed_name)\n     \n']","['from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\ndef _count_history_uses(name):\n    script = ""history | egrep \'\\\\b{}\\\\b\' | wc -l"".format(name)\n    result = Popen(script, shell=True,\n                   stdout=PIPE)\n    return int(result.stdout.read())\n\ndef _get_candidate_commands(command, settings):\n    output = _get_output(command, settings)\n    if ""No command"" in output and ""from package"" in output:\n        fixed_names = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)\n        return [name for name in fixed_names if which(name)]\n    return []\n        \n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return len(_get_candidate_commands(command, settings)) != 0\n\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    candidates = _get_candidate_commands(command, settings)\n    fixed_name = sorted(candidates, key=_count_history_uses, reverse=True)[0]\n    return command.script.replace(broken_name, fixed_name)\n     \n']","[[<pydriller.domain.commit.Method object at 0x7f1983d95550>, <pydriller.domain.commit.Method object at 0x7f1983d95ac0>, <pydriller.domain.commit.Method object at 0x7f1983d952e0>, <pydriller.domain.commit.Method object at 0x7f1983d95190>, <pydriller.domain.commit.Method object at 0x7f1983d90d60>]]",[[<pydriller.domain.commit.Method object at 0x7f1983d95940>]]
thefuck,cc1a69fb6526a6b9d0e3bcab3825496eded350d3,another oopsie that was revealed in python3,2015-04-18 16:49:26-05:00,Jon Mason,1,2,3,1,['test_no_command.py'],"['from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b\'\'\'No command \'aptget\' found, did you mean:\n Command \'apt-get\' from package \'apt\' (main)\n Command \'not-installed\' from package \'derp\' (main)\n Command \'not-really-used\' from package \'whatever\' (main)\naptget: command not found\n\'\'\'\n\n@pytest.fixture\ndef uninstalled_command_found():\n    return b\'\'\'No command \'pish\' found, did you mean:\n Command \'vish\' from package \'vish\' (universe)\n Command \'wish\' from package \'tk\' (main)\n Command \'fish\' from package \'fish\' (universe)\n Command \'pdsh\' from package \'pdsh\' (universe)\npish: command not found\n\'\'\'\n\n@pytest.fixture\ndef command_not_found():\n    return b\'\'\'No command \'vom\' found, but there are 19 similar ones\nvom: command not found\n\'\'\'\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch(\'thefuck.rules.no_command.which\',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n@pytest.fixture\ndef bin_might_exist(request):\n    def side_effect(name):\n        return name in [\'not-really-used\', \'apt-get\', \'/usr/lib/command-not-found\', \'test\']\n    p = patch(\'thefuck.rules.no_command.which\',\n              side_effect = side_effect)\n    p.start()\n    request.addfinalizer(p.stop)\n            \n\n@pytest.fixture\ndef patch_history(request):\n    def side_effect(name):\n        print(""history(\'{}\')"".format(name))\n        count = 2 if name == \'not-really-used\' else 12\n    p = patch(\'thefuck.rules.no_command._count_history_uses\',\n              side_effect = side_effect)\n    p.start()\n    request.addfinalizer(p.stop)\n    \n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures(\'bin_might_exist\', \'patch_history\')\ndef test_match(command_found, command_not_found, uninstalled_command_found, settings):\n    with patch(\'thefuck.rules.no_command.Popen\') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command(\'aptget install vim\', \'\', \'\'), settings)\n        Popen.assert_called_with(\'/usr/lib/command-not-found aptget\',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command(\'ls\', \'\', \'\'), settings)\n\n    with patch(\'thefuck.rules.no_command.Popen\') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command(\'sudo aptget install vim\', \'\', \'\'),\n                     Mock(command_not_found=\'test\'))\n        Popen.assert_called_with(\'test aptget\',\n                                      shell=True, stderr=PIPE)\n\n    with patch(\'thefuck.rules.no_command.Popen\') as Popen:\n        Popen.return_value.stderr.read.return_value = uninstalled_command_found\n        assert not match(Command(\'pish bla blah\', \'\', \'\'), settings)\n\n@pytest.mark.usefixtures(\'bin_might_exist\', \'patch_history\')\ndef test_get_new_command(command_found):\n    with patch(\'thefuck.rules.no_command._get_output\',\n               return_value=command_found.decode()):\n        assert get_new_command(Command(\'aptget install vim\', \'\', \'\'), settings)\\\n            == \'apt-get install vim\'\n        assert get_new_command(Command(\'sudo aptget install vim\', \'\', \'\'), settings) \\\n            == \'sudo apt-get install vim\'\n']","[""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\n Command 'not-installed' from package 'derp' (main)\n Command 'not-really-used' from package 'whatever' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef uninstalled_command_found():\n    return b'''No command 'pish' found, did you mean:\n Command 'vish' from package 'vish' (universe)\n Command 'wish' from package 'tk' (main)\n Command 'fish' from package 'fish' (universe)\n Command 'pdsh' from package 'pdsh' (universe)\npish: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n@pytest.fixture\ndef bin_might_exist(request):\n    def side_effect(name):\n        return name in ['not-really-used', 'apt-get', '/usr/lib/command-not-found', 'test']\n    p = patch('thefuck.rules.no_command.which',\n              side_effect = side_effect)\n    p.start()\n    request.addfinalizer(p.stop)\n            \n\n@pytest.fixture\ndef patch_history(request):\n    def side_effect(name):\n        return 2 if name == 'not-really-used' else 12\n    p = patch('thefuck.rules.no_command._count_history_uses',\n              side_effect = side_effect)\n    p.start()\n    request.addfinalizer(p.stop)\n    \n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures('bin_might_exist', 'patch_history')\ndef test_match(command_found, command_not_found, uninstalled_command_found, settings):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), settings)\n        Popen.assert_called_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), settings)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = uninstalled_command_found\n        assert not match(Command('pish bla blah', '', ''), settings)\n\n@pytest.mark.usefixtures('bin_might_exist', 'patch_history')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), settings)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), settings) \\\n            == 'sudo apt-get install vim'\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983d90fd0>, <pydriller.domain.commit.Method object at 0x7f1983d906a0>, <pydriller.domain.commit.Method object at 0x7f1983d90e80>, <pydriller.domain.commit.Method object at 0x7f1983d90eb0>, <pydriller.domain.commit.Method object at 0x7f1983d95040>, <pydriller.domain.commit.Method object at 0x7f1983d95400>, <pydriller.domain.commit.Method object at 0x7f1983d95160>, <pydriller.domain.commit.Method object at 0x7f1983d952b0>, <pydriller.domain.commit.Method object at 0x7f1983d95a90>, <pydriller.domain.commit.Method object at 0x7f1983d95430>, <pydriller.domain.commit.Method object at 0x7f1983db1fd0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983e097f0>, <pydriller.domain.commit.Method object at 0x7f1983e09be0>]]"
thefuck,650c3f4e45602d0faa4376291ae1b51f92bd90be,Fixed grammar in comments for easier understanding,2015-04-19 02:09:53+02:00,Max Dietrich,2,2,4,1,['main.py'],"['from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","['from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","[[<pydriller.domain.commit.Method object at 0x7f1983d23580>, <pydriller.domain.commit.Method object at 0x7f1983d236a0>, <pydriller.domain.commit.Method object at 0x7f1983d23550>, <pydriller.domain.commit.Method object at 0x7f1983d23040>, <pydriller.domain.commit.Method object at 0x7f1983d0b2e0>, <pydriller.domain.commit.Method object at 0x7f1983d0b580>, <pydriller.domain.commit.Method object at 0x7f1983d0b820>, <pydriller.domain.commit.Method object at 0x7f1983ccceb0>, <pydriller.domain.commit.Method object at 0x7f1983ccc820>, <pydriller.domain.commit.Method object at 0x7f1983d1ceb0>, <pydriller.domain.commit.Method object at 0x7f1983cd7ac0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983d56d30>, <pydriller.domain.commit.Method object at 0x7f1983d3ba90>]]"
thefuck,0d577ffa83ed7d410d2577c7d72995cf88c974f5,sudo rule: add support for mtr,2015-04-19 11:57:01+08:00,Felix Yan,2,1,3,1,['sudo.py'],"[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983d6e580>, <pydriller.domain.commit.Method object at 0x7f1983d4a040>]]",[[]]
thefuck,2a79a5e413b41bbbe3886828a97958ca824e7bdc,Create rm_root.py,2015-04-19 09:03:34+05:00,SpyCheese,8,0,8,1,['rm_root.py'],[None],"[""def match(command, settings):\n    return ('rm' in command.script\n            and '--help' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return '{} --no-preserve-root'.format(command.script)\n""]",[[]],"[[<pydriller.domain.commit.Method object at 0x7f1983d74190>, <pydriller.domain.commit.Method object at 0x7f1983d742b0>]]"
thefuck,f113bae59d97ab1cd90857680e8c6e9320b96327,Update rm_root.py,2015-04-19 09:12:19+05:00,SpyCheese,2,2,4,1,['rm_root.py'],"[""def match(command, settings):\n    return ('rm' in command.script\n            and '--help' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return '{} --no-preserve-root'.format(command.script)\n""]","[""def match(command, settings):\n    return ('/' in command.script\n            and '--no-preserve-root' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return '{} --no-preserve-root'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983dc5be0>, <pydriller.domain.commit.Method object at 0x7f1983dc5580>]]",[[<pydriller.domain.commit.Method object at 0x7f1983dbeeb0>]]
thefuck,ceeccf1cd7de156ae48ce5aa7f01366015fa6de9,"Update rm_root.py

Okay, there was an incorrect match function.",2015-04-19 10:21:46+05:00,SpyCheese,1,1,2,1,['rm_root.py'],"[""def match(command, settings):\n    return ('/' in command.script\n            and '--no-preserve-root' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return '{} --no-preserve-root'.format(command.script)\n""]","[""def match(command, settings):\n    return ('/' in command.script.split()\n            and '--no-preserve-root' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return '{} --no-preserve-root'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983e09820>, <pydriller.domain.commit.Method object at 0x7f1983e09550>]]",[[<pydriller.domain.commit.Method object at 0x7f1983da8430>]]
thefuck,ab91eaf73d2012266aaa3f82d08d05e62a82c4a4,"Revert ""Merge pull request #36 from jjmason/improve-no-command""

This reverts commit 28a5c1214b730e727b88648cf56dd36d51862ff6, reversing
changes made to 3f0cbb9326895cf516eb9f4f0f834d23200dc21e.",2015-04-19 14:58:44+02:00,nvbn,11,61,72,2,"['test_no_command.py', 'no_command.py']","[""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\n Command 'not-installed' from package 'derp' (main)\n Command 'not-really-used' from package 'whatever' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef uninstalled_command_found():\n    return b'''No command 'pish' found, did you mean:\n Command 'vish' from package 'vish' (universe)\n Command 'wish' from package 'tk' (main)\n Command 'fish' from package 'fish' (universe)\n Command 'pdsh' from package 'pdsh' (universe)\npish: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n@pytest.fixture\ndef bin_might_exist(request):\n    def side_effect(name):\n        return name in ['not-really-used', 'apt-get', '/usr/lib/command-not-found', 'test']\n    p = patch('thefuck.rules.no_command.which',\n              side_effect = side_effect)\n    p.start()\n    request.addfinalizer(p.stop)\n            \n\n@pytest.fixture\ndef patch_history(request):\n    def side_effect(name):\n        return 2 if name == 'not-really-used' else 12\n    p = patch('thefuck.rules.no_command._count_history_uses',\n              side_effect = side_effect)\n    p.start()\n    request.addfinalizer(p.stop)\n    \n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures('bin_might_exist', 'patch_history')\ndef test_match(command_found, command_not_found, uninstalled_command_found, settings):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), settings)\n        Popen.assert_called_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), settings)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = uninstalled_command_found\n        assert not match(Command('pish bla blah', '', ''), settings)\n\n@pytest.mark.usefixtures('bin_might_exist', 'patch_history')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), settings)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), settings) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode(\'utf-8\')\n\ndef _count_history_uses(name):\n    script = ""history | egrep \'\\\\b{}\\\\b\' | wc -l"".format(name)\n    result = Popen(script, shell=True,\n                   stdout=PIPE)\n    return int(result.stdout.read())\n\ndef _get_candidate_commands(command, settings):\n    output = _get_output(command, settings)\n    if ""No command"" in output and ""from package"" in output:\n        fixed_names = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)\n        return [name for name in fixed_names if which(name)]\n    return []\n        \n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return len(_get_candidate_commands(command, settings)) != 0\n\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    candidates = _get_candidate_commands(command, settings)\n    fixed_name = sorted(candidates, key=_count_history_uses, reverse=True)[0]\n    return command.script.replace(broken_name, fixed_name)\n     \n']","[""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_match(command_found, command_not_found, settings):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), settings)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), settings)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), settings)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), settings) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode(\'utf-8\')\n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n']","[[<pydriller.domain.commit.Method object at 0x7f1983dfe550>, <pydriller.domain.commit.Method object at 0x7f1983dfe6a0>, <pydriller.domain.commit.Method object at 0x7f1983dfe580>, <pydriller.domain.commit.Method object at 0x7f1983df8fd0>, <pydriller.domain.commit.Method object at 0x7f1983df8820>, <pydriller.domain.commit.Method object at 0x7f1983df86a0>, <pydriller.domain.commit.Method object at 0x7f1983df86d0>, <pydriller.domain.commit.Method object at 0x7f1983df8550>, <pydriller.domain.commit.Method object at 0x7f1983df8580>, <pydriller.domain.commit.Method object at 0x7f1983df8400>, <pydriller.domain.commit.Method object at 0x7f1983df8430>], [<pydriller.domain.commit.Method object at 0x7f1983df2430>, <pydriller.domain.commit.Method object at 0x7f1983df22b0>, <pydriller.domain.commit.Method object at 0x7f1983df2580>, <pydriller.domain.commit.Method object at 0x7f1983df8d60>, <pydriller.domain.commit.Method object at 0x7f1983df8c10>]]","[[<pydriller.domain.commit.Method object at 0x7f1983df86a0>, <pydriller.domain.commit.Method object at 0x7f1983df86d0>, <pydriller.domain.commit.Method object at 0x7f1983dfe6a0>, <pydriller.domain.commit.Method object at 0x7f1983df8400>, <pydriller.domain.commit.Method object at 0x7f1983dfe550>, <pydriller.domain.commit.Method object at 0x7f1983df8550>, <pydriller.domain.commit.Method object at 0x7f1983df8820>, <pydriller.domain.commit.Method object at 0x7f1983dfe160>], [<pydriller.domain.commit.Method object at 0x7f1983debfd0>, <pydriller.domain.commit.Method object at 0x7f1983df2580>, <pydriller.domain.commit.Method object at 0x7f1983df2160>, <pydriller.domain.commit.Method object at 0x7f1983df22b0>]]"
thefuck,a2c086ed73dd6489a2fde61902b7112a06a71904,"sudo rule: add support for ""Operation not permitted"" errors",2015-04-19 22:53:09+08:00,Felix Yan,2,1,3,1,['sudo.py'],"[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983e04d60>, <pydriller.domain.commit.Method object at 0x7f1983e04580>]]",[[]]
thefuck,f9f757f618378ed2b4ef9592c5dbc7d200b6c103,Added rule:cp_omitting_directory,2015-04-20 14:34:09+05:30,Nabeel Valapra,10,0,10,1,['cp_omitting_directory.py'],[None],"[""def match(command, settings):\n    if 'cp: omitting directory' in command.stderr.lower():\n        return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return command.script.replace('cp', 'cp -r') \n\n\n""]",[[]],"[[<pydriller.domain.commit.Method object at 0x7f1983da12b0>, <pydriller.domain.commit.Method object at 0x7f1983da16a0>]]"
thefuck,0b7fd6ae2ab20c99f9d0625f4ac7bf186bd92126,"Added rm -rf support

When someone tries to remove a directory without specifying `-rf`, e.g.

    $ mkdir foo
    $ rm foo

the shell refuses to remove the directory with an error:

    rm: foo: is a directory

Instead, you need to use

    $ rm -rf foo

This rule adds fuck support for this:

    $ mkdir foo
    $ rm foo
    rm: foo: is a directory
    $ fuck
    rm -rf foo",2015-04-20 12:32:32+02:00,Nils Winkler,22,0,22,2,"['test_rm_dir.py', 'rm_dir.py']","[None, None]","[""from thefuck.main import Command\nfrom thefuck.rules.rm_dir import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('rm foo', '', 'rm: foo: is a directory'), None)\n    assert not match(Command('rm foo', '', ''), None)\n    assert not match(Command('rm foo', '', 'foo bar baz'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('rm foo', '', ''), None) == 'rm -rf foo'\n"", ""import re\n\ndef match(command, settings):\n    return ('rm' in command.script\n            and 'is a directory' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return re.sub('^rm (.*)', 'rm -rf \\\\1', command.script)\n""]","[[], []]","[[<pydriller.domain.commit.Method object at 0x7f1983e09a90>, <pydriller.domain.commit.Method object at 0x7f1983e096a0>], [<pydriller.domain.commit.Method object at 0x7f1983dc56d0>, <pydriller.domain.commit.Method object at 0x7f1983dc52e0>]]"
thefuck,2b08a136b59c80bf4d0d04545078156a577279c3,add a rule to run the script you enter by add './' in command's prefix,2015-04-20 19:48:27+08:00,dannion,9,0,9,1,['has_exists_script.py'],[None],"[""import os\n\ndef match(command, settings):\n\texist = os.path.exists(command.script)\n\treturn exist\n\ndef get_new_command(command, settings):\n    return './{}'.format(command.script)\n\n""]",[[]],"[[<pydriller.domain.commit.Method object at 0x7f1983dbec10>, <pydriller.domain.commit.Method object at 0x7f1983dbed30>]]"
thefuck,36d9e13eceb9a3c9cb7037440538815983fa327b,#55 Add tests and check for `command not found`,2015-04-20 15:46:02+02:00,nvbn,24,2,26,2,"['test_has_exists_script.py', 'has_exists_script.py']","[None, ""import os\n\ndef match(command, settings):\n\texist = os.path.exists(command.script)\n\treturn exist\n\ndef get_new_command(command, settings):\n    return './{}'.format(command.script)\n\n""]","[""from mock import Mock, patch\nfrom thefuck.rules. has_exists_script import match, get_new_command\n\n\ndef test_match():\n    with patch('os.path.exists', return_value=True):\n        assert match(Mock(script='main', stderr='main: command not found'),\n                     None)\n        assert match(Mock(script='main --help',\n                          stderr='main: command not found'),\n                     None)\n        assert not match(Mock(script='main', stderr=''), None)\n\n    with patch('os.path.exists', return_value=False):\n        assert not match(Mock(script='main', stderr='main: command not found'),\n                         None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Mock(script='main --help'), None) == './main --help'\n"", ""import os\n\n\ndef match(command, settings):\n    return os.path.exists(command.script.split()[0]) \\\n        and 'command not found' in command.stderr\n\n\ndef get_new_command(command, settings):\n    return './{}'.format(command.script)\n\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d5cfd0>, <pydriller.domain.commit.Method object at 0x7f1983d5c2e0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983d67a90>, <pydriller.domain.commit.Method object at 0x7f1983d67820>], [<pydriller.domain.commit.Method object at 0x7f1983d7f2b0>]]"
thefuck,9ecda9a399cab6a683eed27e5dd8de7b394c581c,Bump version to 1.13,2015-04-20 15:48:17+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.12,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.13,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,411aea67f771fb2a9ba0bf253b750d05deb2c242,"A special case for 'Permission denied' error msg when trying to execute a
python scripy.

The script does not have execute permission and/or does not start with !#/usr/...
In that case, pre-pend the command with 'python' keyword.

Change-Id: Idf73ee9cf0a523f51c78672188a457b2fcedc1e6",2015-04-20 10:49:39-04:00,Sudeep Juvekar,22,1,23,3,"['test_python_command.py', 'main.py', 'python_command.py']","[None, 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n', None]","[""from thefuck.main import Command\nfrom thefuck.rules.sudo import match, get_new_command\n\ndef test_match():\n    assert match(Command('', '', 'Permission denied'), None)\n    assert not match(Command('', '', ''), None)\n\ndef test_get_new_command():\n    assert get_new_command(Command('./test_sudo.py', '', ''), None) == 'python ./test_sudo.py'\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n', ""# add 'python' suffix to the command if\n#  1) The script does not have execute permission or\n#  2) is interpreted as shell script\n\ndef match(command, settings):\n  toks = command.script.split()\n  return (toks[0].endswith('.py')\n          and ('Permission denied' in command.stderr or\n               'command not found' in command.stderr))\n\ndef get_new_command(command, settings):\n  return 'python ' + command.script\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983ddfd60>, <pydriller.domain.commit.Method object at 0x7f1983ddfeb0>, <pydriller.domain.commit.Method object at 0x7f1983ddfbe0>, <pydriller.domain.commit.Method object at 0x7f1983ddfc10>, <pydriller.domain.commit.Method object at 0x7f1983ddf430>, <pydriller.domain.commit.Method object at 0x7f1983ddf2b0>, <pydriller.domain.commit.Method object at 0x7f1983ddf2e0>, <pydriller.domain.commit.Method object at 0x7f1983ddf160>, <pydriller.domain.commit.Method object at 0x7f1983ddf190>, <pydriller.domain.commit.Method object at 0x7f1983ddf040>, <pydriller.domain.commit.Method object at 0x7f1983ddbfd0>], []]","[[<pydriller.domain.commit.Method object at 0x7f1983debeb0>, <pydriller.domain.commit.Method object at 0x7f1983debd60>], [<pydriller.domain.commit.Method object at 0x7f1983de67f0>], [<pydriller.domain.commit.Method object at 0x7f1983ddb940>, <pydriller.domain.commit.Method object at 0x7f1983ddb7f0>]]"
thefuck,17397bf30ff94e5fda0c1bcdaca75bdcac458641,"A special case for 'Permission denied' error msg when trying to execute a
python scripy.

The script does not have execute permission and/or does not start with !#/usr/...
In that case, pre-pend the command with 'python' keyword.

Change-Id: Idf73ee9cf0a523f51c78672188a457b2fcedc1e6",2015-04-20 11:00:35-04:00,Sudeep Juvekar,1,1,2,1,['test_python_command.py'],"[""from thefuck.main import Command\nfrom thefuck.rules.sudo import match, get_new_command\n\ndef test_match():\n    assert match(Command('', '', 'Permission denied'), None)\n    assert not match(Command('', '', ''), None)\n\ndef test_get_new_command():\n    assert get_new_command(Command('./test_sudo.py', '', ''), None) == 'python ./test_sudo.py'\n""]","[""from thefuck.main import Command\nfrom thefuck.rules.python_command import match, get_new_command\n\ndef test_match():\n    assert match(Command('', '', 'Permission denied'), None)\n    assert not match(Command('', '', ''), None)\n\ndef test_get_new_command():\n    assert get_new_command(Command('./test_sudo.py', '', ''), None) == 'python ./test_sudo.py'\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983dd5fd0>, <pydriller.domain.commit.Method object at 0x7f1983dd5970>]]",[[]]
thefuck,cb31a1f7d08776b5a9e42bc944b2e12a23c1613e,"A special case for 'Permission denied' error msg when trying to execute a
python scripy.

The script does not have execute permission and/or does not start with !#/usr/...
In that case, pre-pend the command with 'python' keyword.

Change-Id: Idf73ee9cf0a523f51c78672188a457b2fcedc1e6",2015-04-20 12:00:08-04:00,Sudeep Juvekar,2,1,3,1,['python_command.py'],"[""# add 'python' suffix to the command if\n#  1) The script does not have execute permission or\n#  2) is interpreted as shell script\n\ndef match(command, settings):\n  toks = command.script.split()\n  return (toks[0].endswith('.py')\n          and ('Permission denied' in command.stderr or\n               'command not found' in command.stderr))\n\ndef get_new_command(command, settings):\n  return 'python ' + command.script\n""]","[""# add 'python' suffix to the command if\n#  1) The script does not have execute permission or\n#  2) is interpreted as shell script\n\ndef match(command, settings):\n  toks = command.script.split()\n  return (len(toks) > 0\n          and toks[0].endswith('.py')\n          and ('Permission denied' in command.stderr or\n               'command not found' in command.stderr))\n\ndef get_new_command(command, settings):\n  return 'python ' + command.script\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983dd52b0>, <pydriller.domain.commit.Method object at 0x7f1983dd5160>]]",[[<pydriller.domain.commit.Method object at 0x7f1983dcf2e0>]]
thefuck,1d878243ca50dcfe371ef30eec1bad4bd6b2e4a5,"A special case for 'Permission denied' error msg when trying to execute a
python scripy.

The script does not have execute permission and/or does not start with !#/usr/...
In that case, pre-pend the command with 'python' keyword.

Change-Id: Idf73ee9cf0a523f51c78672188a457b2fcedc1e6",2015-04-20 12:11:06-04:00,Sudeep Juvekar,1,1,2,1,['test_python_command.py'],"[""from thefuck.main import Command\nfrom thefuck.rules.python_command import match, get_new_command\n\ndef test_match():\n    assert match(Command('', '', 'Permission denied'), None)\n    assert not match(Command('', '', ''), None)\n\ndef test_get_new_command():\n    assert get_new_command(Command('./test_sudo.py', '', ''), None) == 'python ./test_sudo.py'\n""]","[""from thefuck.main import Command\nfrom thefuck.rules.python_command import match, get_new_command\n\ndef test_match():\n    assert match(Command('temp.py', '', 'Permission denied'), None)\n    assert not match(Command('', '', ''), None)\n\ndef test_get_new_command():\n    assert get_new_command(Command('./test_sudo.py', '', ''), None) == 'python ./test_sudo.py'\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983ddfd30>, <pydriller.domain.commit.Method object at 0x7f1983ddf580>]]",[[<pydriller.domain.commit.Method object at 0x7f1983ddb2b0>]]
thefuck,c0c584b13a0d6f5e177e25f48d5de918f1bef7e2,"mkdir -p

When adding directories using `mkdir`, intermediate directories have to
exist, unless you specify the `-p` option:

    $ mkdir foo/bar/baz
    mkdir: foo/bar: No such file or directory
    $ fuck
    mkdir -p foo/bar/baz",2015-04-20 18:38:03+02:00,Nils Winkler,22,0,22,2,"['test_mkdir_p.py', 'mkdir_p.py']","[None, None]","[""from thefuck.main import Command\nfrom thefuck.rules.mkdir_p import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('mkdir foo/bar/baz', '', 'mkdir: foo/bar: No such file or directory'), None)\n    assert not match(Command('mkdir foo/bar/baz', '', ''), None)\n    assert not match(Command('mkdir foo/bar/baz', '', 'foo bar baz'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('mkdir foo/bar/baz', '', ''), None) == 'mkdir -p foo/bar/baz'\n"", ""import re\n\ndef match(command, settings):\n    return ('mkdir' in command.script\n            and 'No such file or directory' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return re.sub('^mkdir (.*)', 'mkdir -p \\\\1', command.script)\n""]","[[], []]","[[<pydriller.domain.commit.Method object at 0x7f1983deb2e0>, <pydriller.domain.commit.Method object at 0x7f1983debd30>], [<pydriller.domain.commit.Method object at 0x7f1983de6a90>, <pydriller.domain.commit.Method object at 0x7f1983de6ac0>]]"
thefuck,2db0a215b4006555b21281957fe8e8446da1beb7,Fix fuck when more than one git command available,2015-04-20 21:48:54+02:00,nvbn,21,5,26,3,"['setup.py', 'test_git_not_command.py', 'git_not_command.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.13,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', 'import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.git_not_command import match, get_new_command\n\n\n@pytest.fixture\ndef git_not_command():\n    return """"""git: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\nbranch\n""""""\n\n\n@pytest.fixture\ndef git_command():\n    return ""* master""\n\n\ndef test_match(git_not_command, git_command):\n    assert match(Command(\'git brnch\', \'\', git_not_command), None)\n    assert not match(Command(\'ls brnch\', \'\', git_not_command), None)\n    assert not match(Command(\'git branch\', \'\', git_command), None)\n\n\ndef test_get_new_command(git_not_command):\n    assert get_new_command(Command(\'git brnch\', \'\', git_not_command), None)\\\n        == \'git branch\'\n', 'import re\n\n\ndef match(command, settings):\n    return (\'git\' in command.script\n            and "" is not a git command. See \'git --help\'."" in command.stderr\n            and \'Did you mean this?\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r""git: \'([^\']*)\' is not a git command"",\n                            command.stderr)[0]\n    new_cmd = re.findall(r\'Did you mean this\\?\\n\\s*([^\\n]*)\',\n                         command.stderr)[0]\n    return command.script.replace(broken_cmd, new_cmd, 1)\n\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.14,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', 'import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.git_not_command import match, get_new_command\n\n\n@pytest.fixture\ndef git_not_command():\n    return """"""git: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\nbranch\n""""""\n\n\n@pytest.fixture\ndef git_not_command_one_of_this():\n    return """"""git: \'st\' is not a git command. See \'git --help\'.\n\nDid you mean one of these?\nstatus\nreset\nstage\nstash\nstats\n""""""\n\n\n@pytest.fixture\ndef git_command():\n    return ""* master""\n\n\ndef test_match(git_not_command, git_command, git_not_command_one_of_this):\n    assert match(Command(\'git brnch\', \'\', git_not_command), None)\n    assert match(Command(\'git st\', \'\', git_not_command_one_of_this), None)\n    assert not match(Command(\'ls brnch\', \'\', git_not_command), None)\n    assert not match(Command(\'git branch\', \'\', git_command), None)\n\n\ndef test_get_new_command(git_not_command, git_not_command_one_of_this):\n    assert get_new_command(Command(\'git brnch\', \'\', git_not_command), None)\\\n        == \'git branch\'\n    assert get_new_command(\n        Command(\'git st\', \'\', git_not_command_one_of_this), None) == \'git status\'\n', 'import re\n\n\ndef match(command, settings):\n    return (\'git\' in command.script\n            and "" is not a git command. See \'git --help\'."" in command.stderr\n            and \'Did you mean\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r""git: \'([^\']*)\' is not a git command"",\n                            command.stderr)[0]\n    new_cmd = re.findall(r\'Did you mean[^\\n]*\\n\\s*([^\\n]*)\',\n                         command.stderr)[0]\n    return command.script.replace(broken_cmd, new_cmd, 1)\n\n']","[[], [<pydriller.domain.commit.Method object at 0x7f1983ce9970>, <pydriller.domain.commit.Method object at 0x7f1983ce96d0>, <pydriller.domain.commit.Method object at 0x7f1983ce9550>, <pydriller.domain.commit.Method object at 0x7f1983d4afd0>], [<pydriller.domain.commit.Method object at 0x7f1983dacc10>, <pydriller.domain.commit.Method object at 0x7f1983dacbe0>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d4afd0>, <pydriller.domain.commit.Method object at 0x7f1983ce9550>, <pydriller.domain.commit.Method object at 0x7f1983d85c10>, <pydriller.domain.commit.Method object at 0x7f1983d7f160>, <pydriller.domain.commit.Method object at 0x7f1983d5c6d0>], [<pydriller.domain.commit.Method object at 0x7f1983dbe970>, <pydriller.domain.commit.Method object at 0x7f1983dbe550>]]"
thefuck,7888315196a5e97549e93d772396e85f34f65bc5,"#52 Use `cp -a`, add tests",2015-04-20 22:00:37+02:00,nvbn,20,6,26,2,"['test_cp_omitting_directory.py', 'cp_omitting_directory.py']","[None, ""def match(command, settings):\n    if 'cp: omitting directory' in command.stderr.lower():\n        return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return command.script.replace('cp', 'cp -r') \n\n\n""]","['from mock import Mock\nfrom thefuck.rules.cp_omitting_directory import match, get_new_command\n\n\ndef test_match():\n    assert match(Mock(script=\'cp dir\', stderr=""cp: omitting directory \'dir\'""),\n                 None)\n    assert not match(Mock(script=\'some dir\',\n                          stderr=""cp: omitting directory \'dir\'""), None)\n    assert not match(Mock(script=\'cp dir\', stderr=""""), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Mock(script=\'cp dir\'), None) == \'cp -a dir\'\n', ""import re\n\n\ndef match(command, settings):\n    return command.script.startswith('cp ') \\\n        and 'cp: omitting directory' in command.stderr.lower()\n\n\ndef get_new_command(command, settings):\n    return re.sub(r'^cp', 'cp -a', command.script)\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e04970>, <pydriller.domain.commit.Method object at 0x7f1983e04c10>]]","[[<pydriller.domain.commit.Method object at 0x7f1983da1820>, <pydriller.domain.commit.Method object at 0x7f1983da17f0>], [<pydriller.domain.commit.Method object at 0x7f1983e09400>, <pydriller.domain.commit.Method object at 0x7f1983e09fd0>]]"
thefuck,e822fade4c58377ed0eb3ec9759c4eddf4ecf842,#10 Add `require_confirmation` option,2015-04-21 05:30:15+02:00,nvbn,62,3,65,3,"['README.md', 'test_main.py', 'main.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scary to blindly run changed command, there\'s `require_confirmation`\n[settings](#Settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","[[], [<pydriller.domain.commit.Method object at 0x7f1983dfe7f0>, <pydriller.domain.commit.Method object at 0x7f1983dfed30>, <pydriller.domain.commit.Method object at 0x7f1983e096d0>, <pydriller.domain.commit.Method object at 0x7f1983e09ac0>, <pydriller.domain.commit.Method object at 0x7f1983e09e80>, <pydriller.domain.commit.Method object at 0x7f1983e092e0>], [<pydriller.domain.commit.Method object at 0x7f1983d5c400>, <pydriller.domain.commit.Method object at 0x7f1983d7f970>, <pydriller.domain.commit.Method object at 0x7f1983d7fd30>, <pydriller.domain.commit.Method object at 0x7f1983d7fac0>, <pydriller.domain.commit.Method object at 0x7f1983d56be0>, <pydriller.domain.commit.Method object at 0x7f1983d56040>, <pydriller.domain.commit.Method object at 0x7f1983d56580>, <pydriller.domain.commit.Method object at 0x7f1983d56970>, <pydriller.domain.commit.Method object at 0x7f1983d56550>, <pydriller.domain.commit.Method object at 0x7f1983d562b0>, <pydriller.domain.commit.Method object at 0x7f1983d566a0>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e42400>, <pydriller.domain.commit.Method object at 0x7f1983df2040>], [<pydriller.domain.commit.Method object at 0x7f1983d3b580>, <pydriller.domain.commit.Method object at 0x7f1983d3b040>, <pydriller.domain.commit.Method object at 0x7f1983dbe580>]]"
thefuck,0925c7966f19f02da93b2047318eb060bf022349,Bump version,2015-04-21 05:34:44+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.14,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.15,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,5ccf163594fa11239b5cb83c73aa9c63879a17f2,`command.script` now unicode,2015-04-21 06:24:40+02:00,nvbn,13,12,25,6,"['test_main.py', 'main.py', 'has_exists_script.py', 'no_command.py', 'python_command.py', 'sudo.py']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n', ""import os\n\n\ndef match(command, settings):\n    return os.path.exists(command.script.split()[0]) \\\n        and 'command not found' in command.stderr\n\n\ndef get_new_command(command, settings):\n    return './{}'.format(command.script)\n\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode(\'utf-8\')\n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n', ""# add 'python' suffix to the command if\n#  1) The script does not have execute permission or\n#  2) is interpreted as shell script\n\ndef match(command, settings):\n  toks = command.script.split()\n  return (len(toks) > 0\n          and toks[0].endswith('.py')\n          and ('Permission denied' in command.stderr or\n               'command not found' in command.stderr))\n\ndef get_new_command(command, settings):\n  return 'python ' + command.script\n"", ""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), [b'thefuck', b'apt-get',\n                                         b'search', b'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n', ""import os\n\n\ndef match(command, settings):\n    return os.path.exists(command.script.split()[0]) \\\n        and 'command not found' in command.stderr\n\n\ndef get_new_command(command, settings):\n    return u'./{}'.format(command.script)\n\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = u\'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode(\'utf-8\')\n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n', ""# add 'python' suffix to the command if\n#  1) The script does not have execute permission or\n#  2) is interpreted as shell script\n\ndef match(command, settings):\n    toks = command.script.split()\n    return (len(toks) > 0\n            and toks[0].endswith('.py')\n            and ('Permission denied' in command.stderr or\n                 'command not found' in command.stderr))\n\n\ndef get_new_command(command, settings):\n    return 'python ' + command.script\n"", ""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983e42be0>, <pydriller.domain.commit.Method object at 0x7f1983e42d30>, <pydriller.domain.commit.Method object at 0x7f1983e42c10>, <pydriller.domain.commit.Method object at 0x7f1983e42a60>, <pydriller.domain.commit.Method object at 0x7f1983e42670>, <pydriller.domain.commit.Method object at 0x7f1983e426a0>, <pydriller.domain.commit.Method object at 0x7f1983e42d60>, <pydriller.domain.commit.Method object at 0x7f1983e42eb0>], [<pydriller.domain.commit.Method object at 0x7f1983e047f0>, <pydriller.domain.commit.Method object at 0x7f1983e42520>, <pydriller.domain.commit.Method object at 0x7f1983e42a90>, <pydriller.domain.commit.Method object at 0x7f1983e42910>, <pydriller.domain.commit.Method object at 0x7f1983e42940>, <pydriller.domain.commit.Method object at 0x7f1983e427c0>, <pydriller.domain.commit.Method object at 0x7f1983e427f0>, <pydriller.domain.commit.Method object at 0x7f1983dcf7f0>, <pydriller.domain.commit.Method object at 0x7f1983dcf160>, <pydriller.domain.commit.Method object at 0x7f1983dcfac0>, <pydriller.domain.commit.Method object at 0x7f1983dcfa90>, <pydriller.domain.commit.Method object at 0x7f1983dcf040>], [<pydriller.domain.commit.Method object at 0x7f1983dcfbe0>, <pydriller.domain.commit.Method object at 0x7f1983dcf550>], [<pydriller.domain.commit.Method object at 0x7f1983de6160>, <pydriller.domain.commit.Method object at 0x7f1983de6400>, <pydriller.domain.commit.Method object at 0x7f1983de6190>], [<pydriller.domain.commit.Method object at 0x7f1983ddf970>, <pydriller.domain.commit.Method object at 0x7f1983d95970>], [<pydriller.domain.commit.Method object at 0x7f1983d90ac0>, <pydriller.domain.commit.Method object at 0x7f1983d907f0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983dcf6d0>], [<pydriller.domain.commit.Method object at 0x7f1983dcaeb0>], [<pydriller.domain.commit.Method object at 0x7f1983dca6a0>], [<pydriller.domain.commit.Method object at 0x7f1983ddbd60>], [<pydriller.domain.commit.Method object at 0x7f1983deb430>, <pydriller.domain.commit.Method object at 0x7f1983deb550>], [<pydriller.domain.commit.Method object at 0x7f1983d9c940>]]"
thefuck,e7d5d93056e5238f24da548d578157dbc655dde9,#68 Add rule for switching layout,2015-04-21 06:26:15+02:00,nvbn,50,2,52,4,"['README.md', 'setup.py', 'test_switch_lang.py', 'switch_lang.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scary to blindly run changed command, there\'s `require_confirmation`\n[settings](#Settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.15,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', None, None]","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scary to blindly run changed command, there\'s `require_confirmation`\n[settings](#Settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.16,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""# -*- encoding: utf-8 -*-\n\nfrom mock import Mock\nfrom thefuck.rules import switch_lang\n\n\ndef test_match():\n    assert switch_lang.match(Mock(stderr='command not found: фзе-пуе',\n                                  script=u'фзе-пуе'), None)\n    assert not switch_lang.match(Mock(stderr='command not found: pat-get',\n                                      script=u'pat-get'), None)\n    assert not switch_lang.match(Mock(stderr='some info',\n                                      script=u'фзе-пуе'), None)\n\n\ndef test_get_new_command():\n    assert switch_lang.get_new_command(\n        Mock(script=u'фзе-пуе штыефдд мшь'), None) == 'apt-get install vim'\n"", '# -*- encoding: utf-8 -*-\n\ntarget_layout = \'\'\'qwertyuiop[]asdfghjkl;\'zxcvbnm,./QWERTYUIOP{}ASDFGHJKL:""ZXCVBNM<>?\'\'\'\n\nsource_layouts = [u\'\'\'йцукенгшщзхъфывапролджэячсмитьбю.ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,\'\'\']\n\n\ndef _get_matched_layout(command):\n    for source_layout in source_layouts:\n        if all([ch in source_layout or ch in \'-_\'\n                for ch in command.script.split(\' \')[0]]):\n            return source_layout\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and _get_matched_layout(command)\n\n\ndef _switch(ch, layout):\n    if ch in layout:\n        return target_layout[layout.index(ch)]\n    else:\n        return ch\n\n\ndef get_new_command(command, settings):\n    matched_layout = _get_matched_layout(command)\n    return \'\'.join(_switch(ch, matched_layout) for ch in command.script)\n\n']","[[], [], [], []]","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983d4a190>, <pydriller.domain.commit.Method object at 0x7f1983d4abe0>], [<pydriller.domain.commit.Method object at 0x7f1983d23160>, <pydriller.domain.commit.Method object at 0x7f1983dfe400>, <pydriller.domain.commit.Method object at 0x7f1983d74160>, <pydriller.domain.commit.Method object at 0x7f1983d74d60>]]"
thefuck,ab8ac23749d90f0265d29cfe3440357098b97225,Fix python 3 support,2015-04-21 06:33:51+02:00,nvbn,4,1,5,1,['main.py'],"['from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","['from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","[[<pydriller.domain.commit.Method object at 0x7f1983e34250>, <pydriller.domain.commit.Method object at 0x7f1983e343a0>, <pydriller.domain.commit.Method object at 0x7f1983e34280>, <pydriller.domain.commit.Method object at 0x7f1983e34100>, <pydriller.domain.commit.Method object at 0x7f1983e2e910>, <pydriller.domain.commit.Method object at 0x7f1983e2e790>, <pydriller.domain.commit.Method object at 0x7f1983e2e7c0>, <pydriller.domain.commit.Method object at 0x7f1983e2e640>, <pydriller.domain.commit.Method object at 0x7f1983e2e670>, <pydriller.domain.commit.Method object at 0x7f1983e2e4f0>, <pydriller.domain.commit.Method object at 0x7f1983e2e520>, <pydriller.domain.commit.Method object at 0x7f1983e2e3a0>]]",[[<pydriller.domain.commit.Method object at 0x7f1983e34cd0>]]
thefuck,8ed01fedbfcca1cb5acf1ca728a857ff93807942,Bump version,2015-04-21 06:34:03+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.16,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.17,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,360613150247c52804d0c0f00aa84e21d717f746,Fix tests,2015-04-21 06:36:51+02:00,nvbn,2,2,4,1,['test_main.py'],"[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), [b'thefuck', b'apt-get',\n                                         b'search', b'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n""]","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983e237c0>, <pydriller.domain.commit.Method object at 0x7f1983e23280>, <pydriller.domain.commit.Method object at 0x7f1983e29910>, <pydriller.domain.commit.Method object at 0x7f1983e29670>, <pydriller.domain.commit.Method object at 0x7f1983e29b80>, <pydriller.domain.commit.Method object at 0x7f1983e29e20>, <pydriller.domain.commit.Method object at 0x7f1983e29fa0>, <pydriller.domain.commit.Method object at 0x7f1983e29130>]]",[[<pydriller.domain.commit.Method object at 0x7f1983e1dfa0>]]
thefuck,e3edea05edc29bc1e0a5bdcfea4e35c2a46fd972,#24 Make `no_command` crossplatform,2015-04-21 06:55:47+02:00,nvbn,29,81,110,3,"['README.md', 'test_no_command.py', 'no_command.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scary to blindly run changed command, there\'s `require_confirmation`\n[settings](#Settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_match(command_found, command_not_found, settings):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), settings)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), settings)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), settings)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), settings) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = u\'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode(\'utf-8\')\n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scary to blindly run changed command, there\'s `require_confirmation`\n[settings](#Settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""from mock import patch, Mock\nfrom thefuck.rules.no_command import match, get_new_command\n\n\ndef test_match():\n    with patch('thefuck.rules.no_command._get_all_bins',\n               return_value=['vim', 'apt-get']):\n        assert match(Mock(stderr='vom: not found', script='vom file.py'), None)\n        assert not match(Mock(stderr='qweqwe: not found', script='qweqwe'), None)\n        assert not match(Mock(stderr='some text', script='vom file.py'), None)\n\n\ndef test_get_new_command():\n    with patch('thefuck.rules.no_command._get_all_bins',\n               return_value=['vim', 'apt-get']):\n        assert get_new_command(\n            Mock(stderr='vom: not found',\n                 script='vom file.py'),\n            None) == 'vim file.py'\n"", ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ['PATH'].split(':')\n            for exe in Path(path).iterdir()\n            if exe.is_file()]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d746d0>, <pydriller.domain.commit.Method object at 0x7f1983d74e80>, <pydriller.domain.commit.Method object at 0x7f1983d746a0>, <pydriller.domain.commit.Method object at 0x7f1983e238e0>, <pydriller.domain.commit.Method object at 0x7f1983e23bb0>, <pydriller.domain.commit.Method object at 0x7f1983e23a30>], [<pydriller.domain.commit.Method object at 0x7f1983dc5550>, <pydriller.domain.commit.Method object at 0x7f1983d62160>, <pydriller.domain.commit.Method object at 0x7f1983d62430>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d74e80>, <pydriller.domain.commit.Method object at 0x7f1983e2ee20>, <pydriller.domain.commit.Method object at 0x7f1983e238e0>, <pydriller.domain.commit.Method object at 0x7f1983d746d0>, <pydriller.domain.commit.Method object at 0x7f1983e2efa0>, <pydriller.domain.commit.Method object at 0x7f1983d746a0>, <pydriller.domain.commit.Method object at 0x7f1983e23a30>, <pydriller.domain.commit.Method object at 0x7f1983e23bb0>], [<pydriller.domain.commit.Method object at 0x7f1983d4ac10>, <pydriller.domain.commit.Method object at 0x7f1983d4ad60>, <pydriller.domain.commit.Method object at 0x7f1983d4a2e0>, <pydriller.domain.commit.Method object at 0x7f1983dc5550>]]"
thefuck,e1fe7ff7d02abe9fc1a447bf49eb97b37ca7b18d,Bump version,2015-04-21 06:56:26+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.17,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.18,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,3798c341d524eb474763d4ccfc8a49e8bf106aa7,"add persian language to switch lang rule
refs #28",2015-04-21 09:42:13+04:30,fzerorubigd,1,1,2,1,['switch_lang.py'],"['# -*- encoding: utf-8 -*-\n\ntarget_layout = \'\'\'qwertyuiop[]asdfghjkl;\'zxcvbnm,./QWERTYUIOP{}ASDFGHJKL:""ZXCVBNM<>?\'\'\'\n\nsource_layouts = [u\'\'\'йцукенгшщзхъфывапролджэячсмитьбю.ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,\'\'\']\n\n\ndef _get_matched_layout(command):\n    for source_layout in source_layouts:\n        if all([ch in source_layout or ch in \'-_\'\n                for ch in command.script.split(\' \')[0]]):\n            return source_layout\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and _get_matched_layout(command)\n\n\ndef _switch(ch, layout):\n    if ch in layout:\n        return target_layout[layout.index(ch)]\n    else:\n        return ch\n\n\ndef get_new_command(command, settings):\n    matched_layout = _get_matched_layout(command)\n    return \'\'.join(_switch(ch, matched_layout) for ch in command.script)\n\n']","['# -*- encoding: utf-8 -*-\n\ntarget_layout = \'\'\'qwertyuiop[]asdfghjkl;\'zxcvbnm,./QWERTYUIOP{}ASDFGHJKL:""ZXCVBNM<>?\'\'\'\n\nsource_layouts = [u\'\'\'йцукенгшщзхъфывапролджэячсмитьбю.ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,\'\'\', u\'\'\'ضصثقفغعهخحجچشسیبلاتنمکگظطزرذدپو./ًٌٍَُِّْ][}{ؤئيإأآة»«:؛كٓژٰ\u200cٔء><؟\'\'\']\n\n\ndef _get_matched_layout(command):\n    for source_layout in source_layouts:\n        if all([ch in source_layout or ch in \'-_\'\n                for ch in command.script.split(\' \')[0]]):\n            return source_layout\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and _get_matched_layout(command)\n\n\ndef _switch(ch, layout):\n    if ch in layout:\n        return target_layout[layout.index(ch)]\n    else:\n        return ch\n\n\ndef get_new_command(command, settings):\n    matched_layout = _get_matched_layout(command)\n    return \'\'.join(_switch(ch, matched_layout) for ch in command.script)\n\n']","[[<pydriller.domain.commit.Method object at 0x7f1983ddb2e0>, <pydriller.domain.commit.Method object at 0x7f1983ddbeb0>, <pydriller.domain.commit.Method object at 0x7f1983ddb550>, <pydriller.domain.commit.Method object at 0x7f1983ddb400>]]",[[]]
thefuck,273fc097bd87058a4f303edc3149941d42264240,Update switch_lang.py,2015-04-21 07:16:36+02:00,Vladimir Iakovlev,2,1,3,1,['switch_lang.py'],"['# -*- encoding: utf-8 -*-\n\ntarget_layout = \'\'\'qwertyuiop[]asdfghjkl;\'zxcvbnm,./QWERTYUIOP{}ASDFGHJKL:""ZXCVBNM<>?\'\'\'\n\nsource_layouts = [u\'\'\'йцукенгшщзхъфывапролджэячсмитьбю.ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,\'\'\', u\'\'\'ضصثقفغعهخحجچشسیبلاتنمکگظطزرذدپو./ًٌٍَُِّْ][}{ؤئيإأآة»«:؛كٓژٰ\u200cٔء><؟\'\'\']\n\n\ndef _get_matched_layout(command):\n    for source_layout in source_layouts:\n        if all([ch in source_layout or ch in \'-_\'\n                for ch in command.script.split(\' \')[0]]):\n            return source_layout\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and _get_matched_layout(command)\n\n\ndef _switch(ch, layout):\n    if ch in layout:\n        return target_layout[layout.index(ch)]\n    else:\n        return ch\n\n\ndef get_new_command(command, settings):\n    matched_layout = _get_matched_layout(command)\n    return \'\'.join(_switch(ch, matched_layout) for ch in command.script)\n\n']","['# -*- encoding: utf-8 -*-\n\ntarget_layout = \'\'\'qwertyuiop[]asdfghjkl;\'zxcvbnm,./QWERTYUIOP{}ASDFGHJKL:""ZXCVBNM<>?\'\'\'\n\nsource_layouts = [u\'\'\'йцукенгшщзхъфывапролджэячсмитьбю.ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,\'\'\',\n                  u\'\'\'ضصثقفغعهخحجچشسیبلاتنمکگظطزرذدپو./ًٌٍَُِّْ][}{ؤئيإأآة»«:؛كٓژٰ\u200cٔء><؟\'\'\']\n\n\ndef _get_matched_layout(command):\n    for source_layout in source_layouts:\n        if all([ch in source_layout or ch in \'-_\'\n                for ch in command.script.split(\' \')[0]]):\n            return source_layout\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and _get_matched_layout(command)\n\n\ndef _switch(ch, layout):\n    if ch in layout:\n        return target_layout[layout.index(ch)]\n    else:\n        return ch\n\n\ndef get_new_command(command, settings):\n    matched_layout = _get_matched_layout(command)\n    return \'\'.join(_switch(ch, matched_layout) for ch in command.script)\n\n']","[[<pydriller.domain.commit.Method object at 0x7f1983dca2b0>, <pydriller.domain.commit.Method object at 0x7f1983dca970>, <pydriller.domain.commit.Method object at 0x7f1983dcae80>, <pydriller.domain.commit.Method object at 0x7f1983dcafd0>]]",[[]]
thefuck,478fa4cd09059eea4c89adf16ac31dcd975cfa8f,#71 Not fail on os error,2015-04-21 08:30:48+02:00,nvbn,10,3,13,2,"['setup.py', 'no_command.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.18,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ['PATH'].split(':')\n            for exe in Path(path).iterdir()\n            if exe.is_file()]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n""]","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.19,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _safe(path, method):\n    try:\n        return getattr(path, method)()\n    except OSError:\n        return []\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ['PATH'].split(':')\n            for exe in _safe(Path(path), 'iterdir')\n            if not _safe(exe, 'is_dir')]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e1de50>, <pydriller.domain.commit.Method object at 0x7f1983e1d3d0>, <pydriller.domain.commit.Method object at 0x7f1983dca580>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e1d670>, <pydriller.domain.commit.Method object at 0x7f1983e1d640>]]"
thefuck,f2392349f732060b2530545f4da37d0bfa611bb2,#71 Handle `OSError` more gratefully,2015-04-21 08:38:52+02:00,nvbn,6,6,12,2,"['setup.py', 'no_command.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.19,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _safe(path, method):\n    try:\n        return getattr(path, method)()\n    except OSError:\n        return []\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ['PATH'].split(':')\n            for exe in _safe(Path(path), 'iterdir')\n            if not _safe(exe, 'is_dir')]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n""]","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.20,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _safe(fn, fallback):\n    try:\n        return fn()\n    except OSError:\n        return fallback\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ['PATH'].split(':')\n            for exe in _safe(Path(path).iterdir, [])\n            if not _safe(exe.is_dir, True)]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983ddffd0>, <pydriller.domain.commit.Method object at 0x7f1983ddfe80>, <pydriller.domain.commit.Method object at 0x7f1983cdd6d0>, <pydriller.domain.commit.Method object at 0x7f1983ce9400>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983de6040>, <pydriller.domain.commit.Method object at 0x7f1983ddffd0>, <pydriller.domain.commit.Method object at 0x7f1983de6c10>]]"
thefuck,82e2c894720e0316d9799eb56374ee06858a8b0c,Fix version number,2015-04-21 08:40:17+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.20,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=""1.20"",\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,798928b5adc67cbacecc166937b6282b079ef7c1,#71 Don't fail on non-exists dir in $PATH,2015-04-21 08:45:45+02:00,nvbn,2,2,4,2,"['setup.py', 'no_command.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=""1.20"",\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _safe(fn, fallback):\n    try:\n        return fn()\n    except OSError:\n        return fallback\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ['PATH'].split(':')\n            for exe in _safe(Path(path).iterdir, [])\n            if not _safe(exe.is_dir, True)]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n""]","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=""1.21"",\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _safe(fn, fallback):\n    try:\n        return fn()\n    except OSError:\n        return fallback\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ['PATH'].split(':')\n            for exe in _safe(lambda: Path(path).iterdir(), [])\n            if not _safe(exe.is_dir, True)]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e29bb0>, <pydriller.domain.commit.Method object at 0x7f1983e297c0>, <pydriller.domain.commit.Method object at 0x7f1983e29250>, <pydriller.domain.commit.Method object at 0x7f1983e298e0>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e23d00>]]"
thefuck,bd5f5045aa208e737ce61f77b279574cd5a8e31b,#71 Handle `iterdir` iterator fails,2015-04-21 08:57:35+02:00,nvbn,3,3,6,2,"['setup.py', 'no_command.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=""1.21"",\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _safe(fn, fallback):\n    try:\n        return fn()\n    except OSError:\n        return fallback\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ['PATH'].split(':')\n            for exe in _safe(lambda: Path(path).iterdir(), [])\n            if not _safe(exe.is_dir, True)]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n""]","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=""1.22"",\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _safe(fn, fallback):\n    try:\n        return fn()\n    except OSError:\n        return fallback\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ.get('PATH', '').split(':')\n            for exe in _safe(lambda: list(Path(path).iterdir()), [])\n            if not _safe(exe.is_dir, True)]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e86b80>, <pydriller.domain.commit.Method object at 0x7f1983e86cd0>, <pydriller.domain.commit.Method object at 0x7f1983e86bb0>, <pydriller.domain.commit.Method object at 0x7f1983e86a30>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e0c910>]]"
thefuck,3af5c80d293c579591b58f63a5b01574f76991c9,Add 'root privilege' pattern to sudo rule.,2015-04-21 12:57:35+04:30,Soheil Rashidi,2,1,3,1,['sudo.py'],"[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted',\n            'root privilege']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983e12520>, <pydriller.domain.commit.Method object at 0x7f1983e12f70>]]",[[]]
thefuck,de4b774134ed671451a6b44c5d8628a227bf25c4,Added a string which could be thrown by Fedora's new dnf package manager.,2015-04-21 19:43:10+08:00,Dugucloud,2,1,3,1,['sudo.py'],"[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted',\n            'This command has to be run under the root user.']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983e347c0>, <pydriller.domain.commit.Method object at 0x7f1983e34e50>]]",[[]]
thefuck,d5b4bddc4cf958e362ed0ee1b8a6c474fc78e242,#74 Don't fail when runned without args,2015-04-21 14:26:45+02:00,nvbn,5,0,5,2,"['test_main.py', 'main.py']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","[[<pydriller.domain.commit.Method object at 0x7f1983d0b6a0>, <pydriller.domain.commit.Method object at 0x7f1983d902e0>, <pydriller.domain.commit.Method object at 0x7f1983d9c430>, <pydriller.domain.commit.Method object at 0x7f1983d9cac0>, <pydriller.domain.commit.Method object at 0x7f1983ce9e80>, <pydriller.domain.commit.Method object at 0x7f1983ce9fd0>, <pydriller.domain.commit.Method object at 0x7f1983d3b940>, <pydriller.domain.commit.Method object at 0x7f1983d3b7f0>], [<pydriller.domain.commit.Method object at 0x7f1983dcf820>, <pydriller.domain.commit.Method object at 0x7f1983dcf190>, <pydriller.domain.commit.Method object at 0x7f1983dcffd0>, <pydriller.domain.commit.Method object at 0x7f1983dcf970>, <pydriller.domain.commit.Method object at 0x7f1983e17130>, <pydriller.domain.commit.Method object at 0x7f1983e178e0>, <pydriller.domain.commit.Method object at 0x7f1983e17b80>, <pydriller.domain.commit.Method object at 0x7f1983e17790>, <pydriller.domain.commit.Method object at 0x7f1983e174f0>, <pydriller.domain.commit.Method object at 0x7f1983e17280>, <pydriller.domain.commit.Method object at 0x7f1983e17250>, <pydriller.domain.commit.Method object at 0x7f1983e17cd0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983e2e3d0>], [<pydriller.domain.commit.Method object at 0x7f1983ddb820>]]"
thefuck,888756d519ba1915c37e2da3e137f35c2e5e3cea,#74 Don't fail when rule throws exception,2015-04-21 14:40:52+02:00,nvbn,25,16,41,2,"['test_main.py', 'main.py']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule('bash', match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash', 'bash'),\n                                  main.Rule('lisp', 'lisp', 'lisp'),\n                                  main.Rule('bash', 'bash', 'bash'),\n                                  main.Rule('lisp', 'lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash', 'bash'),\n                                      main.Rule('bash', 'bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None),\n             main.Rule('', lambda *_: False, None),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0]\\\n           == '[WARN] rule: Traceback (most recent call last):'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom traceback import format_exception\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            sys.stderr.write(u\'[WARN] {}: {}---------------------\\n\\n\'.format(\n                rule.name, \'\'.join(format_exception(*sys.exc_info()))))\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","[[<pydriller.domain.commit.Method object at 0x7f1983e1df70>, <pydriller.domain.commit.Method object at 0x7f1983e1dd00>, <pydriller.domain.commit.Method object at 0x7f1983e1d100>, <pydriller.domain.commit.Method object at 0x7f1983e1da60>, <pydriller.domain.commit.Method object at 0x7f1983e04550>, <pydriller.domain.commit.Method object at 0x7f1983e04ac0>, <pydriller.domain.commit.Method object at 0x7f1983e04fd0>, <pydriller.domain.commit.Method object at 0x7f1983e04430>], [<pydriller.domain.commit.Method object at 0x7f1983deb040>, <pydriller.domain.commit.Method object at 0x7f1983deb580>, <pydriller.domain.commit.Method object at 0x7f1983deb2b0>, <pydriller.domain.commit.Method object at 0x7f1983deb6d0>, <pydriller.domain.commit.Method object at 0x7f1983e3c250>, <pydriller.domain.commit.Method object at 0x7f1983e3cbb0>, <pydriller.domain.commit.Method object at 0x7f1983e3c4f0>, <pydriller.domain.commit.Method object at 0x7f1983e3ca60>, <pydriller.domain.commit.Method object at 0x7f1983e3c8e0>, <pydriller.domain.commit.Method object at 0x7f1983e3c670>, <pydriller.domain.commit.Method object at 0x7f1983e3c3a0>, <pydriller.domain.commit.Method object at 0x7f1983e3c910>]]","[[<pydriller.domain.commit.Method object at 0x7f1983dca940>, <pydriller.domain.commit.Method object at 0x7f1983e09eb0>, <pydriller.domain.commit.Method object at 0x7f1983e04ac0>, <pydriller.domain.commit.Method object at 0x7f1983dca190>, <pydriller.domain.commit.Method object at 0x7f1983e09160>], [<pydriller.domain.commit.Method object at 0x7f1983deb970>, <pydriller.domain.commit.Method object at 0x7f1983dacd30>]]"
thefuck,54d82f9528ae9cb0b7fa62522156ad832c976ed1,Bump version,2015-04-21 14:41:28+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=""1.22"",\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=""1.23"",\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,93b6a623e1c527b8e08093a986ca23fbb189d949,"adding rule to run ""sudo apt-get install""",2015-04-21 17:59:44+02:00,Lukas Vacek,28,0,28,1,['apt_get.py'],[None],"['import sys\n\ndef match(command, settings):\n    try:\n        import CommandNotFound\n        if \'not found\' in command.stderr:\n            try:\n                c = CommandNotFound.CommandNotFound()\n                pkgs = c.getPackages(command.script.split("" "")[0])\n                name,_ = pkgs[0]\n                return True\n            except IndexError:\n                # IndexError is thrown when no matching package is found\n                return False\n    except:\n        return False\n\ndef get_new_command(command, settings):\n    try:\n        import CommandNotFound\n        c = CommandNotFound.CommandNotFound()\n        if \'not found\' in command.stderr:\n            pkgs = c.getPackages(command.script.split("" "")[0])\n            name,_ = pkgs[0]\n            return ""sudo apt-get install %s"" % name\n    except:\n        sys.stderr.write(""Can\'t apt fuck\\n"")\n        return """"\n']",[[]],"[[<pydriller.domain.commit.Method object at 0x7f1983cd7970>, <pydriller.domain.commit.Method object at 0x7f1983cd72b0>]]"
thefuck,943613a194ee76be9a73eedcb82c0036bb37b3f0,add thing for when known hosts have changed,2015-04-21 17:05:52+01:00,Nic West,112,0,112,2,"['test_ssh_known_host.py', 'ssh_known_hosts.py']","[None, None]","['import os\nimport pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.ssh_known_hosts import match, get_new_command, remove_offending_keys\n\n\n@pytest.fixture\ndef ssh_error(tmpdir):\n    path = os.path.join(str(tmpdir), \'known_hosts\')\n\n    def reset(path):\n        with open(path, \'w\') as fh:\n            lines = [\n                \'123.234.567.890 asdjkasjdakjsd\\n\'\n                \'98.765.432.321 ejioweojwejrosj\\n\'\n                \'111.222.333.444 qwepoiwqepoiss\\n\'\n            ]\n            fh.writelines(lines)\n\n    def known_hosts(path):\n        with open(path, \'r\') as fh:\n            return fh.readlines()\n\n    reset(path)\n\n    errormsg = u""""""@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\nb6:cb:07:34:c0:a0:94:d3:0d:69:83:31:f4:c5:20:9b.\nPlease contact your system administrator.\nAdd correct host key in {0} to get rid of this message.\nOffending RSA key in {0}:2\nRSA host key for {1} has changed and you have requested strict checking.\nHost key verification failed."""""".format(path, \'98.765.432.321\')\n\n    return errormsg, path, reset, known_hosts\n\n\ndef test_match(ssh_error):\n    errormsg, _, _, _ = ssh_error    \n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert not match(Command(\'\', \'\', errormsg), None)\n    assert not match(Command(\'notssh\', \'\', errormsg), None)\n    assert not match(Command(\'ssh\', \'\', \'\'), None)\n\n\ndef test_remove_offending_keys(ssh_error):\n    errormsg, path, reset, known_hosts = ssh_error\n    command = Command(\'ssh user@host\', \'\', errormsg)\n    remove_offending_keys(command, None)\n    expected =[\'123.234.567.890 asdjkasjdakjsd\\n\', \'111.222.333.444 qwepoiwqepoiss\\n\']\n    assert known_hosts(path) == expected\n\n\ndef test_get_new_command(ssh_error, monkeypatch):\n    errormsg, _, _, _ = ssh_error\n\n    class Mock:\n        was_called = False\n\n        def __call__(self, *args, **kwargs):\n            self.was_called = True\n\n    method = Mock()\n    monkeypatch.setattr(\'thefuck.rules.ssh_known_hosts.remove_offending_keys\', method)\n    assert get_new_command(Command(\'ssh user@host\', \'\', errormsg), None) == \'ssh user@host\'\n    assert method.was_called\n', 'import re\npatterns = [\n    r\'WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!\',\n    r\'WARNING: POSSIBLE DNS SPOOFING DETECTED!\',\n    r""Warning: the \\S+ host key for \'([^\']+)\' differs from the key for the IP address \'([^\']+)\'"",\n]\noffending_pattern = re.compile(\n    r\'(?:Offending (?:key for IP|\\S+ key)|Matching host key) in ([^:]+):(\\d+)\',\n    re.MULTILINE)\n\ncommands = [\'ssh\', \'scp\']\n\n\ndef match(command, settings):\n    if not command.script:\n        return False\n    if not command.script.split()[0] in commands:\n        return False\n    if not any([re.findall(pattern, command.stderr) for pattern in patterns]):\n        return False\n    return True\n\n\ndef remove_offending_keys(command, settings):\n    offending = offending_pattern.findall(command.stderr)\n    print offending\n    for filepath, lineno in offending:\n        with open(filepath, \'r\') as fh:\n            lines = fh.readlines()\n            del lines[int(lineno) - 1]\n            print lines\n        with open(filepath, \'w\') as fh:\n            fh.writelines(lines)\n\n\ndef get_new_command(command, settings):\n    remove_offending_keys(command, settings)\n    return command.script\n']","[[], []]","[[<pydriller.domain.commit.Method object at 0x7f1983dc5eb0>, <pydriller.domain.commit.Method object at 0x7f1983d9ca90>, <pydriller.domain.commit.Method object at 0x7f1983ddf550>, <pydriller.domain.commit.Method object at 0x7f1983d90430>, <pydriller.domain.commit.Method object at 0x7f1983ddf820>, <pydriller.domain.commit.Method object at 0x7f1983dc5820>, <pydriller.domain.commit.Method object at 0x7f1983d906d0>], [<pydriller.domain.commit.Method object at 0x7f1983e23520>, <pydriller.domain.commit.Method object at 0x7f1983e23130>, <pydriller.domain.commit.Method object at 0x7f1983e23790>]]"
thefuck,2a7cbef3b5e364fa6da4850178b06ed85bb5304c,add tests for cd_parent,2015-04-21 23:41:49+05:30,SanketDG,12,0,12,1,['test_cd_parent.py'],[None],"[""from thefuck.main import Command\nfrom thefuck.rules.cd_parent import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('cd..', '', 'cd..: command not found'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(\n        Command('cd..', '', ''), None) == 'cd ..'\n""]",[[]],"[[<pydriller.domain.commit.Method object at 0x7f1983e12cd0>, <pydriller.domain.commit.Method object at 0x7f1983e12fa0>]]"
thefuck,4b8d4926aa2362340f4e8b57ee55e48846ccb6c3,Add Greek to switch lang,2015-04-21 22:00:05+02:00,Dionysis Zindros,2,1,3,1,['switch_lang.py'],"['# -*- encoding: utf-8 -*-\n\ntarget_layout = \'\'\'qwertyuiop[]asdfghjkl;\'zxcvbnm,./QWERTYUIOP{}ASDFGHJKL:""ZXCVBNM<>?\'\'\'\n\nsource_layouts = [u\'\'\'йцукенгшщзхъфывапролджэячсмитьбю.ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,\'\'\',\n                  u\'\'\'ضصثقفغعهخحجچشسیبلاتنمکگظطزرذدپو./ًٌٍَُِّْ][}{ؤئيإأآة»«:؛كٓژٰ\u200cٔء><؟\'\'\']\n\n\ndef _get_matched_layout(command):\n    for source_layout in source_layouts:\n        if all([ch in source_layout or ch in \'-_\'\n                for ch in command.script.split(\' \')[0]]):\n            return source_layout\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and _get_matched_layout(command)\n\n\ndef _switch(ch, layout):\n    if ch in layout:\n        return target_layout[layout.index(ch)]\n    else:\n        return ch\n\n\ndef get_new_command(command, settings):\n    matched_layout = _get_matched_layout(command)\n    return \'\'.join(_switch(ch, matched_layout) for ch in command.script)\n\n']","['# -*- encoding: utf-8 -*-\n\ntarget_layout = \'\'\'qwertyuiop[]asdfghjkl;\'zxcvbnm,./QWERTYUIOP{}ASDFGHJKL:""ZXCVBNM<>?\'\'\'\n\nsource_layouts = [u\'\'\'йцукенгшщзхъфывапролджэячсмитьбю.ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,\'\'\',\n                  u\'\'\'ضصثقفغعهخحجچشسیبلاتنمکگظطزرذدپو./ًٌٍَُِّْ][}{ؤئيإأآة»«:؛كٓژٰ\u200cٔء><؟\'\'\',\n                  u\'\'\';ςερτυθιοπ[]ασδφγηξκλ΄ζχψωβνμ,./:΅ΕΡΤΥΘΙΟΠ{}ΑΣΔΦΓΗΞΚΛ¨""ΖΧΨΩΒΝΜ<>?\'\'\']\n\n\ndef _get_matched_layout(command):\n    for source_layout in source_layouts:\n        if all([ch in source_layout or ch in \'-_\'\n                for ch in command.script.split(\' \')[0]]):\n            return source_layout\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and _get_matched_layout(command)\n\n\ndef _switch(ch, layout):\n    if ch in layout:\n        return target_layout[layout.index(ch)]\n    else:\n        return ch\n\n\ndef get_new_command(command, settings):\n    matched_layout = _get_matched_layout(command)\n    return \'\'.join(_switch(ch, matched_layout) for ch in command.script)\n\n']","[[<pydriller.domain.commit.Method object at 0x7f1983e86e20>, <pydriller.domain.commit.Method object at 0x7f1983e86d00>, <pydriller.domain.commit.Method object at 0x7f1983e86a60>, <pydriller.domain.commit.Method object at 0x7f1983e868e0>]]",[[]]
thefuck,4f10fe647d31e455c2a43c6ea326cf6f3c1d49ac,Add tests for greek langage,2015-04-21 22:09:48+02:00,Dionysis Zindros,7,0,7,1,['test_switch_lang.py'],"[""# -*- encoding: utf-8 -*-\n\nfrom mock import Mock\nfrom thefuck.rules import switch_lang\n\n\ndef test_match():\n    assert switch_lang.match(Mock(stderr='command not found: фзе-пуе',\n                                  script=u'фзе-пуе'), None)\n    assert not switch_lang.match(Mock(stderr='command not found: pat-get',\n                                      script=u'pat-get'), None)\n    assert not switch_lang.match(Mock(stderr='some info',\n                                      script=u'фзе-пуе'), None)\n\n\ndef test_get_new_command():\n    assert switch_lang.get_new_command(\n        Mock(script=u'фзе-пуе штыефдд мшь'), None) == 'apt-get install vim'\n""]","[""# -*- encoding: utf-8 -*-\n\nfrom mock import Mock\nfrom thefuck.rules import switch_lang\n\n\ndef test_match():\n    assert switch_lang.match(Mock(stderr='command not found: фзе-пуе',\n                                  script=u'фзе-пуе'), None)\n    assert switch_lang.match(Mock(stderr='command not found: λσ',\n                                  script=u'λσ'), None)\n\n    assert not switch_lang.match(Mock(stderr='command not found: pat-get',\n                                      script=u'pat-get'), None)\n    assert not switch_lang.match(Mock(stderr='command not found: ls',\n                                      script=u'ls'), None)\n    assert not switch_lang.match(Mock(stderr='some info',\n                                      script=u'фзе-пуе'), None)\n\n\ndef test_get_new_command():\n    assert switch_lang.get_new_command(\n        Mock(script=u'фзе-пуе штыефдд мшь'), None) == 'apt-get install vim'\n    assert switch_lang.get_new_command(\n        Mock(script=u'λσ -λα'), None) == 'ls -la'\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983e7ad00>, <pydriller.domain.commit.Method object at 0x7f1983e7afa0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983e817c0>, <pydriller.domain.commit.Method object at 0x7f1983e81d00>]]"
thefuck,d1416a6c2a54cfba46675b44a2b99a0cd05d7c83,"#82 Remove unned print, fix python 3 support",2015-04-21 22:10:53+02:00,nvbn,5,11,16,2,"['test_ssh_known_host.py', 'ssh_known_hosts.py']","['import os\nimport pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.ssh_known_hosts import match, get_new_command, remove_offending_keys\n\n\n@pytest.fixture\ndef ssh_error(tmpdir):\n    path = os.path.join(str(tmpdir), \'known_hosts\')\n\n    def reset(path):\n        with open(path, \'w\') as fh:\n            lines = [\n                \'123.234.567.890 asdjkasjdakjsd\\n\'\n                \'98.765.432.321 ejioweojwejrosj\\n\'\n                \'111.222.333.444 qwepoiwqepoiss\\n\'\n            ]\n            fh.writelines(lines)\n\n    def known_hosts(path):\n        with open(path, \'r\') as fh:\n            return fh.readlines()\n\n    reset(path)\n\n    errormsg = u""""""@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\nb6:cb:07:34:c0:a0:94:d3:0d:69:83:31:f4:c5:20:9b.\nPlease contact your system administrator.\nAdd correct host key in {0} to get rid of this message.\nOffending RSA key in {0}:2\nRSA host key for {1} has changed and you have requested strict checking.\nHost key verification failed."""""".format(path, \'98.765.432.321\')\n\n    return errormsg, path, reset, known_hosts\n\n\ndef test_match(ssh_error):\n    errormsg, _, _, _ = ssh_error    \n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert not match(Command(\'\', \'\', errormsg), None)\n    assert not match(Command(\'notssh\', \'\', errormsg), None)\n    assert not match(Command(\'ssh\', \'\', \'\'), None)\n\n\ndef test_remove_offending_keys(ssh_error):\n    errormsg, path, reset, known_hosts = ssh_error\n    command = Command(\'ssh user@host\', \'\', errormsg)\n    remove_offending_keys(command, None)\n    expected =[\'123.234.567.890 asdjkasjdakjsd\\n\', \'111.222.333.444 qwepoiwqepoiss\\n\']\n    assert known_hosts(path) == expected\n\n\ndef test_get_new_command(ssh_error, monkeypatch):\n    errormsg, _, _, _ = ssh_error\n\n    class Mock:\n        was_called = False\n\n        def __call__(self, *args, **kwargs):\n            self.was_called = True\n\n    method = Mock()\n    monkeypatch.setattr(\'thefuck.rules.ssh_known_hosts.remove_offending_keys\', method)\n    assert get_new_command(Command(\'ssh user@host\', \'\', errormsg), None) == \'ssh user@host\'\n    assert method.was_called\n', 'import re\npatterns = [\n    r\'WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!\',\n    r\'WARNING: POSSIBLE DNS SPOOFING DETECTED!\',\n    r""Warning: the \\S+ host key for \'([^\']+)\' differs from the key for the IP address \'([^\']+)\'"",\n]\noffending_pattern = re.compile(\n    r\'(?:Offending (?:key for IP|\\S+ key)|Matching host key) in ([^:]+):(\\d+)\',\n    re.MULTILINE)\n\ncommands = [\'ssh\', \'scp\']\n\n\ndef match(command, settings):\n    if not command.script:\n        return False\n    if not command.script.split()[0] in commands:\n        return False\n    if not any([re.findall(pattern, command.stderr) for pattern in patterns]):\n        return False\n    return True\n\n\ndef remove_offending_keys(command, settings):\n    offending = offending_pattern.findall(command.stderr)\n    print offending\n    for filepath, lineno in offending:\n        with open(filepath, \'r\') as fh:\n            lines = fh.readlines()\n            del lines[int(lineno) - 1]\n            print lines\n        with open(filepath, \'w\') as fh:\n            fh.writelines(lines)\n\n\ndef get_new_command(command, settings):\n    remove_offending_keys(command, settings)\n    return command.script\n']","['import os\nimport pytest\nfrom mock import Mock\nfrom thefuck.main import Command\nfrom thefuck.rules.ssh_known_hosts import match, get_new_command, remove_offending_keys\n\n\n@pytest.fixture\ndef ssh_error(tmpdir):\n    path = os.path.join(str(tmpdir), \'known_hosts\')\n\n    def reset(path):\n        with open(path, \'w\') as fh:\n            lines = [\n                \'123.234.567.890 asdjkasjdakjsd\\n\'\n                \'98.765.432.321 ejioweojwejrosj\\n\'\n                \'111.222.333.444 qwepoiwqepoiss\\n\'\n            ]\n            fh.writelines(lines)\n\n    def known_hosts(path):\n        with open(path, \'r\') as fh:\n            return fh.readlines()\n\n    reset(path)\n\n    errormsg = u""""""@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\nb6:cb:07:34:c0:a0:94:d3:0d:69:83:31:f4:c5:20:9b.\nPlease contact your system administrator.\nAdd correct host key in {0} to get rid of this message.\nOffending RSA key in {0}:2\nRSA host key for {1} has changed and you have requested strict checking.\nHost key verification failed."""""".format(path, \'98.765.432.321\')\n\n    return errormsg, path, reset, known_hosts\n\n\ndef test_match(ssh_error):\n    errormsg, _, _, _ = ssh_error\n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert not match(Command(\'\', \'\', errormsg), None)\n    assert not match(Command(\'notssh\', \'\', errormsg), None)\n    assert not match(Command(\'ssh\', \'\', \'\'), None)\n\n\ndef test_remove_offending_keys(ssh_error):\n    errormsg, path, reset, known_hosts = ssh_error\n    command = Command(\'ssh user@host\', \'\', errormsg)\n    remove_offending_keys(command, None)\n    expected = [\'123.234.567.890 asdjkasjdakjsd\\n\', \'111.222.333.444 qwepoiwqepoiss\\n\']\n    assert known_hosts(path) == expected\n\n\ndef test_get_new_command(ssh_error, monkeypatch):\n    errormsg, _, _, _ = ssh_error\n\n    method = Mock()\n    monkeypatch.setattr(\'thefuck.rules.ssh_known_hosts.remove_offending_keys\', method)\n    assert get_new_command(Command(\'ssh user@host\', \'\', errormsg), None) == \'ssh user@host\'\n    assert method.call_count\n', 'import re\n\npatterns = [\n    r\'WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!\',\n    r\'WARNING: POSSIBLE DNS SPOOFING DETECTED!\',\n    r""Warning: the \\S+ host key for \'([^\']+)\' differs from the key for the IP address \'([^\']+)\'"",\n]\noffending_pattern = re.compile(\n    r\'(?:Offending (?:key for IP|\\S+ key)|Matching host key) in ([^:]+):(\\d+)\',\n    re.MULTILINE)\n\ncommands = [\'ssh\', \'scp\']\n\n\ndef match(command, settings):\n    if not command.script:\n        return False\n    if not command.script.split()[0] in commands:\n        return False\n    if not any([re.findall(pattern, command.stderr) for pattern in patterns]):\n        return False\n    return True\n\n\ndef remove_offending_keys(command, settings):\n    offending = offending_pattern.findall(command.stderr)\n    for filepath, lineno in offending:\n        with open(filepath, \'r\') as fh:\n            lines = fh.readlines()\n            del lines[int(lineno) - 1]\n        with open(filepath, \'w\') as fh:\n            fh.writelines(lines)\n\n\ndef get_new_command(command, settings):\n    remove_offending_keys(command, settings)\n    return command.script\n']","[[<pydriller.domain.commit.Method object at 0x7f1983e6ea30>, <pydriller.domain.commit.Method object at 0x7f1983e6eb80>, <pydriller.domain.commit.Method object at 0x7f1983e6ea60>, <pydriller.domain.commit.Method object at 0x7f1983e6e8e0>, <pydriller.domain.commit.Method object at 0x7f1983e6e3a0>, <pydriller.domain.commit.Method object at 0x7f1983e6e3d0>, <pydriller.domain.commit.Method object at 0x7f1983e6e250>], [<pydriller.domain.commit.Method object at 0x7f1983e68bb0>, <pydriller.domain.commit.Method object at 0x7f1983e68cd0>, <pydriller.domain.commit.Method object at 0x7f1983e68d00>]]","[[<pydriller.domain.commit.Method object at 0x7f1983e743a0>, <pydriller.domain.commit.Method object at 0x7f1983e74cd0>, <pydriller.domain.commit.Method object at 0x7f1983e6e3d0>, <pydriller.domain.commit.Method object at 0x7f1983e74a30>], [<pydriller.domain.commit.Method object at 0x7f1983e68cd0>]]"
thefuck,20f8a4ad17e4fb014d38a390b98fed872cc4ebc8,Bump to 1.24,2015-04-21 22:30:15+02:00,nvbn,36,2,38,2,"['release.py', 'setup.py']","[None, 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=""1.23"",\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['#!/usr/bin/env python\nfrom subprocess import call\nimport re\n\n\nversion = None\n\n\ndef get_new_setup_py_lines():\n    global version\n    with open(\'setup.py\', \'r\') as sf:\n        current_setup = sf.readlines()\n    for line in current_setup:\n        if line.startswith(\'VERSION = \'):\n            major, minor = re.findall(r""VERSION = \'(\\d+)\\.(\\d+)\'"", line)[0]\n            version = ""{}.{}"".format(major, int(minor) + 1)\n            yield ""VERSION = \'{}\'\\n"".format(version)\n        else:\n            yield line\n\n\nlines = list(get_new_setup_py_lines())\nwith open(\'setup.py\', \'w\') as sf:\n    sf.writelines(lines)\n\ncall(\'git commit -am ""Bump to {}""\'.format(version), shell=True)\ncall(\'git tag {}\'.format(version), shell=True)\ncall(\'git push\', shell=True)\ncall(\'git push --tags\', shell=True)\ncall(\'python setup.py sdist upload\', shell=True)\n', 'from setuptools import setup, find_packages\n\n\nVERSION = \'1.24\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","[[], []]","[[<pydriller.domain.commit.Method object at 0x7f1983e74910>], []]"
thefuck,d1b1465f4e80dc08fd210638c05248890c974b35,Bump to 1.26,2015-04-21 22:31:01+02:00,nvbn,2,1,3,2,"['release.py', 'setup.py']","['#!/usr/bin/env python\nfrom subprocess import call\nimport re\n\n\nversion = None\n\n\ndef get_new_setup_py_lines():\n    global version\n    with open(\'setup.py\', \'r\') as sf:\n        current_setup = sf.readlines()\n    for line in current_setup:\n        if line.startswith(\'VERSION = \'):\n            major, minor = re.findall(r""VERSION = \'(\\d+)\\.(\\d+)\'"", line)[0]\n            version = ""{}.{}"".format(major, int(minor) + 1)\n            yield ""VERSION = \'{}\'\\n"".format(version)\n        else:\n            yield line\n\n\nlines = list(get_new_setup_py_lines())\nwith open(\'setup.py\', \'w\') as sf:\n    sf.writelines(lines)\n\ncall(\'git commit -am ""Bump to {}""\'.format(version), shell=True)\ncall(\'git tag {}\'.format(version), shell=True)\ncall(\'git push\', shell=True)\ncall(\'git push --tags\', shell=True)\ncall(\'python setup.py sdist upload\', shell=True)\n', 'from setuptools import setup, find_packages\n\n\nVERSION = \'1.24\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['#!/usr/bin/env python\nfrom subprocess import call\nimport re\n\n\nversion = None\n\n\ndef get_new_setup_py_lines():\n    global version\n    with open(\'setup.py\', \'r\') as sf:\n        current_setup = sf.readlines()\n    for line in current_setup:\n        if line.startswith(\'VERSION = \'):\n            major, minor = re.findall(r""VERSION = \'(\\d+)\\.(\\d+)\'"", line)[0]\n            version = ""{}.{}"".format(major, int(minor) + 1)\n            yield ""VERSION = \'{}\'\\n"".format(version)\n        else:\n            yield line\n\n\nlines = list(get_new_setup_py_lines())\nwith open(\'setup.py\', \'w\') as sf:\n    sf.writelines(lines)\n\ncall(\'git pull\', shell=True)\ncall(\'git commit -am ""Bump to {}""\'.format(version), shell=True)\ncall(\'git tag {}\'.format(version), shell=True)\ncall(\'git push\', shell=True)\ncall(\'git push --tags\', shell=True)\ncall(\'python setup.py sdist upload\', shell=True)\n', 'from setuptools import setup, find_packages\n\n\nVERSION = \'1.26\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","[[<pydriller.domain.commit.Method object at 0x7f1983e0cb80>], []]","[[], []]"
thefuck,79fb7c987cb589fb6fa296121f9ea392feb4752d,Added sudo rule for Fedora yum's output.,2015-04-22 09:26:45+08:00,Dugucloud,2,1,3,1,['sudo.py'],"[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted',\n            'root privilege',\n            'This command has to be run under the root user.']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted',\n            'root privilege',\n            'This command has to be run under the root user.',\n            'You need to be root to perform this command.']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983d90be0>, <pydriller.domain.commit.Method object at 0x7f1983d90550>]]",[[]]
thefuck,126194ec2ee0045efb3fe8a2ccf85087352ad04f,"Put errors in stderr instead of ""echo ..."" in stdout",2015-04-22 05:29:44+02:00,nvbn,2,2,4,1,['main.py'],"['from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom traceback import format_exception\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            sys.stderr.write(u\'[WARN] {}: {}---------------------\\n\\n\'.format(\n                rule.name, \'\'.join(format_exception(*sys.exc_info()))))\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","['from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom traceback import format_exception\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            sys.stderr.write(u\'[WARN] {}: {}---------------------\\n\\n\'.format(\n                rule.name, \'\'.join(format_exception(*sys.exc_info()))))\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            sys.stderr.write(""Can\'t fuck twice\\n"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    sys.stderr.write(\'No fuck given\\n\')\n']","[[<pydriller.domain.commit.Method object at 0x7f1983deb940>, <pydriller.domain.commit.Method object at 0x7f1983debac0>, <pydriller.domain.commit.Method object at 0x7f1983deba90>, <pydriller.domain.commit.Method object at 0x7f1983deb6a0>, <pydriller.domain.commit.Method object at 0x7f1983e628e0>, <pydriller.domain.commit.Method object at 0x7f1983e62910>, <pydriller.domain.commit.Method object at 0x7f1983e62790>, <pydriller.domain.commit.Method object at 0x7f1983e627c0>, <pydriller.domain.commit.Method object at 0x7f1983e62640>, <pydriller.domain.commit.Method object at 0x7f1983e62670>, <pydriller.domain.commit.Method object at 0x7f1983e624f0>, <pydriller.domain.commit.Method object at 0x7f1983e62520>]]",[[<pydriller.domain.commit.Method object at 0x7f1983e1d4f0>]]
thefuck,5d424dad88c71b926c6356df6e207cceb5a05c5a,Use colorama for colored output,2015-04-22 06:03:06+02:00,nvbn,76,18,94,6,"['README.md', 'setup.py', 'test_logs.py', 'test_main.py', 'logs.py', 'main.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', 'from setuptools import setup, find_packages\n\n\nVERSION = \'1.26\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', None, ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule('bash', match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash', 'bash'),\n                                  main.Rule('lisp', 'lisp', 'lisp'),\n                                  main.Rule('bash', 'bash', 'bash'),\n                                  main.Rule('lisp', 'lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash', 'bash'),\n                                      main.Rule('bash', 'bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None),\n             main.Rule('', lambda *_: False, None),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0]\\\n           == '[WARN] rule: Traceback (most recent call last):'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n"", None, 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom traceback import format_exception\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            sys.stderr.write(u\'[WARN] {}: {}---------------------\\n\\n\'.format(\n                rule.name, \'\'.join(format_exception(*sys.exc_info()))))\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            sys.stderr.write(""Can\'t fuck twice\\n"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    sys.stderr.write(\'No fuck given\\n\')\n']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', 'from setuptools import setup, find_packages\n\n\nVERSION = \'1.26\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from mock import Mock\nfrom thefuck import logs\n\n\ndef test_color():\n    assert logs.color('red', Mock(no_colors=False)) == 'red'\n    assert logs.color('red', Mock(no_colors=True)) == ''\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule('bash', match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash', 'bash'),\n                                  main.Rule('lisp', 'lisp', 'lisp'),\n                                  main.Rule('bash', 'bash', 'bash'),\n                                  main.Rule('lisp', 'lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash', 'bash'),\n                                      main.Rule('bash', 'bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None),\n             main.Rule('', lambda *_: False, None),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0]\\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", 'import sys\nfrom traceback import format_exception\nimport colorama\n\n\ndef color(color_, settings):\n    """"""Utility for ability to disabling colored output.""""""\n    if settings.no_colors:\n        return \'\'\n    else:\n        return color_\n\n\ndef rule_failed(rule, exc_info, settings):\n    sys.stderr.write(\n        u\'{warn}[WARN] Rule {name}:{reset}\\n{trace}\'\n        u\'{warn}----------------------------{reset}\\n\\n\'.format(\n            warn=color(colorama.Back.RED + colorama.Fore.WHITE\n                       + colorama.Style.BRIGHT, settings),\n            reset=color(colorama.Style.RESET_ALL, settings),\n            name=rule.name,\n            trace=\'\'.join(format_exception(*exc_info))))\n\n\ndef show_command(new_command, settings):\n    sys.stderr.write(\'{bold}{command}{reset}\\n\'.format(\n        command=new_command,\n        bold=color(colorama.Style.BRIGHT, settings),\n        reset=color(colorama.Style.RESET_ALL, settings)))\n\n\ndef confirm_command(new_command, settings):\n    sys.stderr.write(\n        \'{bold}{command}{reset} [{green}enter{reset}/{red}ctrl+c{reset}]\'.format(\n            command=new_command,\n            bold=color(colorama.Style.BRIGHT, settings),\n            green=color(colorama.Fore.GREEN, settings),\n            red=color(colorama.Fore.RED, settings),\n            reset=color(colorama.Style.RESET_ALL, settings)))\n    sys.stderr.flush()\n\n\ndef failed(msg, settings):\n    sys.stderr.write(\'{red}{msg}{reset}\\n\'.format(\n        msg=msg,\n        red=color(colorama.Fore.RED, settings),\n        reset=color(colorama.Style.RESET_ALL, settings)))\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom thefuck import logs\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    settings.__dict__.setdefault(\'no_colors\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n']","[[], [], [], [<pydriller.domain.commit.Method object at 0x7f1983e17520>, <pydriller.domain.commit.Method object at 0x7f1983de62b0>, <pydriller.domain.commit.Method object at 0x7f1983de66d0>, <pydriller.domain.commit.Method object at 0x7f1983de6580>, <pydriller.domain.commit.Method object at 0x7f1983db12e0>, <pydriller.domain.commit.Method object at 0x7f1983d95c10>, <pydriller.domain.commit.Method object at 0x7f1983d956a0>, <pydriller.domain.commit.Method object at 0x7f1983e1d520>], [], [<pydriller.domain.commit.Method object at 0x7f1983e0ce50>, <pydriller.domain.commit.Method object at 0x7f1983e0c640>, <pydriller.domain.commit.Method object at 0x7f1983e86280>, <pydriller.domain.commit.Method object at 0x7f1983e86f70>, <pydriller.domain.commit.Method object at 0x7f1983e81100>, <pydriller.domain.commit.Method object at 0x7f1983e81cd0>, <pydriller.domain.commit.Method object at 0x7f1983e81790>, <pydriller.domain.commit.Method object at 0x7f1983e81fa0>, <pydriller.domain.commit.Method object at 0x7f1983e81640>, <pydriller.domain.commit.Method object at 0x7f1983e81bb0>, <pydriller.domain.commit.Method object at 0x7f1983e81e50>, <pydriller.domain.commit.Method object at 0x7f1983e81520>]]","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983e57b80>], [<pydriller.domain.commit.Method object at 0x7f1983e62fa0>, <pydriller.domain.commit.Method object at 0x7f1983debc10>], [<pydriller.domain.commit.Method object at 0x7f1983e293a0>, <pydriller.domain.commit.Method object at 0x7f1983d62be0>, <pydriller.domain.commit.Method object at 0x7f1983d62c10>, <pydriller.domain.commit.Method object at 0x7f1983d62190>, <pydriller.domain.commit.Method object at 0x7f1983d622e0>], [<pydriller.domain.commit.Method object at 0x7f1983e0c520>, <pydriller.domain.commit.Method object at 0x7f1983e0c130>, <pydriller.domain.commit.Method object at 0x7f1983e0cfa0>, <pydriller.domain.commit.Method object at 0x7f1983e23250>]]"
thefuck,957209bdb681ba169dc7b0ce4088554b51f7b6fd,Add ability to bundle disabled by default rules,2015-04-22 15:59:44+02:00,nvbn,43,25,68,2,"['test_main.py', 'main.py']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule('bash', match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash', 'bash'),\n                                  main.Rule('lisp', 'lisp', 'lisp'),\n                                  main.Rule('bash', 'bash', 'bash'),\n                                  main.Rule('lisp', 'lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash', 'bash'),\n                                      main.Rule('bash', 'bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None),\n             main.Rule('', lambda *_: False, None),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0]\\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom thefuck import logs\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    settings.__dict__.setdefault(\'no_colors\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None),\n                                main.Rule('bash', None, None, True))\n    assert not main.is_rule_enabled(Mock(rules=None),\n                                    main.Rule('bash', None, None, False))\n    assert main.is_rule_enabled(Mock(rules=['bash']),\n                                main.Rule('bash', None, None, True))\n    assert not main.is_rule_enabled(Mock(rules=['bash']),\n                                    main.Rule('lisp', None, None, True))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == main.Rule('bash', match, get_new_command, True)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=None))) == [main.Rule('bash', 'bash', 'bash', True),\n                                   main.Rule('lisp', 'lisp', 'lisp', True),\n                                   main.Rule('bash', 'bash', 'bash', True),\n                                   main.Rule('lisp', 'lisp', 'lisp', True)]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=['bash']))) == [main.Rule('bash', 'bash', 'bash', True),\n                                       main.Rule('bash', 'bash', 'bash', True)]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None, True),\n             main.Rule('', lambda *_: False, None, True),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None, True)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom thefuck import logs\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    settings.__dict__.setdefault(\'no_colors\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    if settings.rules is None and rule.enabled_by_default:\n        return True\n    elif settings.rules and rule.name in settings.rules:\n        return True\n    else:\n        return False\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if is_rule_enabled(settings, loaded_rule):\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n']","[[<pydriller.domain.commit.Method object at 0x7f1983e74e50>, <pydriller.domain.commit.Method object at 0x7f1983e747c0>, <pydriller.domain.commit.Method object at 0x7f1983e74130>, <pydriller.domain.commit.Method object at 0x7f1983e748e0>, <pydriller.domain.commit.Method object at 0x7f1983e6e640>, <pydriller.domain.commit.Method object at 0x7f1983e6ecd0>, <pydriller.domain.commit.Method object at 0x7f1983e6ebb0>, <pydriller.domain.commit.Method object at 0x7f1983e6ee50>], [<pydriller.domain.commit.Method object at 0x7f1983e4ba60>, <pydriller.domain.commit.Method object at 0x7f1983e4bbb0>, <pydriller.domain.commit.Method object at 0x7f1983e4b8e0>, <pydriller.domain.commit.Method object at 0x7f1983e4b910>, <pydriller.domain.commit.Method object at 0x7f1983ec5f70>, <pydriller.domain.commit.Method object at 0x7f1983ec5fa0>, <pydriller.domain.commit.Method object at 0x7f1983ec5e20>, <pydriller.domain.commit.Method object at 0x7f1983ec5e50>, <pydriller.domain.commit.Method object at 0x7f1983ec5cd0>, <pydriller.domain.commit.Method object at 0x7f1983ec5d00>, <pydriller.domain.commit.Method object at 0x7f1983ec5b80>, <pydriller.domain.commit.Method object at 0x7f1983ec5bb0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983e7aa60>, <pydriller.domain.commit.Method object at 0x7f1983e7a640>, <pydriller.domain.commit.Method object at 0x7f1983e7aa30>, <pydriller.domain.commit.Method object at 0x7f1983e81280>, <pydriller.domain.commit.Method object at 0x7f1983e81910>], [<pydriller.domain.commit.Method object at 0x7f1983e5c8e0>, <pydriller.domain.commit.Method object at 0x7f1983e5c100>, <pydriller.domain.commit.Method object at 0x7f1983e5c250>]]"
thefuck,fa4e4522b78ccf0811e8b6b671a20fab6099c1f2,#43 Add `rm_root` as disabled by default rule,2015-04-22 16:08:54+02:00,nvbn,10,2,12,3,"['README.md', 'main.py', 'rm_root.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom thefuck import logs\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    settings.__dict__.setdefault(\'no_colors\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    if settings.rules is None and rule.enabled_by_default:\n        return True\n    elif settings.rules and rule.name in settings.rules:\n        return True\n    else:\n        return False\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if is_rule_enabled(settings, loaded_rule):\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', ""def match(command, settings):\n    return ('/' in command.script.split()\n            and '--no-preserve-root' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return '{} --no-preserve-root'.format(command.script)\n""]","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom thefuck import logs\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    settings.__dict__.setdefault(\'no_colors\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    if settings.rules is None and rule.enabled_by_default:\n        return True\n    elif settings.rules and rule.name in settings.rules:\n        return True\n    else:\n        return False\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if is_rule_enabled(settings, loaded_rule):\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = list(get_rules(user_dir, settings))\n        sys.stderr.write(str([r.name for r in rules]) + \'\\n\')\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', ""enabled_by_default = False\n\n\ndef match(command, settings):\n    return ({'rm', '/'}.issubset(command.script.split())\n            and '--no-preserve-root' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return '{} --no-preserve-root'.format(command.script)\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e6e520>, <pydriller.domain.commit.Method object at 0x7f1983e6e670>, <pydriller.domain.commit.Method object at 0x7f1983e68a60>, <pydriller.domain.commit.Method object at 0x7f1983e743d0>, <pydriller.domain.commit.Method object at 0x7f1983e74790>, <pydriller.domain.commit.Method object at 0x7f1983e74520>, <pydriller.domain.commit.Method object at 0x7f1983e74100>, <pydriller.domain.commit.Method object at 0x7f1983e7a670>, <pydriller.domain.commit.Method object at 0x7f1983e7abb0>, <pydriller.domain.commit.Method object at 0x7f1983e7a910>, <pydriller.domain.commit.Method object at 0x7f1983e7a280>, <pydriller.domain.commit.Method object at 0x7f1983e7a520>], [<pydriller.domain.commit.Method object at 0x7f1983e86640>, <pydriller.domain.commit.Method object at 0x7f1983e86790>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e5c280>], [<pydriller.domain.commit.Method object at 0x7f1983e0c3a0>]]"
thefuck,7010b3a7f601608c4f3f943a374ba0ef098fc2da,#43 Add test for `rm_root`,2015-04-22 16:22:10+02:00,nvbn,20,3,23,3,"['test_rm_root.py', 'main.py', 'rm_root.py']","[None, 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom thefuck import logs\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    settings.__dict__.setdefault(\'no_colors\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    if settings.rules is None and rule.enabled_by_default:\n        return True\n    elif settings.rules and rule.name in settings.rules:\n        return True\n    else:\n        return False\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if is_rule_enabled(settings, loaded_rule):\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = list(get_rules(user_dir, settings))\n        sys.stderr.write(str([r.name for r in rules]) + \'\\n\')\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', ""enabled_by_default = False\n\n\ndef match(command, settings):\n    return ({'rm', '/'}.issubset(command.script.split())\n            and '--no-preserve-root' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return '{} --no-preserve-root'.format(command.script)\n""]","[""from mock import Mock\nfrom thefuck.rules.rm_root import match, get_new_command\n\n\ndef test_match():\n    assert match(Mock(script='rm -rf /',\n                      stderr='add --no-preserve-root'), None)\n    assert not match(Mock(script='ls',\n                          stderr='add --no-preserve-root'), None)\n    assert not match(Mock(script='rm --no-preserve-root /',\n                          stderr='add --no-preserve-root'), None)\n    assert not match(Mock(script='rm -rf /',\n                          stderr=''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Mock(script='rm -rf /'), None) \\\n        == 'rm -rf / --no-preserve-root'\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom thefuck import logs\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    settings.__dict__.setdefault(\'no_colors\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    if settings.rules is None and rule.enabled_by_default:\n        return True\n    elif settings.rules and rule.name in settings.rules:\n        return True\n    else:\n        return False\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if is_rule_enabled(settings, loaded_rule):\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', ""enabled_by_default = False\n\n\ndef match(command, settings):\n    return ({'rm', '/'}.issubset(command.script.split())\n            and '--no-preserve-root' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return u'{} --no-preserve-root'.format(command.script)\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e62e20>, <pydriller.domain.commit.Method object at 0x7f1983de66a0>, <pydriller.domain.commit.Method object at 0x7f1983de6940>, <pydriller.domain.commit.Method object at 0x7f1983de62e0>, <pydriller.domain.commit.Method object at 0x7f1983e57100>, <pydriller.domain.commit.Method object at 0x7f1983e57e20>, <pydriller.domain.commit.Method object at 0x7f1983e57fa0>, <pydriller.domain.commit.Method object at 0x7f1983e573d0>, <pydriller.domain.commit.Method object at 0x7f1983e57250>, <pydriller.domain.commit.Method object at 0x7f1983e57280>, <pydriller.domain.commit.Method object at 0x7f1983e57e50>, <pydriller.domain.commit.Method object at 0x7f1983e57a60>], [<pydriller.domain.commit.Method object at 0x7f1983ec0d00>, <pydriller.domain.commit.Method object at 0x7f1983ec0100>]]","[[<pydriller.domain.commit.Method object at 0x7f1983e813d0>, <pydriller.domain.commit.Method object at 0x7f1983e81670>], [<pydriller.domain.commit.Method object at 0x7f1983e173d0>], [<pydriller.domain.commit.Method object at 0x7f1983e3c640>]]"
thefuck,e7b78205f4c7cb060ebe5670f1d0986dbb0cf924,Add transparent sudo support for rules where it required,2015-04-22 16:45:38+02:00,nvbn,68,1,69,11,"['setup.py', 'test_utils.py', 'cp_omitting_directory.py', 'has_exists_script.py', 'lein_not_task.py', 'mkdir_p.py', 'no_command.py', 'python_command.py', 'rm_dir.py', 'rm_root.py', 'utils.py']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.26\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', None, ""import re\n\n\ndef match(command, settings):\n    return command.script.startswith('cp ') \\\n        and 'cp: omitting directory' in command.stderr.lower()\n\n\ndef get_new_command(command, settings):\n    return re.sub(r'^cp', 'cp -a', command.script)\n"", ""import os\n\n\ndef match(command, settings):\n    return os.path.exists(command.script.split()[0]) \\\n        and 'command not found' in command.stderr\n\n\ndef get_new_command(command, settings):\n    return u'./{}'.format(command.script)\n\n"", 'import re\n\n\ndef match(command, settings):\n    return (command.script.startswith(\'lein\')\n            and ""is not a task. See \'lein help\'"" in command.stderr\n            and \'Did you mean this?\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r""\'([^\']*)\' is not a task"",\n                            command.stderr)[0]\n    new_cmd = re.findall(r\'Did you mean this\\?\\n\\s*([^\\n]*)\',\n                         command.stderr)[0]\n    return command.script.replace(broken_cmd, new_cmd, 1)\n', ""import re\n\ndef match(command, settings):\n    return ('mkdir' in command.script\n            and 'No such file or directory' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return re.sub('^mkdir (.*)', 'mkdir -p \\\\1', command.script)\n"", ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _safe(fn, fallback):\n    try:\n        return fn()\n    except OSError:\n        return fallback\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ.get('PATH', '').split(':')\n            for exe in _safe(lambda: list(Path(path).iterdir()), [])\n            if not _safe(exe.is_dir, True)]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n"", ""# add 'python' suffix to the command if\n#  1) The script does not have execute permission or\n#  2) is interpreted as shell script\n\ndef match(command, settings):\n    toks = command.script.split()\n    return (len(toks) > 0\n            and toks[0].endswith('.py')\n            and ('Permission denied' in command.stderr or\n                 'command not found' in command.stderr))\n\n\ndef get_new_command(command, settings):\n    return 'python ' + command.script\n"", ""import re\n\ndef match(command, settings):\n    return ('rm' in command.script\n            and 'is a directory' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return re.sub('^rm (.*)', 'rm -rf \\\\1', command.script)\n"", ""enabled_by_default = False\n\n\ndef match(command, settings):\n    return ({'rm', '/'}.issubset(command.script.split())\n            and '--no-preserve-root' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return u'{} --no-preserve-root'.format(command.script)\n"", 'from functools import wraps\nimport os\n\n\ndef which(program):\n    """"""Returns `program` path or `None`.""""""\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef wrap_settings(params):\n    """"""Adds default values to settings if it not presented.\n\n    Usage:\n\n        @wrap_settings({\'apt\': \'/usr/bin/apt\'})\n        def match(command, settings):\n            print(settings.apt)\n\n    """"""\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(command, settings):\n            for key, val in params.items():\n                if not hasattr(settings, key):\n                    setattr(settings, key, val)\n            return fn(command, settings)\n        return wrapper\n    return decorator\n']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.26\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from mock import Mock\nfrom thefuck.utils import sudo_support\nfrom thefuck.main import Command\n\n\ndef test_sudo_support():\n    fn = Mock(return_value=True, __name__='')\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n    fn.assert_called_once_with(Command('ls', 'out', 'err'), None)\n\n    fn.return_value = False\n    assert not sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n\n    fn.return_value = 'pwd'\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None) == 'sudo pwd'\n\n    assert sudo_support(fn)(Command('ls', 'out', 'err'), None) == 'pwd'\n"", ""import re\nfrom thefuck.utils import sudo_support\n\n\n@sudo_support\ndef match(command, settings):\n    return command.script.startswith('cp ') \\\n        and 'cp: omitting directory' in command.stderr.lower()\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return re.sub(r'^cp', 'cp -a', command.script)\n"", ""import os\nfrom thefuck.utils import sudo_support\n\n\n@sudo_support\ndef match(command, settings):\n    return os.path.exists(command.script.split()[0]) \\\n        and 'command not found' in command.stderr\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return u'./{}'.format(command.script)\n\n"", 'import re\nfrom thefuck.utils import sudo_support\n\n\n@sudo_support\ndef match(command, settings):\n    return (command.script.startswith(\'lein\')\n            and ""is not a task. See \'lein help\'"" in command.stderr\n            and \'Did you mean this?\' in command.stderr)\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r""\'([^\']*)\' is not a task"",\n                            command.stderr)[0]\n    new_cmd = re.findall(r\'Did you mean this\\?\\n\\s*([^\\n]*)\',\n                         command.stderr)[0]\n    return command.script.replace(broken_cmd, new_cmd, 1)\n', ""import re\nfrom thefuck.utils import sudo_support\n\n\n@sudo_support\ndef match(command, settings):\n    return ('mkdir' in command.script\n            and 'No such file or directory' in command.stderr)\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return re.sub('^mkdir (.*)', 'mkdir -p \\\\1', command.script)\n"", ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\nfrom thefuck.utils import sudo_support\n\n\ndef _safe(fn, fallback):\n    try:\n        return fn()\n    except OSError:\n        return fallback\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ.get('PATH', '').split(':')\n            for exe in _safe(lambda: list(Path(path).iterdir()), [])\n            if not _safe(exe.is_dir, True)]\n\n\n@sudo_support\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n"", ""from thefuck.utils import sudo_support\n# add 'python' suffix to the command if\n#  1) The script does not have execute permission or\n#  2) is interpreted as shell script\n\n\n@sudo_support\ndef match(command, settings):\n    toks = command.script.split()\n    return (len(toks) > 0\n            and toks[0].endswith('.py')\n            and ('Permission denied' in command.stderr or\n                 'command not found' in command.stderr))\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return 'python ' + command.script\n"", ""import re\nfrom thefuck.utils import sudo_support\n\n\n@sudo_support\ndef match(command, settings):\n    return ('rm' in command.script\n            and 'is a directory' in command.stderr)\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return re.sub('^rm (.*)', 'rm -rf \\\\1', command.script)\n"", ""from thefuck.utils import sudo_support\n\n\nenabled_by_default = False\n\n\n@sudo_support\ndef match(command, settings):\n    return ({'rm', '/'}.issubset(command.script.split())\n            and '--no-preserve-root' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return u'{} --no-preserve-root'.format(command.script)\n"", 'from functools import wraps\nimport os\nimport six\nfrom thefuck.main import Command\n\n\ndef which(program):\n    """"""Returns `program` path or `None`.""""""\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef wrap_settings(params):\n    """"""Adds default values to settings if it not presented.\n\n    Usage:\n\n        @wrap_settings({\'apt\': \'/usr/bin/apt\'})\n        def match(command, settings):\n            print(settings.apt)\n\n    """"""\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(command, settings):\n            for key, val in params.items():\n                if not hasattr(settings, key):\n                    setattr(settings, key, val)\n            return fn(command, settings)\n        return wrapper\n    return decorator\n\n\ndef sudo_support(fn):\n    """"""Removes sudo before calling fn and adds it after.""""""\n    @wraps(fn)\n    def wrapper(command, settings):\n        if not command.script.startswith(\'sudo \'):\n            return fn(command, settings)\n\n        result = fn(Command(command.script[5:],\n                            command.stdout,\n                            command.stderr),\n                    settings)\n\n        if result and isinstance(result, six.string_types):\n            return u\'sudo {}\'.format(result)\n        else:\n            return result\n    return wrapper\n']","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983eae670>, <pydriller.domain.commit.Method object at 0x7f1983eae7c0>], [<pydriller.domain.commit.Method object at 0x7f1983e57cd0>, <pydriller.domain.commit.Method object at 0x7f1983e57790>], [<pydriller.domain.commit.Method object at 0x7f1983e1dbb0>, <pydriller.domain.commit.Method object at 0x7f1983e1da30>], [<pydriller.domain.commit.Method object at 0x7f1983e86130>, <pydriller.domain.commit.Method object at 0x7f1983e7ae50>], [<pydriller.domain.commit.Method object at 0x7f1983e74670>, <pydriller.domain.commit.Method object at 0x7f1983e74d00>, <pydriller.domain.commit.Method object at 0x7f1983e74bb0>, <pydriller.domain.commit.Method object at 0x7f1983e74a60>], [<pydriller.domain.commit.Method object at 0x7f1983ec5130>, <pydriller.domain.commit.Method object at 0x7f1983ec5520>], [<pydriller.domain.commit.Method object at 0x7f1983e4be50>, <pydriller.domain.commit.Method object at 0x7f1983e4bfa0>], [<pydriller.domain.commit.Method object at 0x7f1983e5c4f0>, <pydriller.domain.commit.Method object at 0x7f1983e5c790>], [<pydriller.domain.commit.Method object at 0x7f1983e86910>, <pydriller.domain.commit.Method object at 0x7f1983e86250>, <pydriller.domain.commit.Method object at 0x7f1983e86fa0>, <pydriller.domain.commit.Method object at 0x7f1983e86670>, <pydriller.domain.commit.Method object at 0x7f1983e7a3d0>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983eb9cd0>], [], [], [], [], [], [], [], [], [<pydriller.domain.commit.Method object at 0x7f1983e0c280>, <pydriller.domain.commit.Method object at 0x7f1983db9400>]]"
thefuck,69ddd82baeb5ead4366c4e6a1bee7f28b4aacca1,Bump to 1.27,2015-04-22 16:46:06+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nVERSION = \'1.26\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.27\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,c788dfbc1498e3d7efae7274e986662645dd49fa,"fix rm dir rule to make it case insensitive

In bash the output for the command `rm -f foo/` is:

    rm: cannot remove ‘foo/’: Is a directory

And not:

    rm: cannot remove ‘foo/’: is a directory",2015-04-22 19:04:52+02:00,Timo Furrer,2,1,3,2,"['test_rm_dir.py', 'rm_dir.py']","[""from thefuck.main import Command\nfrom thefuck.rules.rm_dir import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('rm foo', '', 'rm: foo: is a directory'), None)\n    assert not match(Command('rm foo', '', ''), None)\n    assert not match(Command('rm foo', '', 'foo bar baz'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('rm foo', '', ''), None) == 'rm -rf foo'\n"", ""import re\nfrom thefuck.utils import sudo_support\n\n\n@sudo_support\ndef match(command, settings):\n    return ('rm' in command.script\n            and 'is a directory' in command.stderr)\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return re.sub('^rm (.*)', 'rm -rf \\\\1', command.script)\n""]","[""from thefuck.main import Command\nfrom thefuck.rules.rm_dir import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('rm foo', '', 'rm: foo: is a directory'), None)\n    assert match(Command('rm foo', '', 'rm: foo: Is a directory'), None)\n    assert not match(Command('rm foo', '', ''), None)\n    assert not match(Command('rm foo', '', 'foo bar baz'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('rm foo', '', ''), None) == 'rm -rf foo'\n"", ""import re\nfrom thefuck.utils import sudo_support\n\n\n@sudo_support\ndef match(command, settings):\n    return ('rm' in command.script\n            and 'is a directory' in command.stderr.lower())\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return re.sub('^rm (.*)', 'rm -rf \\\\1', command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983eb9d00>, <pydriller.domain.commit.Method object at 0x7f1983eb9790>], [<pydriller.domain.commit.Method object at 0x7f1983eae640>, <pydriller.domain.commit.Method object at 0x7f1983eae100>]]","[[<pydriller.domain.commit.Method object at 0x7f1983eb98e0>], [<pydriller.domain.commit.Method object at 0x7f1983ec0670>]]"
thefuck,69a95164773772262816f5f260074f1070d7f43d,Add ability to change settings via environment variables,2015-04-22 20:18:53+02:00,nvbn,233,61,294,8,"['README.md', 'test_conf.py', 'test_main.py', 'test_utils.py', 'conf.py', 'logs.py', 'main.py', 'utils.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', None, ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None),\n                                main.Rule('bash', None, None, True))\n    assert not main.is_rule_enabled(Mock(rules=None),\n                                    main.Rule('bash', None, None, False))\n    assert main.is_rule_enabled(Mock(rules=['bash']),\n                                main.Rule('bash', None, None, True))\n    assert not main.is_rule_enabled(Mock(rules=['bash']),\n                                    main.Rule('lisp', None, None, True))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == main.Rule('bash', match, get_new_command, True)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=None))) == [main.Rule('bash', 'bash', 'bash', True),\n                                   main.Rule('lisp', 'lisp', 'lisp', True),\n                                   main.Rule('bash', 'bash', 'bash', True),\n                                   main.Rule('lisp', 'lisp', 'lisp', True)]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=['bash']))) == [main.Rule('bash', 'bash', 'bash', True),\n                                       main.Rule('bash', 'bash', 'bash', True)]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None, True),\n             main.Rule('', lambda *_: False, None, True),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None, True)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", ""from mock import Mock\nfrom thefuck.utils import sudo_support\nfrom thefuck.main import Command\n\n\ndef test_sudo_support():\n    fn = Mock(return_value=True, __name__='')\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n    fn.assert_called_once_with(Command('ls', 'out', 'err'), None)\n\n    fn.return_value = False\n    assert not sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n\n    fn.return_value = 'pwd'\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None) == 'sudo pwd'\n\n    assert sudo_support(fn)(Command('ls', 'out', 'err'), None) == 'pwd'\n"", None, 'import sys\nfrom traceback import format_exception\nimport colorama\n\n\ndef color(color_, settings):\n    """"""Utility for ability to disabling colored output.""""""\n    if settings.no_colors:\n        return \'\'\n    else:\n        return color_\n\n\ndef rule_failed(rule, exc_info, settings):\n    sys.stderr.write(\n        u\'{warn}[WARN] Rule {name}:{reset}\\n{trace}\'\n        u\'{warn}----------------------------{reset}\\n\\n\'.format(\n            warn=color(colorama.Back.RED + colorama.Fore.WHITE\n                       + colorama.Style.BRIGHT, settings),\n            reset=color(colorama.Style.RESET_ALL, settings),\n            name=rule.name,\n            trace=\'\'.join(format_exception(*exc_info))))\n\n\ndef show_command(new_command, settings):\n    sys.stderr.write(\'{bold}{command}{reset}\\n\'.format(\n        command=new_command,\n        bold=color(colorama.Style.BRIGHT, settings),\n        reset=color(colorama.Style.RESET_ALL, settings)))\n\n\ndef confirm_command(new_command, settings):\n    sys.stderr.write(\n        \'{bold}{command}{reset} [{green}enter{reset}/{red}ctrl+c{reset}]\'.format(\n            command=new_command,\n            bold=color(colorama.Style.BRIGHT, settings),\n            green=color(colorama.Fore.GREEN, settings),\n            red=color(colorama.Fore.RED, settings),\n            reset=color(colorama.Style.RESET_ALL, settings)))\n    sys.stderr.flush()\n\n\ndef failed(msg, settings):\n    sys.stderr.write(\'{red}{msg}{reset}\\n\'.format(\n        msg=msg,\n        red=color(colorama.Fore.RED, settings),\n        reset=color(colorama.Style.RESET_ALL, settings)))\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom thefuck import logs\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    settings.__dict__.setdefault(\'no_colors\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    if settings.rules is None and rule.enabled_by_default:\n        return True\n    elif settings.rules and rule.name in settings.rules:\n        return True\n    else:\n        return False\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if is_rule_enabled(settings, loaded_rule):\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', 'from functools import wraps\nimport os\nimport six\nfrom thefuck.main import Command\n\n\ndef which(program):\n    """"""Returns `program` path or `None`.""""""\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef wrap_settings(params):\n    """"""Adds default values to settings if it not presented.\n\n    Usage:\n\n        @wrap_settings({\'apt\': \'/usr/bin/apt\'})\n        def match(command, settings):\n            print(settings.apt)\n\n    """"""\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(command, settings):\n            for key, val in params.items():\n                if not hasattr(settings, key):\n                    setattr(settings, key, val)\n            return fn(command, settings)\n        return wrapper\n    return decorator\n\n\ndef sudo_support(fn):\n    """"""Removes sudo before calling fn and adds it after.""""""\n    @wraps(fn)\n    def wrapper(command, settings):\n        if not command.script.startswith(\'sudo \'):\n            return fn(command, settings)\n\n        result = fn(Command(command.script[5:],\n                            command.stdout,\n                            command.stderr),\n                    settings)\n\n        if result and isinstance(result, six.string_types):\n            return u\'sudo {}\'.format(result)\n        else:\n            return result\n    return wrapper\n']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""from mock import patch, Mock\nfrom thefuck.main import Rule\nfrom thefuck import conf\n\n\ndef test_rules_list():\n    assert conf.RulesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert conf.RulesList(['bash', 'lisp']) == conf.RulesList(['bash', 'lisp'])\n    assert Rule('lisp', None, None, False) in conf.RulesList(['lisp'])\n    assert Rule('bash', None, None, False) not in conf.RulesList(['lisp'])\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT\n    assert Rule('test', None, None, False) not in conf.DEFAULT\n    assert Rule('test', None, None, False) in (conf.DEFAULT + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.Settings.defaults.items():\n            assert getattr(conf.Settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.Settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.Settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.Settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT:bash:lisp'}):\n        settings = conf.Settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['bash', 'lisp']\n\n\ndef test_update_settings():\n    settings = conf.BaseSettings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main, conf\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == main.Rule('bash', match, get_new_command, True)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.DEFAULT))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True),\n                   main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True)]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.RulesList(['bash'])))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('bash', 'bash', 'bash', True)]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None, True),\n             main.Rule('', lambda *_: False, None, True),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None, True)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", ""from mock import Mock\nfrom thefuck.utils import sudo_support, wrap_settings\nfrom thefuck.main import Command\nfrom thefuck.conf import BaseSettings\n\n\ndef test_wrap_settings():\n    fn = lambda _, settings: settings._conf\n    assert wrap_settings({'key': 'val'})(fn)(None, BaseSettings({})) \\\n           == {'key': 'val'}\n    assert wrap_settings({'key': 'new-val'})(fn)(\n        None, BaseSettings({'key': 'val'})) == {'key': 'new-val'}\n\n\ndef test_sudo_support():\n    fn = Mock(return_value=True, __name__='')\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n    fn.assert_called_once_with(Command('ls', 'out', 'err'), None)\n\n    fn.return_value = False\n    assert not sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n\n    fn.return_value = 'pwd'\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None) == 'sudo pwd'\n\n    assert sudo_support(fn)(Command('ls', 'out', 'err'), None) == 'pwd'\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs\n\n\nclass RulesList(object):\n    """"""Wrapper a top of list for string rules names.""""""\n\n    def __init__(self, rules):\n        self.rules = rules\n\n    def __contains__(self, item):\n        return item.name in self.rules\n\n    def __getattr__(self, item):\n        return getattr(self.rules, item)\n\n    def __eq__(self, other):\n        return self.rules == other\n\n\nclass _DefaultRules(RulesList):\n    def __add__(self, items):\n        return _DefaultRules(self.rules + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRules, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRules):\n            return self.rules == other.rules\n        else:\n            return False\n\n\nDEFAULT = _DefaultRules([])\n\n\nclass BaseSettings(object):\n    def __init__(self, conf):\n        self._conf = conf\n\n    def __getattr__(self, item):\n        return self._conf.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = copy(self._conf)\n        conf.update(kwargs)\n        return BaseSettings(conf)\n\n\nclass Settings(BaseSettings):\n    """"""Settings loaded from defaults/file/env.""""""\n    defaults = {\'rules\': DEFAULT,\n                \'wait_command\': 3,\n                \'require_confirmation\': False,\n                \'no_colors\': False}\n\n    env_to_attr = {\'THEFUCK_RULES\': \'rules\',\n                   \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n                   \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n                   \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n    def __init__(self, user_dir):\n        super(Settings, self).__init__(self._load_conf(user_dir))\n\n    def _load_conf(self, user_dir):\n        conf = copy(self.defaults)\n        try:\n            conf.update(self._load_from_file(user_dir))\n        except:\n            logs.exception(""Can\'t load settings from file"",\n                           sys.exc_info(),\n                           BaseSettings(conf))\n        try:\n            conf.update(self._load_from_env())\n        except:\n            logs.exception(""Can\'t load settings from env"",\n                           sys.exc_info(),\n                           BaseSettings(conf))\n        if not isinstance(conf[\'rules\'], RulesList):\n            conf[\'rules\'] = RulesList(conf[\'rules\'])\n        return conf\n\n    def _load_from_file(self, user_dir):\n        """"""Loads settings from file.""""""\n        settings = load_source(\'settings\',\n                               text_type(user_dir.joinpath(\'settings.py\')))\n        return {key: getattr(settings, key)\n                for key in self.defaults.keys()\n                if hasattr(settings, key)}\n\n    def _load_from_env(self):\n        """"""Loads settings from env.""""""\n        return {attr: self._val_from_env(env, attr)\n                for env, attr in self.env_to_attr.items()\n                if env in os.environ}\n\n    def _val_from_env(self, env, attr):\n        """"""Transforms env-strings to python.""""""\n        val = os.environ[env]\n        if attr == \'rules\':\n            val = self._rules_from_env(val)\n        elif attr == \'wait_command\':\n            val = int(val)\n        elif attr in (\'require_confirmation\', \'no_colors\'):\n            val = val.lower() == \'true\'\n        return val\n\n    def _rules_from_env(self, val):\n        """"""Transforms rules list from env-string to python.""""""\n        val = val.split(\':\')\n        if \'DEFAULT\' in val:\n            val = DEFAULT + [rule for rule in val if rule != \'DEFAULT\']\n        return val\n', 'import sys\nfrom traceback import format_exception\nimport colorama\n\n\ndef color(color_, settings):\n    """"""Utility for ability to disabling colored output.""""""\n    if settings.no_colors:\n        return \'\'\n    else:\n        return color_\n\n\ndef exception(title, exc_info, settings):\n    sys.stderr.write(\n        u\'{warn}[WARN] {title}:{reset}\\n{trace}\'\n        u\'{warn}----------------------------{reset}\\n\\n\'.format(\n            warn=color(colorama.Back.RED + colorama.Fore.WHITE\n                       + colorama.Style.BRIGHT, settings),\n            reset=color(colorama.Style.RESET_ALL, settings),\n            title=title,\n            trace=\'\'.join(format_exception(*exc_info))))\n\n\ndef rule_failed(rule, exc_info, settings):\n    exception(\'Rule {}\'.format(rule.name), exc_info, settings)\n\n\ndef show_command(new_command, settings):\n    sys.stderr.write(\'{bold}{command}{reset}\\n\'.format(\n        command=new_command,\n        bold=color(colorama.Style.BRIGHT, settings),\n        reset=color(colorama.Style.RESET_ALL, settings)))\n\n\ndef confirm_command(new_command, settings):\n    sys.stderr.write(\n        \'{bold}{command}{reset} [{green}enter{reset}/{red}ctrl+c{reset}]\'.format(\n            command=new_command,\n            bold=color(colorama.Style.BRIGHT, settings),\n            green=color(colorama.Fore.GREEN, settings),\n            red=color(colorama.Fore.RED, settings),\n            reset=color(colorama.Style.RESET_ALL, settings)))\n    sys.stderr.flush()\n\n\ndef failed(msg, settings):\n    sys.stderr.write(\'{red}{msg}{reset}\\n\'.format(\n        msg=msg,\n        red=color(colorama.Fore.RED, settings),\n        reset=color(colorama.Style.RESET_ALL, settings)))\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom . import logs, conf\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.Settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', 'from functools import wraps\nimport os\nimport six\nfrom thefuck.main import Command\n\n\ndef which(program):\n    """"""Returns `program` path or `None`.""""""\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef wrap_settings(params):\n    """"""Adds default values to settings if it not presented.\n\n    Usage:\n\n        @wrap_settings({\'apt\': \'/usr/bin/apt\'})\n        def match(command, settings):\n            print(settings.apt)\n\n    """"""\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(command, settings):\n            return fn(command, settings.update(**params))\n        return wrapper\n    return decorator\n\n\ndef sudo_support(fn):\n    """"""Removes sudo before calling fn and adds it after.""""""\n    @wraps(fn)\n    def wrapper(command, settings):\n        if not command.script.startswith(\'sudo \'):\n            return fn(command, settings)\n\n        result = fn(Command(command.script[5:],\n                            command.stdout,\n                            command.stderr),\n                    settings)\n\n        if result and isinstance(result, six.string_types):\n            return u\'sudo {}\'.format(result)\n        else:\n            return result\n    return wrapper\n']","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983e9cbb0>, <pydriller.domain.commit.Method object at 0x7f1983e9ca30>, <pydriller.domain.commit.Method object at 0x7f1983e9ccd0>, <pydriller.domain.commit.Method object at 0x7f1983e9cd00>, <pydriller.domain.commit.Method object at 0x7f1983ea27c0>, <pydriller.domain.commit.Method object at 0x7f1983ea2640>, <pydriller.domain.commit.Method object at 0x7f1983ea2670>, <pydriller.domain.commit.Method object at 0x7f1983ea24f0>], [<pydriller.domain.commit.Method object at 0x7f1983ea8cd0>], [], [<pydriller.domain.commit.Method object at 0x7f1983e573a0>, <pydriller.domain.commit.Method object at 0x7f1983e57640>, <pydriller.domain.commit.Method object at 0x7f1983e574f0>, <pydriller.domain.commit.Method object at 0x7f1983e57f70>, <pydriller.domain.commit.Method object at 0x7f1983e57520>], [<pydriller.domain.commit.Method object at 0x7f1983e74b80>, <pydriller.domain.commit.Method object at 0x7f1983e74e20>, <pydriller.domain.commit.Method object at 0x7f1983e744f0>, <pydriller.domain.commit.Method object at 0x7f1983e74280>, <pydriller.domain.commit.Method object at 0x7f1983e4b3d0>, <pydriller.domain.commit.Method object at 0x7f1983e4bf70>, <pydriller.domain.commit.Method object at 0x7f1983ec5280>, <pydriller.domain.commit.Method object at 0x7f1983ec5100>, <pydriller.domain.commit.Method object at 0x7f1983ec58e0>, <pydriller.domain.commit.Method object at 0x7f1983ec5250>, <pydriller.domain.commit.Method object at 0x7f1983ec54f0>, <pydriller.domain.commit.Method object at 0x7f1983ec53d0>], [<pydriller.domain.commit.Method object at 0x7f1983eae4f0>, <pydriller.domain.commit.Method object at 0x7f1983eaea30>, <pydriller.domain.commit.Method object at 0x7f1983eaef70>, <pydriller.domain.commit.Method object at 0x7f1983eaeb80>, <pydriller.domain.commit.Method object at 0x7f1983eaecd0>, <pydriller.domain.commit.Method object at 0x7f1983eaee50>, <pydriller.domain.commit.Method object at 0x7f1983e29280>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e9cf70>, <pydriller.domain.commit.Method object at 0x7f1983ea2a30>, <pydriller.domain.commit.Method object at 0x7f1983ea2130>, <pydriller.domain.commit.Method object at 0x7f1983ea28e0>, <pydriller.domain.commit.Method object at 0x7f1983ea2280>, <pydriller.domain.commit.Method object at 0x7f1983ea2100>, <pydriller.domain.commit.Method object at 0x7f1983ea2910>, <pydriller.domain.commit.Method object at 0x7f1983ea2790>], [<pydriller.domain.commit.Method object at 0x7f1983e9ca30>, <pydriller.domain.commit.Method object at 0x7f1983e9ca60>, <pydriller.domain.commit.Method object at 0x7f1983e9cbb0>], [<pydriller.domain.commit.Method object at 0x7f1983ea23d0>], [<pydriller.domain.commit.Method object at 0x7f1983ec0280>, <pydriller.domain.commit.Method object at 0x7f1983eb2f70>, <pydriller.domain.commit.Method object at 0x7f1983e3ccd0>, <pydriller.domain.commit.Method object at 0x7f1983e3cd00>, <pydriller.domain.commit.Method object at 0x7f1983ec0f70>, <pydriller.domain.commit.Method object at 0x7f1983eb2910>, <pydriller.domain.commit.Method object at 0x7f1983ec03a0>, <pydriller.domain.commit.Method object at 0x7f1983eb2cd0>, <pydriller.domain.commit.Method object at 0x7f1983ec0cd0>, <pydriller.domain.commit.Method object at 0x7f1983ec0b80>, <pydriller.domain.commit.Method object at 0x7f1983ec04f0>, <pydriller.domain.commit.Method object at 0x7f1983ec0910>, <pydriller.domain.commit.Method object at 0x7f1983eb2790>], [<pydriller.domain.commit.Method object at 0x7f1983eb97c0>, <pydriller.domain.commit.Method object at 0x7f1983eb9250>], [<pydriller.domain.commit.Method object at 0x7f1983e744f0>, <pydriller.domain.commit.Method object at 0x7f1983e7a790>, <pydriller.domain.commit.Method object at 0x7f1983e12a30>, <pydriller.domain.commit.Method object at 0x7f1983e74e20>], [<pydriller.domain.commit.Method object at 0x7f1983e96280>, <pydriller.domain.commit.Method object at 0x7f1983e96130>, <pydriller.domain.commit.Method object at 0x7f1983e96bb0>]]"
thefuck,0553d57ec145db4a043b3f115a5e8b7865c3a4bc,Don't mess with inheritance for filling settings,2015-04-22 22:29:23+02:00,nvbn,83,79,162,4,"['test_conf.py', 'test_utils.py', 'conf.py', 'main.py']","[""from mock import patch, Mock\nfrom thefuck.main import Rule\nfrom thefuck import conf\n\n\ndef test_rules_list():\n    assert conf.RulesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert conf.RulesList(['bash', 'lisp']) == conf.RulesList(['bash', 'lisp'])\n    assert Rule('lisp', None, None, False) in conf.RulesList(['lisp'])\n    assert Rule('bash', None, None, False) not in conf.RulesList(['lisp'])\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT\n    assert Rule('test', None, None, False) not in conf.DEFAULT\n    assert Rule('test', None, None, False) in (conf.DEFAULT + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.Settings.defaults.items():\n            assert getattr(conf.Settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.Settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.Settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.Settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT:bash:lisp'}):\n        settings = conf.Settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['bash', 'lisp']\n\n\ndef test_update_settings():\n    settings = conf.BaseSettings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from mock import Mock\nfrom thefuck.utils import sudo_support, wrap_settings\nfrom thefuck.main import Command\nfrom thefuck.conf import BaseSettings\n\n\ndef test_wrap_settings():\n    fn = lambda _, settings: settings._conf\n    assert wrap_settings({'key': 'val'})(fn)(None, BaseSettings({})) \\\n           == {'key': 'val'}\n    assert wrap_settings({'key': 'new-val'})(fn)(\n        None, BaseSettings({'key': 'val'})) == {'key': 'new-val'}\n\n\ndef test_sudo_support():\n    fn = Mock(return_value=True, __name__='')\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n    fn.assert_called_once_with(Command('ls', 'out', 'err'), None)\n\n    fn.return_value = False\n    assert not sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n\n    fn.return_value = 'pwd'\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None) == 'sudo pwd'\n\n    assert sudo_support(fn)(Command('ls', 'out', 'err'), None) == 'pwd'\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs\n\n\nclass RulesList(object):\n    """"""Wrapper a top of list for string rules names.""""""\n\n    def __init__(self, rules):\n        self.rules = rules\n\n    def __contains__(self, item):\n        return item.name in self.rules\n\n    def __getattr__(self, item):\n        return getattr(self.rules, item)\n\n    def __eq__(self, other):\n        return self.rules == other\n\n\nclass _DefaultRules(RulesList):\n    def __add__(self, items):\n        return _DefaultRules(self.rules + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRules, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRules):\n            return self.rules == other.rules\n        else:\n            return False\n\n\nDEFAULT = _DefaultRules([])\n\n\nclass BaseSettings(object):\n    def __init__(self, conf):\n        self._conf = conf\n\n    def __getattr__(self, item):\n        return self._conf.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = copy(self._conf)\n        conf.update(kwargs)\n        return BaseSettings(conf)\n\n\nclass Settings(BaseSettings):\n    """"""Settings loaded from defaults/file/env.""""""\n    defaults = {\'rules\': DEFAULT,\n                \'wait_command\': 3,\n                \'require_confirmation\': False,\n                \'no_colors\': False}\n\n    env_to_attr = {\'THEFUCK_RULES\': \'rules\',\n                   \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n                   \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n                   \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n    def __init__(self, user_dir):\n        super(Settings, self).__init__(self._load_conf(user_dir))\n\n    def _load_conf(self, user_dir):\n        conf = copy(self.defaults)\n        try:\n            conf.update(self._load_from_file(user_dir))\n        except:\n            logs.exception(""Can\'t load settings from file"",\n                           sys.exc_info(),\n                           BaseSettings(conf))\n        try:\n            conf.update(self._load_from_env())\n        except:\n            logs.exception(""Can\'t load settings from env"",\n                           sys.exc_info(),\n                           BaseSettings(conf))\n        if not isinstance(conf[\'rules\'], RulesList):\n            conf[\'rules\'] = RulesList(conf[\'rules\'])\n        return conf\n\n    def _load_from_file(self, user_dir):\n        """"""Loads settings from file.""""""\n        settings = load_source(\'settings\',\n                               text_type(user_dir.joinpath(\'settings.py\')))\n        return {key: getattr(settings, key)\n                for key in self.defaults.keys()\n                if hasattr(settings, key)}\n\n    def _load_from_env(self):\n        """"""Loads settings from env.""""""\n        return {attr: self._val_from_env(env, attr)\n                for env, attr in self.env_to_attr.items()\n                if env in os.environ}\n\n    def _val_from_env(self, env, attr):\n        """"""Transforms env-strings to python.""""""\n        val = os.environ[env]\n        if attr == \'rules\':\n            val = self._rules_from_env(val)\n        elif attr == \'wait_command\':\n            val = int(val)\n        elif attr in (\'require_confirmation\', \'no_colors\'):\n            val = val.lower() == \'true\'\n        return val\n\n    def _rules_from_env(self, val):\n        """"""Transforms rules list from env-string to python.""""""\n        val = val.split(\':\')\n        if \'DEFAULT\' in val:\n            val = DEFAULT + [rule for rule in val if rule != \'DEFAULT\']\n        return val\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom . import logs, conf\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.Settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n']","[""from mock import patch, Mock\nfrom thefuck.main import Rule\nfrom thefuck import conf\n\n\ndef test_rules_list():\n    assert conf.RulesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert conf.RulesList(['bash', 'lisp']) == conf.RulesList(['bash', 'lisp'])\n    assert Rule('lisp', None, None, False) in conf.RulesList(['lisp'])\n    assert Rule('bash', None, None, False) not in conf.RulesList(['lisp'])\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT\n    assert Rule('test', None, None, False) not in conf.DEFAULT\n    assert Rule('test', None, None, False) in (conf.DEFAULT + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.DEFAULT_SETTINGS.items():\n            assert getattr(conf.get_settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT:bash:lisp'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['bash', 'lisp']\n\n\ndef test_update_settings():\n    settings = conf.Settings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from mock import Mock\nfrom thefuck.utils import sudo_support, wrap_settings\nfrom thefuck.main import Command\nfrom thefuck.conf import Settings\n\n\ndef test_wrap_settings():\n    fn = lambda _, settings: settings._conf\n    assert wrap_settings({'key': 'val'})(fn)(None, Settings({})) \\\n           == {'key': 'val'}\n    assert wrap_settings({'key': 'new-val'})(fn)(\n        None, Settings({'key': 'val'})) == {'key': 'new-val'}\n\n\ndef test_sudo_support():\n    fn = Mock(return_value=True, __name__='')\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n    fn.assert_called_once_with(Command('ls', 'out', 'err'), None)\n\n    fn.return_value = False\n    assert not sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n\n    fn.return_value = 'pwd'\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None) == 'sudo pwd'\n\n    assert sudo_support(fn)(Command('ls', 'out', 'err'), None) == 'pwd'\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs\n\n\nclass RulesList(object):\n    """"""Wrapper a top of list for string rules names.""""""\n\n    def __init__(self, rules):\n        self.rules = rules\n\n    def __contains__(self, item):\n        return item.name in self.rules\n\n    def __getattr__(self, item):\n        return getattr(self.rules, item)\n\n    def __eq__(self, other):\n        return self.rules == other\n\n\nclass _DefaultRules(RulesList):\n    def __add__(self, items):\n        return _DefaultRules(self.rules + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRules, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRules):\n            return self.rules == other.rules\n        else:\n            return False\n\n\nDEFAULT = _DefaultRules([])\n\n\nclass Settings(object):\n    def __init__(self, conf):\n        self._conf = conf\n\n    def __getattr__(self, item):\n        return self._conf.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = copy(self._conf)\n        conf.update(kwargs)\n        return Settings(conf)\n\n\nDEFAULT_SETTINGS = {\'rules\': DEFAULT,\n                    \'wait_command\': 3,\n                    \'require_confirmation\': False,\n                    \'no_colors\': False}\n\nENV_TO_ATTR = {\'THEFUCK_RULES\': \'rules\',\n               \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n               \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n               \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n\ndef _settings_from_file(user_dir):\n    """"""Loads settings from file.""""""\n    settings = load_source(\'settings\',\n                           text_type(user_dir.joinpath(\'settings.py\')))\n    return {key: getattr(settings, key)\n            for key in DEFAULT_SETTINGS.keys()\n            if hasattr(settings, key)}\n\n\ndef _rules_from_env(val):\n    """"""Transforms rules list from env-string to python.""""""\n    val = val.split(\':\')\n    if \'DEFAULT\' in val:\n        val = DEFAULT + [rule for rule in val if rule != \'DEFAULT\']\n    return val\n\n\ndef _val_from_env(env, attr):\n    """"""Transforms env-strings to python.""""""\n    val = os.environ[env]\n    if attr == \'rules\':\n        val = _rules_from_env(val)\n    elif attr == \'wait_command\':\n        val = int(val)\n    elif attr in (\'require_confirmation\', \'no_colors\'):\n        val = val.lower() == \'true\'\n    return val\n\n\ndef _settings_from_env():\n    """"""Loads settings from env.""""""\n    return {attr: _val_from_env(env, attr)\n            for env, attr in ENV_TO_ATTR.items()\n            if env in os.environ}\n\n\ndef get_settings(user_dir):\n    """"""Returns settings filled with values from `settings.py` and env.""""""\n    conf = copy(DEFAULT_SETTINGS)\n    try:\n        conf.update(_settings_from_file(user_dir))\n    except Exception:\n        logs.exception(""Can\'t load settings from file"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    try:\n        conf.update(_settings_from_env())\n    except Exception:\n        logs.exception(""Can\'t load settings from env"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    if not isinstance(conf[\'rules\'], RulesList):\n        conf[\'rules\'] = RulesList(conf[\'rules\'])\n\n    return Settings(conf)\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom . import logs, conf\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n']","[[<pydriller.domain.commit.Method object at 0x7f1983e5c670>, <pydriller.domain.commit.Method object at 0x7f1983e5ca30>, <pydriller.domain.commit.Method object at 0x7f1983e5c520>, <pydriller.domain.commit.Method object at 0x7f1983e5cf70>, <pydriller.domain.commit.Method object at 0x7f1983e96910>, <pydriller.domain.commit.Method object at 0x7f1983e96520>, <pydriller.domain.commit.Method object at 0x7f1983e96100>, <pydriller.domain.commit.Method object at 0x7f1983e96cd0>], [<pydriller.domain.commit.Method object at 0x7f1983e4b100>, <pydriller.domain.commit.Method object at 0x7f1983e4b4f0>], [<pydriller.domain.commit.Method object at 0x7f1983eb9130>, <pydriller.domain.commit.Method object at 0x7f1983eb9100>, <pydriller.domain.commit.Method object at 0x7f1983eb9520>, <pydriller.domain.commit.Method object at 0x7f1983eb9910>, <pydriller.domain.commit.Method object at 0x7f1983eb2bb0>, <pydriller.domain.commit.Method object at 0x7f1983eb2670>, <pydriller.domain.commit.Method object at 0x7f1983eb2520>, <pydriller.domain.commit.Method object at 0x7f1983eb2250>, <pydriller.domain.commit.Method object at 0x7f1983ec0640>, <pydriller.domain.commit.Method object at 0x7f1983ec0130>, <pydriller.domain.commit.Method object at 0x7f1983ec07c0>, <pydriller.domain.commit.Method object at 0x7f1983ec0790>, <pydriller.domain.commit.Method object at 0x7f1983ec0a60>, <pydriller.domain.commit.Method object at 0x7f1983ec08e0>, <pydriller.domain.commit.Method object at 0x7f1983ec03d0>, <pydriller.domain.commit.Method object at 0x7f1983ec0a30>], [<pydriller.domain.commit.Method object at 0x7f1983f053a0>, <pydriller.domain.commit.Method object at 0x7f1983f054f0>, <pydriller.domain.commit.Method object at 0x7f1983f053d0>, <pydriller.domain.commit.Method object at 0x7f1983f05250>, <pydriller.domain.commit.Method object at 0x7f1983efebb0>, <pydriller.domain.commit.Method object at 0x7f1983efea30>, <pydriller.domain.commit.Method object at 0x7f1983efea60>, <pydriller.domain.commit.Method object at 0x7f1983efe8e0>, <pydriller.domain.commit.Method object at 0x7f1983efe910>, <pydriller.domain.commit.Method object at 0x7f1983efe790>]]","[[<pydriller.domain.commit.Method object at 0x7f1983eaed00>, <pydriller.domain.commit.Method object at 0x7f1983e294f0>, <pydriller.domain.commit.Method object at 0x7f1983eae3d0>, <pydriller.domain.commit.Method object at 0x7f1983eae790>, <pydriller.domain.commit.Method object at 0x7f1983e29a60>, <pydriller.domain.commit.Method object at 0x7f1983eae250>], [<pydriller.domain.commit.Method object at 0x7f1983e7af70>], [<pydriller.domain.commit.Method object at 0x7f1983ec07c0>, <pydriller.domain.commit.Method object at 0x7f1983ec0790>, <pydriller.domain.commit.Method object at 0x7f1983ec0a30>, <pydriller.domain.commit.Method object at 0x7f1983e62a30>, <pydriller.domain.commit.Method object at 0x7f1983e62280>, <pydriller.domain.commit.Method object at 0x7f1983e3ca30>, <pydriller.domain.commit.Method object at 0x7f1983ec08e0>, <pydriller.domain.commit.Method object at 0x7f1983e62a60>, <pydriller.domain.commit.Method object at 0x7f1983debbe0>, <pydriller.domain.commit.Method object at 0x7f1983ec0a60>, <pydriller.domain.commit.Method object at 0x7f1983ec03d0>, <pydriller.domain.commit.Method object at 0x7f1983e62cd0>], [<pydriller.domain.commit.Method object at 0x7f1983f05bb0>]]"
thefuck,20b6c4c1600e5d696c0f004242b6d21ce90ea4f0,Inherit `RulesNamesList` from `list`,2015-04-22 22:36:18+02:00,nvbn,16,25,41,3,"['test_conf.py', 'test_main.py', 'conf.py']","[""from mock import patch, Mock\nfrom thefuck.main import Rule\nfrom thefuck import conf\n\n\ndef test_rules_list():\n    assert conf.RulesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert conf.RulesList(['bash', 'lisp']) == conf.RulesList(['bash', 'lisp'])\n    assert Rule('lisp', None, None, False) in conf.RulesList(['lisp'])\n    assert Rule('bash', None, None, False) not in conf.RulesList(['lisp'])\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT\n    assert Rule('test', None, None, False) not in conf.DEFAULT\n    assert Rule('test', None, None, False) in (conf.DEFAULT + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.DEFAULT_SETTINGS.items():\n            assert getattr(conf.get_settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT:bash:lisp'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['bash', 'lisp']\n\n\ndef test_update_settings():\n    settings = conf.Settings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main, conf\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == main.Rule('bash', match, get_new_command, True)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.DEFAULT))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True),\n                   main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True)]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.RulesList(['bash'])))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('bash', 'bash', 'bash', True)]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None, True),\n             main.Rule('', lambda *_: False, None, True),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None, True)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs\n\n\nclass RulesList(object):\n    """"""Wrapper a top of list for string rules names.""""""\n\n    def __init__(self, rules):\n        self.rules = rules\n\n    def __contains__(self, item):\n        return item.name in self.rules\n\n    def __getattr__(self, item):\n        return getattr(self.rules, item)\n\n    def __eq__(self, other):\n        return self.rules == other\n\n\nclass _DefaultRules(RulesList):\n    def __add__(self, items):\n        return _DefaultRules(self.rules + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRules, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRules):\n            return self.rules == other.rules\n        else:\n            return False\n\n\nDEFAULT = _DefaultRules([])\n\n\nclass Settings(object):\n    def __init__(self, conf):\n        self._conf = conf\n\n    def __getattr__(self, item):\n        return self._conf.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = copy(self._conf)\n        conf.update(kwargs)\n        return Settings(conf)\n\n\nDEFAULT_SETTINGS = {\'rules\': DEFAULT,\n                    \'wait_command\': 3,\n                    \'require_confirmation\': False,\n                    \'no_colors\': False}\n\nENV_TO_ATTR = {\'THEFUCK_RULES\': \'rules\',\n               \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n               \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n               \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n\ndef _settings_from_file(user_dir):\n    """"""Loads settings from file.""""""\n    settings = load_source(\'settings\',\n                           text_type(user_dir.joinpath(\'settings.py\')))\n    return {key: getattr(settings, key)\n            for key in DEFAULT_SETTINGS.keys()\n            if hasattr(settings, key)}\n\n\ndef _rules_from_env(val):\n    """"""Transforms rules list from env-string to python.""""""\n    val = val.split(\':\')\n    if \'DEFAULT\' in val:\n        val = DEFAULT + [rule for rule in val if rule != \'DEFAULT\']\n    return val\n\n\ndef _val_from_env(env, attr):\n    """"""Transforms env-strings to python.""""""\n    val = os.environ[env]\n    if attr == \'rules\':\n        val = _rules_from_env(val)\n    elif attr == \'wait_command\':\n        val = int(val)\n    elif attr in (\'require_confirmation\', \'no_colors\'):\n        val = val.lower() == \'true\'\n    return val\n\n\ndef _settings_from_env():\n    """"""Loads settings from env.""""""\n    return {attr: _val_from_env(env, attr)\n            for env, attr in ENV_TO_ATTR.items()\n            if env in os.environ}\n\n\ndef get_settings(user_dir):\n    """"""Returns settings filled with values from `settings.py` and env.""""""\n    conf = copy(DEFAULT_SETTINGS)\n    try:\n        conf.update(_settings_from_file(user_dir))\n    except Exception:\n        logs.exception(""Can\'t load settings from file"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    try:\n        conf.update(_settings_from_env())\n    except Exception:\n        logs.exception(""Can\'t load settings from env"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    if not isinstance(conf[\'rules\'], RulesList):\n        conf[\'rules\'] = RulesList(conf[\'rules\'])\n\n    return Settings(conf)\n']","[""from mock import patch, Mock\nfrom thefuck.main import Rule\nfrom thefuck import conf\n\n\ndef test_rules_names_list():\n    assert conf.RulesNamesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert conf.RulesNamesList(['bash', 'lisp']) == conf.RulesNamesList(['bash', 'lisp'])\n    assert Rule('lisp', None, None, False) in conf.RulesNamesList(['lisp'])\n    assert Rule('bash', None, None, False) not in conf.RulesNamesList(['lisp'])\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT\n    assert Rule('test', None, None, False) not in conf.DEFAULT\n    assert Rule('test', None, None, False) in (conf.DEFAULT + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.DEFAULT_SETTINGS.items():\n            assert getattr(conf.get_settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT:bash:lisp'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['bash', 'lisp']\n\n\ndef test_update_settings():\n    settings = conf.Settings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main, conf\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == main.Rule('bash', match, get_new_command, True)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.DEFAULT))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True),\n                   main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True)]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.RulesNamesList(['bash'])))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('bash', 'bash', 'bash', True)]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None, True),\n             main.Rule('', lambda *_: False, None, True),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None, True)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs\n\n\nclass RulesNamesList(list):\n    """"""Wrapper a top of list for string rules names.""""""\n\n    def __contains__(self, item):\n        return super(RulesNamesList, self).__contains__(item.name)\n\n\nclass _DefaultRulesNames(RulesNamesList):\n    def __add__(self, items):\n        return _DefaultRulesNames(list(self) + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRulesNames, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRulesNames):\n            return super(_DefaultRulesNames, self).__eq__(other)\n        else:\n            return False\n\n\nDEFAULT = _DefaultRulesNames([])\n\n\nclass Settings(object):\n    def __init__(self, conf):\n        self._conf = conf\n\n    def __getattr__(self, item):\n        return self._conf.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = copy(self._conf)\n        conf.update(kwargs)\n        return Settings(conf)\n\n\nDEFAULT_SETTINGS = {\'rules\': DEFAULT,\n                    \'wait_command\': 3,\n                    \'require_confirmation\': False,\n                    \'no_colors\': False}\n\nENV_TO_ATTR = {\'THEFUCK_RULES\': \'rules\',\n               \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n               \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n               \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n\ndef _settings_from_file(user_dir):\n    """"""Loads settings from file.""""""\n    settings = load_source(\'settings\',\n                           text_type(user_dir.joinpath(\'settings.py\')))\n    return {key: getattr(settings, key)\n            for key in DEFAULT_SETTINGS.keys()\n            if hasattr(settings, key)}\n\n\ndef _rules_from_env(val):\n    """"""Transforms rules list from env-string to python.""""""\n    val = val.split(\':\')\n    if \'DEFAULT\' in val:\n        val = DEFAULT + [rule for rule in val if rule != \'DEFAULT\']\n    return val\n\n\ndef _val_from_env(env, attr):\n    """"""Transforms env-strings to python.""""""\n    val = os.environ[env]\n    if attr == \'rules\':\n        val = _rules_from_env(val)\n    elif attr == \'wait_command\':\n        val = int(val)\n    elif attr in (\'require_confirmation\', \'no_colors\'):\n        val = val.lower() == \'true\'\n    return val\n\n\ndef _settings_from_env():\n    """"""Loads settings from env.""""""\n    return {attr: _val_from_env(env, attr)\n            for env, attr in ENV_TO_ATTR.items()\n            if env in os.environ}\n\n\ndef get_settings(user_dir):\n    """"""Returns settings filled with values from `settings.py` and env.""""""\n    conf = copy(DEFAULT_SETTINGS)\n    try:\n        conf.update(_settings_from_file(user_dir))\n    except Exception:\n        logs.exception(""Can\'t load settings from file"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    try:\n        conf.update(_settings_from_env())\n    except Exception:\n        logs.exception(""Can\'t load settings from env"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    if not isinstance(conf[\'rules\'], RulesNamesList):\n        conf[\'rules\'] = RulesNamesList(conf[\'rules\'])\n\n    return Settings(conf)\n']","[[<pydriller.domain.commit.Method object at 0x7f1983ef3cd0>, <pydriller.domain.commit.Method object at 0x7f1983ef3e20>, <pydriller.domain.commit.Method object at 0x7f1983ef3d00>, <pydriller.domain.commit.Method object at 0x7f1983ef3b80>, <pydriller.domain.commit.Method object at 0x7f1983ef3670>, <pydriller.domain.commit.Method object at 0x7f1983ef34f0>, <pydriller.domain.commit.Method object at 0x7f1983ef3520>, <pydriller.domain.commit.Method object at 0x7f1983ef33a0>], [<pydriller.domain.commit.Method object at 0x7f1983efee20>, <pydriller.domain.commit.Method object at 0x7f1983efef70>, <pydriller.domain.commit.Method object at 0x7f1983efee50>, <pydriller.domain.commit.Method object at 0x7f1983efecd0>, <pydriller.domain.commit.Method object at 0x7f1983f09520>, <pydriller.domain.commit.Method object at 0x7f1983f094f0>], [<pydriller.domain.commit.Method object at 0x7f1983eb93a0>, <pydriller.domain.commit.Method object at 0x7f1983eb9670>, <pydriller.domain.commit.Method object at 0x7f1983eb9f70>, <pydriller.domain.commit.Method object at 0x7f1983eb93d0>, <pydriller.domain.commit.Method object at 0x7f1983de6fd0>, <pydriller.domain.commit.Method object at 0x7f1983de6430>, <pydriller.domain.commit.Method object at 0x7f1983de6550>, <pydriller.domain.commit.Method object at 0x7f1983ddfac0>, <pydriller.domain.commit.Method object at 0x7f1983e86520>, <pydriller.domain.commit.Method object at 0x7f1983e12130>, <pydriller.domain.commit.Method object at 0x7f1983e12640>, <pydriller.domain.commit.Method object at 0x7f1983e12100>, <pydriller.domain.commit.Method object at 0x7f1983e12d00>, <pydriller.domain.commit.Method object at 0x7f1983e123a0>, <pydriller.domain.commit.Method object at 0x7f1983e123d0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983ef3cd0>, <pydriller.domain.commit.Method object at 0x7f1983e90790>], [<pydriller.domain.commit.Method object at 0x7f1983ef87c0>], [<pydriller.domain.commit.Method object at 0x7f1983f09250>, <pydriller.domain.commit.Method object at 0x7f1983eb9f70>, <pydriller.domain.commit.Method object at 0x7f1983f05fa0>, <pydriller.domain.commit.Method object at 0x7f1983f09b80>, <pydriller.domain.commit.Method object at 0x7f1983f09100>, <pydriller.domain.commit.Method object at 0x7f1983eb93a0>]]"
thefuck,54c408a6b572e84f75b1f11133d6769a6aef3dab,Rename `DEFAULT` to `DEFAULT_RULES`,2015-04-22 22:37:11+02:00,nvbn,14,14,28,4,"['README.md', 'test_conf.py', 'test_main.py', 'conf.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""from mock import patch, Mock\nfrom thefuck.main import Rule\nfrom thefuck import conf\n\n\ndef test_rules_names_list():\n    assert conf.RulesNamesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert conf.RulesNamesList(['bash', 'lisp']) == conf.RulesNamesList(['bash', 'lisp'])\n    assert Rule('lisp', None, None, False) in conf.RulesNamesList(['lisp'])\n    assert Rule('bash', None, None, False) not in conf.RulesNamesList(['lisp'])\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT\n    assert Rule('test', None, None, False) not in conf.DEFAULT\n    assert Rule('test', None, None, False) in (conf.DEFAULT + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.DEFAULT_SETTINGS.items():\n            assert getattr(conf.get_settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT:bash:lisp'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['bash', 'lisp']\n\n\ndef test_update_settings():\n    settings = conf.Settings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main, conf\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == main.Rule('bash', match, get_new_command, True)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.DEFAULT))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True),\n                   main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True)]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.RulesNamesList(['bash'])))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('bash', 'bash', 'bash', True)]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None, True),\n             main.Rule('', lambda *_: False, None, True),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None, True)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs\n\n\nclass RulesNamesList(list):\n    """"""Wrapper a top of list for string rules names.""""""\n\n    def __contains__(self, item):\n        return super(RulesNamesList, self).__contains__(item.name)\n\n\nclass _DefaultRulesNames(RulesNamesList):\n    def __add__(self, items):\n        return _DefaultRulesNames(list(self) + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRulesNames, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRulesNames):\n            return super(_DefaultRulesNames, self).__eq__(other)\n        else:\n            return False\n\n\nDEFAULT = _DefaultRulesNames([])\n\n\nclass Settings(object):\n    def __init__(self, conf):\n        self._conf = conf\n\n    def __getattr__(self, item):\n        return self._conf.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = copy(self._conf)\n        conf.update(kwargs)\n        return Settings(conf)\n\n\nDEFAULT_SETTINGS = {\'rules\': DEFAULT,\n                    \'wait_command\': 3,\n                    \'require_confirmation\': False,\n                    \'no_colors\': False}\n\nENV_TO_ATTR = {\'THEFUCK_RULES\': \'rules\',\n               \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n               \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n               \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n\ndef _settings_from_file(user_dir):\n    """"""Loads settings from file.""""""\n    settings = load_source(\'settings\',\n                           text_type(user_dir.joinpath(\'settings.py\')))\n    return {key: getattr(settings, key)\n            for key in DEFAULT_SETTINGS.keys()\n            if hasattr(settings, key)}\n\n\ndef _rules_from_env(val):\n    """"""Transforms rules list from env-string to python.""""""\n    val = val.split(\':\')\n    if \'DEFAULT\' in val:\n        val = DEFAULT + [rule for rule in val if rule != \'DEFAULT\']\n    return val\n\n\ndef _val_from_env(env, attr):\n    """"""Transforms env-strings to python.""""""\n    val = os.environ[env]\n    if attr == \'rules\':\n        val = _rules_from_env(val)\n    elif attr == \'wait_command\':\n        val = int(val)\n    elif attr in (\'require_confirmation\', \'no_colors\'):\n        val = val.lower() == \'true\'\n    return val\n\n\ndef _settings_from_env():\n    """"""Loads settings from env.""""""\n    return {attr: _val_from_env(env, attr)\n            for env, attr in ENV_TO_ATTR.items()\n            if env in os.environ}\n\n\ndef get_settings(user_dir):\n    """"""Returns settings filled with values from `settings.py` and env.""""""\n    conf = copy(DEFAULT_SETTINGS)\n    try:\n        conf.update(_settings_from_file(user_dir))\n    except Exception:\n        logs.exception(""Can\'t load settings from file"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    try:\n        conf.update(_settings_from_env())\n    except Exception:\n        logs.exception(""Can\'t load settings from env"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    if not isinstance(conf[\'rules\'], RulesNamesList):\n        conf[\'rules\'] = RulesNamesList(conf[\'rules\'])\n\n    return Settings(conf)\n']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""from mock import patch, Mock\nfrom thefuck.main import Rule\nfrom thefuck import conf\n\n\ndef test_rules_names_list():\n    assert conf.RulesNamesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert conf.RulesNamesList(['bash', 'lisp']) == conf.RulesNamesList(['bash', 'lisp'])\n    assert Rule('lisp', None, None, False) in conf.RulesNamesList(['lisp'])\n    assert Rule('bash', None, None, False) not in conf.RulesNamesList(['lisp'])\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT_RULES\n    assert Rule('test', None, None, False) not in conf.DEFAULT_RULES\n    assert Rule('test', None, None, False) in (conf.DEFAULT_RULES + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.DEFAULT_SETTINGS.items():\n            assert getattr(conf.get_settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT_RULES + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT_RULES:bash:lisp'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['bash', 'lisp']\n\n\ndef test_update_settings():\n    settings = conf.Settings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main, conf\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == main.Rule('bash', match, get_new_command, True)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.DEFAULT_RULES))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True),\n                   main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True)]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.RulesNamesList(['bash'])))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('bash', 'bash', 'bash', True)]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None, True),\n             main.Rule('', lambda *_: False, None, True),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None, True)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs\n\n\nclass RulesNamesList(list):\n    """"""Wrapper a top of list for string rules names.""""""\n\n    def __contains__(self, item):\n        return super(RulesNamesList, self).__contains__(item.name)\n\n\nclass _DefaultRulesNames(RulesNamesList):\n    def __add__(self, items):\n        return _DefaultRulesNames(list(self) + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRulesNames, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRulesNames):\n            return super(_DefaultRulesNames, self).__eq__(other)\n        else:\n            return False\n\n\nDEFAULT_RULES = _DefaultRulesNames([])\n\n\nclass Settings(object):\n    def __init__(self, conf):\n        self._conf = conf\n\n    def __getattr__(self, item):\n        return self._conf.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = copy(self._conf)\n        conf.update(kwargs)\n        return Settings(conf)\n\n\nDEFAULT_SETTINGS = {\'rules\': DEFAULT_RULES,\n                    \'wait_command\': 3,\n                    \'require_confirmation\': False,\n                    \'no_colors\': False}\n\nENV_TO_ATTR = {\'THEFUCK_RULES\': \'rules\',\n               \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n               \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n               \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n\ndef _settings_from_file(user_dir):\n    """"""Loads settings from file.""""""\n    settings = load_source(\'settings\',\n                           text_type(user_dir.joinpath(\'settings.py\')))\n    return {key: getattr(settings, key)\n            for key in DEFAULT_SETTINGS.keys()\n            if hasattr(settings, key)}\n\n\ndef _rules_from_env(val):\n    """"""Transforms rules list from env-string to python.""""""\n    val = val.split(\':\')\n    if \'DEFAULT_RULES\' in val:\n        val = DEFAULT_RULES + [rule for rule in val if rule != \'DEFAULT_RULES\']\n    return val\n\n\ndef _val_from_env(env, attr):\n    """"""Transforms env-strings to python.""""""\n    val = os.environ[env]\n    if attr == \'rules\':\n        val = _rules_from_env(val)\n    elif attr == \'wait_command\':\n        val = int(val)\n    elif attr in (\'require_confirmation\', \'no_colors\'):\n        val = val.lower() == \'true\'\n    return val\n\n\ndef _settings_from_env():\n    """"""Loads settings from env.""""""\n    return {attr: _val_from_env(env, attr)\n            for env, attr in ENV_TO_ATTR.items()\n            if env in os.environ}\n\n\ndef get_settings(user_dir):\n    """"""Returns settings filled with values from `settings.py` and env.""""""\n    conf = copy(DEFAULT_SETTINGS)\n    try:\n        conf.update(_settings_from_file(user_dir))\n    except Exception:\n        logs.exception(""Can\'t load settings from file"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    try:\n        conf.update(_settings_from_env())\n    except Exception:\n        logs.exception(""Can\'t load settings from env"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    if not isinstance(conf[\'rules\'], RulesNamesList):\n        conf[\'rules\'] = RulesNamesList(conf[\'rules\'])\n\n    return Settings(conf)\n']","[[], [<pydriller.domain.commit.Method object at 0x7f1983e51a30>, <pydriller.domain.commit.Method object at 0x7f1983ef33d0>, <pydriller.domain.commit.Method object at 0x7f1983ef3e50>, <pydriller.domain.commit.Method object at 0x7f1983ef3250>, <pydriller.domain.commit.Method object at 0x7f1983ef3790>, <pydriller.domain.commit.Method object at 0x7f1983ef37c0>, <pydriller.domain.commit.Method object at 0x7f1983ef3640>, <pydriller.domain.commit.Method object at 0x7f1983ef3100>], [<pydriller.domain.commit.Method object at 0x7f1983ee7b80>, <pydriller.domain.commit.Method object at 0x7f1983ee7cd0>, <pydriller.domain.commit.Method object at 0x7f1983ee7bb0>, <pydriller.domain.commit.Method object at 0x7f1983ee7a30>, <pydriller.domain.commit.Method object at 0x7f1983ee7670>, <pydriller.domain.commit.Method object at 0x7f1983ee74f0>], [<pydriller.domain.commit.Method object at 0x7f1983edc790>, <pydriller.domain.commit.Method object at 0x7f1983edc8e0>, <pydriller.domain.commit.Method object at 0x7f1983edc7c0>, <pydriller.domain.commit.Method object at 0x7f1983edc640>, <pydriller.domain.commit.Method object at 0x7f1983ee7130>, <pydriller.domain.commit.Method object at 0x7f1983ee7250>, <pydriller.domain.commit.Method object at 0x7f1983ee7280>, <pydriller.domain.commit.Method object at 0x7f1983ee73d0>, <pydriller.domain.commit.Method object at 0x7f1983ee7e50>, <pydriller.domain.commit.Method object at 0x7f1983ee7fa0>, <pydriller.domain.commit.Method object at 0x7f1983ee7e20>, <pydriller.domain.commit.Method object at 0x7f1983ee7f70>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983ec5640>, <pydriller.domain.commit.Method object at 0x7f1983eaea60>, <pydriller.domain.commit.Method object at 0x7f1983e96d00>], [<pydriller.domain.commit.Method object at 0x7f1983eedbb0>], [<pydriller.domain.commit.Method object at 0x7f1983ee0100>]]"
thefuck,d3d1f992328dfaf245ef268090cf54bb492815b7,Move special data types to `types`,2015-04-22 23:04:22+02:00,nvbn,89,88,177,17,"['test_cd_parent.py', 'test_git_not_command.py', 'test_git_push.py', 'test_has_exists_script.py', 'test_mkdir_p.py', 'test_python_command.py', 'test_rm_dir.py', 'test_ssh_known_host.py', 'test_sudo.py', 'test_conf.py', 'test_main.py', 'test_types.py', 'test_utils.py', 'conf.py', 'main.py', 'types.py', 'utils.py']","[""from thefuck.main import Command\nfrom thefuck.rules.cd_parent import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('cd..', '', 'cd..: command not found'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(\n        Command('cd..', '', ''), None) == 'cd ..'\n"", 'import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.git_not_command import match, get_new_command\n\n\n@pytest.fixture\ndef git_not_command():\n    return """"""git: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\nbranch\n""""""\n\n\n@pytest.fixture\ndef git_not_command_one_of_this():\n    return """"""git: \'st\' is not a git command. See \'git --help\'.\n\nDid you mean one of these?\nstatus\nreset\nstage\nstash\nstats\n""""""\n\n\n@pytest.fixture\ndef git_command():\n    return ""* master""\n\n\ndef test_match(git_not_command, git_command, git_not_command_one_of_this):\n    assert match(Command(\'git brnch\', \'\', git_not_command), None)\n    assert match(Command(\'git st\', \'\', git_not_command_one_of_this), None)\n    assert not match(Command(\'ls brnch\', \'\', git_not_command), None)\n    assert not match(Command(\'git branch\', \'\', git_command), None)\n\n\ndef test_get_new_command(git_not_command, git_not_command_one_of_this):\n    assert get_new_command(Command(\'git brnch\', \'\', git_not_command), None)\\\n        == \'git branch\'\n    assert get_new_command(\n        Command(\'git st\', \'\', git_not_command_one_of_this), None) == \'git status\'\n', 'import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.git_push import match, get_new_command\n\n\n@pytest.fixture\ndef stderr():\n    return \'\'\'fatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\'\'\'\n\n\ndef test_match(stderr):\n    assert match(Command(\'git push master\', \'\', stderr), None)\n    assert not match(Command(\'git push master\', \'\', \'\'), None)\n    assert not match(Command(\'ls\', \'\', stderr), None)\n\n\ndef test_get_new_command(stderr):\n    assert get_new_command(Command(\'\', \'\', stderr), None)\\\n        == ""git push --set-upstream origin master""\n', ""from mock import Mock, patch\nfrom thefuck.rules. has_exists_script import match, get_new_command\n\n\ndef test_match():\n    with patch('os.path.exists', return_value=True):\n        assert match(Mock(script='main', stderr='main: command not found'),\n                     None)\n        assert match(Mock(script='main --help',\n                          stderr='main: command not found'),\n                     None)\n        assert not match(Mock(script='main', stderr=''), None)\n\n    with patch('os.path.exists', return_value=False):\n        assert not match(Mock(script='main', stderr='main: command not found'),\n                         None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Mock(script='main --help'), None) == './main --help'\n"", ""from thefuck.main import Command\nfrom thefuck.rules.mkdir_p import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('mkdir foo/bar/baz', '', 'mkdir: foo/bar: No such file or directory'), None)\n    assert not match(Command('mkdir foo/bar/baz', '', ''), None)\n    assert not match(Command('mkdir foo/bar/baz', '', 'foo bar baz'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('mkdir foo/bar/baz', '', ''), None) == 'mkdir -p foo/bar/baz'\n"", ""from thefuck.main import Command\nfrom thefuck.rules.python_command import match, get_new_command\n\ndef test_match():\n    assert match(Command('temp.py', '', 'Permission denied'), None)\n    assert not match(Command('', '', ''), None)\n\ndef test_get_new_command():\n    assert get_new_command(Command('./test_sudo.py', '', ''), None) == 'python ./test_sudo.py'\n"", ""from thefuck.main import Command\nfrom thefuck.rules.rm_dir import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('rm foo', '', 'rm: foo: is a directory'), None)\n    assert not match(Command('rm foo', '', ''), None)\n    assert not match(Command('rm foo', '', 'foo bar baz'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('rm foo', '', ''), None) == 'rm -rf foo'\n"", 'import os\nimport pytest\nfrom mock import Mock\nfrom thefuck.main import Command\nfrom thefuck.rules.ssh_known_hosts import match, get_new_command, remove_offending_keys\n\n\n@pytest.fixture\ndef ssh_error(tmpdir):\n    path = os.path.join(str(tmpdir), \'known_hosts\')\n\n    def reset(path):\n        with open(path, \'w\') as fh:\n            lines = [\n                \'123.234.567.890 asdjkasjdakjsd\\n\'\n                \'98.765.432.321 ejioweojwejrosj\\n\'\n                \'111.222.333.444 qwepoiwqepoiss\\n\'\n            ]\n            fh.writelines(lines)\n\n    def known_hosts(path):\n        with open(path, \'r\') as fh:\n            return fh.readlines()\n\n    reset(path)\n\n    errormsg = u""""""@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\nb6:cb:07:34:c0:a0:94:d3:0d:69:83:31:f4:c5:20:9b.\nPlease contact your system administrator.\nAdd correct host key in {0} to get rid of this message.\nOffending RSA key in {0}:2\nRSA host key for {1} has changed and you have requested strict checking.\nHost key verification failed."""""".format(path, \'98.765.432.321\')\n\n    return errormsg, path, reset, known_hosts\n\n\ndef test_match(ssh_error):\n    errormsg, _, _, _ = ssh_error\n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert not match(Command(\'\', \'\', errormsg), None)\n    assert not match(Command(\'notssh\', \'\', errormsg), None)\n    assert not match(Command(\'ssh\', \'\', \'\'), None)\n\n\ndef test_remove_offending_keys(ssh_error):\n    errormsg, path, reset, known_hosts = ssh_error\n    command = Command(\'ssh user@host\', \'\', errormsg)\n    remove_offending_keys(command, None)\n    expected = [\'123.234.567.890 asdjkasjdakjsd\\n\', \'111.222.333.444 qwepoiwqepoiss\\n\']\n    assert known_hosts(path) == expected\n\n\ndef test_get_new_command(ssh_error, monkeypatch):\n    errormsg, _, _, _ = ssh_error\n\n    method = Mock()\n    monkeypatch.setattr(\'thefuck.rules.ssh_known_hosts.remove_offending_keys\', method)\n    assert get_new_command(Command(\'ssh user@host\', \'\', errormsg), None) == \'ssh user@host\'\n    assert method.call_count\n', 'from thefuck.main import Command\nfrom thefuck.rules.sudo import match, get_new_command\n\n\ndef test_match():\n    assert match(Command(\'\', \'\', \'Permission denied\'), None)\n    assert match(Command(\'\', \'\', \'permission denied\'), None)\n    assert match(Command(\'\', \'\', ""npm ERR! Error: EACCES, unlink""), None)\n    assert not match(Command(\'\', \'\', \'\'), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command(\'ls\', \'\', \'\'), None) == \'sudo ls\'\n', ""from mock import patch, Mock\nfrom thefuck.main import Rule\nfrom thefuck import conf\n\n\ndef test_rules_names_list():\n    assert conf.RulesNamesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert conf.RulesNamesList(['bash', 'lisp']) == conf.RulesNamesList(['bash', 'lisp'])\n    assert Rule('lisp', None, None, False) in conf.RulesNamesList(['lisp'])\n    assert Rule('bash', None, None, False) not in conf.RulesNamesList(['lisp'])\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT_RULES\n    assert Rule('test', None, None, False) not in conf.DEFAULT_RULES\n    assert Rule('test', None, None, False) in (conf.DEFAULT_RULES + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.DEFAULT_SETTINGS.items():\n            assert getattr(conf.get_settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT_RULES + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT_RULES:bash:lisp'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['bash', 'lisp']\n\n\ndef test_update_settings():\n    settings = conf.Settings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main, conf\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == main.Rule('bash', match, get_new_command, True)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.DEFAULT_RULES))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True),\n                   main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True)]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.RulesNamesList(['bash'])))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('bash', 'bash', 'bash', True)]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None, True),\n             main.Rule('', lambda *_: False, None, True),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None, True)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", None, ""from mock import Mock\nfrom thefuck.utils import sudo_support, wrap_settings\nfrom thefuck.main import Command\nfrom thefuck.conf import Settings\n\n\ndef test_wrap_settings():\n    fn = lambda _, settings: settings._conf\n    assert wrap_settings({'key': 'val'})(fn)(None, Settings({})) \\\n           == {'key': 'val'}\n    assert wrap_settings({'key': 'new-val'})(fn)(\n        None, Settings({'key': 'val'})) == {'key': 'new-val'}\n\n\ndef test_sudo_support():\n    fn = Mock(return_value=True, __name__='')\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n    fn.assert_called_once_with(Command('ls', 'out', 'err'), None)\n\n    fn.return_value = False\n    assert not sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n\n    fn.return_value = 'pwd'\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None) == 'sudo pwd'\n\n    assert sudo_support(fn)(Command('ls', 'out', 'err'), None) == 'pwd'\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs\n\n\nclass RulesNamesList(list):\n    """"""Wrapper a top of list for string rules names.""""""\n\n    def __contains__(self, item):\n        return super(RulesNamesList, self).__contains__(item.name)\n\n\nclass _DefaultRulesNames(RulesNamesList):\n    def __add__(self, items):\n        return _DefaultRulesNames(list(self) + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRulesNames, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRulesNames):\n            return super(_DefaultRulesNames, self).__eq__(other)\n        else:\n            return False\n\n\nDEFAULT_RULES = _DefaultRulesNames([])\n\n\nclass Settings(object):\n    def __init__(self, conf):\n        self._conf = conf\n\n    def __getattr__(self, item):\n        return self._conf.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = copy(self._conf)\n        conf.update(kwargs)\n        return Settings(conf)\n\n\nDEFAULT_SETTINGS = {\'rules\': DEFAULT_RULES,\n                    \'wait_command\': 3,\n                    \'require_confirmation\': False,\n                    \'no_colors\': False}\n\nENV_TO_ATTR = {\'THEFUCK_RULES\': \'rules\',\n               \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n               \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n               \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n\ndef _settings_from_file(user_dir):\n    """"""Loads settings from file.""""""\n    settings = load_source(\'settings\',\n                           text_type(user_dir.joinpath(\'settings.py\')))\n    return {key: getattr(settings, key)\n            for key in DEFAULT_SETTINGS.keys()\n            if hasattr(settings, key)}\n\n\ndef _rules_from_env(val):\n    """"""Transforms rules list from env-string to python.""""""\n    val = val.split(\':\')\n    if \'DEFAULT_RULES\' in val:\n        val = DEFAULT_RULES + [rule for rule in val if rule != \'DEFAULT_RULES\']\n    return val\n\n\ndef _val_from_env(env, attr):\n    """"""Transforms env-strings to python.""""""\n    val = os.environ[env]\n    if attr == \'rules\':\n        val = _rules_from_env(val)\n    elif attr == \'wait_command\':\n        val = int(val)\n    elif attr in (\'require_confirmation\', \'no_colors\'):\n        val = val.lower() == \'true\'\n    return val\n\n\ndef _settings_from_env():\n    """"""Loads settings from env.""""""\n    return {attr: _val_from_env(env, attr)\n            for env, attr in ENV_TO_ATTR.items()\n            if env in os.environ}\n\n\ndef get_settings(user_dir):\n    """"""Returns settings filled with values from `settings.py` and env.""""""\n    conf = copy(DEFAULT_SETTINGS)\n    try:\n        conf.update(_settings_from_file(user_dir))\n    except Exception:\n        logs.exception(""Can\'t load settings from file"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    try:\n        conf.update(_settings_from_env())\n    except Exception:\n        logs.exception(""Can\'t load settings from env"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    if not isinstance(conf[\'rules\'], RulesNamesList):\n        conf[\'rules\'] = RulesNamesList(conf[\'rules\'])\n\n    return Settings(conf)\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom . import logs, conf\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', None, 'from functools import wraps\nimport os\nimport six\nfrom thefuck.main import Command\n\n\ndef which(program):\n    """"""Returns `program` path or `None`.""""""\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef wrap_settings(params):\n    """"""Adds default values to settings if it not presented.\n\n    Usage:\n\n        @wrap_settings({\'apt\': \'/usr/bin/apt\'})\n        def match(command, settings):\n            print(settings.apt)\n\n    """"""\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(command, settings):\n            return fn(command, settings.update(**params))\n        return wrapper\n    return decorator\n\n\ndef sudo_support(fn):\n    """"""Removes sudo before calling fn and adds it after.""""""\n    @wraps(fn)\n    def wrapper(command, settings):\n        if not command.script.startswith(\'sudo \'):\n            return fn(command, settings)\n\n        result = fn(Command(command.script[5:],\n                            command.stdout,\n                            command.stderr),\n                    settings)\n\n        if result and isinstance(result, six.string_types):\n            return u\'sudo {}\'.format(result)\n        else:\n            return result\n    return wrapper\n']","[""from thefuck.types import Command\nfrom thefuck.rules.cd_parent import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('cd..', '', 'cd..: command not found'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(\n        Command('cd..', '', ''), None) == 'cd ..'\n"", 'import pytest\nfrom thefuck.types import Command\nfrom thefuck.rules.git_not_command import match, get_new_command\n\n\n@pytest.fixture\ndef git_not_command():\n    return """"""git: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\nbranch\n""""""\n\n\n@pytest.fixture\ndef git_not_command_one_of_this():\n    return """"""git: \'st\' is not a git command. See \'git --help\'.\n\nDid you mean one of these?\nstatus\nreset\nstage\nstash\nstats\n""""""\n\n\n@pytest.fixture\ndef git_command():\n    return ""* master""\n\n\ndef test_match(git_not_command, git_command, git_not_command_one_of_this):\n    assert match(Command(\'git brnch\', \'\', git_not_command), None)\n    assert match(Command(\'git st\', \'\', git_not_command_one_of_this), None)\n    assert not match(Command(\'ls brnch\', \'\', git_not_command), None)\n    assert not match(Command(\'git branch\', \'\', git_command), None)\n\n\ndef test_get_new_command(git_not_command, git_not_command_one_of_this):\n    assert get_new_command(Command(\'git brnch\', \'\', git_not_command), None)\\\n        == \'git branch\'\n    assert get_new_command(\n        Command(\'git st\', \'\', git_not_command_one_of_this), None) == \'git status\'\n', 'import pytest\nfrom thefuck.types import Command\nfrom thefuck.rules.git_push import match, get_new_command\n\n\n@pytest.fixture\ndef stderr():\n    return \'\'\'fatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\'\'\'\n\n\ndef test_match(stderr):\n    assert match(Command(\'git push master\', \'\', stderr), None)\n    assert not match(Command(\'git push master\', \'\', \'\'), None)\n    assert not match(Command(\'ls\', \'\', stderr), None)\n\n\ndef test_get_new_command(stderr):\n    assert get_new_command(Command(\'\', \'\', stderr), None)\\\n        == ""git push --set-upstream origin master""\n', ""from mock import Mock, patch\nfrom thefuck.rules.has_exists_script import match, get_new_command\n\n\ndef test_match():\n    with patch('os.path.exists', return_value=True):\n        assert match(Mock(script='main', stderr='main: command not found'),\n                     None)\n        assert match(Mock(script='main --help',\n                          stderr='main: command not found'),\n                     None)\n        assert not match(Mock(script='main', stderr=''), None)\n\n    with patch('os.path.exists', return_value=False):\n        assert not match(Mock(script='main', stderr='main: command not found'),\n                         None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Mock(script='main --help'), None) == './main --help'\n"", ""from thefuck.types import Command\nfrom thefuck.rules.mkdir_p import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('mkdir foo/bar/baz', '', 'mkdir: foo/bar: No such file or directory'), None)\n    assert not match(Command('mkdir foo/bar/baz', '', ''), None)\n    assert not match(Command('mkdir foo/bar/baz', '', 'foo bar baz'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('mkdir foo/bar/baz', '', ''), None) == 'mkdir -p foo/bar/baz'\n"", ""from thefuck.types import Command\nfrom thefuck.rules.python_command import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('temp.py', '', 'Permission denied'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('./test_sudo.py', '', ''), None) == 'python ./test_sudo.py'\n"", ""from thefuck.types import Command\nfrom thefuck.rules.rm_dir import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('rm foo', '', 'rm: foo: is a directory'), None)\n    assert not match(Command('rm foo', '', ''), None)\n    assert not match(Command('rm foo', '', 'foo bar baz'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('rm foo', '', ''), None) == 'rm -rf foo'\n"", 'import os\nimport pytest\nfrom mock import Mock\nfrom thefuck.types import Command\nfrom thefuck.rules.ssh_known_hosts import match, get_new_command, remove_offending_keys\n\n\n@pytest.fixture\ndef ssh_error(tmpdir):\n    path = os.path.join(str(tmpdir), \'known_hosts\')\n\n    def reset(path):\n        with open(path, \'w\') as fh:\n            lines = [\n                \'123.234.567.890 asdjkasjdakjsd\\n\'\n                \'98.765.432.321 ejioweojwejrosj\\n\'\n                \'111.222.333.444 qwepoiwqepoiss\\n\'\n            ]\n            fh.writelines(lines)\n\n    def known_hosts(path):\n        with open(path, \'r\') as fh:\n            return fh.readlines()\n\n    reset(path)\n\n    errormsg = u""""""@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\nb6:cb:07:34:c0:a0:94:d3:0d:69:83:31:f4:c5:20:9b.\nPlease contact your system administrator.\nAdd correct host key in {0} to get rid of this message.\nOffending RSA key in {0}:2\nRSA host key for {1} has changed and you have requested strict checking.\nHost key verification failed."""""".format(path, \'98.765.432.321\')\n\n    return errormsg, path, reset, known_hosts\n\n\ndef test_match(ssh_error):\n    errormsg, _, _, _ = ssh_error\n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert not match(Command(\'\', \'\', errormsg), None)\n    assert not match(Command(\'notssh\', \'\', errormsg), None)\n    assert not match(Command(\'ssh\', \'\', \'\'), None)\n\n\ndef test_remove_offending_keys(ssh_error):\n    errormsg, path, reset, known_hosts = ssh_error\n    command = Command(\'ssh user@host\', \'\', errormsg)\n    remove_offending_keys(command, None)\n    expected = [\'123.234.567.890 asdjkasjdakjsd\\n\', \'111.222.333.444 qwepoiwqepoiss\\n\']\n    assert known_hosts(path) == expected\n\n\ndef test_get_new_command(ssh_error, monkeypatch):\n    errormsg, _, _, _ = ssh_error\n\n    method = Mock()\n    monkeypatch.setattr(\'thefuck.rules.ssh_known_hosts.remove_offending_keys\', method)\n    assert get_new_command(Command(\'ssh user@host\', \'\', errormsg), None) == \'ssh user@host\'\n    assert method.call_count\n', 'from thefuck.types import Command\nfrom thefuck.rules.sudo import match, get_new_command\n\n\ndef test_match():\n    assert match(Command(\'\', \'\', \'Permission denied\'), None)\n    assert match(Command(\'\', \'\', \'permission denied\'), None)\n    assert match(Command(\'\', \'\', ""npm ERR! Error: EACCES, unlink""), None)\n    assert not match(Command(\'\', \'\', \'\'), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command(\'ls\', \'\', \'\'), None) == \'sudo ls\'\n', ""from mock import patch, Mock\nfrom thefuck.types import Rule\nfrom thefuck import conf\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT_RULES\n    assert Rule('test', None, None, False) not in conf.DEFAULT_RULES\n    assert Rule('test', None, None, False) in (conf.DEFAULT_RULES + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.DEFAULT_SETTINGS.items():\n            assert getattr(conf.get_settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT_RULES + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT_RULES:bash:lisp'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['bash', 'lisp']\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main, conf, types\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == types.Rule('bash', match, get_new_command, True)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.DEFAULT_RULES))) \\\n               == [types.Rule('bash', 'bash', 'bash', True),\n                   types.Rule('lisp', 'lisp', 'lisp', True),\n                   types.Rule('bash', 'bash', 'bash', True),\n                   types.Rule('lisp', 'lisp', 'lisp', True)]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=types.RulesNamesList(['bash'])))) \\\n               == [types.Rule('bash', 'bash', 'bash', True),\n                   types.Rule('bash', 'bash', 'bash', True)]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == types.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [types.Rule('', lambda x, _: x.script == 'cd ..', None, True),\n             types.Rule('', lambda *_: False, None, True),\n             types.Rule('rule', Mock(side_effect=OSError('Denied')), None, True)]\n    assert main.get_matched_rule(types.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(types.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(types.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(types.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", ""from thefuck.types import Rule, RulesNamesList, Settings\n\n\ndef test_rules_names_list():\n    assert RulesNamesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert RulesNamesList(['bash', 'lisp']) == RulesNamesList(['bash', 'lisp'])\n    assert Rule('lisp', None, None, False) in RulesNamesList(['lisp'])\n    assert Rule('bash', None, None, False) not in RulesNamesList(['lisp'])\n\n\ndef test_update_settings():\n    settings = Settings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from mock import Mock\nfrom thefuck.utils import sudo_support, wrap_settings\nfrom thefuck.types import Command, Settings\n\n\ndef test_wrap_settings():\n    fn = lambda _, settings: settings\n    assert wrap_settings({'key': 'val'})(fn)(None, Settings({})) \\\n           == {'key': 'val'}\n    assert wrap_settings({'key': 'new-val'})(fn)(\n        None, Settings({'key': 'val'})) == {'key': 'new-val'}\n\n\ndef test_sudo_support():\n    fn = Mock(return_value=True, __name__='')\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n    fn.assert_called_once_with(Command('ls', 'out', 'err'), None)\n\n    fn.return_value = False\n    assert not sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n\n    fn.return_value = 'pwd'\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None) == 'sudo pwd'\n\n    assert sudo_support(fn)(Command('ls', 'out', 'err'), None) == 'pwd'\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs, types\n\n\nclass _DefaultRulesNames(types.RulesNamesList):\n    def __add__(self, items):\n        return _DefaultRulesNames(list(self) + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRulesNames, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRulesNames):\n            return super(_DefaultRulesNames, self).__eq__(other)\n        else:\n            return False\n\n\nDEFAULT_RULES = _DefaultRulesNames([])\n\n\nDEFAULT_SETTINGS = {\'rules\': DEFAULT_RULES,\n                    \'wait_command\': 3,\n                    \'require_confirmation\': False,\n                    \'no_colors\': False}\n\nENV_TO_ATTR = {\'THEFUCK_RULES\': \'rules\',\n               \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n               \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n               \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n\ndef _settings_from_file(user_dir):\n    """"""Loads settings from file.""""""\n    settings = load_source(\'settings\',\n                           text_type(user_dir.joinpath(\'settings.py\')))\n    return {key: getattr(settings, key)\n            for key in DEFAULT_SETTINGS.keys()\n            if hasattr(settings, key)}\n\n\ndef _rules_from_env(val):\n    """"""Transforms rules list from env-string to python.""""""\n    val = val.split(\':\')\n    if \'DEFAULT_RULES\' in val:\n        val = DEFAULT_RULES + [rule for rule in val if rule != \'DEFAULT_RULES\']\n    return val\n\n\ndef _val_from_env(env, attr):\n    """"""Transforms env-strings to python.""""""\n    val = os.environ[env]\n    if attr == \'rules\':\n        val = _rules_from_env(val)\n    elif attr == \'wait_command\':\n        val = int(val)\n    elif attr in (\'require_confirmation\', \'no_colors\'):\n        val = val.lower() == \'true\'\n    return val\n\n\ndef _settings_from_env():\n    """"""Loads settings from env.""""""\n    return {attr: _val_from_env(env, attr)\n            for env, attr in ENV_TO_ATTR.items()\n            if env in os.environ}\n\n\ndef get_settings(user_dir):\n    """"""Returns settings filled with values from `settings.py` and env.""""""\n    conf = copy(DEFAULT_SETTINGS)\n    try:\n        conf.update(_settings_from_file(user_dir))\n    except Exception:\n        logs.exception(""Can\'t load settings from file"",\n                       sys.exc_info(),\n                       types.Settings(conf))\n\n    try:\n        conf.update(_settings_from_env())\n    except Exception:\n        logs.exception(""Can\'t load settings from env"",\n                       sys.exc_info(),\n                       types.Settings(conf))\n\n    if not isinstance(conf[\'rules\'], types.RulesNamesList):\n        conf[\'rules\'] = types.RulesNamesList(conf[\'rules\'])\n\n    return types.Settings(conf)\n', 'from imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom . import logs, conf, types\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return types.Rule(rule.name[:-3], rule_module.match,\n                      rule_module.get_new_command,\n                      getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent \\\n        .joinpath(\'rules\') \\\n        .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return types.Command(script, result.stdout.read().decode(\'utf-8\'),\n                             result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', 'from collections import namedtuple\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\n\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\nclass RulesNamesList(list):\n    """"""Wrapper a top of list for string rules names.""""""\n\n    def __contains__(self, item):\n        return super(RulesNamesList, self).__contains__(item.name)\n\n\nclass Settings(dict):\n\n    def __getattr__(self, item):\n        return self.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = dict(self)\n        conf.update(kwargs)\n        return Settings(conf)\n', 'from functools import wraps\nimport os\nimport six\nfrom .types import Command\n\n\ndef which(program):\n    """"""Returns `program` path or `None`.""""""\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef wrap_settings(params):\n    """"""Adds default values to settings if it not presented.\n\n    Usage:\n\n        @wrap_settings({\'apt\': \'/usr/bin/apt\'})\n        def match(command, settings):\n            print(settings.apt)\n\n    """"""\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(command, settings):\n            return fn(command, settings.update(**params))\n        return wrapper\n    return decorator\n\n\ndef sudo_support(fn):\n    """"""Removes sudo before calling fn and adds it after.""""""\n    @wraps(fn)\n    def wrapper(command, settings):\n        if not command.script.startswith(\'sudo \'):\n            return fn(command, settings)\n\n        result = fn(Command(command.script[5:],\n                            command.stdout,\n                            command.stderr),\n                    settings)\n\n        if result and isinstance(result, six.string_types):\n            return u\'sudo {}\'.format(result)\n        else:\n            return result\n    return wrapper\n']","[[<pydriller.domain.commit.Method object at 0x7f1983eb94f0>, <pydriller.domain.commit.Method object at 0x7f1983eb9a60>], [<pydriller.domain.commit.Method object at 0x7f1983ed5d00>, <pydriller.domain.commit.Method object at 0x7f1983ed5e20>, <pydriller.domain.commit.Method object at 0x7f1983ed5e50>, <pydriller.domain.commit.Method object at 0x7f1983ed5cd0>, <pydriller.domain.commit.Method object at 0x7f1983e57a30>], [<pydriller.domain.commit.Method object at 0x7f1983ef8bb0>, <pydriller.domain.commit.Method object at 0x7f1983ef8520>, <pydriller.domain.commit.Method object at 0x7f1983ef8130>], [<pydriller.domain.commit.Method object at 0x7f1983f097c0>, <pydriller.domain.commit.Method object at 0x7f1983f093a0>], [<pydriller.domain.commit.Method object at 0x7f1983f05280>, <pydriller.domain.commit.Method object at 0x7f1983f05130>], [<pydriller.domain.commit.Method object at 0x7f1983ee0e50>, <pydriller.domain.commit.Method object at 0x7f1983ee0fa0>], [<pydriller.domain.commit.Method object at 0x7f1983eedd00>, <pydriller.domain.commit.Method object at 0x7f1983eedfa0>], [<pydriller.domain.commit.Method object at 0x7f1983ecacd0>, <pydriller.domain.commit.Method object at 0x7f1983ecae20>, <pydriller.domain.commit.Method object at 0x7f1983ecad00>, <pydriller.domain.commit.Method object at 0x7f1983ecab80>, <pydriller.domain.commit.Method object at 0x7f1983eca7c0>, <pydriller.domain.commit.Method object at 0x7f1983eca640>], [<pydriller.domain.commit.Method object at 0x7f1983f44640>, <pydriller.domain.commit.Method object at 0x7f1983f44790>], [<pydriller.domain.commit.Method object at 0x7f1983f3d100>, <pydriller.domain.commit.Method object at 0x7f1983f36f70>, <pydriller.domain.commit.Method object at 0x7f1983f36fa0>, <pydriller.domain.commit.Method object at 0x7f1983f36e20>, <pydriller.domain.commit.Method object at 0x7f1983f36910>, <pydriller.domain.commit.Method object at 0x7f1983f36790>, <pydriller.domain.commit.Method object at 0x7f1983f367c0>, <pydriller.domain.commit.Method object at 0x7f1983f36640>], [<pydriller.domain.commit.Method object at 0x7f1983f3d8e0>, <pydriller.domain.commit.Method object at 0x7f1983f3da30>, <pydriller.domain.commit.Method object at 0x7f1983f3d910>, <pydriller.domain.commit.Method object at 0x7f1983f44100>, <pydriller.domain.commit.Method object at 0x7f1983f444f0>, <pydriller.domain.commit.Method object at 0x7f1983f44910>], [], [<pydriller.domain.commit.Method object at 0x7f1983eed520>, <pydriller.domain.commit.Method object at 0x7f1983eedcd0>], [<pydriller.domain.commit.Method object at 0x7f1983efe280>, <pydriller.domain.commit.Method object at 0x7f1983f09640>, <pydriller.domain.commit.Method object at 0x7f1983f09670>, <pydriller.domain.commit.Method object at 0x7f1983f09a60>, <pydriller.domain.commit.Method object at 0x7f1983ef8280>, <pydriller.domain.commit.Method object at 0x7f1983ef84f0>, <pydriller.domain.commit.Method object at 0x7f1983ef8100>, <pydriller.domain.commit.Method object at 0x7f1983ef8d00>, <pydriller.domain.commit.Method object at 0x7f1983ef8a60>, <pydriller.domain.commit.Method object at 0x7f1983ef8e50>, <pydriller.domain.commit.Method object at 0x7f1983ef8670>, <pydriller.domain.commit.Method object at 0x7f1983ef8b80>], [<pydriller.domain.commit.Method object at 0x7f1983ed5640>, <pydriller.domain.commit.Method object at 0x7f1983ed5b80>, <pydriller.domain.commit.Method object at 0x7f1983ed54f0>, <pydriller.domain.commit.Method object at 0x7f1983ed5fa0>, <pydriller.domain.commit.Method object at 0x7f1983edca60>, <pydriller.domain.commit.Method object at 0x7f1983edcbb0>, <pydriller.domain.commit.Method object at 0x7f1983edca30>, <pydriller.domain.commit.Method object at 0x7f1983edcd00>, <pydriller.domain.commit.Method object at 0x7f1983edcb80>, <pydriller.domain.commit.Method object at 0x7f1983edccd0>], [], [<pydriller.domain.commit.Method object at 0x7f1983e90640>, <pydriller.domain.commit.Method object at 0x7f1983e96790>, <pydriller.domain.commit.Method object at 0x7f1983e96670>, <pydriller.domain.commit.Method object at 0x7f1983e967c0>, <pydriller.domain.commit.Method object at 0x7f1983e96fa0>, <pydriller.domain.commit.Method object at 0x7f1983e96e20>, <pydriller.domain.commit.Method object at 0x7f1983e96250>]]","[[], [], [], [], [], [], [], [], [], [<pydriller.domain.commit.Method object at 0x7f1983f36640>, <pydriller.domain.commit.Method object at 0x7f1983f3d100>], [<pydriller.domain.commit.Method object at 0x7f1983f36b80>, <pydriller.domain.commit.Method object at 0x7f1983f36130>, <pydriller.domain.commit.Method object at 0x7f1983f3de20>, <pydriller.domain.commit.Method object at 0x7f1983f36d00>, <pydriller.domain.commit.Method object at 0x7f1983f36cd0>], [<pydriller.domain.commit.Method object at 0x7f1983ecaa60>, <pydriller.domain.commit.Method object at 0x7f1983ecabb0>], [<pydriller.domain.commit.Method object at 0x7f1983ed0b80>], [<pydriller.domain.commit.Method object at 0x7f1983ef8100>, <pydriller.domain.commit.Method object at 0x7f1983efe280>, <pydriller.domain.commit.Method object at 0x7f1983ef84f0>, <pydriller.domain.commit.Method object at 0x7f1983ef8280>, <pydriller.domain.commit.Method object at 0x7f1983efe250>], [<pydriller.domain.commit.Method object at 0x7f1983d9c040>, <pydriller.domain.commit.Method object at 0x7f1983e0ca60>, <pydriller.domain.commit.Method object at 0x7f1983eb2d00>], [<pydriller.domain.commit.Method object at 0x7f1983ee0280>, <pydriller.domain.commit.Method object at 0x7f1983ee0cd0>, <pydriller.domain.commit.Method object at 0x7f1983ee0250>], []]"
thefuck,0272e8a8018344d0f9757e21999ffb517d199a03,Bump to 1.28,2015-04-22 23:37:02+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nVERSION = \'1.27\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.28\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,5de020bccd2a7ea6ba34087fef06f08df09ced41,unf*ck sl -> ls,2015-04-22 20:41:56-05:00,Brobin,14,0,14,1,['sl_ls.py'],[None],"['""""""\nThis happens way too often\n\nWhen typing really fast cause I\'m a 1337 H4X0R,\nI often fuck up \'ls\' and type \'sl\'. No more!\n""""""\n\n\ndef match(command, settings):\n    return command.script == \'sl\'\n\n\ndef get_new_command(command, settings):\n    return \'ls\'\n']",[[]],"[[<pydriller.domain.commit.Method object at 0x7f1983e9ce50>, <pydriller.domain.commit.Method object at 0x7f1983e9c8e0>]]"
thefuck,157e3e95fc56353d3961d1ebde7a703103e7b335,added sl_ls test :shipit:,2015-04-22 20:51:18-05:00,Brobin,12,0,12,1,['test_sl_ls.py'],[None],"[""\nfrom thefuck.types import Command\nfrom thefuck.rules.sl_ls import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('sl', '', ''), None)\n    assert not match(Command('ls', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('sl', '', ''), None) == 'ls'\n""]",[[]],"[[<pydriller.domain.commit.Method object at 0x7f1983e4b7c0>, <pydriller.domain.commit.Method object at 0x7f1983e4be20>]]"
thefuck,af2bfe7c582c588db7f2a148d46e1cf588938165,Add a support for pip unknown commands,2015-04-23 15:25:12+09:00,Namwoo Kim,39,0,39,2,"['test_pip_unknown_command.py', 'pip_unknown_command.py']","[None, None]","['import pytest\nfrom thefuck.types import Command\nfrom thefuck.rules.pip_unknown_command import match, get_new_command\n\n\n@pytest.fixture\ndef pip_unknown_cmd():\n    return \'\'\'ERROR: unknown command ""instatl"" - maybe you meant ""install""\'\'\'\n\n\n@pytest.fixture\ndef pip_unknown_cmd_without_recommend():\n    return \'\'\'ERROR: unknown command ""i""\'\'\'\n\n\ndef test_match(pip_unknown_cmd, pip_unknown_cmd_without_recommend):\n    assert match(Command(\'pip instatl\', \'\', pip_unknown_cmd), None)\n    assert not match(Command(\'pip i\', \'\', pip_unknown_cmd_without_recommend),\n                     None)\n\n\ndef test_get_new_command(pip_unknown_cmd):\n    assert get_new_command(Command(\'pip instatl\', \'\', pip_unknown_cmd), None)\\\n        == \'pip install\'\n', 'import re\n\n\ndef match(command, settings):\n    return (\'pip\' in command.script and\n            \'unknown command\' in command.stderr and\n            \'maybe you meant\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r\'ERROR: unknown command \\""([a-z]+)\\""\',\n                            command.stderr)[0]\n    new_cmd = re.findall(r\'maybe you meant \\""([a-z]+)\\""\', command.stderr)[0]\n\n    return command.script.replace(broken_cmd, new_cmd, 1)\n']","[[], []]","[[<pydriller.domain.commit.Method object at 0x7f1983ec0520>, <pydriller.domain.commit.Method object at 0x7f1983e57bb0>, <pydriller.domain.commit.Method object at 0x7f1983ec0250>, <pydriller.domain.commit.Method object at 0x7f1983e57130>], [<pydriller.domain.commit.Method object at 0x7f1983e51fa0>, <pydriller.domain.commit.Method object at 0x7f1983e513a0>]]"
thefuck,07b9aba0d0b21d4b52f471bc2c7403ad4b484d19,"MacOSX specific message

Patch for understanding macosx message.
Example case:
```
[10:24:48][bethrezen@bethrezen-mac ~]$ apachectl graceful
This operation requires root.
[10:24:54][bethrezen@bethrezen-mac ~]$ fuck
No fuck given
```",2015-04-23 10:29:34+03:00,Alexander Kozhevnikov,1,0,1,1,['sudo.py'],"[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted',\n            'root privilege',\n            'This command has to be run under the root user.',\n            'You need to be root to perform this command.']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted',\n            'root privilege',\n            'This command has to be run under the root user.',\n            'This operation requires root.',\n            'You need to be root to perform this command.']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983ccc2e0>, <pydriller.domain.commit.Method object at 0x7f1983ccc2b0>]]",[[]]
thefuck,24ce459f2cac721a08ab4e359119dc5603b03fa3,Add a support for unknown brew commands - #83,2015-04-23 17:06:05+09:00,Namwoo Kim,61,0,61,2,"['test_brew_unknown_command.py', 'brew_unknown_command.py']","[None, None]","[""import pytest\nfrom thefuck.types import Command\nfrom thefuck.rules.brew_unknown_command import match, get_new_command\nfrom thefuck.rules.brew_unknown_command import brew_commands\n\n\n@pytest.fixture\ndef brew_unknown_cmd():\n    return '''Error: Unknown command: inst'''\n\n\n@pytest.fixture\ndef brew_unknown_cmd_instaa():\n    return '''Error: Unknown command: instaa'''\n\n\ndef test_match(brew_unknown_cmd):\n    assert match(Command('brew inst', '', brew_unknown_cmd), None)\n    for command in brew_commands:\n        assert not match(Command('brew ' + command, '', ''), None)\n\n\ndef test_get_new_command(brew_unknown_cmd, brew_unknown_cmd_instaa):\n    assert get_new_command(Command('brew inst', '', brew_unknown_cmd), None)\\\n        == 'brew list'\n\n    assert get_new_command(Command('brew instaa', '', brew_unknown_cmd_instaa),\n                           None) == 'brew install'\n"", ""import difflib\nimport re\nimport thefuck.logs\n\n# This commands are based on Homebrew 0.9.5\nbrew_commands = ['info', 'home', 'options', 'install', 'uninstall', 'search',\n                 'list', 'update', 'upgrade', 'pin', 'unpin', 'doctor',\n                 'create', 'edit']\n\n\ndef _get_similar_commands(command):\n    return difflib.get_close_matches(command, brew_commands)\n\n\ndef match(command, settings):\n    is_proper_command = ('brew' in command.script and\n                         'Unknown command' in command.stderr)\n\n    has_possible_commands = False\n    if is_proper_command:\n        broken_cmd = re.findall(r'Error: Unknown command: ([a-z]+)',\n                                command.stderr)[0]\n        has_possible_commands = len(_get_similar_commands(broken_cmd)) > 0\n\n    return has_possible_commands\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r'Error: Unknown command: ([a-z]+)',\n                            command.stderr)[0]\n    new_cmd = _get_similar_commands(broken_cmd)[0]\n\n    return command.script.replace(broken_cmd, new_cmd, 1)\n""]","[[], []]","[[<pydriller.domain.commit.Method object at 0x7f1983cddbe0>, <pydriller.domain.commit.Method object at 0x7f1983cddeb0>, <pydriller.domain.commit.Method object at 0x7f1983cdd820>, <pydriller.domain.commit.Method object at 0x7f1983cdda90>], [<pydriller.domain.commit.Method object at 0x7f1983d3bd60>, <pydriller.domain.commit.Method object at 0x7f1983d3bc10>, <pydriller.domain.commit.Method object at 0x7f1983d3b430>]]"
thefuck,54b5cd61226994ebd5700fceb2e184ecfdc15f5f,Add a support for brew unavailable formulas,2015-04-23 18:16:36+09:00,Namwoo Kim,92,0,92,2,"['test_brew_install.py', 'brew_install.py']","[None, None]","[""import pytest\nfrom thefuck.types import Command\nfrom thefuck.rules.brew_install import match, get_new_command\nfrom thefuck.rules.brew_install import brew_formulas\n\n\n@pytest.fixture\ndef brew_no_available_formula():\n    return '''Error: No available formula for elsticsearch '''\n\n\n@pytest.fixture\ndef brew_install_no_argument():\n    return '''This command requires a formula argument'''\n\n\n@pytest.fixture\ndef brew_already_installed():\n    return '''Warning: git-2.3.5 already installed'''\n\n\ndef _is_not_okay_to_test():\n    if 'elasticsearch' not in brew_formulas:\n        return True\n    return False\n\n\n@pytest.mark.skipif(_is_not_okay_to_test(),\n                    reason='No need to run if there\\'s no formula')\ndef test_match(brew_no_available_formula, brew_already_installed,\n               brew_install_no_argument):\n    assert match(Command('brew install elsticsearch', '',\n                         brew_no_available_formula), None)\n    assert not match(Command('brew install git', '',\n                             brew_already_installed), None)\n    assert not match(Command('brew install', '', brew_install_no_argument),\n                     None)\n\n\n@pytest.mark.skipif(_is_not_okay_to_test(),\n                    reason='No need to run if there\\'s no formula')\ndef test_get_new_command(brew_no_available_formula):\n    assert get_new_command(Command('brew install elsticsearch', '',\n                                   brew_no_available_formula), None)\\\n        == 'brew install elasticsearch'\n\n    assert get_new_command(Command('brew install aa', '',\n                                   brew_no_available_formula),\n                           None) != 'brew install aha'\n"", ""import difflib\nimport os\nimport re\nfrom subprocess import check_output\n\nimport thefuck.logs\n\n# Formulars are base on each local system's status\nbrew_formulas = []\ntry:\n    brew_path_prefix = check_output(['brew', '--prefix']).strip()\n    brew_formula_path = brew_path_prefix + '/Library/Formula'\n\n    for file_name in os.listdir(brew_formula_path):\n        if file_name.endswith('.rb'):\n            brew_formulas.append(file_name.replace('.rb', ''))\nexcept:\n    pass\n\n\ndef _get_similar_formulars(formula_name):\n    return difflib.get_close_matches(formula_name, brew_formulas, 1, 0.85)\n\n\ndef match(command, settings):\n    is_proper_command = ('brew install' in command.script and\n                         'No available formula' in command.stderr)\n\n    has_possible_formulas = False\n    if is_proper_command:\n        formula = re.findall(r'Error: No available formula for ([a-z]+)',\n                             command.stderr)[0]\n        has_possible_formulas = len(_get_similar_formulars(formula)) > 0\n\n    return has_possible_formulas\n\n\ndef get_new_command(command, settings):\n    not_exist_formula = re.findall(r'Error: No available formula for ([a-z]+)',\n                                   command.stderr)[0]\n    exist_formula = _get_similar_formulars(not_exist_formula)[0]\n\n    return command.script.replace(not_exist_formula, exist_formula, 1)\n""]","[[], []]","[[<pydriller.domain.commit.Method object at 0x7f1983d35430>, <pydriller.domain.commit.Method object at 0x7f1983d35040>, <pydriller.domain.commit.Method object at 0x7f1983d17ac0>, <pydriller.domain.commit.Method object at 0x7f1983d352b0>, <pydriller.domain.commit.Method object at 0x7f1983d17400>, <pydriller.domain.commit.Method object at 0x7f1983d35820>], [<pydriller.domain.commit.Method object at 0x7f1983ce36d0>, <pydriller.domain.commit.Method object at 0x7f1983ce3a90>, <pydriller.domain.commit.Method object at 0x7f1983ce3970>]]"
thefuck,f1cce413b35b4a476568aa090ea1c86aff72f3bb,"Added rule for fixing Alt+Space character

Happens on the Mac a lot when typing a pipe character (Alt+7), and
keeping the Alt key pressed down for a bit too long, so instead of
Space, you're typing Alt+Space. This rule replaces the Alt+Space with a
simple Space character.

$ ps -ef | grep foo
-bash:  grep: command not found
$ fuck
ps -ef | grep foo",2015-04-23 15:19:30+02:00,Nils Winkler,34,0,34,3,"['README.md', 'test_fix_alt_space.py', 'fix_alt_space.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nOr using an OS package manager (currently supported in OSX via [brew](http://brew.sh)):\n\n```bash\nbrew install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck {\n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) {\n        $fuck.substring(5)\n    }\n    else { iex ""$fuck"" }\n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', None, None]","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nOr using an OS package manager (currently supported in OSX via [brew](http://brew.sh)):\n\n```bash\nbrew install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck {\n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) {\n        $fuck.substring(5)\n    }\n    else { iex ""$fuck"" }\n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', '# -*- encoding: utf-8 -*-\n\n\nfrom thefuck.types import Command\nfrom thefuck.rules.fix_alt_space import match, get_new_command\n\n\ndef test_match():\n    """""" The character before \'grep\' is Alt+Space, which happens frequently on the Mac when typing\n        the pipe character (Alt+7), and holding the Alt key pressed for longer than necessary. """"""\n    assert match(Command(u\'ps -ef |\xa0grep foo\', \'\', u\'-bash: \xa0grep: command not found\'), None)\n    assert not match(Command(\'ps -ef | grep foo\', \'\', \'\'), None)\n    assert not match(Command(\'\', \'\', \'\'), None)\n\n\ndef test_get_new_command():\n    """""" Replace the Alt+Space character by a simple space """"""\n    assert get_new_command(Command(u\'ps -ef |\xa0grep foo\', \'\', \'\'), None) == \'ps -ef | grep foo\'\n', ""# -*- encoding: utf-8 -*-\n\nimport re\nfrom thefuck.utils import sudo_support\n\n\n@sudo_support\ndef match(command, settings):\n    return ('command not found' in command.stderr.lower()\n            and u'\xa0' in command.script)\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return re.sub(u'\xa0', ' ', command.script)\n""]","[[], [], []]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d2e6d0>, <pydriller.domain.commit.Method object at 0x7f1983d2e820>], [<pydriller.domain.commit.Method object at 0x7f1983d51430>, <pydriller.domain.commit.Method object at 0x7f1983d51c10>]]"
thefuck,473f5e6a333d89a54813daf5495d68b17490ae8b,Add composer rule,2015-04-23 17:34:34+02:00,Rubén Simón Andreo,64,0,64,2,"['test_composer_not_command.py', 'composer_not_command.py']","[None, None]","['import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.composer_not_command import match, get_new_command\n\n\n@pytest.fixture\ndef composer_not_command():\n    return """"""\n\n                                    \n  [InvalidArgumentException]        \n  Command ""udpate"" is not defined.  \n  Did you mean this?                \n      update\n\n\n""""""\n\n\n@pytest.fixture\ndef composer_not_command_one_of_this():\n    return """"""\n                            \n\n\n  [InvalidArgumentException]       \n  Command ""pdate"" is not defined.  \n  Did you mean one of these?       \n      selfupdate                   \n      self-update                  \n      update                       \n\n\n\n""""""\n\ndef test_match(composer_not_command, composer_not_command_one_of_this):\n    assert match(Command(\'composer udpate\', \'\', composer_not_command), None)\n    assert match(Command(\'composer pdate\', \'\', composer_not_command_one_of_this), None)\n    assert not match(Command(\'ls update\', \'\', composer_not_command), None)\n    #assert not match(Command(\'composer update\', \'\', composer_command), None)\n\n\ndef test_get_new_command(composer_not_command, composer_not_command_one_of_this):\n    assert get_new_command(Command(\'composer udpate\', \'\', composer_not_command), None)\\\n        == \'composer update\'\n    assert get_new_command(\n        Command(\'composer pdate\', \'\', composer_not_command_one_of_this), None) == \'composer selfupdate\'\n', 'import re\n\ndef match(command, settings):\n    return (\'composer\' in command.script\n        and (\n        \t\'did you mean this?\' in command.stderr.lower()\n        \tor \'did you mean one of these?\' in command.stderr.lower()\n        \t)\n        )\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r""Command \\""([^\']*)\\"" is not defined"", command.stderr)[0]\n    new_cmd = re.findall(r\'Did you mean this\\?[^\\n]*\\n\\s*([^\\n]*)\', command.stderr)\n    if not new_cmd:\n    \tnew_cmd = re.findall(r\'Did you mean one of these\\?[^\\n]*\\n\\s*([^\\n]*)\', command.stderr)\n    return command.script.replace(broken_cmd, new_cmd[0].strip(), 1)']","[[], []]","[[<pydriller.domain.commit.Method object at 0x7f1983e422b0>, <pydriller.domain.commit.Method object at 0x7f1983e42e80>, <pydriller.domain.commit.Method object at 0x7f1983d1c040>, <pydriller.domain.commit.Method object at 0x7f1983e42160>], [<pydriller.domain.commit.Method object at 0x7f1983e3c520>, <pydriller.domain.commit.Method object at 0x7f1983e3cfa0>]]"
thefuck,1f96faef2cd530806310478f6e812113ed583874,#116 Fix tests,2015-04-23 21:47:46+02:00,nvbn,9,10,19,2,"['test_composer_not_command.py', 'composer_not_command.py']","['import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.composer_not_command import match, get_new_command\n\n\n@pytest.fixture\ndef composer_not_command():\n    return """"""\n\n                                    \n  [InvalidArgumentException]        \n  Command ""udpate"" is not defined.  \n  Did you mean this?                \n      update\n\n\n""""""\n\n\n@pytest.fixture\ndef composer_not_command_one_of_this():\n    return """"""\n                            \n\n\n  [InvalidArgumentException]       \n  Command ""pdate"" is not defined.  \n  Did you mean one of these?       \n      selfupdate                   \n      self-update                  \n      update                       \n\n\n\n""""""\n\ndef test_match(composer_not_command, composer_not_command_one_of_this):\n    assert match(Command(\'composer udpate\', \'\', composer_not_command), None)\n    assert match(Command(\'composer pdate\', \'\', composer_not_command_one_of_this), None)\n    assert not match(Command(\'ls update\', \'\', composer_not_command), None)\n    #assert not match(Command(\'composer update\', \'\', composer_command), None)\n\n\ndef test_get_new_command(composer_not_command, composer_not_command_one_of_this):\n    assert get_new_command(Command(\'composer udpate\', \'\', composer_not_command), None)\\\n        == \'composer update\'\n    assert get_new_command(\n        Command(\'composer pdate\', \'\', composer_not_command_one_of_this), None) == \'composer selfupdate\'\n', 'import re\n\ndef match(command, settings):\n    return (\'composer\' in command.script\n        and (\n        \t\'did you mean this?\' in command.stderr.lower()\n        \tor \'did you mean one of these?\' in command.stderr.lower()\n        \t)\n        )\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r""Command \\""([^\']*)\\"" is not defined"", command.stderr)[0]\n    new_cmd = re.findall(r\'Did you mean this\\?[^\\n]*\\n\\s*([^\\n]*)\', command.stderr)\n    if not new_cmd:\n    \tnew_cmd = re.findall(r\'Did you mean one of these\\?[^\\n]*\\n\\s*([^\\n]*)\', command.stderr)\n    return command.script.replace(broken_cmd, new_cmd[0].strip(), 1)']","['import pytest\nfrom thefuck.types import Command\nfrom thefuck.rules.composer_not_command import match, get_new_command\n\n\n@pytest.fixture\ndef composer_not_command():\n    return """"""\n\n                                    \n  [InvalidArgumentException]        \n  Command ""udpate"" is not defined.  \n  Did you mean this?                \n      update\n\n\n""""""\n\n\n@pytest.fixture\ndef composer_not_command_one_of_this():\n    return """"""\n                            \n\n\n  [InvalidArgumentException]       \n  Command ""pdate"" is not defined.  \n  Did you mean one of these?       \n      selfupdate                   \n      self-update                  \n      update                       \n\n\n\n""""""\n\n\ndef test_match(composer_not_command, composer_not_command_one_of_this):\n    assert match(Command(\'composer udpate\', \'\', composer_not_command), None)\n    assert match(Command(\'composer pdate\', \'\', composer_not_command_one_of_this), None)\n    assert not match(Command(\'ls update\', \'\', composer_not_command), None)\n\n\ndef test_get_new_command(composer_not_command, composer_not_command_one_of_this):\n    assert get_new_command(Command(\'composer udpate\', \'\', composer_not_command), None) \\\n           == \'composer update\'\n    assert get_new_command(\n        Command(\'composer pdate\', \'\', composer_not_command_one_of_this), None) == \'composer selfupdate\'\n', 'import re\n\n\ndef match(command, settings):\n    return (\'composer\' in command.script\n            and (\'did you mean this?\' in command.stderr.lower()\n                 or \'did you mean one of these?\' in command.stderr.lower()))\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r""Command \\""([^\']*)\\"" is not defined"", command.stderr)[0]\n    new_cmd = re.findall(r\'Did you mean this\\?[^\\n]*\\n\\s*([^\\n]*)\', command.stderr)\n    if not new_cmd:\n        new_cmd = re.findall(r\'Did you mean one of these\\?[^\\n]*\\n\\s*([^\\n]*)\', command.stderr)\n    return command.script.replace(broken_cmd, new_cmd[0].strip(), 1)']","[[<pydriller.domain.commit.Method object at 0x7f1983e17100>, <pydriller.domain.commit.Method object at 0x7f1983e17f70>, <pydriller.domain.commit.Method object at 0x7f1983e17e20>, <pydriller.domain.commit.Method object at 0x7f1983e17910>], [<pydriller.domain.commit.Method object at 0x7f1983d2e430>, <pydriller.domain.commit.Method object at 0x7f1983d2e190>]]","[[<pydriller.domain.commit.Method object at 0x7f1983e42130>], [<pydriller.domain.commit.Method object at 0x7f1983d51550>, <pydriller.domain.commit.Method object at 0x7f1983d512b0>]]"
