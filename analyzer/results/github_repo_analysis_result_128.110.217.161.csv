Project Name,Commit Hash,Message,Commit Date,Author Name,Additions,Deletions,Lines changed,Files Changed,Modified files,Original Code,Modified Code,Methods Before,Methods After
thefuck,71f1f4224b267711bd9cc372a2ec69902f423a01,Initial commit,2015-04-08 18:15:49+02:00,nvbn,362,0,362,11,"['.gitignore', 'README.md', 'requirements.txt', 'setup.cfg', 'setup.py', 'test_git_push.py', 'test_sudo.py', 'test_main.py', 'main.py', 'git_push.py', 'sudo.py']","[None, None, None, None, None, None, None, None, None, None, None]","['# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nenv/\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\n*.egg-info/\n.installed.cfg\n*.egg\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*,cover\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\ntarget/\n\n.env\n.idea\n', ""# The Fuck\n\nMagnificent app which corrects your previous console command.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip3 install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip3 install -r requirements.txt\npython3 setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'pytest\n', '[egg_info]\ntag_build = dev\ntag_svn_revision = true\n', 'from setuptools import setup, find_packages\n\n\nversion = \'1\'\n\nsetup(name=\'thefuck\',\n      version=version,\n      description="""",\n      long_description=""""""\\\n"""""",\n      classifiers=[],  # Get strings from http://pypi.python.org/pypi?%3Aaction=list_classifiers\n      keywords=\'\',\n      author=\'\',\n      author_email=\'\',\n      url=\'\',\n      license=\'\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\n          # -*- Extra requirements: -*-\n      ],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\',\n      ]},\n      )\n', 'import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.git_push import match, get_new_command\n\n\n@pytest.fixture\ndef stderr():\n    return \'\'\'fatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\'\'\'\n\n\ndef test_match(stderr):\n    assert match(Command(\'git push master\', \'\', stderr))\n    assert not match(Command(\'git push master\', \'\', \'\'))\n    assert not match(Command(\'ls\', \'\', stderr))\n\n\ndef test_get_new_command(stderr):\n    assert get_new_command(Command(\'\', \'\', stderr))\\\n        == ""git push --set-upstream origin master""\n', ""from thefuck.main import Command\nfrom thefuck.rules.sudo import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('', '', 'Permission denied'))\n    assert match(Command('', '', 'permission denied'))\n    assert not match(Command('', '', ''))\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('ls', '', '')) == 'sudo ls'\n"", ""from unittest.mock import patch, Mock\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom thefuck import main\n\n\ndef test_setup_user_dir():\n    with patch('thefuck.main.Path.is_dir', return_value=False), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 2\n        assert touch.call_count == 1\n    with patch('thefuck.main.Path.is_dir', return_value=True), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 0\n        assert touch.call_count == 0\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(main.Settings(None), Path('bash.py'))\n    assert main.is_rule_enabled(main.Settings(['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(main.Settings(['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            main.Settings(None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            main.Settings(['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x: x.script == 'cd ..', None),\n             main.Rule(lambda _: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nSettings = namedtuple(\'Settings\', (\'rules\',))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir() -> Path:\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir: Path) -> Settings:\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    return Settings(getattr(settings, \'rules\', None))\n\n\ndef is_rule_enabled(settings: Settings, rule: Path) -> bool:\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule: Path) -> Rule:\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir: Path, settings: Settings) -> [Rule]:\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if is_rule_enabled(settings, rule)]\n\n\ndef get_command(args: [str]) -> Command:\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command: Command, rules: [Rule]) -> Rule:\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command):\n            return rule\n\n\ndef run_rule(rule: Rule, command: Command):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command)\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules)\n    if matched_rule:\n        run_rule(matched_rule, command)\n    else:\n        print(\'echo No fuck given\')\n', ""def match(command):\n    return ('git' in command.script\n            and 'push' in command.script\n            and 'set-upstream' in command.stderr)\n\n\ndef get_new_command(command):\n    return command.stderr.split('\\n')[-3].strip()\n"", ""def match(command):\n    return 'permission denied' in command.stderr.lower()\n\n\ndef get_new_command(command):\n    return 'sudo {}'.format(command.script)\n""]","[[], [], [], [], [], [], [], [], [], [], []]","[[], [], [], [], [], [<pydriller.domain.commit.Method object at 0x7f1983cccc10>, <pydriller.domain.commit.Method object at 0x7f1983cccac0>, <pydriller.domain.commit.Method object at 0x7f1983ccc940>], [<pydriller.domain.commit.Method object at 0x7f1983d45e80>, <pydriller.domain.commit.Method object at 0x7f1983d45fd0>], [<pydriller.domain.commit.Method object at 0x7f1983d452b0>, <pydriller.domain.commit.Method object at 0x7f1983ce9be0>, <pydriller.domain.commit.Method object at 0x7f1983ce9c10>, <pydriller.domain.commit.Method object at 0x7f1983d45400>, <pydriller.domain.commit.Method object at 0x7f1983d452e0>, <pydriller.domain.commit.Method object at 0x7f1983ce9d60>, <pydriller.domain.commit.Method object at 0x7f1983d45160>], [<pydriller.domain.commit.Method object at 0x7f1983cf02e0>, <pydriller.domain.commit.Method object at 0x7f1983ce92e0>, <pydriller.domain.commit.Method object at 0x7f1983cf0970>, <pydriller.domain.commit.Method object at 0x7f1983ce9430>, <pydriller.domain.commit.Method object at 0x7f1983cf0940>, <pydriller.domain.commit.Method object at 0x7f1983ce9190>, <pydriller.domain.commit.Method object at 0x7f1983cf0a90>, <pydriller.domain.commit.Method object at 0x7f1983cf0d60>, <pydriller.domain.commit.Method object at 0x7f1983ce9160>], [<pydriller.domain.commit.Method object at 0x7f1983cdd430>, <pydriller.domain.commit.Method object at 0x7f1983cdd2e0>], [<pydriller.domain.commit.Method object at 0x7f1983cd1400>, <pydriller.domain.commit.Method object at 0x7f1983cd1940>]]"
thefuck,327c3a0cf5647ef6ae7a8fc273f7db70a3c4ee90,Fill setup.py,2015-04-08 18:19:01+02:00,nvbn,7,21,28,2,"['setup.cfg', 'setup.py']","['[egg_info]\ntag_build = dev\ntag_svn_revision = true\n', 'from setuptools import setup, find_packages\n\n\nversion = \'1\'\n\nsetup(name=\'thefuck\',\n      version=version,\n      description="""",\n      long_description=""""""\\\n"""""",\n      classifiers=[],  # Get strings from http://pypi.python.org/pypi?%3Aaction=list_classifiers\n      keywords=\'\',\n      author=\'\',\n      author_email=\'\',\n      url=\'\',\n      license=\'\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\n          # -*- Extra requirements: -*-\n      ],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\',\n      ]},\n      )\n']","[None, 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.0,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","[[], []]","[[], []]"
thefuck,8e5cc9d73a08acafef64848a81fd63cbc89e8490,Add command not found handler,2015-04-08 19:00:03+02:00,nvbn,79,1,80,5,"['README.md', 'setup.py', 'test_no_command.py', 'main.py', 'no_command.py']","[""# The Fuck\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip3 install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip3 install -r requirements.txt\npython3 setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.0,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', None, 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nSettings = namedtuple(\'Settings\', (\'rules\',))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir() -> Path:\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir: Path) -> Settings:\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    return Settings(getattr(settings, \'rules\', None))\n\n\ndef is_rule_enabled(settings: Settings, rule: Path) -> bool:\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule: Path) -> Rule:\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir: Path, settings: Settings) -> [Rule]:\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if is_rule_enabled(settings, rule)]\n\n\ndef get_command(args: [str]) -> Command:\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command: Command, rules: [Rule]) -> Rule:\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command):\n            return rule\n\n\ndef run_rule(rule: Rule, command: Command):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command)\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules)\n    if matched_rule:\n        run_rule(matched_rule, command)\n    else:\n        print(\'echo No fuck given\')\n', None]","[""# The Fuck\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip3 install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip3 install -r requirements.txt\npython3 setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.1,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from unittest.mock import patch\nimport pytest\nfrom subprocess import PIPE\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\ndef test_match(command_found, command_not_found):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''))\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''))\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''))\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n\n\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''))\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', '')) \\\n            == 'sudo apt-get install vim'\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom os import environ\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nSettings = namedtuple(\'Settings\', (\'rules\',))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir() -> Path:\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir: Path) -> Settings:\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    return Settings(getattr(settings, \'rules\', None))\n\n\ndef is_rule_enabled(settings: Settings, rule: Path) -> bool:\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule: Path) -> Rule:\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir: Path, settings: Settings) -> [Rule]:\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if is_rule_enabled(settings, rule)]\n\n\ndef get_command(args: [str]) -> Command:\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command: Command, rules: [Rule]) -> Rule:\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command):\n            return rule\n\n\ndef run_rule(rule: Rule, command: Command):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command)\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules)\n    if matched_rule:\n        run_rule(matched_rule, command)\n    else:\n        print(\'echo No fuck given\')\n', 'from subprocess import Popen, PIPE\nimport re\n\n\ndef _get_output(command):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'/usr/lib/command-not-found {}\'.format(name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\ndef match(command):\n    output = _get_output(command)\n    return ""No command"" in output and ""from package"" in output\n\n\ndef get_new_command(command):\n    output = _get_output(command)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name)\n']","[[], [], [], [<pydriller.domain.commit.Method object at 0x7f1983d35fd0>, <pydriller.domain.commit.Method object at 0x7f1983d35e80>, <pydriller.domain.commit.Method object at 0x7f1983d35eb0>, <pydriller.domain.commit.Method object at 0x7f1983d35d30>, <pydriller.domain.commit.Method object at 0x7f1983d356a0>, <pydriller.domain.commit.Method object at 0x7f1983d356d0>, <pydriller.domain.commit.Method object at 0x7f1983d35550>, <pydriller.domain.commit.Method object at 0x7f1983d35580>, <pydriller.domain.commit.Method object at 0x7f1983d35400>], []]","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983cd76d0>, <pydriller.domain.commit.Method object at 0x7f1983cd7580>, <pydriller.domain.commit.Method object at 0x7f1983d41fd0>, <pydriller.domain.commit.Method object at 0x7f1983cd7400>], [], [<pydriller.domain.commit.Method object at 0x7f1983d2ebe0>, <pydriller.domain.commit.Method object at 0x7f1983d2eeb0>, <pydriller.domain.commit.Method object at 0x7f1983d2ed60>]]"
thefuck,173a4300b40653458614c9fdf73ed740289d7357,Fix sudo after npm errors,2015-04-08 19:16:15+02:00,nvbn,4,2,6,3,"['setup.py', 'test_sudo.py', 'sudo.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.1,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from thefuck.main import Command\nfrom thefuck.rules.sudo import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('', '', 'Permission denied'))\n    assert match(Command('', '', 'permission denied'))\n    assert not match(Command('', '', ''))\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('ls', '', '')) == 'sudo ls'\n"", ""def match(command):\n    return 'permission denied' in command.stderr.lower()\n\n\ndef get_new_command(command):\n    return 'sudo {}'.format(command.script)\n""]","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.2,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', 'from thefuck.main import Command\nfrom thefuck.rules.sudo import match, get_new_command\n\n\ndef test_match():\n    assert match(Command(\'\', \'\', \'Permission denied\'))\n    assert match(Command(\'\', \'\', \'permission denied\'))\n    assert match(Command(\'\', \'\', ""npm ERR! Error: EACCES, unlink""))\n    assert not match(Command(\'\', \'\', \'\'))\n\n\ndef test_get_new_command():\n    assert get_new_command(Command(\'ls\', \'\', \'\')) == \'sudo ls\'\n', ""def match(command):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command):\n    return 'sudo {}'.format(command.script)\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983ce3190>, <pydriller.domain.commit.Method object at 0x7f1983ce3940>], [<pydriller.domain.commit.Method object at 0x7f1983ccca90>, <pydriller.domain.commit.Method object at 0x7f1983ccce80>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d41be0>], [<pydriller.domain.commit.Method object at 0x7f1983ce3040>]]"
thefuck,9ed022d67f451331f4ac3535cd7f4041cf43a863,Pass settings to the rules,2015-04-08 21:08:35+02:00,nvbn,50,47,97,8,"['test_git_push.py', 'test_no_command.py', 'test_sudo.py', 'test_main.py', 'main.py', 'git_push.py', 'no_command.py', 'sudo.py']","['import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.git_push import match, get_new_command\n\n\n@pytest.fixture\ndef stderr():\n    return \'\'\'fatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\'\'\'\n\n\ndef test_match(stderr):\n    assert match(Command(\'git push master\', \'\', stderr))\n    assert not match(Command(\'git push master\', \'\', \'\'))\n    assert not match(Command(\'ls\', \'\', stderr))\n\n\ndef test_get_new_command(stderr):\n    assert get_new_command(Command(\'\', \'\', stderr))\\\n        == ""git push --set-upstream origin master""\n', ""from unittest.mock import patch\nimport pytest\nfrom subprocess import PIPE\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\ndef test_match(command_found, command_not_found):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''))\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''))\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''))\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n\n\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''))\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', '')) \\\n            == 'sudo apt-get install vim'\n"", 'from thefuck.main import Command\nfrom thefuck.rules.sudo import match, get_new_command\n\n\ndef test_match():\n    assert match(Command(\'\', \'\', \'Permission denied\'))\n    assert match(Command(\'\', \'\', \'permission denied\'))\n    assert match(Command(\'\', \'\', ""npm ERR! Error: EACCES, unlink""))\n    assert not match(Command(\'\', \'\', \'\'))\n\n\ndef test_get_new_command():\n    assert get_new_command(Command(\'ls\', \'\', \'\')) == \'sudo ls\'\n', ""from unittest.mock import patch, Mock\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom thefuck import main\n\n\ndef test_setup_user_dir():\n    with patch('thefuck.main.Path.is_dir', return_value=False), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 2\n        assert touch.call_count == 1\n    with patch('thefuck.main.Path.is_dir', return_value=True), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 0\n        assert touch.call_count == 0\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(main.Settings(None), Path('bash.py'))\n    assert main.is_rule_enabled(main.Settings(['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(main.Settings(['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            main.Settings(None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            main.Settings(['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x: x.script == 'cd ..', None),\n             main.Rule(lambda _: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom os import environ\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nSettings = namedtuple(\'Settings\', (\'rules\',))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir() -> Path:\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir: Path) -> Settings:\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    return Settings(getattr(settings, \'rules\', None))\n\n\ndef is_rule_enabled(settings: Settings, rule: Path) -> bool:\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule: Path) -> Rule:\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir: Path, settings: Settings) -> [Rule]:\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if is_rule_enabled(settings, rule)]\n\n\ndef get_command(args: [str]) -> Command:\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command: Command, rules: [Rule]) -> Rule:\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command):\n            return rule\n\n\ndef run_rule(rule: Rule, command: Command):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command)\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules)\n    if matched_rule:\n        run_rule(matched_rule, command)\n    else:\n        print(\'echo No fuck given\')\n', ""def match(command):\n    return ('git' in command.script\n            and 'push' in command.script\n            and 'set-upstream' in command.stderr)\n\n\ndef get_new_command(command):\n    return command.stderr.split('\\n')[-3].strip()\n"", 'from subprocess import Popen, PIPE\nimport re\n\n\ndef _get_output(command):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'/usr/lib/command-not-found {}\'.format(name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\ndef match(command):\n    output = _get_output(command)\n    return ""No command"" in output and ""from package"" in output\n\n\ndef get_new_command(command):\n    output = _get_output(command)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name)\n', ""def match(command):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command):\n    return 'sudo {}'.format(command.script)\n""]","['import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.git_push import match, get_new_command\n\n\n@pytest.fixture\ndef stderr():\n    return \'\'\'fatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\'\'\'\n\n\ndef test_match(stderr):\n    assert match(Command(\'git push master\', \'\', stderr), None)\n    assert not match(Command(\'git push master\', \'\', \'\'), None)\n    assert not match(Command(\'ls\', \'\', stderr), None)\n\n\ndef test_get_new_command(stderr):\n    assert get_new_command(Command(\'\', \'\', stderr), None)\\\n        == ""git push --set-upstream origin master""\n', ""from unittest.mock import patch, Mock\nimport pytest\nfrom subprocess import PIPE\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\ndef test_match(command_found, command_not_found):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), None)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), None)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), None)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), None) \\\n            == 'sudo apt-get install vim'\n"", 'from thefuck.main import Command\nfrom thefuck.rules.sudo import match, get_new_command\n\n\ndef test_match():\n    assert match(Command(\'\', \'\', \'Permission denied\'), None)\n    assert match(Command(\'\', \'\', \'permission denied\'), None)\n    assert match(Command(\'\', \'\', ""npm ERR! Error: EACCES, unlink""), None)\n    assert not match(Command(\'\', \'\', \'\'), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command(\'ls\', \'\', \'\'), None) == \'sudo ls\'\n', ""from unittest.mock import patch, Mock\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom thefuck import main\n\n\ndef test_setup_user_dir():\n    with patch('thefuck.main.Path.is_dir', return_value=False), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 2\n        assert touch.call_count == 1\n    with patch('thefuck.main.Path.is_dir', return_value=True), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 0\n        assert touch.call_count == 0\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda _, _: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir() -> Path:\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir: Path):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule: Path) -> bool:\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule: Path) -> Rule:\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir: Path, settings) -> [Rule]:\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if is_rule_enabled(settings, rule)]\n\n\ndef get_command(args: [str]) -> Command:\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command: Command, rules: [Rule], settings) -> Rule:\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule: Rule, command: Command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules, settings)\n    if matched_rule:\n        run_rule(matched_rule, command, settings)\n    else:\n        print(\'echo No fuck given\')\n', ""def match(command, settings):\n    return ('git' in command.script\n            and 'push' in command.script\n            and 'set-upstream' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return command.stderr.split('\\n')[-3].strip()\n"", 'from subprocess import Popen, PIPE\nimport re\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(getattr(settings, \'command_not_found\',\n                                          \'/usr/lib/command-not-found\'),\n                                  name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\ndef match(command, settings):\n    output = _get_output(command, settings)\n    return ""No command"" in output and ""from package"" in output\n\n\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name)\n', ""def match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983cdd400>, <pydriller.domain.commit.Method object at 0x7f1983cdd550>, <pydriller.domain.commit.Method object at 0x7f1983d28430>], [<pydriller.domain.commit.Method object at 0x7f1983cdd040>, <pydriller.domain.commit.Method object at 0x7f1983cdd2b0>, <pydriller.domain.commit.Method object at 0x7f1983cddd30>, <pydriller.domain.commit.Method object at 0x7f1983cd17f0>], [<pydriller.domain.commit.Method object at 0x7f1983cf07f0>, <pydriller.domain.commit.Method object at 0x7f1983ce92b0>], [<pydriller.domain.commit.Method object at 0x7f1983d45d30>, <pydriller.domain.commit.Method object at 0x7f1983d45550>, <pydriller.domain.commit.Method object at 0x7f1983d456d0>, <pydriller.domain.commit.Method object at 0x7f1983d45580>, <pydriller.domain.commit.Method object at 0x7f1983cd7d30>, <pydriller.domain.commit.Method object at 0x7f1983cd7fd0>, <pydriller.domain.commit.Method object at 0x7f1983cd7be0>], [<pydriller.domain.commit.Method object at 0x7f1983ce37f0>, <pydriller.domain.commit.Method object at 0x7f1983ce3e80>, <pydriller.domain.commit.Method object at 0x7f1983ce3400>, <pydriller.domain.commit.Method object at 0x7f1983d41a90>, <pydriller.domain.commit.Method object at 0x7f1983d41190>, <pydriller.domain.commit.Method object at 0x7f1983d41eb0>, <pydriller.domain.commit.Method object at 0x7f1983d41d30>, <pydriller.domain.commit.Method object at 0x7f1983d3be80>, <pydriller.domain.commit.Method object at 0x7f1983d3b2e0>], [<pydriller.domain.commit.Method object at 0x7f1983d35d60>, <pydriller.domain.commit.Method object at 0x7f1983d35a90>], [<pydriller.domain.commit.Method object at 0x7f1983d17c10>, <pydriller.domain.commit.Method object at 0x7f1983d17d60>, <pydriller.domain.commit.Method object at 0x7f1983d17a90>], [<pydriller.domain.commit.Method object at 0x7f1983d10400>, <pydriller.domain.commit.Method object at 0x7f1983d10550>]]","[[<pydriller.domain.commit.Method object at 0x7f1983cd16a0>, <pydriller.domain.commit.Method object at 0x7f1983cd12e0>], [<pydriller.domain.commit.Method object at 0x7f1983d1cfd0>, <pydriller.domain.commit.Method object at 0x7f1983d1ce80>], [<pydriller.domain.commit.Method object at 0x7f1983d23400>, <pydriller.domain.commit.Method object at 0x7f1983d23190>], [<pydriller.domain.commit.Method object at 0x7f1983d28be0>, <pydriller.domain.commit.Method object at 0x7f1983d28580>, <pydriller.domain.commit.Method object at 0x7f1983d28820>], [<pydriller.domain.commit.Method object at 0x7f1983d41190>, <pydriller.domain.commit.Method object at 0x7f1983ce3d30>, <pydriller.domain.commit.Method object at 0x7f1983ce32e0>, <pydriller.domain.commit.Method object at 0x7f1983ce3430>, <pydriller.domain.commit.Method object at 0x7f1983ccc6d0>, <pydriller.domain.commit.Method object at 0x7f1983ce3820>, <pydriller.domain.commit.Method object at 0x7f1983d3be80>, <pydriller.domain.commit.Method object at 0x7f1983d41d30>, <pydriller.domain.commit.Method object at 0x7f1983ce3400>, <pydriller.domain.commit.Method object at 0x7f1983cccfd0>], [<pydriller.domain.commit.Method object at 0x7f1983d3b550>, <pydriller.domain.commit.Method object at 0x7f1983d3b160>, <pydriller.domain.commit.Method object at 0x7f1983d35d60>, <pydriller.domain.commit.Method object at 0x7f1983d35a90>], [<pydriller.domain.commit.Method object at 0x7f1983d1c580>, <pydriller.domain.commit.Method object at 0x7f1983d17d60>, <pydriller.domain.commit.Method object at 0x7f1983d17c10>, <pydriller.domain.commit.Method object at 0x7f1983d1cd60>, <pydriller.domain.commit.Method object at 0x7f1983d1c550>, <pydriller.domain.commit.Method object at 0x7f1983d17a90>], [<pydriller.domain.commit.Method object at 0x7f1983d10eb0>, <pydriller.domain.commit.Method object at 0x7f1983d10d60>, <pydriller.domain.commit.Method object at 0x7f1983d10400>, <pydriller.domain.commit.Method object at 0x7f1983d10550>]]"
thefuck,e7b377a3105d1b3d59e5e8b4882a325b9909fe21,"Add handler for ""is not a git command""",2015-04-08 21:20:11+02:00,nvbn,55,2,57,5,"['README.md', 'setup.py', 'test_git_not_command.py', 'git_not_command.py', 'no_command.py']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip3 install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip3 install -r requirements.txt\npython3 setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.2,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', None, None, 'from subprocess import Popen, PIPE\nimport re\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(getattr(settings, \'command_not_found\',\n                                          \'/usr/lib/command-not-found\'),\n                                  name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\ndef match(command, settings):\n    output = _get_output(command, settings)\n    return ""No command"" in output and ""from package"" in output\n\n\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name)\n']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\n* master\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip3 install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip3 install -r requirements.txt\npython3 setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.3,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', 'import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.git_not_command import match, get_new_command\n\n\n@pytest.fixture\ndef git_not_command():\n    return """"""git: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\nbranch\n""""""\n\n\n@pytest.fixture\ndef git_command():\n    return ""* master""\n\n\ndef test_match(git_not_command, git_command):\n    assert match(Command(\'git brnch\', \'\', git_not_command), None)\n    assert not match(Command(\'ls brnch\', \'\', git_not_command), None)\n    assert not match(Command(\'git branch\', \'\', git_command), None)\n\n\ndef test_get_new_command(git_not_command):\n    assert get_new_command(Command(\'git brnch\', \'\', git_not_command), None)\\\n        == \'git branch\'\n', 'import re\n\n\ndef match(command, settings):\n    return (\'git\' in command.script\n            and "" is not a git command. See \'git --help\'."" in command.stderr\n            and \'Did you mean this?\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r""git: \'([^\']*)\' is not a git command"",\n                            command.stderr)[0]\n    new_cmd = re.findall(r\'Did you mean this\\?\\n\\s*([^\\n]*)\',\n                         command.stderr)[0]\n    return command.script.replace(broken_cmd, new_cmd, 1)\n\n', 'from subprocess import Popen, PIPE\nimport re\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(getattr(settings, \'command_not_found\',\n                                          \'/usr/lib/command-not-found\'),\n                                  name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\ndef match(command, settings):\n    output = _get_output(command, settings)\n    return ""No command"" in output and ""from package"" in output\n\n\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n']","[[], [], [], [], [<pydriller.domain.commit.Method object at 0x7f1983d85400>, <pydriller.domain.commit.Method object at 0x7f1983d85430>, <pydriller.domain.commit.Method object at 0x7f1983d85970>]]","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983d7fc10>, <pydriller.domain.commit.Method object at 0x7f1983d7fbe0>, <pydriller.domain.commit.Method object at 0x7f1983d7feb0>, <pydriller.domain.commit.Method object at 0x7f1983d7fd60>], [<pydriller.domain.commit.Method object at 0x7f1983d7afd0>, <pydriller.domain.commit.Method object at 0x7f1983d7f190>], [<pydriller.domain.commit.Method object at 0x7f1983d7fa90>]]"
thefuck,282217fd02322229d918682e9152afe79ab43a5a,Fix tests,2015-04-08 21:22:59+02:00,nvbn,1,1,2,1,['test_main.py'],"[""from unittest.mock import patch, Mock\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom thefuck import main\n\n\ndef test_setup_user_dir():\n    with patch('thefuck.main.Path.is_dir', return_value=False), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 2\n        assert touch.call_count == 1\n    with patch('thefuck.main.Path.is_dir', return_value=True), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 0\n        assert touch.call_count == 0\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda _, _: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n""]","[""from unittest.mock import patch, Mock\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom thefuck import main\n\n\ndef test_setup_user_dir():\n    with patch('thefuck.main.Path.is_dir', return_value=False), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 2\n        assert touch.call_count == 1\n    with patch('thefuck.main.Path.is_dir', return_value=True), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 0\n        assert touch.call_count == 0\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983d10e80>, <pydriller.domain.commit.Method object at 0x7f1983d102e0>, <pydriller.domain.commit.Method object at 0x7f1983d10fd0>, <pydriller.domain.commit.Method object at 0x7f1983d10a90>, <pydriller.domain.commit.Method object at 0x7f1983d176a0>, <pydriller.domain.commit.Method object at 0x7f1983d17d30>, <pydriller.domain.commit.Method object at 0x7f1983d17e80>]]",[[<pydriller.domain.commit.Method object at 0x7f1983d102b0>]]
thefuck,2eb777a5bb41527b627ed0826eca3e16890ef83a,Add python 2 support,2015-04-17 16:24:03+02:00,nvbn,19,15,34,9,"['.travis.yml', 'README.md', 'requirements.txt', 'setup.py', 'test_no_command.py', 'test_main.py', '__init__.py', 'main.py', '__init__.py']","['language: python\npython:\n  - ""3.4""\ninstall:\n  - python setup.py develop\n  - pip install -r requirements.txt\nscript: py.test\n', ""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\n* master\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip3 install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip3 install -r requirements.txt\npython3 setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'pytest\n', 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.3,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from unittest.mock import patch, Mock\nimport pytest\nfrom subprocess import PIPE\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\ndef test_match(command_found, command_not_found):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), None)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), None)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), None)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), None) \\\n            == 'sudo apt-get install vim'\n"", ""from unittest.mock import patch, Mock\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom thefuck import main\n\n\ndef test_setup_user_dir():\n    with patch('thefuck.main.Path.is_dir', return_value=False), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 2\n        assert touch.call_count == 1\n    with patch('thefuck.main.Path.is_dir', return_value=True), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 0\n        assert touch.call_count == 0\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", None, 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir() -> Path:\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir: Path):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule: Path) -> bool:\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule: Path) -> Rule:\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir: Path, settings) -> [Rule]:\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if is_rule_enabled(settings, rule)]\n\n\ndef get_command(args: [str]) -> Command:\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command: Command, rules: [Rule], settings) -> Rule:\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule: Rule, command: Command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules, settings)\n    if matched_rule:\n        run_rule(matched_rule, command, settings)\n    else:\n        print(\'echo No fuck given\')\n', None]","['language: python\npython:\n  - ""3.4""\n  - ""3.3""\n  - ""2.7""\ninstall:\n  - python setup.py develop\n  - pip install -r requirements.txt\nscript: py.test\n', ""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\n* master\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'pytest\nmock\n', 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.3,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\ndef test_match(command_found, command_not_found):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), None)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), None)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), None)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), None) \\\n            == 'sudo apt-get install vim'\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_setup_user_dir():\n    with patch('thefuck.main.Path.is_dir', return_value=False), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 2\n        assert touch.call_count == 1\n    with patch('thefuck.main.Path.is_dir', return_value=True), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 0\n        assert touch.call_count == 0\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", None, 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules, settings)\n    if matched_rule:\n        run_rule(matched_rule, command, settings)\n    else:\n        print(\'echo No fuck given\')\n', None]","[[], [], [], [], [<pydriller.domain.commit.Method object at 0x7f1983cd16d0>, <pydriller.domain.commit.Method object at 0x7f1983cd1a90>, <pydriller.domain.commit.Method object at 0x7f1983cd1430>, <pydriller.domain.commit.Method object at 0x7f1983d23820>], [<pydriller.domain.commit.Method object at 0x7f1983cf0160>, <pydriller.domain.commit.Method object at 0x7f1983cf0d30>, <pydriller.domain.commit.Method object at 0x7f1983cf0400>, <pydriller.domain.commit.Method object at 0x7f1983cf0be0>, <pydriller.domain.commit.Method object at 0x7f1983d28190>, <pydriller.domain.commit.Method object at 0x7f1983d282b0>, <pydriller.domain.commit.Method object at 0x7f1983d28160>], [], [<pydriller.domain.commit.Method object at 0x7f1983d45d60>, <pydriller.domain.commit.Method object at 0x7f1983d45ac0>, <pydriller.domain.commit.Method object at 0x7f1983d45940>, <pydriller.domain.commit.Method object at 0x7f1985075fa0>, <pydriller.domain.commit.Method object at 0x7f1983ce3be0>, <pydriller.domain.commit.Method object at 0x7f1983ce36a0>, <pydriller.domain.commit.Method object at 0x7f1983ce3c10>, <pydriller.domain.commit.Method object at 0x7f1983ce3d60>, <pydriller.domain.commit.Method object at 0x7f1983ce3ac0>], []]","[[], [], [], [], [], [], [], [<pydriller.domain.commit.Method object at 0x7f1983cd7190>, <pydriller.domain.commit.Method object at 0x7f1983d41430>, <pydriller.domain.commit.Method object at 0x7f1983d41400>, <pydriller.domain.commit.Method object at 0x7f1983ce3be0>, <pydriller.domain.commit.Method object at 0x7f1983ce3c10>, <pydriller.domain.commit.Method object at 0x7f1983cd7eb0>, <pydriller.domain.commit.Method object at 0x7f1983d45ac0>, <pydriller.domain.commit.Method object at 0x7f1983d41160>, <pydriller.domain.commit.Method object at 0x7f1983ce3d60>, <pydriller.domain.commit.Method object at 0x7f1983d41580>, <pydriller.domain.commit.Method object at 0x7f1985075fa0>, <pydriller.domain.commit.Method object at 0x7f1983cd7940>, <pydriller.domain.commit.Method object at 0x7f1983cd7a90>, <pydriller.domain.commit.Method object at 0x7f1983ce36a0>, <pydriller.domain.commit.Method object at 0x7f1983d45940>], []]"
thefuck,1503dcf294cd59f345b1ded6d24e0691f9414d32,Make `no_command` work only when apt available,2015-04-17 16:36:38+02:00,nvbn,42,9,51,3,"['test_no_command_apt.py', 'no_command_apt.py', 'utils.py']","[""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\ndef test_match(command_found, command_not_found):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), None)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), None)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), None)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), None) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(getattr(settings, \'command_not_found\',\n                                          \'/usr/lib/command-not-found\'),\n                                  name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\ndef match(command, settings):\n    output = _get_output(command, settings)\n    return ""No command"" in output and ""from package"" in output\n\n\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n', None]","[""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command_apt import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command_apt.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_match(command_found, command_not_found):\n    with patch('thefuck.rules.no_command_apt.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), None)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), None)\n\n    with patch('thefuck.rules.no_command_apt.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command_apt._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), None)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), None) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which\n\n\ndef _get_bin(settings):\n    return getattr(settings, \'command_not_found\', \'/usr/lib/command-not-found\')\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(_get_bin(settings), name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\ndef match(command, settings):\n    if which(\'apt-get\') and which(_get_bin(settings)):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n', 'import os\n\n\ndef which(program):\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n']","[[<pydriller.domain.commit.Method object at 0x7f1983d17be0>, <pydriller.domain.commit.Method object at 0x7f1983d17970>, <pydriller.domain.commit.Method object at 0x7f1983d172e0>, <pydriller.domain.commit.Method object at 0x7f1983d17190>], [<pydriller.domain.commit.Method object at 0x7f1983d7ffd0>, <pydriller.domain.commit.Method object at 0x7f1983d7f820>, <pydriller.domain.commit.Method object at 0x7f1983d7fe80>], []]","[[<pydriller.domain.commit.Method object at 0x7f1983cf0580>, <pydriller.domain.commit.Method object at 0x7f1983d1c2e0>, <pydriller.domain.commit.Method object at 0x7f1983d10be0>], [<pydriller.domain.commit.Method object at 0x7f1983d0bd60>, <pydriller.domain.commit.Method object at 0x7f1983d0b190>, <pydriller.domain.commit.Method object at 0x7f1983d0b940>], [<pydriller.domain.commit.Method object at 0x7f1983d85160>, <pydriller.domain.commit.Method object at 0x7f1983d85820>]]"
thefuck,1de9c5f77b4eab61f55d421e8baee07c0dc6f88d,"Add information about writting yourself rules, revert no_command changes",2015-04-17 17:01:30+02:00,nvbn,82,16,98,5,"['README.md', 'setup.py', 'test_no_command.py', 'no_command.py', 'utils.py']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\n* master\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.3,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command_apt import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command_apt.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_match(command_found, command_not_found):\n    with patch('thefuck.rules.no_command_apt.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), None)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), None)\n\n    with patch('thefuck.rules.no_command_apt.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command_apt._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), None)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), None) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which\n\n\ndef _get_bin(settings):\n    return getattr(settings, \'command_not_found\', \'/usr/lib/command-not-found\')\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(_get_bin(settings), name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\ndef match(command, settings):\n    if which(\'apt-get\') and which(_get_bin(settings)):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n', 'import os\n\n\ndef which(program):\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\n* master\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` have three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules]((https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py)).\n\n## Settings\n\nThe Fuck have a few settings parameters:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.4,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_match(command_found, command_not_found, settings):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), settings)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), settings)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), settings)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), settings) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n', 'from functools import wraps\nimport os\n\n\ndef which(program):\n    """"""Returns `program` path or `None`.""""""\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef wrap_settings(params):\n    """"""Adds default values to settings if it not presented.\n\n    Usage:\n\n        @wrap_settings({\'apt\': \'/usr/bin/apt\'})\n        def match(command, settings):\n            print(settings.apt)\n\n    """"""\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(command, settings):\n            for key, val in params.items():\n                if not hasattr(settings, key):\n                    setattr(settings, key, val)\n            return fn(command, settings)\n        return wrapper\n    return decorator\n']","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983d67eb0>, <pydriller.domain.commit.Method object at 0x7f1983d67940>, <pydriller.domain.commit.Method object at 0x7f1983d67d30>, <pydriller.domain.commit.Method object at 0x7f1983d67fd0>, <pydriller.domain.commit.Method object at 0x7f1983d6e550>], [<pydriller.domain.commit.Method object at 0x7f1983d85d30>, <pydriller.domain.commit.Method object at 0x7f1983d85040>, <pydriller.domain.commit.Method object at 0x7f1983d856a0>, <pydriller.domain.commit.Method object at 0x7f1983d7f940>], [<pydriller.domain.commit.Method object at 0x7f1983d106a0>, <pydriller.domain.commit.Method object at 0x7f1983d10190>]]","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983d67160>, <pydriller.domain.commit.Method object at 0x7f1983d67fd0>, <pydriller.domain.commit.Method object at 0x7f1983d67400>, <pydriller.domain.commit.Method object at 0x7f1983d676d0>, <pydriller.domain.commit.Method object at 0x7f1983d672b0>], [<pydriller.domain.commit.Method object at 0x7f1983d85d30>, <pydriller.domain.commit.Method object at 0x7f1983d74be0>, <pydriller.domain.commit.Method object at 0x7f1983d74400>], [<pydriller.domain.commit.Method object at 0x7f1983d0b550>, <pydriller.domain.commit.Method object at 0x7f1983d0b7f0>, <pydriller.domain.commit.Method object at 0x7f1983d0b2b0>, <pydriller.domain.commit.Method object at 0x7f1983d0bd30>]]"
thefuck,11cbb9e1f7c0009b9272426bf2c0f1b481a2dc3e,Print out the fucking command before running it,2015-04-17 16:07:50-04:00,Ford Hurley,6,1,7,2,"['README.md', 'main.py']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\n* master\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` have three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck have a few settings parameters:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules, settings)\n    if matched_rule:\n        run_rule(matched_rule, command, settings)\n    else:\n        print(\'echo No fuck given\')\n']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` have three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck have a few settings parameters:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules, settings)\n    if matched_rule:\n        run_rule(matched_rule, command, settings)\n    else:\n        print(\'echo No fuck given\')\n']","[[], [<pydriller.domain.commit.Method object at 0x7f1983d2eac0>, <pydriller.domain.commit.Method object at 0x7f1983d2ee80>, <pydriller.domain.commit.Method object at 0x7f1983d2ed30>, <pydriller.domain.commit.Method object at 0x7f1983d2e970>, <pydriller.domain.commit.Method object at 0x7f1983d1c7f0>, <pydriller.domain.commit.Method object at 0x7f1983d1c820>, <pydriller.domain.commit.Method object at 0x7f1983d1c940>, <pydriller.domain.commit.Method object at 0x7f1983d1c970>, <pydriller.domain.commit.Method object at 0x7f1983d1cac0>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983ce96a0>]]"
thefuck,48831fa850307d79b786076195ece1d387a4db5f,#1 Don't fuck twice,2015-04-17 22:09:46+02:00,nvbn,16,8,24,2,"['setup.py', 'main.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.4,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules, settings)\n    if matched_rule:\n        run_rule(matched_rule, command, settings)\n    else:\n        print(\'echo No fuck given\')\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.5,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    command = get_command(sys.argv)\n    if is_second_run(command):\n        print(""echo Can\'t fuck twice"")\n    else:\n        user_dir = setup_user_dir()\n        settings = get_settings(user_dir)\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n        else:\n            print(\'echo No fuck given\')\n']","[[], [<pydriller.domain.commit.Method object at 0x7f1983d562e0>, <pydriller.domain.commit.Method object at 0x7f1983d56430>, <pydriller.domain.commit.Method object at 0x7f1983d56160>, <pydriller.domain.commit.Method object at 0x7f1983d56190>, <pydriller.domain.commit.Method object at 0x7f1983d51ac0>, <pydriller.domain.commit.Method object at 0x7f1983d51940>, <pydriller.domain.commit.Method object at 0x7f1983d51970>, <pydriller.domain.commit.Method object at 0x7f1983d517f0>, <pydriller.domain.commit.Method object at 0x7f1983d51820>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d56ac0>, <pydriller.domain.commit.Method object at 0x7f1983d56940>]]"
thefuck,99e418f852f5e6e5269cbe31cf6e7329feba379c,Added rule for misspelled cd.. command,2015-04-17 22:14:01+02:00,Lars Michelsen,14,0,14,1,['cd_parent.py'],[None],"[""# Adds the missing space between the cd command and the target directory\n# when trying to cd to the parent directory.\n#\n# Does not really save chars, but is fun :D\n#\n# Example:\n# > cd..\n# cd..: command not found\n\ndef match(command, settings):\n    return command.script == 'cd..'\n\ndef get_new_command(command, settings):\n    return 'cd ..'\n""]",[[]],"[[<pydriller.domain.commit.Method object at 0x7f1983d56d60>, <pydriller.domain.commit.Method object at 0x7f1983d516a0>]]"
thefuck,2e91158091a9deb506fc369d46ca7f34119371f2,Fixed UnicodeDecodeError,2015-04-17 16:30:46-04:00,Alex Nastetsky,2,2,4,1,['main.py'],"['from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    command = get_command(sys.argv)\n    if is_second_run(command):\n        print(""echo Can\'t fuck twice"")\n    else:\n        user_dir = setup_user_dir()\n        settings = get_settings(user_dir)\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n        else:\n            print(\'echo No fuck given\')\n']","['from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(\'utf-8\'),\n                   result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    command = get_command(sys.argv)\n    if is_second_run(command):\n        print(""echo Can\'t fuck twice"")\n    else:\n        user_dir = setup_user_dir()\n        settings = get_settings(user_dir)\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n        else:\n            print(\'echo No fuck given\')\n']","[[<pydriller.domain.commit.Method object at 0x7f1983d62400>, <pydriller.domain.commit.Method object at 0x7f1983d622b0>, <pydriller.domain.commit.Method object at 0x7f1983d28c10>, <pydriller.domain.commit.Method object at 0x7f1983d28940>, <pydriller.domain.commit.Method object at 0x7f1983d7a820>, <pydriller.domain.commit.Method object at 0x7f1983d7a7f0>, <pydriller.domain.commit.Method object at 0x7f1983d7a970>, <pydriller.domain.commit.Method object at 0x7f1983d7aeb0>, <pydriller.domain.commit.Method object at 0x7f1983d7a2e0>, <pydriller.domain.commit.Method object at 0x7f1983d7aac0>]]",[[<pydriller.domain.commit.Method object at 0x7f1983d62580>]]
thefuck,73a893dc749a9430d2976c7350b7843943411d8f,Bump version,2015-04-17 22:31:10+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.5,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.6,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,bfbb8cd7d0ce90efb4178dcd0b6fda44d1a162af,Bump version,2015-04-17 22:42:18+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.6,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.7,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,14f0817a9920196019990eb5f079d23d43059494,added support for FreeBSD/PCBSD 'pkg' to sudo rule,2015-04-18 08:45:48+02:00,tpltnt,2,1,3,1,['sudo.py'],"[""def match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[""def match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr\n            or 'pkg: Insufficient privileges' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983d67d60>, <pydriller.domain.commit.Method object at 0x7f1983d67970>]]",[[<pydriller.domain.commit.Method object at 0x7f1983d74970>]]
thefuck,de343b84c1a58831fd711b1d70405aa574ae180a,improve no_command rule,2015-04-18 10:52:00-05:00,Jon Mason,22,7,29,2,"['test_no_command.py', 'no_command.py']","[""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_match(command_found, command_not_found, settings):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), settings)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), settings)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), settings)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), settings) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n']","[""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_match(command_found, command_not_found, settings):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), settings)\n        Popen.assert_called_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), settings)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), settings)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), settings) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\ndef _count_history_uses(name):\n    script = \'history | grep {}\'.format(name)\n    result = Popen(script, shell=True, stdout=PIPE)\n    return len(list(result.stdout))\n\ndef _get_candidate_commands(command, settings):\n    output = _get_output(command, settings)\n    if ""No command"" in output and ""from package"" in output:\n        fixed_names = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)\n        return filter(which, fixed_names)\n    return []\n        \n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return len(_get_candidate_commands(command, settings)) != 0\n\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    candidates = _get_candidate_commands(command, settings)\n    fixed_name = sorted(candidates, key=_count_history_uses)[0]\n    return command.script.replace(broken_name, fixed_name)\n     \n']","[[<pydriller.domain.commit.Method object at 0x7f1983dc5940>, <pydriller.domain.commit.Method object at 0x7f1983dc5a90>, <pydriller.domain.commit.Method object at 0x7f1983dc5970>, <pydriller.domain.commit.Method object at 0x7f1983dc57f0>, <pydriller.domain.commit.Method object at 0x7f1983dc5430>, <pydriller.domain.commit.Method object at 0x7f1983dc52b0>], [<pydriller.domain.commit.Method object at 0x7f1983db9fd0>, <pydriller.domain.commit.Method object at 0x7f1983db9e80>, <pydriller.domain.commit.Method object at 0x7f1983db9eb0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983d4a820>], [<pydriller.domain.commit.Method object at 0x7f1983dbe6d0>, <pydriller.domain.commit.Method object at 0x7f1983dbea90>, <pydriller.domain.commit.Method object at 0x7f1983dbed60>, <pydriller.domain.commit.Method object at 0x7f1983dbeac0>]]"
thefuck,34015ef27c59189d3c1191440c245188dc90741d,make sudo rule work with pacman,2015-04-18 15:16:15-04:00,Viktor Stanchev,1,0,1,1,['sudo.py'],"[""def match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr\n            or 'pkg: Insufficient privileges' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[""def match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr\n            or 'error: you cannot perform this operation unless you are root.' in command.stderr\n            or 'pkg: Insufficient privileges' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983d4aa90>, <pydriller.domain.commit.Method object at 0x7f1983d4a940>]]",[[<pydriller.domain.commit.Method object at 0x7f1983dc5400>]]
thefuck,9518416a2faf52c17d910726d4186068c50e96fd,#17 Fix creating configuration files/dirs,2015-04-18 21:16:49+02:00,nvbn,5,20,25,3,"['setup.py', 'test_main.py', 'main.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.7,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_setup_user_dir():\n    with patch('thefuck.main.Path.is_dir', return_value=False), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 2\n        assert touch.call_count == 1\n    with patch('thefuck.main.Path.is_dir', return_value=True), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 0\n        assert touch.call_count == 0\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(\'utf-8\'),\n                   result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    command = get_command(sys.argv)\n    if is_second_run(command):\n        print(""echo Can\'t fuck twice"")\n    else:\n        user_dir = setup_user_dir()\n        settings = get_settings(user_dir)\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n        else:\n            print(\'echo No fuck given\')\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.8,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(\'utf-8\'),\n                   result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    command = get_command(sys.argv)\n    if is_second_run(command):\n        print(""echo Can\'t fuck twice"")\n    else:\n        user_dir = setup_user_dir()\n        settings = get_settings(user_dir)\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n        else:\n            print(\'echo No fuck given\')\n']","[[], [<pydriller.domain.commit.Method object at 0x7f1983ccc190>, <pydriller.domain.commit.Method object at 0x7f1983cccd60>, <pydriller.domain.commit.Method object at 0x7f1983ccc580>, <pydriller.domain.commit.Method object at 0x7f1983ccc430>, <pydriller.domain.commit.Method object at 0x7f1983ce9eb0>, <pydriller.domain.commit.Method object at 0x7f1983ce9580>, <pydriller.domain.commit.Method object at 0x7f1983ce9820>], [<pydriller.domain.commit.Method object at 0x7f1983d286a0>, <pydriller.domain.commit.Method object at 0x7f1983d28040>, <pydriller.domain.commit.Method object at 0x7f1983d286d0>, <pydriller.domain.commit.Method object at 0x7f1983d28d30>, <pydriller.domain.commit.Method object at 0x7f1983d5c820>, <pydriller.domain.commit.Method object at 0x7f1983d5c430>, <pydriller.domain.commit.Method object at 0x7f1983d5cc10>, <pydriller.domain.commit.Method object at 0x7f1983d5c940>, <pydriller.domain.commit.Method object at 0x7f1983d5cd60>, <pydriller.domain.commit.Method object at 0x7f1983d5cac0>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983ccc190>], [<pydriller.domain.commit.Method object at 0x7f1983d232b0>]]"
thefuck,235b31e176405cf8f58349580def4db198251909,#22 Get stderr and stdout with `LANG=C`,2015-04-18 21:27:43+02:00,nvbn,8,3,11,2,"['test_main.py', 'main.py']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(\'utf-8\'),\n                   result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    command = get_command(sys.argv)\n    if is_second_run(command):\n        print(""echo Can\'t fuck twice"")\n    else:\n        user_dir = setup_user_dir()\n        settings = get_settings(user_dir)\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n        else:\n            print(\'echo No fuck given\')\n']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen,\\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    return Command(script, result.stdout.read().decode(\'utf-8\'),\n                   result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    command = get_command(sys.argv)\n    if is_second_run(command):\n        print(""echo Can\'t fuck twice"")\n    else:\n        user_dir = setup_user_dir()\n        settings = get_settings(user_dir)\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n        else:\n            print(\'echo No fuck given\')\n']","[[<pydriller.domain.commit.Method object at 0x7f1983d5c550>, <pydriller.domain.commit.Method object at 0x7f1983d5c6a0>, <pydriller.domain.commit.Method object at 0x7f1983d5cbe0>, <pydriller.domain.commit.Method object at 0x7f1983d5ca90>, <pydriller.domain.commit.Method object at 0x7f1983db9c10>, <pydriller.domain.commit.Method object at 0x7f1983db96d0>], [<pydriller.domain.commit.Method object at 0x7f1983db9a90>, <pydriller.domain.commit.Method object at 0x7f1983db9ac0>, <pydriller.domain.commit.Method object at 0x7f1983db96a0>, <pydriller.domain.commit.Method object at 0x7f1983db9d60>, <pydriller.domain.commit.Method object at 0x7f1983db9be0>, <pydriller.domain.commit.Method object at 0x7f1983d41550>, <pydriller.domain.commit.Method object at 0x7f1983cf0ac0>, <pydriller.domain.commit.Method object at 0x7f1983d566d0>, <pydriller.domain.commit.Method object at 0x7f1983d56e80>, <pydriller.domain.commit.Method object at 0x7f1983d56fd0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983d56a90>], [<pydriller.domain.commit.Method object at 0x7f1983db1550>]]"
thefuck,b0d353c699df50c0a40d21d1d0a708046af6bb9c,#22 Simplify adding patterns for the `sudo` rule,2015-04-18 21:30:48+02:00,nvbn,11,4,15,2,"['setup.py', 'sudo.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.8,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""def match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr\n            or 'pkg: Insufficient privileges' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.9,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d1cc10>, <pydriller.domain.commit.Method object at 0x7f1983d1c6d0>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d5c2b0>]]"
thefuck,a84671dd3b7505d4d73f11ee9c7d057429542e24,#20 Fix `UnicodeDecodeError` in `no_command`,2015-04-18 21:46:17+02:00,nvbn,2,2,4,2,"['setup.py', 'no_command.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.9,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.10,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode(\'utf-8\')\n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n']","[[], [<pydriller.domain.commit.Method object at 0x7f1983d74c10>, <pydriller.domain.commit.Method object at 0x7f1983d74ac0>, <pydriller.domain.commit.Method object at 0x7f1983d74a90>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d7f6a0>]]"
thefuck,e745f3d4a95ad8c8479955a45e624c1081ff2c86,#21 Add timeout for getting previous command output,2015-04-18 22:50:18+02:00,nvbn,50,22,72,4,"['README.md', 'setup.py', 'test_main.py', 'main.py']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_intall thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n# You can use wahtever you want for as an alias, like for mondays:\nalias FUCK='fuck'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions.  \n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` have three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck have a few settings parameters:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.10,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen,\\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    return Command(script, result.stdout.read().decode(\'utf-8\'),\n                   result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    command = get_command(sys.argv)\n    if is_second_run(command):\n        print(""echo Can\'t fuck twice"")\n    else:\n        user_dir = setup_user_dir()\n        settings = get_settings(user_dir)\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n        else:\n            print(\'echo No fuck given\')\n']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_intall thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n# You can use wahtever you want for as an alias, like for mondays:\nalias FUCK='fuck'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions.  \n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` have three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck have a few settings parameters:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.11,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983da8190>, <pydriller.domain.commit.Method object at 0x7f1983da82e0>, <pydriller.domain.commit.Method object at 0x7f1983da8040>, <pydriller.domain.commit.Method object at 0x7f1983da1fd0>, <pydriller.domain.commit.Method object at 0x7f1983da1a90>, <pydriller.domain.commit.Method object at 0x7f1983da1ac0>], [<pydriller.domain.commit.Method object at 0x7f1983da1c10>, <pydriller.domain.commit.Method object at 0x7f1983da1d60>, <pydriller.domain.commit.Method object at 0x7f19867bfd90>, <pydriller.domain.commit.Method object at 0x7f1983da8160>, <pydriller.domain.commit.Method object at 0x7f1983da8c10>, <pydriller.domain.commit.Method object at 0x7f1983da8a90>, <pydriller.domain.commit.Method object at 0x7f1983da8ac0>, <pydriller.domain.commit.Method object at 0x7f1983da8940>, <pydriller.domain.commit.Method object at 0x7f1983dac190>, <pydriller.domain.commit.Method object at 0x7f1983dac040>]]","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983da8d30>, <pydriller.domain.commit.Method object at 0x7f1983da8970>], [<pydriller.domain.commit.Method object at 0x7f1983da8a90>, <pydriller.domain.commit.Method object at 0x7f1983d9c970>, <pydriller.domain.commit.Method object at 0x7f1983d9c7f0>, <pydriller.domain.commit.Method object at 0x7f1983da1580>, <pydriller.domain.commit.Method object at 0x7f1983da1400>]]"
thefuck,8b2ba5762c6fa3ef9b40d1624d4c76accb40bfb1,"Add support of `lein` ""is not task""",2015-04-18 23:19:34+02:00,nvbn,49,1,50,4,"['README.md', 'setup.py', 'test_lein_not_task.py', 'lein_not_task.py']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_intall thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK='fuck'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions.  \n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` have three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck have a few settings parameters:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.11,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', None, None]","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n\n➜ lein rpl\n'rpl' is not a task. See 'lein help'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_intall thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK='fuck'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions.  \n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` have three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck have a few settings parameters:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.12,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""import pytest\nfrom mock import Mock\nfrom thefuck.rules.lein_not_task import match, get_new_command\n\n\n@pytest.fixture\ndef is_not_task():\n    return ''''rpl' is not a task. See 'lein help'.\n\nDid you mean this?\n         repl\n'''\n\n\ndef test_match(is_not_task):\n    assert match(Mock(script='lein rpl', stderr=is_not_task), None)\n    assert not match(Mock(script='ls', stderr=is_not_task), None)\n\n\ndef test_get_new_command(is_not_task):\n    assert get_new_command(Mock(script='lein rpl --help', stderr=is_not_task),\n                           None) == 'lein repl --help'\n"", 'import re\n\n\ndef match(command, settings):\n    return (command.script.startswith(\'lein\')\n            and ""is not a task. See \'lein help\'"" in command.stderr\n            and \'Did you mean this?\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r""\'([^\']*)\' is not a task"",\n                            command.stderr)[0]\n    new_cmd = re.findall(r\'Did you mean this\\?\\n\\s*([^\\n]*)\',\n                         command.stderr)[0]\n    return command.script.replace(broken_cmd, new_cmd, 1)\n']","[[], [], [], []]","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983d677f0>, <pydriller.domain.commit.Method object at 0x7f1983d67ac0>, <pydriller.domain.commit.Method object at 0x7f1983d67e80>], [<pydriller.domain.commit.Method object at 0x7f1983d747f0>, <pydriller.domain.commit.Method object at 0x7f1983d74820>]]"
thefuck,ac545c6f0ae6012460b4bcc45e37ad604ee60b7e,"improve no_comamnd rule, test it",2015-04-18 16:32:50-05:00,Jon Mason,44,8,52,2,"['test_no_command.py', 'no_command.py']","[""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_match(command_found, command_not_found, settings):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), settings)\n        Popen.assert_called_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), settings)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), settings)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), settings) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\ndef _count_history_uses(name):\n    script = \'history | grep {}\'.format(name)\n    result = Popen(script, shell=True, stdout=PIPE)\n    return len(list(result.stdout))\n\ndef _get_candidate_commands(command, settings):\n    output = _get_output(command, settings)\n    if ""No command"" in output and ""from package"" in output:\n        fixed_names = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)\n        return filter(which, fixed_names)\n    return []\n        \n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return len(_get_candidate_commands(command, settings)) != 0\n\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    candidates = _get_candidate_commands(command, settings)\n    fixed_name = sorted(candidates, key=_count_history_uses)[0]\n    return command.script.replace(broken_name, fixed_name)\n     \n']","['from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b\'\'\'No command \'aptget\' found, did you mean:\n Command \'apt-get\' from package \'apt\' (main)\n Command \'not-installed\' from package \'derp\' (main)\n Command \'not-really-used\' from package \'whatever\' (main)\naptget: command not found\n\'\'\'\n\n@pytest.fixture\ndef uninstalled_command_found():\n    return b\'\'\'No command \'pish\' found, did you mean:\n Command \'vish\' from package \'vish\' (universe)\n Command \'wish\' from package \'tk\' (main)\n Command \'fish\' from package \'fish\' (universe)\n Command \'pdsh\' from package \'pdsh\' (universe)\npish: command not found\n\'\'\'\n\n@pytest.fixture\ndef command_not_found():\n    return b\'\'\'No command \'vom\' found, but there are 19 similar ones\nvom: command not found\n\'\'\'\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch(\'thefuck.rules.no_command.which\',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n@pytest.fixture\ndef bin_might_exist(request):\n    def side_effect(name):\n        return name in [\'not-really-used\', \'apt-get\', \'/usr/lib/command-not-found\', \'test\']\n    p = patch(\'thefuck.rules.no_command.which\',\n              side_effect = side_effect)\n    p.start()\n    request.addfinalizer(p.stop)\n            \n\n@pytest.fixture\ndef patch_history(request):\n    def side_effect(name):\n        print(""history(\'{}\')"".format(name))\n        count = 2 if name == \'not-really-used\' else 12\n    p = patch(\'thefuck.rules.no_command._count_history_uses\',\n              side_effect = side_effect)\n    p.start()\n    request.addfinalizer(p.stop)\n    \n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures(\'bin_might_exist\', \'patch_history\')\ndef test_match(command_found, command_not_found, uninstalled_command_found, settings):\n    with patch(\'thefuck.rules.no_command.Popen\') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command(\'aptget install vim\', \'\', \'\'), settings)\n        Popen.assert_called_with(\'/usr/lib/command-not-found aptget\',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command(\'ls\', \'\', \'\'), settings)\n\n    with patch(\'thefuck.rules.no_command.Popen\') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command(\'sudo aptget install vim\', \'\', \'\'),\n                     Mock(command_not_found=\'test\'))\n        Popen.assert_called_with(\'test aptget\',\n                                      shell=True, stderr=PIPE)\n\n    with patch(\'thefuck.rules.no_command.Popen\') as Popen:\n        Popen.return_value.stderr.read.return_value = uninstalled_command_found\n        assert not match(Command(\'pish bla blah\', \'\', \'\'), settings)\n\n@pytest.mark.usefixtures(\'bin_might_exist\', \'patch_history\')\ndef test_get_new_command(command_found):\n    with patch(\'thefuck.rules.no_command._get_output\',\n               return_value=command_found.decode()):\n        assert get_new_command(Command(\'aptget install vim\', \'\', \'\'), settings)\\\n            == \'apt-get install vim\'\n        assert get_new_command(Command(\'sudo aptget install vim\', \'\', \'\'), settings) \\\n            == \'sudo apt-get install vim\'\n', 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\ndef _count_history_uses(name):\n    script = ""history | egrep \'\\\\b{}\\\\b\' | wc -l"".format(name)\n    result = Popen(script, shell=True,\n                   stdout=PIPE)\n    return int(result.stdout.read())\n\ndef _get_candidate_commands(command, settings):\n    output = _get_output(command, settings)\n    if ""No command"" in output and ""from package"" in output:\n        fixed_names = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)\n        return filter(which, fixed_names)\n    return []\n        \n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return len(_get_candidate_commands(command, settings)) != 0\n\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    candidates = _get_candidate_commands(command, settings)\n    fixed_name = sorted(candidates, key=_count_history_uses, reverse=True)[0]\n    return command.script.replace(broken_name, fixed_name)\n     \n']","[[<pydriller.domain.commit.Method object at 0x7f1983d5c7f0>, <pydriller.domain.commit.Method object at 0x7f1983d5c190>, <pydriller.domain.commit.Method object at 0x7f1983d5c040>, <pydriller.domain.commit.Method object at 0x7f1983d5ceb0>, <pydriller.domain.commit.Method object at 0x7f1983cdd160>, <pydriller.domain.commit.Method object at 0x7f1983cdd6a0>], [<pydriller.domain.commit.Method object at 0x7f1983db1580>, <pydriller.domain.commit.Method object at 0x7f1983db1430>, <pydriller.domain.commit.Method object at 0x7f1983db1d30>, <pydriller.domain.commit.Method object at 0x7f1983db1e80>, <pydriller.domain.commit.Method object at 0x7f1983d9c820>]]","[[<pydriller.domain.commit.Method object at 0x7f1983d0bbe0>, <pydriller.domain.commit.Method object at 0x7f1983d0beb0>, <pydriller.domain.commit.Method object at 0x7f1983ce32b0>, <pydriller.domain.commit.Method object at 0x7f1983d0ba90>, <pydriller.domain.commit.Method object at 0x7f1983d0b160>, <pydriller.domain.commit.Method object at 0x7f1983d74580>, <pydriller.domain.commit.Method object at 0x7f1983d0b400>, <pydriller.domain.commit.Method object at 0x7f1983cdd160>], [<pydriller.domain.commit.Method object at 0x7f1983d56820>, <pydriller.domain.commit.Method object at 0x7f1983d62040>]]"
thefuck,8a2bc75e555cec399f02f51fcc04e0f4a88f8bdb,make it python 3 friendly,2015-04-18 16:46:02-05:00,Jon Mason,1,1,2,1,['no_command.py'],"['from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\ndef _count_history_uses(name):\n    script = ""history | egrep \'\\\\b{}\\\\b\' | wc -l"".format(name)\n    result = Popen(script, shell=True,\n                   stdout=PIPE)\n    return int(result.stdout.read())\n\ndef _get_candidate_commands(command, settings):\n    output = _get_output(command, settings)\n    if ""No command"" in output and ""from package"" in output:\n        fixed_names = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)\n        return filter(which, fixed_names)\n    return []\n        \n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return len(_get_candidate_commands(command, settings)) != 0\n\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    candidates = _get_candidate_commands(command, settings)\n    fixed_name = sorted(candidates, key=_count_history_uses, reverse=True)[0]\n    return command.script.replace(broken_name, fixed_name)\n     \n']","['from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\ndef _count_history_uses(name):\n    script = ""history | egrep \'\\\\b{}\\\\b\' | wc -l"".format(name)\n    result = Popen(script, shell=True,\n                   stdout=PIPE)\n    return int(result.stdout.read())\n\ndef _get_candidate_commands(command, settings):\n    output = _get_output(command, settings)\n    if ""No command"" in output and ""from package"" in output:\n        fixed_names = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)\n        return [name for name in fixed_names if which(name)]\n    return []\n        \n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return len(_get_candidate_commands(command, settings)) != 0\n\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    candidates = _get_candidate_commands(command, settings)\n    fixed_name = sorted(candidates, key=_count_history_uses, reverse=True)[0]\n    return command.script.replace(broken_name, fixed_name)\n     \n']","[[<pydriller.domain.commit.Method object at 0x7f1983d95550>, <pydriller.domain.commit.Method object at 0x7f1983d95ac0>, <pydriller.domain.commit.Method object at 0x7f1983d952e0>, <pydriller.domain.commit.Method object at 0x7f1983d95190>, <pydriller.domain.commit.Method object at 0x7f1983d90d60>]]",[[<pydriller.domain.commit.Method object at 0x7f1983d95940>]]
thefuck,cc1a69fb6526a6b9d0e3bcab3825496eded350d3,another oopsie that was revealed in python3,2015-04-18 16:49:26-05:00,Jon Mason,1,2,3,1,['test_no_command.py'],"['from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b\'\'\'No command \'aptget\' found, did you mean:\n Command \'apt-get\' from package \'apt\' (main)\n Command \'not-installed\' from package \'derp\' (main)\n Command \'not-really-used\' from package \'whatever\' (main)\naptget: command not found\n\'\'\'\n\n@pytest.fixture\ndef uninstalled_command_found():\n    return b\'\'\'No command \'pish\' found, did you mean:\n Command \'vish\' from package \'vish\' (universe)\n Command \'wish\' from package \'tk\' (main)\n Command \'fish\' from package \'fish\' (universe)\n Command \'pdsh\' from package \'pdsh\' (universe)\npish: command not found\n\'\'\'\n\n@pytest.fixture\ndef command_not_found():\n    return b\'\'\'No command \'vom\' found, but there are 19 similar ones\nvom: command not found\n\'\'\'\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch(\'thefuck.rules.no_command.which\',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n@pytest.fixture\ndef bin_might_exist(request):\n    def side_effect(name):\n        return name in [\'not-really-used\', \'apt-get\', \'/usr/lib/command-not-found\', \'test\']\n    p = patch(\'thefuck.rules.no_command.which\',\n              side_effect = side_effect)\n    p.start()\n    request.addfinalizer(p.stop)\n            \n\n@pytest.fixture\ndef patch_history(request):\n    def side_effect(name):\n        print(""history(\'{}\')"".format(name))\n        count = 2 if name == \'not-really-used\' else 12\n    p = patch(\'thefuck.rules.no_command._count_history_uses\',\n              side_effect = side_effect)\n    p.start()\n    request.addfinalizer(p.stop)\n    \n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures(\'bin_might_exist\', \'patch_history\')\ndef test_match(command_found, command_not_found, uninstalled_command_found, settings):\n    with patch(\'thefuck.rules.no_command.Popen\') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command(\'aptget install vim\', \'\', \'\'), settings)\n        Popen.assert_called_with(\'/usr/lib/command-not-found aptget\',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command(\'ls\', \'\', \'\'), settings)\n\n    with patch(\'thefuck.rules.no_command.Popen\') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command(\'sudo aptget install vim\', \'\', \'\'),\n                     Mock(command_not_found=\'test\'))\n        Popen.assert_called_with(\'test aptget\',\n                                      shell=True, stderr=PIPE)\n\n    with patch(\'thefuck.rules.no_command.Popen\') as Popen:\n        Popen.return_value.stderr.read.return_value = uninstalled_command_found\n        assert not match(Command(\'pish bla blah\', \'\', \'\'), settings)\n\n@pytest.mark.usefixtures(\'bin_might_exist\', \'patch_history\')\ndef test_get_new_command(command_found):\n    with patch(\'thefuck.rules.no_command._get_output\',\n               return_value=command_found.decode()):\n        assert get_new_command(Command(\'aptget install vim\', \'\', \'\'), settings)\\\n            == \'apt-get install vim\'\n        assert get_new_command(Command(\'sudo aptget install vim\', \'\', \'\'), settings) \\\n            == \'sudo apt-get install vim\'\n']","[""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\n Command 'not-installed' from package 'derp' (main)\n Command 'not-really-used' from package 'whatever' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef uninstalled_command_found():\n    return b'''No command 'pish' found, did you mean:\n Command 'vish' from package 'vish' (universe)\n Command 'wish' from package 'tk' (main)\n Command 'fish' from package 'fish' (universe)\n Command 'pdsh' from package 'pdsh' (universe)\npish: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n@pytest.fixture\ndef bin_might_exist(request):\n    def side_effect(name):\n        return name in ['not-really-used', 'apt-get', '/usr/lib/command-not-found', 'test']\n    p = patch('thefuck.rules.no_command.which',\n              side_effect = side_effect)\n    p.start()\n    request.addfinalizer(p.stop)\n            \n\n@pytest.fixture\ndef patch_history(request):\n    def side_effect(name):\n        return 2 if name == 'not-really-used' else 12\n    p = patch('thefuck.rules.no_command._count_history_uses',\n              side_effect = side_effect)\n    p.start()\n    request.addfinalizer(p.stop)\n    \n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures('bin_might_exist', 'patch_history')\ndef test_match(command_found, command_not_found, uninstalled_command_found, settings):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), settings)\n        Popen.assert_called_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), settings)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = uninstalled_command_found\n        assert not match(Command('pish bla blah', '', ''), settings)\n\n@pytest.mark.usefixtures('bin_might_exist', 'patch_history')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), settings)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), settings) \\\n            == 'sudo apt-get install vim'\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983d90fd0>, <pydriller.domain.commit.Method object at 0x7f1983d906a0>, <pydriller.domain.commit.Method object at 0x7f1983d90e80>, <pydriller.domain.commit.Method object at 0x7f1983d90eb0>, <pydriller.domain.commit.Method object at 0x7f1983d95040>, <pydriller.domain.commit.Method object at 0x7f1983d95400>, <pydriller.domain.commit.Method object at 0x7f1983d95160>, <pydriller.domain.commit.Method object at 0x7f1983d952b0>, <pydriller.domain.commit.Method object at 0x7f1983d95a90>, <pydriller.domain.commit.Method object at 0x7f1983d95430>, <pydriller.domain.commit.Method object at 0x7f1983db1fd0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983e097f0>, <pydriller.domain.commit.Method object at 0x7f1983e09be0>]]"
thefuck,650c3f4e45602d0faa4376291ae1b51f92bd90be,Fixed grammar in comments for easier understanding,2015-04-19 02:09:53+02:00,Max Dietrich,2,2,4,1,['main.py'],"['from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","['from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","[[<pydriller.domain.commit.Method object at 0x7f1983d23580>, <pydriller.domain.commit.Method object at 0x7f1983d236a0>, <pydriller.domain.commit.Method object at 0x7f1983d23550>, <pydriller.domain.commit.Method object at 0x7f1983d23040>, <pydriller.domain.commit.Method object at 0x7f1983d0b2e0>, <pydriller.domain.commit.Method object at 0x7f1983d0b580>, <pydriller.domain.commit.Method object at 0x7f1983d0b820>, <pydriller.domain.commit.Method object at 0x7f1983ccceb0>, <pydriller.domain.commit.Method object at 0x7f1983ccc820>, <pydriller.domain.commit.Method object at 0x7f1983d1ceb0>, <pydriller.domain.commit.Method object at 0x7f1983cd7ac0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983d56d30>, <pydriller.domain.commit.Method object at 0x7f1983d3ba90>]]"
thefuck,0d577ffa83ed7d410d2577c7d72995cf88c974f5,sudo rule: add support for mtr,2015-04-19 11:57:01+08:00,Felix Yan,2,1,3,1,['sudo.py'],"[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983d6e580>, <pydriller.domain.commit.Method object at 0x7f1983d4a040>]]",[[]]
thefuck,2a79a5e413b41bbbe3886828a97958ca824e7bdc,Create rm_root.py,2015-04-19 09:03:34+05:00,SpyCheese,8,0,8,1,['rm_root.py'],[None],"[""def match(command, settings):\n    return ('rm' in command.script\n            and '--help' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return '{} --no-preserve-root'.format(command.script)\n""]",[[]],"[[<pydriller.domain.commit.Method object at 0x7f1983d74190>, <pydriller.domain.commit.Method object at 0x7f1983d742b0>]]"
thefuck,f113bae59d97ab1cd90857680e8c6e9320b96327,Update rm_root.py,2015-04-19 09:12:19+05:00,SpyCheese,2,2,4,1,['rm_root.py'],"[""def match(command, settings):\n    return ('rm' in command.script\n            and '--help' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return '{} --no-preserve-root'.format(command.script)\n""]","[""def match(command, settings):\n    return ('/' in command.script\n            and '--no-preserve-root' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return '{} --no-preserve-root'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983dc5be0>, <pydriller.domain.commit.Method object at 0x7f1983dc5580>]]",[[<pydriller.domain.commit.Method object at 0x7f1983dbeeb0>]]
thefuck,ceeccf1cd7de156ae48ce5aa7f01366015fa6de9,"Update rm_root.py

Okay, there was an incorrect match function.",2015-04-19 10:21:46+05:00,SpyCheese,1,1,2,1,['rm_root.py'],"[""def match(command, settings):\n    return ('/' in command.script\n            and '--no-preserve-root' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return '{} --no-preserve-root'.format(command.script)\n""]","[""def match(command, settings):\n    return ('/' in command.script.split()\n            and '--no-preserve-root' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return '{} --no-preserve-root'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983e09820>, <pydriller.domain.commit.Method object at 0x7f1983e09550>]]",[[<pydriller.domain.commit.Method object at 0x7f1983da8430>]]
thefuck,ab91eaf73d2012266aaa3f82d08d05e62a82c4a4,"Revert ""Merge pull request #36 from jjmason/improve-no-command""

This reverts commit 28a5c1214b730e727b88648cf56dd36d51862ff6, reversing
changes made to 3f0cbb9326895cf516eb9f4f0f834d23200dc21e.",2015-04-19 14:58:44+02:00,nvbn,11,61,72,2,"['test_no_command.py', 'no_command.py']","[""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\n Command 'not-installed' from package 'derp' (main)\n Command 'not-really-used' from package 'whatever' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef uninstalled_command_found():\n    return b'''No command 'pish' found, did you mean:\n Command 'vish' from package 'vish' (universe)\n Command 'wish' from package 'tk' (main)\n Command 'fish' from package 'fish' (universe)\n Command 'pdsh' from package 'pdsh' (universe)\npish: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n@pytest.fixture\ndef bin_might_exist(request):\n    def side_effect(name):\n        return name in ['not-really-used', 'apt-get', '/usr/lib/command-not-found', 'test']\n    p = patch('thefuck.rules.no_command.which',\n              side_effect = side_effect)\n    p.start()\n    request.addfinalizer(p.stop)\n            \n\n@pytest.fixture\ndef patch_history(request):\n    def side_effect(name):\n        return 2 if name == 'not-really-used' else 12\n    p = patch('thefuck.rules.no_command._count_history_uses',\n              side_effect = side_effect)\n    p.start()\n    request.addfinalizer(p.stop)\n    \n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures('bin_might_exist', 'patch_history')\ndef test_match(command_found, command_not_found, uninstalled_command_found, settings):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), settings)\n        Popen.assert_called_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), settings)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = uninstalled_command_found\n        assert not match(Command('pish bla blah', '', ''), settings)\n\n@pytest.mark.usefixtures('bin_might_exist', 'patch_history')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), settings)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), settings) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode(\'utf-8\')\n\ndef _count_history_uses(name):\n    script = ""history | egrep \'\\\\b{}\\\\b\' | wc -l"".format(name)\n    result = Popen(script, shell=True,\n                   stdout=PIPE)\n    return int(result.stdout.read())\n\ndef _get_candidate_commands(command, settings):\n    output = _get_output(command, settings)\n    if ""No command"" in output and ""from package"" in output:\n        fixed_names = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)\n        return [name for name in fixed_names if which(name)]\n    return []\n        \n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return len(_get_candidate_commands(command, settings)) != 0\n\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    candidates = _get_candidate_commands(command, settings)\n    fixed_name = sorted(candidates, key=_count_history_uses, reverse=True)[0]\n    return command.script.replace(broken_name, fixed_name)\n     \n']","[""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_match(command_found, command_not_found, settings):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), settings)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), settings)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), settings)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), settings) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode(\'utf-8\')\n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n']","[[<pydriller.domain.commit.Method object at 0x7f1983dfe550>, <pydriller.domain.commit.Method object at 0x7f1983dfe6a0>, <pydriller.domain.commit.Method object at 0x7f1983dfe580>, <pydriller.domain.commit.Method object at 0x7f1983df8fd0>, <pydriller.domain.commit.Method object at 0x7f1983df8820>, <pydriller.domain.commit.Method object at 0x7f1983df86a0>, <pydriller.domain.commit.Method object at 0x7f1983df86d0>, <pydriller.domain.commit.Method object at 0x7f1983df8550>, <pydriller.domain.commit.Method object at 0x7f1983df8580>, <pydriller.domain.commit.Method object at 0x7f1983df8400>, <pydriller.domain.commit.Method object at 0x7f1983df8430>], [<pydriller.domain.commit.Method object at 0x7f1983df2430>, <pydriller.domain.commit.Method object at 0x7f1983df22b0>, <pydriller.domain.commit.Method object at 0x7f1983df2580>, <pydriller.domain.commit.Method object at 0x7f1983df8d60>, <pydriller.domain.commit.Method object at 0x7f1983df8c10>]]","[[<pydriller.domain.commit.Method object at 0x7f1983df86a0>, <pydriller.domain.commit.Method object at 0x7f1983df86d0>, <pydriller.domain.commit.Method object at 0x7f1983dfe6a0>, <pydriller.domain.commit.Method object at 0x7f1983df8400>, <pydriller.domain.commit.Method object at 0x7f1983dfe550>, <pydriller.domain.commit.Method object at 0x7f1983df8550>, <pydriller.domain.commit.Method object at 0x7f1983df8820>, <pydriller.domain.commit.Method object at 0x7f1983dfe160>], [<pydriller.domain.commit.Method object at 0x7f1983debfd0>, <pydriller.domain.commit.Method object at 0x7f1983df2580>, <pydriller.domain.commit.Method object at 0x7f1983df2160>, <pydriller.domain.commit.Method object at 0x7f1983df22b0>]]"
thefuck,a2c086ed73dd6489a2fde61902b7112a06a71904,"sudo rule: add support for ""Operation not permitted"" errors",2015-04-19 22:53:09+08:00,Felix Yan,2,1,3,1,['sudo.py'],"[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983e04d60>, <pydriller.domain.commit.Method object at 0x7f1983e04580>]]",[[]]
thefuck,f9f757f618378ed2b4ef9592c5dbc7d200b6c103,Added rule:cp_omitting_directory,2015-04-20 14:34:09+05:30,Nabeel Valapra,10,0,10,1,['cp_omitting_directory.py'],[None],"[""def match(command, settings):\n    if 'cp: omitting directory' in command.stderr.lower():\n        return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return command.script.replace('cp', 'cp -r') \n\n\n""]",[[]],"[[<pydriller.domain.commit.Method object at 0x7f1983da12b0>, <pydriller.domain.commit.Method object at 0x7f1983da16a0>]]"
thefuck,0b7fd6ae2ab20c99f9d0625f4ac7bf186bd92126,"Added rm -rf support

When someone tries to remove a directory without specifying `-rf`, e.g.

    $ mkdir foo
    $ rm foo

the shell refuses to remove the directory with an error:

    rm: foo: is a directory

Instead, you need to use

    $ rm -rf foo

This rule adds fuck support for this:

    $ mkdir foo
    $ rm foo
    rm: foo: is a directory
    $ fuck
    rm -rf foo",2015-04-20 12:32:32+02:00,Nils Winkler,22,0,22,2,"['test_rm_dir.py', 'rm_dir.py']","[None, None]","[""from thefuck.main import Command\nfrom thefuck.rules.rm_dir import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('rm foo', '', 'rm: foo: is a directory'), None)\n    assert not match(Command('rm foo', '', ''), None)\n    assert not match(Command('rm foo', '', 'foo bar baz'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('rm foo', '', ''), None) == 'rm -rf foo'\n"", ""import re\n\ndef match(command, settings):\n    return ('rm' in command.script\n            and 'is a directory' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return re.sub('^rm (.*)', 'rm -rf \\\\1', command.script)\n""]","[[], []]","[[<pydriller.domain.commit.Method object at 0x7f1983e09a90>, <pydriller.domain.commit.Method object at 0x7f1983e096a0>], [<pydriller.domain.commit.Method object at 0x7f1983dc56d0>, <pydriller.domain.commit.Method object at 0x7f1983dc52e0>]]"
thefuck,2b08a136b59c80bf4d0d04545078156a577279c3,add a rule to run the script you enter by add './' in command's prefix,2015-04-20 19:48:27+08:00,dannion,9,0,9,1,['has_exists_script.py'],[None],"[""import os\n\ndef match(command, settings):\n\texist = os.path.exists(command.script)\n\treturn exist\n\ndef get_new_command(command, settings):\n    return './{}'.format(command.script)\n\n""]",[[]],"[[<pydriller.domain.commit.Method object at 0x7f1983dbec10>, <pydriller.domain.commit.Method object at 0x7f1983dbed30>]]"
thefuck,36d9e13eceb9a3c9cb7037440538815983fa327b,#55 Add tests and check for `command not found`,2015-04-20 15:46:02+02:00,nvbn,24,2,26,2,"['test_has_exists_script.py', 'has_exists_script.py']","[None, ""import os\n\ndef match(command, settings):\n\texist = os.path.exists(command.script)\n\treturn exist\n\ndef get_new_command(command, settings):\n    return './{}'.format(command.script)\n\n""]","[""from mock import Mock, patch\nfrom thefuck.rules. has_exists_script import match, get_new_command\n\n\ndef test_match():\n    with patch('os.path.exists', return_value=True):\n        assert match(Mock(script='main', stderr='main: command not found'),\n                     None)\n        assert match(Mock(script='main --help',\n                          stderr='main: command not found'),\n                     None)\n        assert not match(Mock(script='main', stderr=''), None)\n\n    with patch('os.path.exists', return_value=False):\n        assert not match(Mock(script='main', stderr='main: command not found'),\n                         None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Mock(script='main --help'), None) == './main --help'\n"", ""import os\n\n\ndef match(command, settings):\n    return os.path.exists(command.script.split()[0]) \\\n        and 'command not found' in command.stderr\n\n\ndef get_new_command(command, settings):\n    return './{}'.format(command.script)\n\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d5cfd0>, <pydriller.domain.commit.Method object at 0x7f1983d5c2e0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983d67a90>, <pydriller.domain.commit.Method object at 0x7f1983d67820>], [<pydriller.domain.commit.Method object at 0x7f1983d7f2b0>]]"
thefuck,9ecda9a399cab6a683eed27e5dd8de7b394c581c,Bump version to 1.13,2015-04-20 15:48:17+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.12,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.13,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,411aea67f771fb2a9ba0bf253b750d05deb2c242,"A special case for 'Permission denied' error msg when trying to execute a
python scripy.

The script does not have execute permission and/or does not start with !#/usr/...
In that case, pre-pend the command with 'python' keyword.

Change-Id: Idf73ee9cf0a523f51c78672188a457b2fcedc1e6",2015-04-20 10:49:39-04:00,Sudeep Juvekar,22,1,23,3,"['test_python_command.py', 'main.py', 'python_command.py']","[None, 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n', None]","[""from thefuck.main import Command\nfrom thefuck.rules.sudo import match, get_new_command\n\ndef test_match():\n    assert match(Command('', '', 'Permission denied'), None)\n    assert not match(Command('', '', ''), None)\n\ndef test_get_new_command():\n    assert get_new_command(Command('./test_sudo.py', '', ''), None) == 'python ./test_sudo.py'\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n', ""# add 'python' suffix to the command if\n#  1) The script does not have execute permission or\n#  2) is interpreted as shell script\n\ndef match(command, settings):\n  toks = command.script.split()\n  return (toks[0].endswith('.py')\n          and ('Permission denied' in command.stderr or\n               'command not found' in command.stderr))\n\ndef get_new_command(command, settings):\n  return 'python ' + command.script\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983ddfd60>, <pydriller.domain.commit.Method object at 0x7f1983ddfeb0>, <pydriller.domain.commit.Method object at 0x7f1983ddfbe0>, <pydriller.domain.commit.Method object at 0x7f1983ddfc10>, <pydriller.domain.commit.Method object at 0x7f1983ddf430>, <pydriller.domain.commit.Method object at 0x7f1983ddf2b0>, <pydriller.domain.commit.Method object at 0x7f1983ddf2e0>, <pydriller.domain.commit.Method object at 0x7f1983ddf160>, <pydriller.domain.commit.Method object at 0x7f1983ddf190>, <pydriller.domain.commit.Method object at 0x7f1983ddf040>, <pydriller.domain.commit.Method object at 0x7f1983ddbfd0>], []]","[[<pydriller.domain.commit.Method object at 0x7f1983debeb0>, <pydriller.domain.commit.Method object at 0x7f1983debd60>], [<pydriller.domain.commit.Method object at 0x7f1983de67f0>], [<pydriller.domain.commit.Method object at 0x7f1983ddb940>, <pydriller.domain.commit.Method object at 0x7f1983ddb7f0>]]"
thefuck,17397bf30ff94e5fda0c1bcdaca75bdcac458641,"A special case for 'Permission denied' error msg when trying to execute a
python scripy.

The script does not have execute permission and/or does not start with !#/usr/...
In that case, pre-pend the command with 'python' keyword.

Change-Id: Idf73ee9cf0a523f51c78672188a457b2fcedc1e6",2015-04-20 11:00:35-04:00,Sudeep Juvekar,1,1,2,1,['test_python_command.py'],"[""from thefuck.main import Command\nfrom thefuck.rules.sudo import match, get_new_command\n\ndef test_match():\n    assert match(Command('', '', 'Permission denied'), None)\n    assert not match(Command('', '', ''), None)\n\ndef test_get_new_command():\n    assert get_new_command(Command('./test_sudo.py', '', ''), None) == 'python ./test_sudo.py'\n""]","[""from thefuck.main import Command\nfrom thefuck.rules.python_command import match, get_new_command\n\ndef test_match():\n    assert match(Command('', '', 'Permission denied'), None)\n    assert not match(Command('', '', ''), None)\n\ndef test_get_new_command():\n    assert get_new_command(Command('./test_sudo.py', '', ''), None) == 'python ./test_sudo.py'\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983dd5fd0>, <pydriller.domain.commit.Method object at 0x7f1983dd5970>]]",[[]]
thefuck,cb31a1f7d08776b5a9e42bc944b2e12a23c1613e,"A special case for 'Permission denied' error msg when trying to execute a
python scripy.

The script does not have execute permission and/or does not start with !#/usr/...
In that case, pre-pend the command with 'python' keyword.

Change-Id: Idf73ee9cf0a523f51c78672188a457b2fcedc1e6",2015-04-20 12:00:08-04:00,Sudeep Juvekar,2,1,3,1,['python_command.py'],"[""# add 'python' suffix to the command if\n#  1) The script does not have execute permission or\n#  2) is interpreted as shell script\n\ndef match(command, settings):\n  toks = command.script.split()\n  return (toks[0].endswith('.py')\n          and ('Permission denied' in command.stderr or\n               'command not found' in command.stderr))\n\ndef get_new_command(command, settings):\n  return 'python ' + command.script\n""]","[""# add 'python' suffix to the command if\n#  1) The script does not have execute permission or\n#  2) is interpreted as shell script\n\ndef match(command, settings):\n  toks = command.script.split()\n  return (len(toks) > 0\n          and toks[0].endswith('.py')\n          and ('Permission denied' in command.stderr or\n               'command not found' in command.stderr))\n\ndef get_new_command(command, settings):\n  return 'python ' + command.script\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983dd52b0>, <pydriller.domain.commit.Method object at 0x7f1983dd5160>]]",[[<pydriller.domain.commit.Method object at 0x7f1983dcf2e0>]]
thefuck,1d878243ca50dcfe371ef30eec1bad4bd6b2e4a5,"A special case for 'Permission denied' error msg when trying to execute a
python scripy.

The script does not have execute permission and/or does not start with !#/usr/...
In that case, pre-pend the command with 'python' keyword.

Change-Id: Idf73ee9cf0a523f51c78672188a457b2fcedc1e6",2015-04-20 12:11:06-04:00,Sudeep Juvekar,1,1,2,1,['test_python_command.py'],"[""from thefuck.main import Command\nfrom thefuck.rules.python_command import match, get_new_command\n\ndef test_match():\n    assert match(Command('', '', 'Permission denied'), None)\n    assert not match(Command('', '', ''), None)\n\ndef test_get_new_command():\n    assert get_new_command(Command('./test_sudo.py', '', ''), None) == 'python ./test_sudo.py'\n""]","[""from thefuck.main import Command\nfrom thefuck.rules.python_command import match, get_new_command\n\ndef test_match():\n    assert match(Command('temp.py', '', 'Permission denied'), None)\n    assert not match(Command('', '', ''), None)\n\ndef test_get_new_command():\n    assert get_new_command(Command('./test_sudo.py', '', ''), None) == 'python ./test_sudo.py'\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983ddfd30>, <pydriller.domain.commit.Method object at 0x7f1983ddf580>]]",[[<pydriller.domain.commit.Method object at 0x7f1983ddb2b0>]]
thefuck,c0c584b13a0d6f5e177e25f48d5de918f1bef7e2,"mkdir -p

When adding directories using `mkdir`, intermediate directories have to
exist, unless you specify the `-p` option:

    $ mkdir foo/bar/baz
    mkdir: foo/bar: No such file or directory
    $ fuck
    mkdir -p foo/bar/baz",2015-04-20 18:38:03+02:00,Nils Winkler,22,0,22,2,"['test_mkdir_p.py', 'mkdir_p.py']","[None, None]","[""from thefuck.main import Command\nfrom thefuck.rules.mkdir_p import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('mkdir foo/bar/baz', '', 'mkdir: foo/bar: No such file or directory'), None)\n    assert not match(Command('mkdir foo/bar/baz', '', ''), None)\n    assert not match(Command('mkdir foo/bar/baz', '', 'foo bar baz'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('mkdir foo/bar/baz', '', ''), None) == 'mkdir -p foo/bar/baz'\n"", ""import re\n\ndef match(command, settings):\n    return ('mkdir' in command.script\n            and 'No such file or directory' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return re.sub('^mkdir (.*)', 'mkdir -p \\\\1', command.script)\n""]","[[], []]","[[<pydriller.domain.commit.Method object at 0x7f1983deb2e0>, <pydriller.domain.commit.Method object at 0x7f1983debd30>], [<pydriller.domain.commit.Method object at 0x7f1983de6a90>, <pydriller.domain.commit.Method object at 0x7f1983de6ac0>]]"
thefuck,2db0a215b4006555b21281957fe8e8446da1beb7,Fix fuck when more than one git command available,2015-04-20 21:48:54+02:00,nvbn,21,5,26,3,"['setup.py', 'test_git_not_command.py', 'git_not_command.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.13,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', 'import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.git_not_command import match, get_new_command\n\n\n@pytest.fixture\ndef git_not_command():\n    return """"""git: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\nbranch\n""""""\n\n\n@pytest.fixture\ndef git_command():\n    return ""* master""\n\n\ndef test_match(git_not_command, git_command):\n    assert match(Command(\'git brnch\', \'\', git_not_command), None)\n    assert not match(Command(\'ls brnch\', \'\', git_not_command), None)\n    assert not match(Command(\'git branch\', \'\', git_command), None)\n\n\ndef test_get_new_command(git_not_command):\n    assert get_new_command(Command(\'git brnch\', \'\', git_not_command), None)\\\n        == \'git branch\'\n', 'import re\n\n\ndef match(command, settings):\n    return (\'git\' in command.script\n            and "" is not a git command. See \'git --help\'."" in command.stderr\n            and \'Did you mean this?\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r""git: \'([^\']*)\' is not a git command"",\n                            command.stderr)[0]\n    new_cmd = re.findall(r\'Did you mean this\\?\\n\\s*([^\\n]*)\',\n                         command.stderr)[0]\n    return command.script.replace(broken_cmd, new_cmd, 1)\n\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.14,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', 'import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.git_not_command import match, get_new_command\n\n\n@pytest.fixture\ndef git_not_command():\n    return """"""git: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\nbranch\n""""""\n\n\n@pytest.fixture\ndef git_not_command_one_of_this():\n    return """"""git: \'st\' is not a git command. See \'git --help\'.\n\nDid you mean one of these?\nstatus\nreset\nstage\nstash\nstats\n""""""\n\n\n@pytest.fixture\ndef git_command():\n    return ""* master""\n\n\ndef test_match(git_not_command, git_command, git_not_command_one_of_this):\n    assert match(Command(\'git brnch\', \'\', git_not_command), None)\n    assert match(Command(\'git st\', \'\', git_not_command_one_of_this), None)\n    assert not match(Command(\'ls brnch\', \'\', git_not_command), None)\n    assert not match(Command(\'git branch\', \'\', git_command), None)\n\n\ndef test_get_new_command(git_not_command, git_not_command_one_of_this):\n    assert get_new_command(Command(\'git brnch\', \'\', git_not_command), None)\\\n        == \'git branch\'\n    assert get_new_command(\n        Command(\'git st\', \'\', git_not_command_one_of_this), None) == \'git status\'\n', 'import re\n\n\ndef match(command, settings):\n    return (\'git\' in command.script\n            and "" is not a git command. See \'git --help\'."" in command.stderr\n            and \'Did you mean\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r""git: \'([^\']*)\' is not a git command"",\n                            command.stderr)[0]\n    new_cmd = re.findall(r\'Did you mean[^\\n]*\\n\\s*([^\\n]*)\',\n                         command.stderr)[0]\n    return command.script.replace(broken_cmd, new_cmd, 1)\n\n']","[[], [<pydriller.domain.commit.Method object at 0x7f1983ce9970>, <pydriller.domain.commit.Method object at 0x7f1983ce96d0>, <pydriller.domain.commit.Method object at 0x7f1983ce9550>, <pydriller.domain.commit.Method object at 0x7f1983d4afd0>], [<pydriller.domain.commit.Method object at 0x7f1983dacc10>, <pydriller.domain.commit.Method object at 0x7f1983dacbe0>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d4afd0>, <pydriller.domain.commit.Method object at 0x7f1983ce9550>, <pydriller.domain.commit.Method object at 0x7f1983d85c10>, <pydriller.domain.commit.Method object at 0x7f1983d7f160>, <pydriller.domain.commit.Method object at 0x7f1983d5c6d0>], [<pydriller.domain.commit.Method object at 0x7f1983dbe970>, <pydriller.domain.commit.Method object at 0x7f1983dbe550>]]"
thefuck,7888315196a5e97549e93d772396e85f34f65bc5,"#52 Use `cp -a`, add tests",2015-04-20 22:00:37+02:00,nvbn,20,6,26,2,"['test_cp_omitting_directory.py', 'cp_omitting_directory.py']","[None, ""def match(command, settings):\n    if 'cp: omitting directory' in command.stderr.lower():\n        return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return command.script.replace('cp', 'cp -r') \n\n\n""]","['from mock import Mock\nfrom thefuck.rules.cp_omitting_directory import match, get_new_command\n\n\ndef test_match():\n    assert match(Mock(script=\'cp dir\', stderr=""cp: omitting directory \'dir\'""),\n                 None)\n    assert not match(Mock(script=\'some dir\',\n                          stderr=""cp: omitting directory \'dir\'""), None)\n    assert not match(Mock(script=\'cp dir\', stderr=""""), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Mock(script=\'cp dir\'), None) == \'cp -a dir\'\n', ""import re\n\n\ndef match(command, settings):\n    return command.script.startswith('cp ') \\\n        and 'cp: omitting directory' in command.stderr.lower()\n\n\ndef get_new_command(command, settings):\n    return re.sub(r'^cp', 'cp -a', command.script)\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e04970>, <pydriller.domain.commit.Method object at 0x7f1983e04c10>]]","[[<pydriller.domain.commit.Method object at 0x7f1983da1820>, <pydriller.domain.commit.Method object at 0x7f1983da17f0>], [<pydriller.domain.commit.Method object at 0x7f1983e09400>, <pydriller.domain.commit.Method object at 0x7f1983e09fd0>]]"
thefuck,e822fade4c58377ed0eb3ec9759c4eddf4ecf842,#10 Add `require_confirmation` option,2015-04-21 05:30:15+02:00,nvbn,62,3,65,3,"['README.md', 'test_main.py', 'main.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scary to blindly run changed command, there\'s `require_confirmation`\n[settings](#Settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","[[], [<pydriller.domain.commit.Method object at 0x7f1983dfe7f0>, <pydriller.domain.commit.Method object at 0x7f1983dfed30>, <pydriller.domain.commit.Method object at 0x7f1983e096d0>, <pydriller.domain.commit.Method object at 0x7f1983e09ac0>, <pydriller.domain.commit.Method object at 0x7f1983e09e80>, <pydriller.domain.commit.Method object at 0x7f1983e092e0>], [<pydriller.domain.commit.Method object at 0x7f1983d5c400>, <pydriller.domain.commit.Method object at 0x7f1983d7f970>, <pydriller.domain.commit.Method object at 0x7f1983d7fd30>, <pydriller.domain.commit.Method object at 0x7f1983d7fac0>, <pydriller.domain.commit.Method object at 0x7f1983d56be0>, <pydriller.domain.commit.Method object at 0x7f1983d56040>, <pydriller.domain.commit.Method object at 0x7f1983d56580>, <pydriller.domain.commit.Method object at 0x7f1983d56970>, <pydriller.domain.commit.Method object at 0x7f1983d56550>, <pydriller.domain.commit.Method object at 0x7f1983d562b0>, <pydriller.domain.commit.Method object at 0x7f1983d566a0>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e42400>, <pydriller.domain.commit.Method object at 0x7f1983df2040>], [<pydriller.domain.commit.Method object at 0x7f1983d3b580>, <pydriller.domain.commit.Method object at 0x7f1983d3b040>, <pydriller.domain.commit.Method object at 0x7f1983dbe580>]]"
thefuck,0925c7966f19f02da93b2047318eb060bf022349,Bump version,2015-04-21 05:34:44+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.14,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.15,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,5ccf163594fa11239b5cb83c73aa9c63879a17f2,`command.script` now unicode,2015-04-21 06:24:40+02:00,nvbn,13,12,25,6,"['test_main.py', 'main.py', 'has_exists_script.py', 'no_command.py', 'python_command.py', 'sudo.py']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n', ""import os\n\n\ndef match(command, settings):\n    return os.path.exists(command.script.split()[0]) \\\n        and 'command not found' in command.stderr\n\n\ndef get_new_command(command, settings):\n    return './{}'.format(command.script)\n\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode(\'utf-8\')\n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n', ""# add 'python' suffix to the command if\n#  1) The script does not have execute permission or\n#  2) is interpreted as shell script\n\ndef match(command, settings):\n  toks = command.script.split()\n  return (len(toks) > 0\n          and toks[0].endswith('.py')\n          and ('Permission denied' in command.stderr or\n               'command not found' in command.stderr))\n\ndef get_new_command(command, settings):\n  return 'python ' + command.script\n"", ""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), [b'thefuck', b'apt-get',\n                                         b'search', b'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n', ""import os\n\n\ndef match(command, settings):\n    return os.path.exists(command.script.split()[0]) \\\n        and 'command not found' in command.stderr\n\n\ndef get_new_command(command, settings):\n    return u'./{}'.format(command.script)\n\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = u\'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode(\'utf-8\')\n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n', ""# add 'python' suffix to the command if\n#  1) The script does not have execute permission or\n#  2) is interpreted as shell script\n\ndef match(command, settings):\n    toks = command.script.split()\n    return (len(toks) > 0\n            and toks[0].endswith('.py')\n            and ('Permission denied' in command.stderr or\n                 'command not found' in command.stderr))\n\n\ndef get_new_command(command, settings):\n    return 'python ' + command.script\n"", ""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983e42be0>, <pydriller.domain.commit.Method object at 0x7f1983e42d30>, <pydriller.domain.commit.Method object at 0x7f1983e42c10>, <pydriller.domain.commit.Method object at 0x7f1983e42a60>, <pydriller.domain.commit.Method object at 0x7f1983e42670>, <pydriller.domain.commit.Method object at 0x7f1983e426a0>, <pydriller.domain.commit.Method object at 0x7f1983e42d60>, <pydriller.domain.commit.Method object at 0x7f1983e42eb0>], [<pydriller.domain.commit.Method object at 0x7f1983e047f0>, <pydriller.domain.commit.Method object at 0x7f1983e42520>, <pydriller.domain.commit.Method object at 0x7f1983e42a90>, <pydriller.domain.commit.Method object at 0x7f1983e42910>, <pydriller.domain.commit.Method object at 0x7f1983e42940>, <pydriller.domain.commit.Method object at 0x7f1983e427c0>, <pydriller.domain.commit.Method object at 0x7f1983e427f0>, <pydriller.domain.commit.Method object at 0x7f1983dcf7f0>, <pydriller.domain.commit.Method object at 0x7f1983dcf160>, <pydriller.domain.commit.Method object at 0x7f1983dcfac0>, <pydriller.domain.commit.Method object at 0x7f1983dcfa90>, <pydriller.domain.commit.Method object at 0x7f1983dcf040>], [<pydriller.domain.commit.Method object at 0x7f1983dcfbe0>, <pydriller.domain.commit.Method object at 0x7f1983dcf550>], [<pydriller.domain.commit.Method object at 0x7f1983de6160>, <pydriller.domain.commit.Method object at 0x7f1983de6400>, <pydriller.domain.commit.Method object at 0x7f1983de6190>], [<pydriller.domain.commit.Method object at 0x7f1983ddf970>, <pydriller.domain.commit.Method object at 0x7f1983d95970>], [<pydriller.domain.commit.Method object at 0x7f1983d90ac0>, <pydriller.domain.commit.Method object at 0x7f1983d907f0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983dcf6d0>], [<pydriller.domain.commit.Method object at 0x7f1983dcaeb0>], [<pydriller.domain.commit.Method object at 0x7f1983dca6a0>], [<pydriller.domain.commit.Method object at 0x7f1983ddbd60>], [<pydriller.domain.commit.Method object at 0x7f1983deb430>, <pydriller.domain.commit.Method object at 0x7f1983deb550>], [<pydriller.domain.commit.Method object at 0x7f1983d9c940>]]"
thefuck,e7d5d93056e5238f24da548d578157dbc655dde9,#68 Add rule for switching layout,2015-04-21 06:26:15+02:00,nvbn,50,2,52,4,"['README.md', 'setup.py', 'test_switch_lang.py', 'switch_lang.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scary to blindly run changed command, there\'s `require_confirmation`\n[settings](#Settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.15,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', None, None]","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scary to blindly run changed command, there\'s `require_confirmation`\n[settings](#Settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.16,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""# -*- encoding: utf-8 -*-\n\nfrom mock import Mock\nfrom thefuck.rules import switch_lang\n\n\ndef test_match():\n    assert switch_lang.match(Mock(stderr='command not found: фзе-пуе',\n                                  script=u'фзе-пуе'), None)\n    assert not switch_lang.match(Mock(stderr='command not found: pat-get',\n                                      script=u'pat-get'), None)\n    assert not switch_lang.match(Mock(stderr='some info',\n                                      script=u'фзе-пуе'), None)\n\n\ndef test_get_new_command():\n    assert switch_lang.get_new_command(\n        Mock(script=u'фзе-пуе штыефдд мшь'), None) == 'apt-get install vim'\n"", '# -*- encoding: utf-8 -*-\n\ntarget_layout = \'\'\'qwertyuiop[]asdfghjkl;\'zxcvbnm,./QWERTYUIOP{}ASDFGHJKL:""ZXCVBNM<>?\'\'\'\n\nsource_layouts = [u\'\'\'йцукенгшщзхъфывапролджэячсмитьбю.ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,\'\'\']\n\n\ndef _get_matched_layout(command):\n    for source_layout in source_layouts:\n        if all([ch in source_layout or ch in \'-_\'\n                for ch in command.script.split(\' \')[0]]):\n            return source_layout\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and _get_matched_layout(command)\n\n\ndef _switch(ch, layout):\n    if ch in layout:\n        return target_layout[layout.index(ch)]\n    else:\n        return ch\n\n\ndef get_new_command(command, settings):\n    matched_layout = _get_matched_layout(command)\n    return \'\'.join(_switch(ch, matched_layout) for ch in command.script)\n\n']","[[], [], [], []]","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983d4a190>, <pydriller.domain.commit.Method object at 0x7f1983d4abe0>], [<pydriller.domain.commit.Method object at 0x7f1983d23160>, <pydriller.domain.commit.Method object at 0x7f1983dfe400>, <pydriller.domain.commit.Method object at 0x7f1983d74160>, <pydriller.domain.commit.Method object at 0x7f1983d74d60>]]"
thefuck,ab8ac23749d90f0265d29cfe3440357098b97225,Fix python 3 support,2015-04-21 06:33:51+02:00,nvbn,4,1,5,1,['main.py'],"['from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","['from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","[[<pydriller.domain.commit.Method object at 0x7f1983e34250>, <pydriller.domain.commit.Method object at 0x7f1983e343a0>, <pydriller.domain.commit.Method object at 0x7f1983e34280>, <pydriller.domain.commit.Method object at 0x7f1983e34100>, <pydriller.domain.commit.Method object at 0x7f1983e2e910>, <pydriller.domain.commit.Method object at 0x7f1983e2e790>, <pydriller.domain.commit.Method object at 0x7f1983e2e7c0>, <pydriller.domain.commit.Method object at 0x7f1983e2e640>, <pydriller.domain.commit.Method object at 0x7f1983e2e670>, <pydriller.domain.commit.Method object at 0x7f1983e2e4f0>, <pydriller.domain.commit.Method object at 0x7f1983e2e520>, <pydriller.domain.commit.Method object at 0x7f1983e2e3a0>]]",[[<pydriller.domain.commit.Method object at 0x7f1983e34cd0>]]
thefuck,8ed01fedbfcca1cb5acf1ca728a857ff93807942,Bump version,2015-04-21 06:34:03+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.16,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.17,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,360613150247c52804d0c0f00aa84e21d717f746,Fix tests,2015-04-21 06:36:51+02:00,nvbn,2,2,4,1,['test_main.py'],"[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), [b'thefuck', b'apt-get',\n                                         b'search', b'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n""]","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983e237c0>, <pydriller.domain.commit.Method object at 0x7f1983e23280>, <pydriller.domain.commit.Method object at 0x7f1983e29910>, <pydriller.domain.commit.Method object at 0x7f1983e29670>, <pydriller.domain.commit.Method object at 0x7f1983e29b80>, <pydriller.domain.commit.Method object at 0x7f1983e29e20>, <pydriller.domain.commit.Method object at 0x7f1983e29fa0>, <pydriller.domain.commit.Method object at 0x7f1983e29130>]]",[[<pydriller.domain.commit.Method object at 0x7f1983e1dfa0>]]
thefuck,e3edea05edc29bc1e0a5bdcfea4e35c2a46fd972,#24 Make `no_command` crossplatform,2015-04-21 06:55:47+02:00,nvbn,29,81,110,3,"['README.md', 'test_no_command.py', 'no_command.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scary to blindly run changed command, there\'s `require_confirmation`\n[settings](#Settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_match(command_found, command_not_found, settings):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), settings)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), settings)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), settings)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), settings) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = u\'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode(\'utf-8\')\n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scary to blindly run changed command, there\'s `require_confirmation`\n[settings](#Settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""from mock import patch, Mock\nfrom thefuck.rules.no_command import match, get_new_command\n\n\ndef test_match():\n    with patch('thefuck.rules.no_command._get_all_bins',\n               return_value=['vim', 'apt-get']):\n        assert match(Mock(stderr='vom: not found', script='vom file.py'), None)\n        assert not match(Mock(stderr='qweqwe: not found', script='qweqwe'), None)\n        assert not match(Mock(stderr='some text', script='vom file.py'), None)\n\n\ndef test_get_new_command():\n    with patch('thefuck.rules.no_command._get_all_bins',\n               return_value=['vim', 'apt-get']):\n        assert get_new_command(\n            Mock(stderr='vom: not found',\n                 script='vom file.py'),\n            None) == 'vim file.py'\n"", ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ['PATH'].split(':')\n            for exe in Path(path).iterdir()\n            if exe.is_file()]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d746d0>, <pydriller.domain.commit.Method object at 0x7f1983d74e80>, <pydriller.domain.commit.Method object at 0x7f1983d746a0>, <pydriller.domain.commit.Method object at 0x7f1983e238e0>, <pydriller.domain.commit.Method object at 0x7f1983e23bb0>, <pydriller.domain.commit.Method object at 0x7f1983e23a30>], [<pydriller.domain.commit.Method object at 0x7f1983dc5550>, <pydriller.domain.commit.Method object at 0x7f1983d62160>, <pydriller.domain.commit.Method object at 0x7f1983d62430>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d74e80>, <pydriller.domain.commit.Method object at 0x7f1983e2ee20>, <pydriller.domain.commit.Method object at 0x7f1983e238e0>, <pydriller.domain.commit.Method object at 0x7f1983d746d0>, <pydriller.domain.commit.Method object at 0x7f1983e2efa0>, <pydriller.domain.commit.Method object at 0x7f1983d746a0>, <pydriller.domain.commit.Method object at 0x7f1983e23a30>, <pydriller.domain.commit.Method object at 0x7f1983e23bb0>], [<pydriller.domain.commit.Method object at 0x7f1983d4ac10>, <pydriller.domain.commit.Method object at 0x7f1983d4ad60>, <pydriller.domain.commit.Method object at 0x7f1983d4a2e0>, <pydriller.domain.commit.Method object at 0x7f1983dc5550>]]"
thefuck,e1fe7ff7d02abe9fc1a447bf49eb97b37ca7b18d,Bump version,2015-04-21 06:56:26+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.17,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.18,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,3798c341d524eb474763d4ccfc8a49e8bf106aa7,"add persian language to switch lang rule
refs #28",2015-04-21 09:42:13+04:30,fzerorubigd,1,1,2,1,['switch_lang.py'],"['# -*- encoding: utf-8 -*-\n\ntarget_layout = \'\'\'qwertyuiop[]asdfghjkl;\'zxcvbnm,./QWERTYUIOP{}ASDFGHJKL:""ZXCVBNM<>?\'\'\'\n\nsource_layouts = [u\'\'\'йцукенгшщзхъфывапролджэячсмитьбю.ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,\'\'\']\n\n\ndef _get_matched_layout(command):\n    for source_layout in source_layouts:\n        if all([ch in source_layout or ch in \'-_\'\n                for ch in command.script.split(\' \')[0]]):\n            return source_layout\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and _get_matched_layout(command)\n\n\ndef _switch(ch, layout):\n    if ch in layout:\n        return target_layout[layout.index(ch)]\n    else:\n        return ch\n\n\ndef get_new_command(command, settings):\n    matched_layout = _get_matched_layout(command)\n    return \'\'.join(_switch(ch, matched_layout) for ch in command.script)\n\n']","['# -*- encoding: utf-8 -*-\n\ntarget_layout = \'\'\'qwertyuiop[]asdfghjkl;\'zxcvbnm,./QWERTYUIOP{}ASDFGHJKL:""ZXCVBNM<>?\'\'\'\n\nsource_layouts = [u\'\'\'йцукенгшщзхъфывапролджэячсмитьбю.ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,\'\'\', u\'\'\'ضصثقفغعهخحجچشسیبلاتنمکگظطزرذدپو./ًٌٍَُِّْ][}{ؤئيإأآة»«:؛كٓژٰ\u200cٔء><؟\'\'\']\n\n\ndef _get_matched_layout(command):\n    for source_layout in source_layouts:\n        if all([ch in source_layout or ch in \'-_\'\n                for ch in command.script.split(\' \')[0]]):\n            return source_layout\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and _get_matched_layout(command)\n\n\ndef _switch(ch, layout):\n    if ch in layout:\n        return target_layout[layout.index(ch)]\n    else:\n        return ch\n\n\ndef get_new_command(command, settings):\n    matched_layout = _get_matched_layout(command)\n    return \'\'.join(_switch(ch, matched_layout) for ch in command.script)\n\n']","[[<pydriller.domain.commit.Method object at 0x7f1983ddb2e0>, <pydriller.domain.commit.Method object at 0x7f1983ddbeb0>, <pydriller.domain.commit.Method object at 0x7f1983ddb550>, <pydriller.domain.commit.Method object at 0x7f1983ddb400>]]",[[]]
thefuck,273fc097bd87058a4f303edc3149941d42264240,Update switch_lang.py,2015-04-21 07:16:36+02:00,Vladimir Iakovlev,2,1,3,1,['switch_lang.py'],"['# -*- encoding: utf-8 -*-\n\ntarget_layout = \'\'\'qwertyuiop[]asdfghjkl;\'zxcvbnm,./QWERTYUIOP{}ASDFGHJKL:""ZXCVBNM<>?\'\'\'\n\nsource_layouts = [u\'\'\'йцукенгшщзхъфывапролджэячсмитьбю.ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,\'\'\', u\'\'\'ضصثقفغعهخحجچشسیبلاتنمکگظطزرذدپو./ًٌٍَُِّْ][}{ؤئيإأآة»«:؛كٓژٰ\u200cٔء><؟\'\'\']\n\n\ndef _get_matched_layout(command):\n    for source_layout in source_layouts:\n        if all([ch in source_layout or ch in \'-_\'\n                for ch in command.script.split(\' \')[0]]):\n            return source_layout\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and _get_matched_layout(command)\n\n\ndef _switch(ch, layout):\n    if ch in layout:\n        return target_layout[layout.index(ch)]\n    else:\n        return ch\n\n\ndef get_new_command(command, settings):\n    matched_layout = _get_matched_layout(command)\n    return \'\'.join(_switch(ch, matched_layout) for ch in command.script)\n\n']","['# -*- encoding: utf-8 -*-\n\ntarget_layout = \'\'\'qwertyuiop[]asdfghjkl;\'zxcvbnm,./QWERTYUIOP{}ASDFGHJKL:""ZXCVBNM<>?\'\'\'\n\nsource_layouts = [u\'\'\'йцукенгшщзхъфывапролджэячсмитьбю.ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,\'\'\',\n                  u\'\'\'ضصثقفغعهخحجچشسیبلاتنمکگظطزرذدپو./ًٌٍَُِّْ][}{ؤئيإأآة»«:؛كٓژٰ\u200cٔء><؟\'\'\']\n\n\ndef _get_matched_layout(command):\n    for source_layout in source_layouts:\n        if all([ch in source_layout or ch in \'-_\'\n                for ch in command.script.split(\' \')[0]]):\n            return source_layout\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and _get_matched_layout(command)\n\n\ndef _switch(ch, layout):\n    if ch in layout:\n        return target_layout[layout.index(ch)]\n    else:\n        return ch\n\n\ndef get_new_command(command, settings):\n    matched_layout = _get_matched_layout(command)\n    return \'\'.join(_switch(ch, matched_layout) for ch in command.script)\n\n']","[[<pydriller.domain.commit.Method object at 0x7f1983dca2b0>, <pydriller.domain.commit.Method object at 0x7f1983dca970>, <pydriller.domain.commit.Method object at 0x7f1983dcae80>, <pydriller.domain.commit.Method object at 0x7f1983dcafd0>]]",[[]]
thefuck,478fa4cd09059eea4c89adf16ac31dcd975cfa8f,#71 Not fail on os error,2015-04-21 08:30:48+02:00,nvbn,10,3,13,2,"['setup.py', 'no_command.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.18,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ['PATH'].split(':')\n            for exe in Path(path).iterdir()\n            if exe.is_file()]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n""]","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.19,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _safe(path, method):\n    try:\n        return getattr(path, method)()\n    except OSError:\n        return []\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ['PATH'].split(':')\n            for exe in _safe(Path(path), 'iterdir')\n            if not _safe(exe, 'is_dir')]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e1de50>, <pydriller.domain.commit.Method object at 0x7f1983e1d3d0>, <pydriller.domain.commit.Method object at 0x7f1983dca580>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e1d670>, <pydriller.domain.commit.Method object at 0x7f1983e1d640>]]"
thefuck,f2392349f732060b2530545f4da37d0bfa611bb2,#71 Handle `OSError` more gratefully,2015-04-21 08:38:52+02:00,nvbn,6,6,12,2,"['setup.py', 'no_command.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.19,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _safe(path, method):\n    try:\n        return getattr(path, method)()\n    except OSError:\n        return []\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ['PATH'].split(':')\n            for exe in _safe(Path(path), 'iterdir')\n            if not _safe(exe, 'is_dir')]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n""]","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.20,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _safe(fn, fallback):\n    try:\n        return fn()\n    except OSError:\n        return fallback\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ['PATH'].split(':')\n            for exe in _safe(Path(path).iterdir, [])\n            if not _safe(exe.is_dir, True)]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983ddffd0>, <pydriller.domain.commit.Method object at 0x7f1983ddfe80>, <pydriller.domain.commit.Method object at 0x7f1983cdd6d0>, <pydriller.domain.commit.Method object at 0x7f1983ce9400>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983de6040>, <pydriller.domain.commit.Method object at 0x7f1983ddffd0>, <pydriller.domain.commit.Method object at 0x7f1983de6c10>]]"
thefuck,82e2c894720e0316d9799eb56374ee06858a8b0c,Fix version number,2015-04-21 08:40:17+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.20,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=""1.20"",\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,798928b5adc67cbacecc166937b6282b079ef7c1,#71 Don't fail on non-exists dir in $PATH,2015-04-21 08:45:45+02:00,nvbn,2,2,4,2,"['setup.py', 'no_command.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=""1.20"",\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _safe(fn, fallback):\n    try:\n        return fn()\n    except OSError:\n        return fallback\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ['PATH'].split(':')\n            for exe in _safe(Path(path).iterdir, [])\n            if not _safe(exe.is_dir, True)]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n""]","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=""1.21"",\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _safe(fn, fallback):\n    try:\n        return fn()\n    except OSError:\n        return fallback\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ['PATH'].split(':')\n            for exe in _safe(lambda: Path(path).iterdir(), [])\n            if not _safe(exe.is_dir, True)]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e29bb0>, <pydriller.domain.commit.Method object at 0x7f1983e297c0>, <pydriller.domain.commit.Method object at 0x7f1983e29250>, <pydriller.domain.commit.Method object at 0x7f1983e298e0>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e23d00>]]"
thefuck,bd5f5045aa208e737ce61f77b279574cd5a8e31b,#71 Handle `iterdir` iterator fails,2015-04-21 08:57:35+02:00,nvbn,3,3,6,2,"['setup.py', 'no_command.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=""1.21"",\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _safe(fn, fallback):\n    try:\n        return fn()\n    except OSError:\n        return fallback\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ['PATH'].split(':')\n            for exe in _safe(lambda: Path(path).iterdir(), [])\n            if not _safe(exe.is_dir, True)]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n""]","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=""1.22"",\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _safe(fn, fallback):\n    try:\n        return fn()\n    except OSError:\n        return fallback\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ.get('PATH', '').split(':')\n            for exe in _safe(lambda: list(Path(path).iterdir()), [])\n            if not _safe(exe.is_dir, True)]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e86b80>, <pydriller.domain.commit.Method object at 0x7f1983e86cd0>, <pydriller.domain.commit.Method object at 0x7f1983e86bb0>, <pydriller.domain.commit.Method object at 0x7f1983e86a30>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e0c910>]]"
thefuck,3af5c80d293c579591b58f63a5b01574f76991c9,Add 'root privilege' pattern to sudo rule.,2015-04-21 12:57:35+04:30,Soheil Rashidi,2,1,3,1,['sudo.py'],"[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted',\n            'root privilege']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983e12520>, <pydriller.domain.commit.Method object at 0x7f1983e12f70>]]",[[]]
thefuck,de4b774134ed671451a6b44c5d8628a227bf25c4,Added a string which could be thrown by Fedora's new dnf package manager.,2015-04-21 19:43:10+08:00,Dugucloud,2,1,3,1,['sudo.py'],"[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted',\n            'This command has to be run under the root user.']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983e347c0>, <pydriller.domain.commit.Method object at 0x7f1983e34e50>]]",[[]]
thefuck,d5b4bddc4cf958e362ed0ee1b8a6c474fc78e242,#74 Don't fail when runned without args,2015-04-21 14:26:45+02:00,nvbn,5,0,5,2,"['test_main.py', 'main.py']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","[[<pydriller.domain.commit.Method object at 0x7f1983d0b6a0>, <pydriller.domain.commit.Method object at 0x7f1983d902e0>, <pydriller.domain.commit.Method object at 0x7f1983d9c430>, <pydriller.domain.commit.Method object at 0x7f1983d9cac0>, <pydriller.domain.commit.Method object at 0x7f1983ce9e80>, <pydriller.domain.commit.Method object at 0x7f1983ce9fd0>, <pydriller.domain.commit.Method object at 0x7f1983d3b940>, <pydriller.domain.commit.Method object at 0x7f1983d3b7f0>], [<pydriller.domain.commit.Method object at 0x7f1983dcf820>, <pydriller.domain.commit.Method object at 0x7f1983dcf190>, <pydriller.domain.commit.Method object at 0x7f1983dcffd0>, <pydriller.domain.commit.Method object at 0x7f1983dcf970>, <pydriller.domain.commit.Method object at 0x7f1983e17130>, <pydriller.domain.commit.Method object at 0x7f1983e178e0>, <pydriller.domain.commit.Method object at 0x7f1983e17b80>, <pydriller.domain.commit.Method object at 0x7f1983e17790>, <pydriller.domain.commit.Method object at 0x7f1983e174f0>, <pydriller.domain.commit.Method object at 0x7f1983e17280>, <pydriller.domain.commit.Method object at 0x7f1983e17250>, <pydriller.domain.commit.Method object at 0x7f1983e17cd0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983e2e3d0>], [<pydriller.domain.commit.Method object at 0x7f1983ddb820>]]"
thefuck,888756d519ba1915c37e2da3e137f35c2e5e3cea,#74 Don't fail when rule throws exception,2015-04-21 14:40:52+02:00,nvbn,25,16,41,2,"['test_main.py', 'main.py']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule('bash', match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash', 'bash'),\n                                  main.Rule('lisp', 'lisp', 'lisp'),\n                                  main.Rule('bash', 'bash', 'bash'),\n                                  main.Rule('lisp', 'lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash', 'bash'),\n                                      main.Rule('bash', 'bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None),\n             main.Rule('', lambda *_: False, None),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0]\\\n           == '[WARN] rule: Traceback (most recent call last):'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom traceback import format_exception\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            sys.stderr.write(u\'[WARN] {}: {}---------------------\\n\\n\'.format(\n                rule.name, \'\'.join(format_exception(*sys.exc_info()))))\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","[[<pydriller.domain.commit.Method object at 0x7f1983e1df70>, <pydriller.domain.commit.Method object at 0x7f1983e1dd00>, <pydriller.domain.commit.Method object at 0x7f1983e1d100>, <pydriller.domain.commit.Method object at 0x7f1983e1da60>, <pydriller.domain.commit.Method object at 0x7f1983e04550>, <pydriller.domain.commit.Method object at 0x7f1983e04ac0>, <pydriller.domain.commit.Method object at 0x7f1983e04fd0>, <pydriller.domain.commit.Method object at 0x7f1983e04430>], [<pydriller.domain.commit.Method object at 0x7f1983deb040>, <pydriller.domain.commit.Method object at 0x7f1983deb580>, <pydriller.domain.commit.Method object at 0x7f1983deb2b0>, <pydriller.domain.commit.Method object at 0x7f1983deb6d0>, <pydriller.domain.commit.Method object at 0x7f1983e3c250>, <pydriller.domain.commit.Method object at 0x7f1983e3cbb0>, <pydriller.domain.commit.Method object at 0x7f1983e3c4f0>, <pydriller.domain.commit.Method object at 0x7f1983e3ca60>, <pydriller.domain.commit.Method object at 0x7f1983e3c8e0>, <pydriller.domain.commit.Method object at 0x7f1983e3c670>, <pydriller.domain.commit.Method object at 0x7f1983e3c3a0>, <pydriller.domain.commit.Method object at 0x7f1983e3c910>]]","[[<pydriller.domain.commit.Method object at 0x7f1983dca940>, <pydriller.domain.commit.Method object at 0x7f1983e09eb0>, <pydriller.domain.commit.Method object at 0x7f1983e04ac0>, <pydriller.domain.commit.Method object at 0x7f1983dca190>, <pydriller.domain.commit.Method object at 0x7f1983e09160>], [<pydriller.domain.commit.Method object at 0x7f1983deb970>, <pydriller.domain.commit.Method object at 0x7f1983dacd30>]]"
thefuck,54d82f9528ae9cb0b7fa62522156ad832c976ed1,Bump version,2015-04-21 14:41:28+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=""1.22"",\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=""1.23"",\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,93b6a623e1c527b8e08093a986ca23fbb189d949,"adding rule to run ""sudo apt-get install""",2015-04-21 17:59:44+02:00,Lukas Vacek,28,0,28,1,['apt_get.py'],[None],"['import sys\n\ndef match(command, settings):\n    try:\n        import CommandNotFound\n        if \'not found\' in command.stderr:\n            try:\n                c = CommandNotFound.CommandNotFound()\n                pkgs = c.getPackages(command.script.split("" "")[0])\n                name,_ = pkgs[0]\n                return True\n            except IndexError:\n                # IndexError is thrown when no matching package is found\n                return False\n    except:\n        return False\n\ndef get_new_command(command, settings):\n    try:\n        import CommandNotFound\n        c = CommandNotFound.CommandNotFound()\n        if \'not found\' in command.stderr:\n            pkgs = c.getPackages(command.script.split("" "")[0])\n            name,_ = pkgs[0]\n            return ""sudo apt-get install %s"" % name\n    except:\n        sys.stderr.write(""Can\'t apt fuck\\n"")\n        return """"\n']",[[]],"[[<pydriller.domain.commit.Method object at 0x7f1983cd7970>, <pydriller.domain.commit.Method object at 0x7f1983cd72b0>]]"
thefuck,943613a194ee76be9a73eedcb82c0036bb37b3f0,add thing for when known hosts have changed,2015-04-21 17:05:52+01:00,Nic West,112,0,112,2,"['test_ssh_known_host.py', 'ssh_known_hosts.py']","[None, None]","['import os\nimport pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.ssh_known_hosts import match, get_new_command, remove_offending_keys\n\n\n@pytest.fixture\ndef ssh_error(tmpdir):\n    path = os.path.join(str(tmpdir), \'known_hosts\')\n\n    def reset(path):\n        with open(path, \'w\') as fh:\n            lines = [\n                \'123.234.567.890 asdjkasjdakjsd\\n\'\n                \'98.765.432.321 ejioweojwejrosj\\n\'\n                \'111.222.333.444 qwepoiwqepoiss\\n\'\n            ]\n            fh.writelines(lines)\n\n    def known_hosts(path):\n        with open(path, \'r\') as fh:\n            return fh.readlines()\n\n    reset(path)\n\n    errormsg = u""""""@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\nb6:cb:07:34:c0:a0:94:d3:0d:69:83:31:f4:c5:20:9b.\nPlease contact your system administrator.\nAdd correct host key in {0} to get rid of this message.\nOffending RSA key in {0}:2\nRSA host key for {1} has changed and you have requested strict checking.\nHost key verification failed."""""".format(path, \'98.765.432.321\')\n\n    return errormsg, path, reset, known_hosts\n\n\ndef test_match(ssh_error):\n    errormsg, _, _, _ = ssh_error    \n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert not match(Command(\'\', \'\', errormsg), None)\n    assert not match(Command(\'notssh\', \'\', errormsg), None)\n    assert not match(Command(\'ssh\', \'\', \'\'), None)\n\n\ndef test_remove_offending_keys(ssh_error):\n    errormsg, path, reset, known_hosts = ssh_error\n    command = Command(\'ssh user@host\', \'\', errormsg)\n    remove_offending_keys(command, None)\n    expected =[\'123.234.567.890 asdjkasjdakjsd\\n\', \'111.222.333.444 qwepoiwqepoiss\\n\']\n    assert known_hosts(path) == expected\n\n\ndef test_get_new_command(ssh_error, monkeypatch):\n    errormsg, _, _, _ = ssh_error\n\n    class Mock:\n        was_called = False\n\n        def __call__(self, *args, **kwargs):\n            self.was_called = True\n\n    method = Mock()\n    monkeypatch.setattr(\'thefuck.rules.ssh_known_hosts.remove_offending_keys\', method)\n    assert get_new_command(Command(\'ssh user@host\', \'\', errormsg), None) == \'ssh user@host\'\n    assert method.was_called\n', 'import re\npatterns = [\n    r\'WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!\',\n    r\'WARNING: POSSIBLE DNS SPOOFING DETECTED!\',\n    r""Warning: the \\S+ host key for \'([^\']+)\' differs from the key for the IP address \'([^\']+)\'"",\n]\noffending_pattern = re.compile(\n    r\'(?:Offending (?:key for IP|\\S+ key)|Matching host key) in ([^:]+):(\\d+)\',\n    re.MULTILINE)\n\ncommands = [\'ssh\', \'scp\']\n\n\ndef match(command, settings):\n    if not command.script:\n        return False\n    if not command.script.split()[0] in commands:\n        return False\n    if not any([re.findall(pattern, command.stderr) for pattern in patterns]):\n        return False\n    return True\n\n\ndef remove_offending_keys(command, settings):\n    offending = offending_pattern.findall(command.stderr)\n    print offending\n    for filepath, lineno in offending:\n        with open(filepath, \'r\') as fh:\n            lines = fh.readlines()\n            del lines[int(lineno) - 1]\n            print lines\n        with open(filepath, \'w\') as fh:\n            fh.writelines(lines)\n\n\ndef get_new_command(command, settings):\n    remove_offending_keys(command, settings)\n    return command.script\n']","[[], []]","[[<pydriller.domain.commit.Method object at 0x7f1983dc5eb0>, <pydriller.domain.commit.Method object at 0x7f1983d9ca90>, <pydriller.domain.commit.Method object at 0x7f1983ddf550>, <pydriller.domain.commit.Method object at 0x7f1983d90430>, <pydriller.domain.commit.Method object at 0x7f1983ddf820>, <pydriller.domain.commit.Method object at 0x7f1983dc5820>, <pydriller.domain.commit.Method object at 0x7f1983d906d0>], [<pydriller.domain.commit.Method object at 0x7f1983e23520>, <pydriller.domain.commit.Method object at 0x7f1983e23130>, <pydriller.domain.commit.Method object at 0x7f1983e23790>]]"
thefuck,2a7cbef3b5e364fa6da4850178b06ed85bb5304c,add tests for cd_parent,2015-04-21 23:41:49+05:30,SanketDG,12,0,12,1,['test_cd_parent.py'],[None],"[""from thefuck.main import Command\nfrom thefuck.rules.cd_parent import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('cd..', '', 'cd..: command not found'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(\n        Command('cd..', '', ''), None) == 'cd ..'\n""]",[[]],"[[<pydriller.domain.commit.Method object at 0x7f1983e12cd0>, <pydriller.domain.commit.Method object at 0x7f1983e12fa0>]]"
thefuck,4b8d4926aa2362340f4e8b57ee55e48846ccb6c3,Add Greek to switch lang,2015-04-21 22:00:05+02:00,Dionysis Zindros,2,1,3,1,['switch_lang.py'],"['# -*- encoding: utf-8 -*-\n\ntarget_layout = \'\'\'qwertyuiop[]asdfghjkl;\'zxcvbnm,./QWERTYUIOP{}ASDFGHJKL:""ZXCVBNM<>?\'\'\'\n\nsource_layouts = [u\'\'\'йцукенгшщзхъфывапролджэячсмитьбю.ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,\'\'\',\n                  u\'\'\'ضصثقفغعهخحجچشسیبلاتنمکگظطزرذدپو./ًٌٍَُِّْ][}{ؤئيإأآة»«:؛كٓژٰ\u200cٔء><؟\'\'\']\n\n\ndef _get_matched_layout(command):\n    for source_layout in source_layouts:\n        if all([ch in source_layout or ch in \'-_\'\n                for ch in command.script.split(\' \')[0]]):\n            return source_layout\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and _get_matched_layout(command)\n\n\ndef _switch(ch, layout):\n    if ch in layout:\n        return target_layout[layout.index(ch)]\n    else:\n        return ch\n\n\ndef get_new_command(command, settings):\n    matched_layout = _get_matched_layout(command)\n    return \'\'.join(_switch(ch, matched_layout) for ch in command.script)\n\n']","['# -*- encoding: utf-8 -*-\n\ntarget_layout = \'\'\'qwertyuiop[]asdfghjkl;\'zxcvbnm,./QWERTYUIOP{}ASDFGHJKL:""ZXCVBNM<>?\'\'\'\n\nsource_layouts = [u\'\'\'йцукенгшщзхъфывапролджэячсмитьбю.ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,\'\'\',\n                  u\'\'\'ضصثقفغعهخحجچشسیبلاتنمکگظطزرذدپو./ًٌٍَُِّْ][}{ؤئيإأآة»«:؛كٓژٰ\u200cٔء><؟\'\'\',\n                  u\'\'\';ςερτυθιοπ[]ασδφγηξκλ΄ζχψωβνμ,./:΅ΕΡΤΥΘΙΟΠ{}ΑΣΔΦΓΗΞΚΛ¨""ΖΧΨΩΒΝΜ<>?\'\'\']\n\n\ndef _get_matched_layout(command):\n    for source_layout in source_layouts:\n        if all([ch in source_layout or ch in \'-_\'\n                for ch in command.script.split(\' \')[0]]):\n            return source_layout\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and _get_matched_layout(command)\n\n\ndef _switch(ch, layout):\n    if ch in layout:\n        return target_layout[layout.index(ch)]\n    else:\n        return ch\n\n\ndef get_new_command(command, settings):\n    matched_layout = _get_matched_layout(command)\n    return \'\'.join(_switch(ch, matched_layout) for ch in command.script)\n\n']","[[<pydriller.domain.commit.Method object at 0x7f1983e86e20>, <pydriller.domain.commit.Method object at 0x7f1983e86d00>, <pydriller.domain.commit.Method object at 0x7f1983e86a60>, <pydriller.domain.commit.Method object at 0x7f1983e868e0>]]",[[]]
thefuck,4f10fe647d31e455c2a43c6ea326cf6f3c1d49ac,Add tests for greek langage,2015-04-21 22:09:48+02:00,Dionysis Zindros,7,0,7,1,['test_switch_lang.py'],"[""# -*- encoding: utf-8 -*-\n\nfrom mock import Mock\nfrom thefuck.rules import switch_lang\n\n\ndef test_match():\n    assert switch_lang.match(Mock(stderr='command not found: фзе-пуе',\n                                  script=u'фзе-пуе'), None)\n    assert not switch_lang.match(Mock(stderr='command not found: pat-get',\n                                      script=u'pat-get'), None)\n    assert not switch_lang.match(Mock(stderr='some info',\n                                      script=u'фзе-пуе'), None)\n\n\ndef test_get_new_command():\n    assert switch_lang.get_new_command(\n        Mock(script=u'фзе-пуе штыефдд мшь'), None) == 'apt-get install vim'\n""]","[""# -*- encoding: utf-8 -*-\n\nfrom mock import Mock\nfrom thefuck.rules import switch_lang\n\n\ndef test_match():\n    assert switch_lang.match(Mock(stderr='command not found: фзе-пуе',\n                                  script=u'фзе-пуе'), None)\n    assert switch_lang.match(Mock(stderr='command not found: λσ',\n                                  script=u'λσ'), None)\n\n    assert not switch_lang.match(Mock(stderr='command not found: pat-get',\n                                      script=u'pat-get'), None)\n    assert not switch_lang.match(Mock(stderr='command not found: ls',\n                                      script=u'ls'), None)\n    assert not switch_lang.match(Mock(stderr='some info',\n                                      script=u'фзе-пуе'), None)\n\n\ndef test_get_new_command():\n    assert switch_lang.get_new_command(\n        Mock(script=u'фзе-пуе штыефдд мшь'), None) == 'apt-get install vim'\n    assert switch_lang.get_new_command(\n        Mock(script=u'λσ -λα'), None) == 'ls -la'\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983e7ad00>, <pydriller.domain.commit.Method object at 0x7f1983e7afa0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983e817c0>, <pydriller.domain.commit.Method object at 0x7f1983e81d00>]]"
thefuck,d1416a6c2a54cfba46675b44a2b99a0cd05d7c83,"#82 Remove unned print, fix python 3 support",2015-04-21 22:10:53+02:00,nvbn,5,11,16,2,"['test_ssh_known_host.py', 'ssh_known_hosts.py']","['import os\nimport pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.ssh_known_hosts import match, get_new_command, remove_offending_keys\n\n\n@pytest.fixture\ndef ssh_error(tmpdir):\n    path = os.path.join(str(tmpdir), \'known_hosts\')\n\n    def reset(path):\n        with open(path, \'w\') as fh:\n            lines = [\n                \'123.234.567.890 asdjkasjdakjsd\\n\'\n                \'98.765.432.321 ejioweojwejrosj\\n\'\n                \'111.222.333.444 qwepoiwqepoiss\\n\'\n            ]\n            fh.writelines(lines)\n\n    def known_hosts(path):\n        with open(path, \'r\') as fh:\n            return fh.readlines()\n\n    reset(path)\n\n    errormsg = u""""""@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\nb6:cb:07:34:c0:a0:94:d3:0d:69:83:31:f4:c5:20:9b.\nPlease contact your system administrator.\nAdd correct host key in {0} to get rid of this message.\nOffending RSA key in {0}:2\nRSA host key for {1} has changed and you have requested strict checking.\nHost key verification failed."""""".format(path, \'98.765.432.321\')\n\n    return errormsg, path, reset, known_hosts\n\n\ndef test_match(ssh_error):\n    errormsg, _, _, _ = ssh_error    \n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert not match(Command(\'\', \'\', errormsg), None)\n    assert not match(Command(\'notssh\', \'\', errormsg), None)\n    assert not match(Command(\'ssh\', \'\', \'\'), None)\n\n\ndef test_remove_offending_keys(ssh_error):\n    errormsg, path, reset, known_hosts = ssh_error\n    command = Command(\'ssh user@host\', \'\', errormsg)\n    remove_offending_keys(command, None)\n    expected =[\'123.234.567.890 asdjkasjdakjsd\\n\', \'111.222.333.444 qwepoiwqepoiss\\n\']\n    assert known_hosts(path) == expected\n\n\ndef test_get_new_command(ssh_error, monkeypatch):\n    errormsg, _, _, _ = ssh_error\n\n    class Mock:\n        was_called = False\n\n        def __call__(self, *args, **kwargs):\n            self.was_called = True\n\n    method = Mock()\n    monkeypatch.setattr(\'thefuck.rules.ssh_known_hosts.remove_offending_keys\', method)\n    assert get_new_command(Command(\'ssh user@host\', \'\', errormsg), None) == \'ssh user@host\'\n    assert method.was_called\n', 'import re\npatterns = [\n    r\'WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!\',\n    r\'WARNING: POSSIBLE DNS SPOOFING DETECTED!\',\n    r""Warning: the \\S+ host key for \'([^\']+)\' differs from the key for the IP address \'([^\']+)\'"",\n]\noffending_pattern = re.compile(\n    r\'(?:Offending (?:key for IP|\\S+ key)|Matching host key) in ([^:]+):(\\d+)\',\n    re.MULTILINE)\n\ncommands = [\'ssh\', \'scp\']\n\n\ndef match(command, settings):\n    if not command.script:\n        return False\n    if not command.script.split()[0] in commands:\n        return False\n    if not any([re.findall(pattern, command.stderr) for pattern in patterns]):\n        return False\n    return True\n\n\ndef remove_offending_keys(command, settings):\n    offending = offending_pattern.findall(command.stderr)\n    print offending\n    for filepath, lineno in offending:\n        with open(filepath, \'r\') as fh:\n            lines = fh.readlines()\n            del lines[int(lineno) - 1]\n            print lines\n        with open(filepath, \'w\') as fh:\n            fh.writelines(lines)\n\n\ndef get_new_command(command, settings):\n    remove_offending_keys(command, settings)\n    return command.script\n']","['import os\nimport pytest\nfrom mock import Mock\nfrom thefuck.main import Command\nfrom thefuck.rules.ssh_known_hosts import match, get_new_command, remove_offending_keys\n\n\n@pytest.fixture\ndef ssh_error(tmpdir):\n    path = os.path.join(str(tmpdir), \'known_hosts\')\n\n    def reset(path):\n        with open(path, \'w\') as fh:\n            lines = [\n                \'123.234.567.890 asdjkasjdakjsd\\n\'\n                \'98.765.432.321 ejioweojwejrosj\\n\'\n                \'111.222.333.444 qwepoiwqepoiss\\n\'\n            ]\n            fh.writelines(lines)\n\n    def known_hosts(path):\n        with open(path, \'r\') as fh:\n            return fh.readlines()\n\n    reset(path)\n\n    errormsg = u""""""@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\nb6:cb:07:34:c0:a0:94:d3:0d:69:83:31:f4:c5:20:9b.\nPlease contact your system administrator.\nAdd correct host key in {0} to get rid of this message.\nOffending RSA key in {0}:2\nRSA host key for {1} has changed and you have requested strict checking.\nHost key verification failed."""""".format(path, \'98.765.432.321\')\n\n    return errormsg, path, reset, known_hosts\n\n\ndef test_match(ssh_error):\n    errormsg, _, _, _ = ssh_error\n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert not match(Command(\'\', \'\', errormsg), None)\n    assert not match(Command(\'notssh\', \'\', errormsg), None)\n    assert not match(Command(\'ssh\', \'\', \'\'), None)\n\n\ndef test_remove_offending_keys(ssh_error):\n    errormsg, path, reset, known_hosts = ssh_error\n    command = Command(\'ssh user@host\', \'\', errormsg)\n    remove_offending_keys(command, None)\n    expected = [\'123.234.567.890 asdjkasjdakjsd\\n\', \'111.222.333.444 qwepoiwqepoiss\\n\']\n    assert known_hosts(path) == expected\n\n\ndef test_get_new_command(ssh_error, monkeypatch):\n    errormsg, _, _, _ = ssh_error\n\n    method = Mock()\n    monkeypatch.setattr(\'thefuck.rules.ssh_known_hosts.remove_offending_keys\', method)\n    assert get_new_command(Command(\'ssh user@host\', \'\', errormsg), None) == \'ssh user@host\'\n    assert method.call_count\n', 'import re\n\npatterns = [\n    r\'WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!\',\n    r\'WARNING: POSSIBLE DNS SPOOFING DETECTED!\',\n    r""Warning: the \\S+ host key for \'([^\']+)\' differs from the key for the IP address \'([^\']+)\'"",\n]\noffending_pattern = re.compile(\n    r\'(?:Offending (?:key for IP|\\S+ key)|Matching host key) in ([^:]+):(\\d+)\',\n    re.MULTILINE)\n\ncommands = [\'ssh\', \'scp\']\n\n\ndef match(command, settings):\n    if not command.script:\n        return False\n    if not command.script.split()[0] in commands:\n        return False\n    if not any([re.findall(pattern, command.stderr) for pattern in patterns]):\n        return False\n    return True\n\n\ndef remove_offending_keys(command, settings):\n    offending = offending_pattern.findall(command.stderr)\n    for filepath, lineno in offending:\n        with open(filepath, \'r\') as fh:\n            lines = fh.readlines()\n            del lines[int(lineno) - 1]\n        with open(filepath, \'w\') as fh:\n            fh.writelines(lines)\n\n\ndef get_new_command(command, settings):\n    remove_offending_keys(command, settings)\n    return command.script\n']","[[<pydriller.domain.commit.Method object at 0x7f1983e6ea30>, <pydriller.domain.commit.Method object at 0x7f1983e6eb80>, <pydriller.domain.commit.Method object at 0x7f1983e6ea60>, <pydriller.domain.commit.Method object at 0x7f1983e6e8e0>, <pydriller.domain.commit.Method object at 0x7f1983e6e3a0>, <pydriller.domain.commit.Method object at 0x7f1983e6e3d0>, <pydriller.domain.commit.Method object at 0x7f1983e6e250>], [<pydriller.domain.commit.Method object at 0x7f1983e68bb0>, <pydriller.domain.commit.Method object at 0x7f1983e68cd0>, <pydriller.domain.commit.Method object at 0x7f1983e68d00>]]","[[<pydriller.domain.commit.Method object at 0x7f1983e743a0>, <pydriller.domain.commit.Method object at 0x7f1983e74cd0>, <pydriller.domain.commit.Method object at 0x7f1983e6e3d0>, <pydriller.domain.commit.Method object at 0x7f1983e74a30>], [<pydriller.domain.commit.Method object at 0x7f1983e68cd0>]]"
thefuck,20f8a4ad17e4fb014d38a390b98fed872cc4ebc8,Bump to 1.24,2015-04-21 22:30:15+02:00,nvbn,36,2,38,2,"['release.py', 'setup.py']","[None, 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=""1.23"",\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['#!/usr/bin/env python\nfrom subprocess import call\nimport re\n\n\nversion = None\n\n\ndef get_new_setup_py_lines():\n    global version\n    with open(\'setup.py\', \'r\') as sf:\n        current_setup = sf.readlines()\n    for line in current_setup:\n        if line.startswith(\'VERSION = \'):\n            major, minor = re.findall(r""VERSION = \'(\\d+)\\.(\\d+)\'"", line)[0]\n            version = ""{}.{}"".format(major, int(minor) + 1)\n            yield ""VERSION = \'{}\'\\n"".format(version)\n        else:\n            yield line\n\n\nlines = list(get_new_setup_py_lines())\nwith open(\'setup.py\', \'w\') as sf:\n    sf.writelines(lines)\n\ncall(\'git commit -am ""Bump to {}""\'.format(version), shell=True)\ncall(\'git tag {}\'.format(version), shell=True)\ncall(\'git push\', shell=True)\ncall(\'git push --tags\', shell=True)\ncall(\'python setup.py sdist upload\', shell=True)\n', 'from setuptools import setup, find_packages\n\n\nVERSION = \'1.24\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","[[], []]","[[<pydriller.domain.commit.Method object at 0x7f1983e74910>], []]"
thefuck,d1b1465f4e80dc08fd210638c05248890c974b35,Bump to 1.26,2015-04-21 22:31:01+02:00,nvbn,2,1,3,2,"['release.py', 'setup.py']","['#!/usr/bin/env python\nfrom subprocess import call\nimport re\n\n\nversion = None\n\n\ndef get_new_setup_py_lines():\n    global version\n    with open(\'setup.py\', \'r\') as sf:\n        current_setup = sf.readlines()\n    for line in current_setup:\n        if line.startswith(\'VERSION = \'):\n            major, minor = re.findall(r""VERSION = \'(\\d+)\\.(\\d+)\'"", line)[0]\n            version = ""{}.{}"".format(major, int(minor) + 1)\n            yield ""VERSION = \'{}\'\\n"".format(version)\n        else:\n            yield line\n\n\nlines = list(get_new_setup_py_lines())\nwith open(\'setup.py\', \'w\') as sf:\n    sf.writelines(lines)\n\ncall(\'git commit -am ""Bump to {}""\'.format(version), shell=True)\ncall(\'git tag {}\'.format(version), shell=True)\ncall(\'git push\', shell=True)\ncall(\'git push --tags\', shell=True)\ncall(\'python setup.py sdist upload\', shell=True)\n', 'from setuptools import setup, find_packages\n\n\nVERSION = \'1.24\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['#!/usr/bin/env python\nfrom subprocess import call\nimport re\n\n\nversion = None\n\n\ndef get_new_setup_py_lines():\n    global version\n    with open(\'setup.py\', \'r\') as sf:\n        current_setup = sf.readlines()\n    for line in current_setup:\n        if line.startswith(\'VERSION = \'):\n            major, minor = re.findall(r""VERSION = \'(\\d+)\\.(\\d+)\'"", line)[0]\n            version = ""{}.{}"".format(major, int(minor) + 1)\n            yield ""VERSION = \'{}\'\\n"".format(version)\n        else:\n            yield line\n\n\nlines = list(get_new_setup_py_lines())\nwith open(\'setup.py\', \'w\') as sf:\n    sf.writelines(lines)\n\ncall(\'git pull\', shell=True)\ncall(\'git commit -am ""Bump to {}""\'.format(version), shell=True)\ncall(\'git tag {}\'.format(version), shell=True)\ncall(\'git push\', shell=True)\ncall(\'git push --tags\', shell=True)\ncall(\'python setup.py sdist upload\', shell=True)\n', 'from setuptools import setup, find_packages\n\n\nVERSION = \'1.26\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","[[<pydriller.domain.commit.Method object at 0x7f1983e0cb80>], []]","[[], []]"
thefuck,79fb7c987cb589fb6fa296121f9ea392feb4752d,Added sudo rule for Fedora yum's output.,2015-04-22 09:26:45+08:00,Dugucloud,2,1,3,1,['sudo.py'],"[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted',\n            'root privilege',\n            'This command has to be run under the root user.']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted',\n            'root privilege',\n            'This command has to be run under the root user.',\n            'You need to be root to perform this command.']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983d90be0>, <pydriller.domain.commit.Method object at 0x7f1983d90550>]]",[[]]
thefuck,126194ec2ee0045efb3fe8a2ccf85087352ad04f,"Put errors in stderr instead of ""echo ..."" in stdout",2015-04-22 05:29:44+02:00,nvbn,2,2,4,1,['main.py'],"['from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom traceback import format_exception\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            sys.stderr.write(u\'[WARN] {}: {}---------------------\\n\\n\'.format(\n                rule.name, \'\'.join(format_exception(*sys.exc_info()))))\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","['from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom traceback import format_exception\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            sys.stderr.write(u\'[WARN] {}: {}---------------------\\n\\n\'.format(\n                rule.name, \'\'.join(format_exception(*sys.exc_info()))))\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            sys.stderr.write(""Can\'t fuck twice\\n"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    sys.stderr.write(\'No fuck given\\n\')\n']","[[<pydriller.domain.commit.Method object at 0x7f1983deb940>, <pydriller.domain.commit.Method object at 0x7f1983debac0>, <pydriller.domain.commit.Method object at 0x7f1983deba90>, <pydriller.domain.commit.Method object at 0x7f1983deb6a0>, <pydriller.domain.commit.Method object at 0x7f1983e628e0>, <pydriller.domain.commit.Method object at 0x7f1983e62910>, <pydriller.domain.commit.Method object at 0x7f1983e62790>, <pydriller.domain.commit.Method object at 0x7f1983e627c0>, <pydriller.domain.commit.Method object at 0x7f1983e62640>, <pydriller.domain.commit.Method object at 0x7f1983e62670>, <pydriller.domain.commit.Method object at 0x7f1983e624f0>, <pydriller.domain.commit.Method object at 0x7f1983e62520>]]",[[<pydriller.domain.commit.Method object at 0x7f1983e1d4f0>]]
thefuck,5d424dad88c71b926c6356df6e207cceb5a05c5a,Use colorama for colored output,2015-04-22 06:03:06+02:00,nvbn,76,18,94,6,"['README.md', 'setup.py', 'test_logs.py', 'test_main.py', 'logs.py', 'main.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', 'from setuptools import setup, find_packages\n\n\nVERSION = \'1.26\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', None, ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule('bash', match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash', 'bash'),\n                                  main.Rule('lisp', 'lisp', 'lisp'),\n                                  main.Rule('bash', 'bash', 'bash'),\n                                  main.Rule('lisp', 'lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash', 'bash'),\n                                      main.Rule('bash', 'bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None),\n             main.Rule('', lambda *_: False, None),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0]\\\n           == '[WARN] rule: Traceback (most recent call last):'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n"", None, 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom traceback import format_exception\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            sys.stderr.write(u\'[WARN] {}: {}---------------------\\n\\n\'.format(\n                rule.name, \'\'.join(format_exception(*sys.exc_info()))))\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            sys.stderr.write(""Can\'t fuck twice\\n"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    sys.stderr.write(\'No fuck given\\n\')\n']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', 'from setuptools import setup, find_packages\n\n\nVERSION = \'1.26\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from mock import Mock\nfrom thefuck import logs\n\n\ndef test_color():\n    assert logs.color('red', Mock(no_colors=False)) == 'red'\n    assert logs.color('red', Mock(no_colors=True)) == ''\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule('bash', match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash', 'bash'),\n                                  main.Rule('lisp', 'lisp', 'lisp'),\n                                  main.Rule('bash', 'bash', 'bash'),\n                                  main.Rule('lisp', 'lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash', 'bash'),\n                                      main.Rule('bash', 'bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None),\n             main.Rule('', lambda *_: False, None),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0]\\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", 'import sys\nfrom traceback import format_exception\nimport colorama\n\n\ndef color(color_, settings):\n    """"""Utility for ability to disabling colored output.""""""\n    if settings.no_colors:\n        return \'\'\n    else:\n        return color_\n\n\ndef rule_failed(rule, exc_info, settings):\n    sys.stderr.write(\n        u\'{warn}[WARN] Rule {name}:{reset}\\n{trace}\'\n        u\'{warn}----------------------------{reset}\\n\\n\'.format(\n            warn=color(colorama.Back.RED + colorama.Fore.WHITE\n                       + colorama.Style.BRIGHT, settings),\n            reset=color(colorama.Style.RESET_ALL, settings),\n            name=rule.name,\n            trace=\'\'.join(format_exception(*exc_info))))\n\n\ndef show_command(new_command, settings):\n    sys.stderr.write(\'{bold}{command}{reset}\\n\'.format(\n        command=new_command,\n        bold=color(colorama.Style.BRIGHT, settings),\n        reset=color(colorama.Style.RESET_ALL, settings)))\n\n\ndef confirm_command(new_command, settings):\n    sys.stderr.write(\n        \'{bold}{command}{reset} [{green}enter{reset}/{red}ctrl+c{reset}]\'.format(\n            command=new_command,\n            bold=color(colorama.Style.BRIGHT, settings),\n            green=color(colorama.Fore.GREEN, settings),\n            red=color(colorama.Fore.RED, settings),\n            reset=color(colorama.Style.RESET_ALL, settings)))\n    sys.stderr.flush()\n\n\ndef failed(msg, settings):\n    sys.stderr.write(\'{red}{msg}{reset}\\n\'.format(\n        msg=msg,\n        red=color(colorama.Fore.RED, settings),\n        reset=color(colorama.Style.RESET_ALL, settings)))\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom thefuck import logs\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    settings.__dict__.setdefault(\'no_colors\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n']","[[], [], [], [<pydriller.domain.commit.Method object at 0x7f1983e17520>, <pydriller.domain.commit.Method object at 0x7f1983de62b0>, <pydriller.domain.commit.Method object at 0x7f1983de66d0>, <pydriller.domain.commit.Method object at 0x7f1983de6580>, <pydriller.domain.commit.Method object at 0x7f1983db12e0>, <pydriller.domain.commit.Method object at 0x7f1983d95c10>, <pydriller.domain.commit.Method object at 0x7f1983d956a0>, <pydriller.domain.commit.Method object at 0x7f1983e1d520>], [], [<pydriller.domain.commit.Method object at 0x7f1983e0ce50>, <pydriller.domain.commit.Method object at 0x7f1983e0c640>, <pydriller.domain.commit.Method object at 0x7f1983e86280>, <pydriller.domain.commit.Method object at 0x7f1983e86f70>, <pydriller.domain.commit.Method object at 0x7f1983e81100>, <pydriller.domain.commit.Method object at 0x7f1983e81cd0>, <pydriller.domain.commit.Method object at 0x7f1983e81790>, <pydriller.domain.commit.Method object at 0x7f1983e81fa0>, <pydriller.domain.commit.Method object at 0x7f1983e81640>, <pydriller.domain.commit.Method object at 0x7f1983e81bb0>, <pydriller.domain.commit.Method object at 0x7f1983e81e50>, <pydriller.domain.commit.Method object at 0x7f1983e81520>]]","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983e57b80>], [<pydriller.domain.commit.Method object at 0x7f1983e62fa0>, <pydriller.domain.commit.Method object at 0x7f1983debc10>], [<pydriller.domain.commit.Method object at 0x7f1983e293a0>, <pydriller.domain.commit.Method object at 0x7f1983d62be0>, <pydriller.domain.commit.Method object at 0x7f1983d62c10>, <pydriller.domain.commit.Method object at 0x7f1983d62190>, <pydriller.domain.commit.Method object at 0x7f1983d622e0>], [<pydriller.domain.commit.Method object at 0x7f1983e0c520>, <pydriller.domain.commit.Method object at 0x7f1983e0c130>, <pydriller.domain.commit.Method object at 0x7f1983e0cfa0>, <pydriller.domain.commit.Method object at 0x7f1983e23250>]]"
thefuck,957209bdb681ba169dc7b0ce4088554b51f7b6fd,Add ability to bundle disabled by default rules,2015-04-22 15:59:44+02:00,nvbn,43,25,68,2,"['test_main.py', 'main.py']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule('bash', match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash', 'bash'),\n                                  main.Rule('lisp', 'lisp', 'lisp'),\n                                  main.Rule('bash', 'bash', 'bash'),\n                                  main.Rule('lisp', 'lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash', 'bash'),\n                                      main.Rule('bash', 'bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None),\n             main.Rule('', lambda *_: False, None),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0]\\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom thefuck import logs\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    settings.__dict__.setdefault(\'no_colors\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None),\n                                main.Rule('bash', None, None, True))\n    assert not main.is_rule_enabled(Mock(rules=None),\n                                    main.Rule('bash', None, None, False))\n    assert main.is_rule_enabled(Mock(rules=['bash']),\n                                main.Rule('bash', None, None, True))\n    assert not main.is_rule_enabled(Mock(rules=['bash']),\n                                    main.Rule('lisp', None, None, True))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == main.Rule('bash', match, get_new_command, True)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=None))) == [main.Rule('bash', 'bash', 'bash', True),\n                                   main.Rule('lisp', 'lisp', 'lisp', True),\n                                   main.Rule('bash', 'bash', 'bash', True),\n                                   main.Rule('lisp', 'lisp', 'lisp', True)]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=['bash']))) == [main.Rule('bash', 'bash', 'bash', True),\n                                       main.Rule('bash', 'bash', 'bash', True)]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None, True),\n             main.Rule('', lambda *_: False, None, True),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None, True)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom thefuck import logs\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    settings.__dict__.setdefault(\'no_colors\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    if settings.rules is None and rule.enabled_by_default:\n        return True\n    elif settings.rules and rule.name in settings.rules:\n        return True\n    else:\n        return False\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if is_rule_enabled(settings, loaded_rule):\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n']","[[<pydriller.domain.commit.Method object at 0x7f1983e74e50>, <pydriller.domain.commit.Method object at 0x7f1983e747c0>, <pydriller.domain.commit.Method object at 0x7f1983e74130>, <pydriller.domain.commit.Method object at 0x7f1983e748e0>, <pydriller.domain.commit.Method object at 0x7f1983e6e640>, <pydriller.domain.commit.Method object at 0x7f1983e6ecd0>, <pydriller.domain.commit.Method object at 0x7f1983e6ebb0>, <pydriller.domain.commit.Method object at 0x7f1983e6ee50>], [<pydriller.domain.commit.Method object at 0x7f1983e4ba60>, <pydriller.domain.commit.Method object at 0x7f1983e4bbb0>, <pydriller.domain.commit.Method object at 0x7f1983e4b8e0>, <pydriller.domain.commit.Method object at 0x7f1983e4b910>, <pydriller.domain.commit.Method object at 0x7f1983ec5f70>, <pydriller.domain.commit.Method object at 0x7f1983ec5fa0>, <pydriller.domain.commit.Method object at 0x7f1983ec5e20>, <pydriller.domain.commit.Method object at 0x7f1983ec5e50>, <pydriller.domain.commit.Method object at 0x7f1983ec5cd0>, <pydriller.domain.commit.Method object at 0x7f1983ec5d00>, <pydriller.domain.commit.Method object at 0x7f1983ec5b80>, <pydriller.domain.commit.Method object at 0x7f1983ec5bb0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983e7aa60>, <pydriller.domain.commit.Method object at 0x7f1983e7a640>, <pydriller.domain.commit.Method object at 0x7f1983e7aa30>, <pydriller.domain.commit.Method object at 0x7f1983e81280>, <pydriller.domain.commit.Method object at 0x7f1983e81910>], [<pydriller.domain.commit.Method object at 0x7f1983e5c8e0>, <pydriller.domain.commit.Method object at 0x7f1983e5c100>, <pydriller.domain.commit.Method object at 0x7f1983e5c250>]]"
thefuck,fa4e4522b78ccf0811e8b6b671a20fab6099c1f2,#43 Add `rm_root` as disabled by default rule,2015-04-22 16:08:54+02:00,nvbn,10,2,12,3,"['README.md', 'main.py', 'rm_root.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom thefuck import logs\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    settings.__dict__.setdefault(\'no_colors\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    if settings.rules is None and rule.enabled_by_default:\n        return True\n    elif settings.rules and rule.name in settings.rules:\n        return True\n    else:\n        return False\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if is_rule_enabled(settings, loaded_rule):\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', ""def match(command, settings):\n    return ('/' in command.script.split()\n            and '--no-preserve-root' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return '{} --no-preserve-root'.format(command.script)\n""]","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom thefuck import logs\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    settings.__dict__.setdefault(\'no_colors\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    if settings.rules is None and rule.enabled_by_default:\n        return True\n    elif settings.rules and rule.name in settings.rules:\n        return True\n    else:\n        return False\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if is_rule_enabled(settings, loaded_rule):\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = list(get_rules(user_dir, settings))\n        sys.stderr.write(str([r.name for r in rules]) + \'\\n\')\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', ""enabled_by_default = False\n\n\ndef match(command, settings):\n    return ({'rm', '/'}.issubset(command.script.split())\n            and '--no-preserve-root' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return '{} --no-preserve-root'.format(command.script)\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e6e520>, <pydriller.domain.commit.Method object at 0x7f1983e6e670>, <pydriller.domain.commit.Method object at 0x7f1983e68a60>, <pydriller.domain.commit.Method object at 0x7f1983e743d0>, <pydriller.domain.commit.Method object at 0x7f1983e74790>, <pydriller.domain.commit.Method object at 0x7f1983e74520>, <pydriller.domain.commit.Method object at 0x7f1983e74100>, <pydriller.domain.commit.Method object at 0x7f1983e7a670>, <pydriller.domain.commit.Method object at 0x7f1983e7abb0>, <pydriller.domain.commit.Method object at 0x7f1983e7a910>, <pydriller.domain.commit.Method object at 0x7f1983e7a280>, <pydriller.domain.commit.Method object at 0x7f1983e7a520>], [<pydriller.domain.commit.Method object at 0x7f1983e86640>, <pydriller.domain.commit.Method object at 0x7f1983e86790>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e5c280>], [<pydriller.domain.commit.Method object at 0x7f1983e0c3a0>]]"
thefuck,7010b3a7f601608c4f3f943a374ba0ef098fc2da,#43 Add test for `rm_root`,2015-04-22 16:22:10+02:00,nvbn,20,3,23,3,"['test_rm_root.py', 'main.py', 'rm_root.py']","[None, 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom thefuck import logs\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    settings.__dict__.setdefault(\'no_colors\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    if settings.rules is None and rule.enabled_by_default:\n        return True\n    elif settings.rules and rule.name in settings.rules:\n        return True\n    else:\n        return False\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if is_rule_enabled(settings, loaded_rule):\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = list(get_rules(user_dir, settings))\n        sys.stderr.write(str([r.name for r in rules]) + \'\\n\')\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', ""enabled_by_default = False\n\n\ndef match(command, settings):\n    return ({'rm', '/'}.issubset(command.script.split())\n            and '--no-preserve-root' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return '{} --no-preserve-root'.format(command.script)\n""]","[""from mock import Mock\nfrom thefuck.rules.rm_root import match, get_new_command\n\n\ndef test_match():\n    assert match(Mock(script='rm -rf /',\n                      stderr='add --no-preserve-root'), None)\n    assert not match(Mock(script='ls',\n                          stderr='add --no-preserve-root'), None)\n    assert not match(Mock(script='rm --no-preserve-root /',\n                          stderr='add --no-preserve-root'), None)\n    assert not match(Mock(script='rm -rf /',\n                          stderr=''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Mock(script='rm -rf /'), None) \\\n        == 'rm -rf / --no-preserve-root'\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom thefuck import logs\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    settings.__dict__.setdefault(\'no_colors\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    if settings.rules is None and rule.enabled_by_default:\n        return True\n    elif settings.rules and rule.name in settings.rules:\n        return True\n    else:\n        return False\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if is_rule_enabled(settings, loaded_rule):\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', ""enabled_by_default = False\n\n\ndef match(command, settings):\n    return ({'rm', '/'}.issubset(command.script.split())\n            and '--no-preserve-root' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return u'{} --no-preserve-root'.format(command.script)\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e62e20>, <pydriller.domain.commit.Method object at 0x7f1983de66a0>, <pydriller.domain.commit.Method object at 0x7f1983de6940>, <pydriller.domain.commit.Method object at 0x7f1983de62e0>, <pydriller.domain.commit.Method object at 0x7f1983e57100>, <pydriller.domain.commit.Method object at 0x7f1983e57e20>, <pydriller.domain.commit.Method object at 0x7f1983e57fa0>, <pydriller.domain.commit.Method object at 0x7f1983e573d0>, <pydriller.domain.commit.Method object at 0x7f1983e57250>, <pydriller.domain.commit.Method object at 0x7f1983e57280>, <pydriller.domain.commit.Method object at 0x7f1983e57e50>, <pydriller.domain.commit.Method object at 0x7f1983e57a60>], [<pydriller.domain.commit.Method object at 0x7f1983ec0d00>, <pydriller.domain.commit.Method object at 0x7f1983ec0100>]]","[[<pydriller.domain.commit.Method object at 0x7f1983e813d0>, <pydriller.domain.commit.Method object at 0x7f1983e81670>], [<pydriller.domain.commit.Method object at 0x7f1983e173d0>], [<pydriller.domain.commit.Method object at 0x7f1983e3c640>]]"
thefuck,e7b78205f4c7cb060ebe5670f1d0986dbb0cf924,Add transparent sudo support for rules where it required,2015-04-22 16:45:38+02:00,nvbn,68,1,69,11,"['setup.py', 'test_utils.py', 'cp_omitting_directory.py', 'has_exists_script.py', 'lein_not_task.py', 'mkdir_p.py', 'no_command.py', 'python_command.py', 'rm_dir.py', 'rm_root.py', 'utils.py']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.26\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', None, ""import re\n\n\ndef match(command, settings):\n    return command.script.startswith('cp ') \\\n        and 'cp: omitting directory' in command.stderr.lower()\n\n\ndef get_new_command(command, settings):\n    return re.sub(r'^cp', 'cp -a', command.script)\n"", ""import os\n\n\ndef match(command, settings):\n    return os.path.exists(command.script.split()[0]) \\\n        and 'command not found' in command.stderr\n\n\ndef get_new_command(command, settings):\n    return u'./{}'.format(command.script)\n\n"", 'import re\n\n\ndef match(command, settings):\n    return (command.script.startswith(\'lein\')\n            and ""is not a task. See \'lein help\'"" in command.stderr\n            and \'Did you mean this?\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r""\'([^\']*)\' is not a task"",\n                            command.stderr)[0]\n    new_cmd = re.findall(r\'Did you mean this\\?\\n\\s*([^\\n]*)\',\n                         command.stderr)[0]\n    return command.script.replace(broken_cmd, new_cmd, 1)\n', ""import re\n\ndef match(command, settings):\n    return ('mkdir' in command.script\n            and 'No such file or directory' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return re.sub('^mkdir (.*)', 'mkdir -p \\\\1', command.script)\n"", ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _safe(fn, fallback):\n    try:\n        return fn()\n    except OSError:\n        return fallback\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ.get('PATH', '').split(':')\n            for exe in _safe(lambda: list(Path(path).iterdir()), [])\n            if not _safe(exe.is_dir, True)]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n"", ""# add 'python' suffix to the command if\n#  1) The script does not have execute permission or\n#  2) is interpreted as shell script\n\ndef match(command, settings):\n    toks = command.script.split()\n    return (len(toks) > 0\n            and toks[0].endswith('.py')\n            and ('Permission denied' in command.stderr or\n                 'command not found' in command.stderr))\n\n\ndef get_new_command(command, settings):\n    return 'python ' + command.script\n"", ""import re\n\ndef match(command, settings):\n    return ('rm' in command.script\n            and 'is a directory' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return re.sub('^rm (.*)', 'rm -rf \\\\1', command.script)\n"", ""enabled_by_default = False\n\n\ndef match(command, settings):\n    return ({'rm', '/'}.issubset(command.script.split())\n            and '--no-preserve-root' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return u'{} --no-preserve-root'.format(command.script)\n"", 'from functools import wraps\nimport os\n\n\ndef which(program):\n    """"""Returns `program` path or `None`.""""""\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef wrap_settings(params):\n    """"""Adds default values to settings if it not presented.\n\n    Usage:\n\n        @wrap_settings({\'apt\': \'/usr/bin/apt\'})\n        def match(command, settings):\n            print(settings.apt)\n\n    """"""\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(command, settings):\n            for key, val in params.items():\n                if not hasattr(settings, key):\n                    setattr(settings, key, val)\n            return fn(command, settings)\n        return wrapper\n    return decorator\n']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.26\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from mock import Mock\nfrom thefuck.utils import sudo_support\nfrom thefuck.main import Command\n\n\ndef test_sudo_support():\n    fn = Mock(return_value=True, __name__='')\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n    fn.assert_called_once_with(Command('ls', 'out', 'err'), None)\n\n    fn.return_value = False\n    assert not sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n\n    fn.return_value = 'pwd'\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None) == 'sudo pwd'\n\n    assert sudo_support(fn)(Command('ls', 'out', 'err'), None) == 'pwd'\n"", ""import re\nfrom thefuck.utils import sudo_support\n\n\n@sudo_support\ndef match(command, settings):\n    return command.script.startswith('cp ') \\\n        and 'cp: omitting directory' in command.stderr.lower()\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return re.sub(r'^cp', 'cp -a', command.script)\n"", ""import os\nfrom thefuck.utils import sudo_support\n\n\n@sudo_support\ndef match(command, settings):\n    return os.path.exists(command.script.split()[0]) \\\n        and 'command not found' in command.stderr\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return u'./{}'.format(command.script)\n\n"", 'import re\nfrom thefuck.utils import sudo_support\n\n\n@sudo_support\ndef match(command, settings):\n    return (command.script.startswith(\'lein\')\n            and ""is not a task. See \'lein help\'"" in command.stderr\n            and \'Did you mean this?\' in command.stderr)\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r""\'([^\']*)\' is not a task"",\n                            command.stderr)[0]\n    new_cmd = re.findall(r\'Did you mean this\\?\\n\\s*([^\\n]*)\',\n                         command.stderr)[0]\n    return command.script.replace(broken_cmd, new_cmd, 1)\n', ""import re\nfrom thefuck.utils import sudo_support\n\n\n@sudo_support\ndef match(command, settings):\n    return ('mkdir' in command.script\n            and 'No such file or directory' in command.stderr)\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return re.sub('^mkdir (.*)', 'mkdir -p \\\\1', command.script)\n"", ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\nfrom thefuck.utils import sudo_support\n\n\ndef _safe(fn, fallback):\n    try:\n        return fn()\n    except OSError:\n        return fallback\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ.get('PATH', '').split(':')\n            for exe in _safe(lambda: list(Path(path).iterdir()), [])\n            if not _safe(exe.is_dir, True)]\n\n\n@sudo_support\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n"", ""from thefuck.utils import sudo_support\n# add 'python' suffix to the command if\n#  1) The script does not have execute permission or\n#  2) is interpreted as shell script\n\n\n@sudo_support\ndef match(command, settings):\n    toks = command.script.split()\n    return (len(toks) > 0\n            and toks[0].endswith('.py')\n            and ('Permission denied' in command.stderr or\n                 'command not found' in command.stderr))\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return 'python ' + command.script\n"", ""import re\nfrom thefuck.utils import sudo_support\n\n\n@sudo_support\ndef match(command, settings):\n    return ('rm' in command.script\n            and 'is a directory' in command.stderr)\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return re.sub('^rm (.*)', 'rm -rf \\\\1', command.script)\n"", ""from thefuck.utils import sudo_support\n\n\nenabled_by_default = False\n\n\n@sudo_support\ndef match(command, settings):\n    return ({'rm', '/'}.issubset(command.script.split())\n            and '--no-preserve-root' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return u'{} --no-preserve-root'.format(command.script)\n"", 'from functools import wraps\nimport os\nimport six\nfrom thefuck.main import Command\n\n\ndef which(program):\n    """"""Returns `program` path or `None`.""""""\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef wrap_settings(params):\n    """"""Adds default values to settings if it not presented.\n\n    Usage:\n\n        @wrap_settings({\'apt\': \'/usr/bin/apt\'})\n        def match(command, settings):\n            print(settings.apt)\n\n    """"""\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(command, settings):\n            for key, val in params.items():\n                if not hasattr(settings, key):\n                    setattr(settings, key, val)\n            return fn(command, settings)\n        return wrapper\n    return decorator\n\n\ndef sudo_support(fn):\n    """"""Removes sudo before calling fn and adds it after.""""""\n    @wraps(fn)\n    def wrapper(command, settings):\n        if not command.script.startswith(\'sudo \'):\n            return fn(command, settings)\n\n        result = fn(Command(command.script[5:],\n                            command.stdout,\n                            command.stderr),\n                    settings)\n\n        if result and isinstance(result, six.string_types):\n            return u\'sudo {}\'.format(result)\n        else:\n            return result\n    return wrapper\n']","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983eae670>, <pydriller.domain.commit.Method object at 0x7f1983eae7c0>], [<pydriller.domain.commit.Method object at 0x7f1983e57cd0>, <pydriller.domain.commit.Method object at 0x7f1983e57790>], [<pydriller.domain.commit.Method object at 0x7f1983e1dbb0>, <pydriller.domain.commit.Method object at 0x7f1983e1da30>], [<pydriller.domain.commit.Method object at 0x7f1983e86130>, <pydriller.domain.commit.Method object at 0x7f1983e7ae50>], [<pydriller.domain.commit.Method object at 0x7f1983e74670>, <pydriller.domain.commit.Method object at 0x7f1983e74d00>, <pydriller.domain.commit.Method object at 0x7f1983e74bb0>, <pydriller.domain.commit.Method object at 0x7f1983e74a60>], [<pydriller.domain.commit.Method object at 0x7f1983ec5130>, <pydriller.domain.commit.Method object at 0x7f1983ec5520>], [<pydriller.domain.commit.Method object at 0x7f1983e4be50>, <pydriller.domain.commit.Method object at 0x7f1983e4bfa0>], [<pydriller.domain.commit.Method object at 0x7f1983e5c4f0>, <pydriller.domain.commit.Method object at 0x7f1983e5c790>], [<pydriller.domain.commit.Method object at 0x7f1983e86910>, <pydriller.domain.commit.Method object at 0x7f1983e86250>, <pydriller.domain.commit.Method object at 0x7f1983e86fa0>, <pydriller.domain.commit.Method object at 0x7f1983e86670>, <pydriller.domain.commit.Method object at 0x7f1983e7a3d0>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983eb9cd0>], [], [], [], [], [], [], [], [], [<pydriller.domain.commit.Method object at 0x7f1983e0c280>, <pydriller.domain.commit.Method object at 0x7f1983db9400>]]"
thefuck,69ddd82baeb5ead4366c4e6a1bee7f28b4aacca1,Bump to 1.27,2015-04-22 16:46:06+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nVERSION = \'1.26\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.27\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,c788dfbc1498e3d7efae7274e986662645dd49fa,"fix rm dir rule to make it case insensitive

In bash the output for the command `rm -f foo/` is:

    rm: cannot remove ‘foo/’: Is a directory

And not:

    rm: cannot remove ‘foo/’: is a directory",2015-04-22 19:04:52+02:00,Timo Furrer,2,1,3,2,"['test_rm_dir.py', 'rm_dir.py']","[""from thefuck.main import Command\nfrom thefuck.rules.rm_dir import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('rm foo', '', 'rm: foo: is a directory'), None)\n    assert not match(Command('rm foo', '', ''), None)\n    assert not match(Command('rm foo', '', 'foo bar baz'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('rm foo', '', ''), None) == 'rm -rf foo'\n"", ""import re\nfrom thefuck.utils import sudo_support\n\n\n@sudo_support\ndef match(command, settings):\n    return ('rm' in command.script\n            and 'is a directory' in command.stderr)\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return re.sub('^rm (.*)', 'rm -rf \\\\1', command.script)\n""]","[""from thefuck.main import Command\nfrom thefuck.rules.rm_dir import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('rm foo', '', 'rm: foo: is a directory'), None)\n    assert match(Command('rm foo', '', 'rm: foo: Is a directory'), None)\n    assert not match(Command('rm foo', '', ''), None)\n    assert not match(Command('rm foo', '', 'foo bar baz'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('rm foo', '', ''), None) == 'rm -rf foo'\n"", ""import re\nfrom thefuck.utils import sudo_support\n\n\n@sudo_support\ndef match(command, settings):\n    return ('rm' in command.script\n            and 'is a directory' in command.stderr.lower())\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return re.sub('^rm (.*)', 'rm -rf \\\\1', command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983eb9d00>, <pydriller.domain.commit.Method object at 0x7f1983eb9790>], [<pydriller.domain.commit.Method object at 0x7f1983eae640>, <pydriller.domain.commit.Method object at 0x7f1983eae100>]]","[[<pydriller.domain.commit.Method object at 0x7f1983eb98e0>], [<pydriller.domain.commit.Method object at 0x7f1983ec0670>]]"
thefuck,69a95164773772262816f5f260074f1070d7f43d,Add ability to change settings via environment variables,2015-04-22 20:18:53+02:00,nvbn,233,61,294,8,"['README.md', 'test_conf.py', 'test_main.py', 'test_utils.py', 'conf.py', 'logs.py', 'main.py', 'utils.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', None, ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None),\n                                main.Rule('bash', None, None, True))\n    assert not main.is_rule_enabled(Mock(rules=None),\n                                    main.Rule('bash', None, None, False))\n    assert main.is_rule_enabled(Mock(rules=['bash']),\n                                main.Rule('bash', None, None, True))\n    assert not main.is_rule_enabled(Mock(rules=['bash']),\n                                    main.Rule('lisp', None, None, True))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == main.Rule('bash', match, get_new_command, True)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=None))) == [main.Rule('bash', 'bash', 'bash', True),\n                                   main.Rule('lisp', 'lisp', 'lisp', True),\n                                   main.Rule('bash', 'bash', 'bash', True),\n                                   main.Rule('lisp', 'lisp', 'lisp', True)]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=['bash']))) == [main.Rule('bash', 'bash', 'bash', True),\n                                       main.Rule('bash', 'bash', 'bash', True)]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None, True),\n             main.Rule('', lambda *_: False, None, True),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None, True)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", ""from mock import Mock\nfrom thefuck.utils import sudo_support\nfrom thefuck.main import Command\n\n\ndef test_sudo_support():\n    fn = Mock(return_value=True, __name__='')\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n    fn.assert_called_once_with(Command('ls', 'out', 'err'), None)\n\n    fn.return_value = False\n    assert not sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n\n    fn.return_value = 'pwd'\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None) == 'sudo pwd'\n\n    assert sudo_support(fn)(Command('ls', 'out', 'err'), None) == 'pwd'\n"", None, 'import sys\nfrom traceback import format_exception\nimport colorama\n\n\ndef color(color_, settings):\n    """"""Utility for ability to disabling colored output.""""""\n    if settings.no_colors:\n        return \'\'\n    else:\n        return color_\n\n\ndef rule_failed(rule, exc_info, settings):\n    sys.stderr.write(\n        u\'{warn}[WARN] Rule {name}:{reset}\\n{trace}\'\n        u\'{warn}----------------------------{reset}\\n\\n\'.format(\n            warn=color(colorama.Back.RED + colorama.Fore.WHITE\n                       + colorama.Style.BRIGHT, settings),\n            reset=color(colorama.Style.RESET_ALL, settings),\n            name=rule.name,\n            trace=\'\'.join(format_exception(*exc_info))))\n\n\ndef show_command(new_command, settings):\n    sys.stderr.write(\'{bold}{command}{reset}\\n\'.format(\n        command=new_command,\n        bold=color(colorama.Style.BRIGHT, settings),\n        reset=color(colorama.Style.RESET_ALL, settings)))\n\n\ndef confirm_command(new_command, settings):\n    sys.stderr.write(\n        \'{bold}{command}{reset} [{green}enter{reset}/{red}ctrl+c{reset}]\'.format(\n            command=new_command,\n            bold=color(colorama.Style.BRIGHT, settings),\n            green=color(colorama.Fore.GREEN, settings),\n            red=color(colorama.Fore.RED, settings),\n            reset=color(colorama.Style.RESET_ALL, settings)))\n    sys.stderr.flush()\n\n\ndef failed(msg, settings):\n    sys.stderr.write(\'{red}{msg}{reset}\\n\'.format(\n        msg=msg,\n        red=color(colorama.Fore.RED, settings),\n        reset=color(colorama.Style.RESET_ALL, settings)))\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom thefuck import logs\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    settings.__dict__.setdefault(\'no_colors\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    if settings.rules is None and rule.enabled_by_default:\n        return True\n    elif settings.rules and rule.name in settings.rules:\n        return True\n    else:\n        return False\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if is_rule_enabled(settings, loaded_rule):\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', 'from functools import wraps\nimport os\nimport six\nfrom thefuck.main import Command\n\n\ndef which(program):\n    """"""Returns `program` path or `None`.""""""\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef wrap_settings(params):\n    """"""Adds default values to settings if it not presented.\n\n    Usage:\n\n        @wrap_settings({\'apt\': \'/usr/bin/apt\'})\n        def match(command, settings):\n            print(settings.apt)\n\n    """"""\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(command, settings):\n            for key, val in params.items():\n                if not hasattr(settings, key):\n                    setattr(settings, key, val)\n            return fn(command, settings)\n        return wrapper\n    return decorator\n\n\ndef sudo_support(fn):\n    """"""Removes sudo before calling fn and adds it after.""""""\n    @wraps(fn)\n    def wrapper(command, settings):\n        if not command.script.startswith(\'sudo \'):\n            return fn(command, settings)\n\n        result = fn(Command(command.script[5:],\n                            command.stdout,\n                            command.stderr),\n                    settings)\n\n        if result and isinstance(result, six.string_types):\n            return u\'sudo {}\'.format(result)\n        else:\n            return result\n    return wrapper\n']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""from mock import patch, Mock\nfrom thefuck.main import Rule\nfrom thefuck import conf\n\n\ndef test_rules_list():\n    assert conf.RulesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert conf.RulesList(['bash', 'lisp']) == conf.RulesList(['bash', 'lisp'])\n    assert Rule('lisp', None, None, False) in conf.RulesList(['lisp'])\n    assert Rule('bash', None, None, False) not in conf.RulesList(['lisp'])\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT\n    assert Rule('test', None, None, False) not in conf.DEFAULT\n    assert Rule('test', None, None, False) in (conf.DEFAULT + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.Settings.defaults.items():\n            assert getattr(conf.Settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.Settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.Settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.Settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT:bash:lisp'}):\n        settings = conf.Settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['bash', 'lisp']\n\n\ndef test_update_settings():\n    settings = conf.BaseSettings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main, conf\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == main.Rule('bash', match, get_new_command, True)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.DEFAULT))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True),\n                   main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True)]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.RulesList(['bash'])))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('bash', 'bash', 'bash', True)]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None, True),\n             main.Rule('', lambda *_: False, None, True),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None, True)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", ""from mock import Mock\nfrom thefuck.utils import sudo_support, wrap_settings\nfrom thefuck.main import Command\nfrom thefuck.conf import BaseSettings\n\n\ndef test_wrap_settings():\n    fn = lambda _, settings: settings._conf\n    assert wrap_settings({'key': 'val'})(fn)(None, BaseSettings({})) \\\n           == {'key': 'val'}\n    assert wrap_settings({'key': 'new-val'})(fn)(\n        None, BaseSettings({'key': 'val'})) == {'key': 'new-val'}\n\n\ndef test_sudo_support():\n    fn = Mock(return_value=True, __name__='')\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n    fn.assert_called_once_with(Command('ls', 'out', 'err'), None)\n\n    fn.return_value = False\n    assert not sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n\n    fn.return_value = 'pwd'\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None) == 'sudo pwd'\n\n    assert sudo_support(fn)(Command('ls', 'out', 'err'), None) == 'pwd'\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs\n\n\nclass RulesList(object):\n    """"""Wrapper a top of list for string rules names.""""""\n\n    def __init__(self, rules):\n        self.rules = rules\n\n    def __contains__(self, item):\n        return item.name in self.rules\n\n    def __getattr__(self, item):\n        return getattr(self.rules, item)\n\n    def __eq__(self, other):\n        return self.rules == other\n\n\nclass _DefaultRules(RulesList):\n    def __add__(self, items):\n        return _DefaultRules(self.rules + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRules, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRules):\n            return self.rules == other.rules\n        else:\n            return False\n\n\nDEFAULT = _DefaultRules([])\n\n\nclass BaseSettings(object):\n    def __init__(self, conf):\n        self._conf = conf\n\n    def __getattr__(self, item):\n        return self._conf.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = copy(self._conf)\n        conf.update(kwargs)\n        return BaseSettings(conf)\n\n\nclass Settings(BaseSettings):\n    """"""Settings loaded from defaults/file/env.""""""\n    defaults = {\'rules\': DEFAULT,\n                \'wait_command\': 3,\n                \'require_confirmation\': False,\n                \'no_colors\': False}\n\n    env_to_attr = {\'THEFUCK_RULES\': \'rules\',\n                   \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n                   \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n                   \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n    def __init__(self, user_dir):\n        super(Settings, self).__init__(self._load_conf(user_dir))\n\n    def _load_conf(self, user_dir):\n        conf = copy(self.defaults)\n        try:\n            conf.update(self._load_from_file(user_dir))\n        except:\n            logs.exception(""Can\'t load settings from file"",\n                           sys.exc_info(),\n                           BaseSettings(conf))\n        try:\n            conf.update(self._load_from_env())\n        except:\n            logs.exception(""Can\'t load settings from env"",\n                           sys.exc_info(),\n                           BaseSettings(conf))\n        if not isinstance(conf[\'rules\'], RulesList):\n            conf[\'rules\'] = RulesList(conf[\'rules\'])\n        return conf\n\n    def _load_from_file(self, user_dir):\n        """"""Loads settings from file.""""""\n        settings = load_source(\'settings\',\n                               text_type(user_dir.joinpath(\'settings.py\')))\n        return {key: getattr(settings, key)\n                for key in self.defaults.keys()\n                if hasattr(settings, key)}\n\n    def _load_from_env(self):\n        """"""Loads settings from env.""""""\n        return {attr: self._val_from_env(env, attr)\n                for env, attr in self.env_to_attr.items()\n                if env in os.environ}\n\n    def _val_from_env(self, env, attr):\n        """"""Transforms env-strings to python.""""""\n        val = os.environ[env]\n        if attr == \'rules\':\n            val = self._rules_from_env(val)\n        elif attr == \'wait_command\':\n            val = int(val)\n        elif attr in (\'require_confirmation\', \'no_colors\'):\n            val = val.lower() == \'true\'\n        return val\n\n    def _rules_from_env(self, val):\n        """"""Transforms rules list from env-string to python.""""""\n        val = val.split(\':\')\n        if \'DEFAULT\' in val:\n            val = DEFAULT + [rule for rule in val if rule != \'DEFAULT\']\n        return val\n', 'import sys\nfrom traceback import format_exception\nimport colorama\n\n\ndef color(color_, settings):\n    """"""Utility for ability to disabling colored output.""""""\n    if settings.no_colors:\n        return \'\'\n    else:\n        return color_\n\n\ndef exception(title, exc_info, settings):\n    sys.stderr.write(\n        u\'{warn}[WARN] {title}:{reset}\\n{trace}\'\n        u\'{warn}----------------------------{reset}\\n\\n\'.format(\n            warn=color(colorama.Back.RED + colorama.Fore.WHITE\n                       + colorama.Style.BRIGHT, settings),\n            reset=color(colorama.Style.RESET_ALL, settings),\n            title=title,\n            trace=\'\'.join(format_exception(*exc_info))))\n\n\ndef rule_failed(rule, exc_info, settings):\n    exception(\'Rule {}\'.format(rule.name), exc_info, settings)\n\n\ndef show_command(new_command, settings):\n    sys.stderr.write(\'{bold}{command}{reset}\\n\'.format(\n        command=new_command,\n        bold=color(colorama.Style.BRIGHT, settings),\n        reset=color(colorama.Style.RESET_ALL, settings)))\n\n\ndef confirm_command(new_command, settings):\n    sys.stderr.write(\n        \'{bold}{command}{reset} [{green}enter{reset}/{red}ctrl+c{reset}]\'.format(\n            command=new_command,\n            bold=color(colorama.Style.BRIGHT, settings),\n            green=color(colorama.Fore.GREEN, settings),\n            red=color(colorama.Fore.RED, settings),\n            reset=color(colorama.Style.RESET_ALL, settings)))\n    sys.stderr.flush()\n\n\ndef failed(msg, settings):\n    sys.stderr.write(\'{red}{msg}{reset}\\n\'.format(\n        msg=msg,\n        red=color(colorama.Fore.RED, settings),\n        reset=color(colorama.Style.RESET_ALL, settings)))\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom . import logs, conf\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.Settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', 'from functools import wraps\nimport os\nimport six\nfrom thefuck.main import Command\n\n\ndef which(program):\n    """"""Returns `program` path or `None`.""""""\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef wrap_settings(params):\n    """"""Adds default values to settings if it not presented.\n\n    Usage:\n\n        @wrap_settings({\'apt\': \'/usr/bin/apt\'})\n        def match(command, settings):\n            print(settings.apt)\n\n    """"""\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(command, settings):\n            return fn(command, settings.update(**params))\n        return wrapper\n    return decorator\n\n\ndef sudo_support(fn):\n    """"""Removes sudo before calling fn and adds it after.""""""\n    @wraps(fn)\n    def wrapper(command, settings):\n        if not command.script.startswith(\'sudo \'):\n            return fn(command, settings)\n\n        result = fn(Command(command.script[5:],\n                            command.stdout,\n                            command.stderr),\n                    settings)\n\n        if result and isinstance(result, six.string_types):\n            return u\'sudo {}\'.format(result)\n        else:\n            return result\n    return wrapper\n']","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983e9cbb0>, <pydriller.domain.commit.Method object at 0x7f1983e9ca30>, <pydriller.domain.commit.Method object at 0x7f1983e9ccd0>, <pydriller.domain.commit.Method object at 0x7f1983e9cd00>, <pydriller.domain.commit.Method object at 0x7f1983ea27c0>, <pydriller.domain.commit.Method object at 0x7f1983ea2640>, <pydriller.domain.commit.Method object at 0x7f1983ea2670>, <pydriller.domain.commit.Method object at 0x7f1983ea24f0>], [<pydriller.domain.commit.Method object at 0x7f1983ea8cd0>], [], [<pydriller.domain.commit.Method object at 0x7f1983e573a0>, <pydriller.domain.commit.Method object at 0x7f1983e57640>, <pydriller.domain.commit.Method object at 0x7f1983e574f0>, <pydriller.domain.commit.Method object at 0x7f1983e57f70>, <pydriller.domain.commit.Method object at 0x7f1983e57520>], [<pydriller.domain.commit.Method object at 0x7f1983e74b80>, <pydriller.domain.commit.Method object at 0x7f1983e74e20>, <pydriller.domain.commit.Method object at 0x7f1983e744f0>, <pydriller.domain.commit.Method object at 0x7f1983e74280>, <pydriller.domain.commit.Method object at 0x7f1983e4b3d0>, <pydriller.domain.commit.Method object at 0x7f1983e4bf70>, <pydriller.domain.commit.Method object at 0x7f1983ec5280>, <pydriller.domain.commit.Method object at 0x7f1983ec5100>, <pydriller.domain.commit.Method object at 0x7f1983ec58e0>, <pydriller.domain.commit.Method object at 0x7f1983ec5250>, <pydriller.domain.commit.Method object at 0x7f1983ec54f0>, <pydriller.domain.commit.Method object at 0x7f1983ec53d0>], [<pydriller.domain.commit.Method object at 0x7f1983eae4f0>, <pydriller.domain.commit.Method object at 0x7f1983eaea30>, <pydriller.domain.commit.Method object at 0x7f1983eaef70>, <pydriller.domain.commit.Method object at 0x7f1983eaeb80>, <pydriller.domain.commit.Method object at 0x7f1983eaecd0>, <pydriller.domain.commit.Method object at 0x7f1983eaee50>, <pydriller.domain.commit.Method object at 0x7f1983e29280>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e9cf70>, <pydriller.domain.commit.Method object at 0x7f1983ea2a30>, <pydriller.domain.commit.Method object at 0x7f1983ea2130>, <pydriller.domain.commit.Method object at 0x7f1983ea28e0>, <pydriller.domain.commit.Method object at 0x7f1983ea2280>, <pydriller.domain.commit.Method object at 0x7f1983ea2100>, <pydriller.domain.commit.Method object at 0x7f1983ea2910>, <pydriller.domain.commit.Method object at 0x7f1983ea2790>], [<pydriller.domain.commit.Method object at 0x7f1983e9ca30>, <pydriller.domain.commit.Method object at 0x7f1983e9ca60>, <pydriller.domain.commit.Method object at 0x7f1983e9cbb0>], [<pydriller.domain.commit.Method object at 0x7f1983ea23d0>], [<pydriller.domain.commit.Method object at 0x7f1983ec0280>, <pydriller.domain.commit.Method object at 0x7f1983eb2f70>, <pydriller.domain.commit.Method object at 0x7f1983e3ccd0>, <pydriller.domain.commit.Method object at 0x7f1983e3cd00>, <pydriller.domain.commit.Method object at 0x7f1983ec0f70>, <pydriller.domain.commit.Method object at 0x7f1983eb2910>, <pydriller.domain.commit.Method object at 0x7f1983ec03a0>, <pydriller.domain.commit.Method object at 0x7f1983eb2cd0>, <pydriller.domain.commit.Method object at 0x7f1983ec0cd0>, <pydriller.domain.commit.Method object at 0x7f1983ec0b80>, <pydriller.domain.commit.Method object at 0x7f1983ec04f0>, <pydriller.domain.commit.Method object at 0x7f1983ec0910>, <pydriller.domain.commit.Method object at 0x7f1983eb2790>], [<pydriller.domain.commit.Method object at 0x7f1983eb97c0>, <pydriller.domain.commit.Method object at 0x7f1983eb9250>], [<pydriller.domain.commit.Method object at 0x7f1983e744f0>, <pydriller.domain.commit.Method object at 0x7f1983e7a790>, <pydriller.domain.commit.Method object at 0x7f1983e12a30>, <pydriller.domain.commit.Method object at 0x7f1983e74e20>], [<pydriller.domain.commit.Method object at 0x7f1983e96280>, <pydriller.domain.commit.Method object at 0x7f1983e96130>, <pydriller.domain.commit.Method object at 0x7f1983e96bb0>]]"
thefuck,0553d57ec145db4a043b3f115a5e8b7865c3a4bc,Don't mess with inheritance for filling settings,2015-04-22 22:29:23+02:00,nvbn,83,79,162,4,"['test_conf.py', 'test_utils.py', 'conf.py', 'main.py']","[""from mock import patch, Mock\nfrom thefuck.main import Rule\nfrom thefuck import conf\n\n\ndef test_rules_list():\n    assert conf.RulesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert conf.RulesList(['bash', 'lisp']) == conf.RulesList(['bash', 'lisp'])\n    assert Rule('lisp', None, None, False) in conf.RulesList(['lisp'])\n    assert Rule('bash', None, None, False) not in conf.RulesList(['lisp'])\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT\n    assert Rule('test', None, None, False) not in conf.DEFAULT\n    assert Rule('test', None, None, False) in (conf.DEFAULT + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.Settings.defaults.items():\n            assert getattr(conf.Settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.Settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.Settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.Settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT:bash:lisp'}):\n        settings = conf.Settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['bash', 'lisp']\n\n\ndef test_update_settings():\n    settings = conf.BaseSettings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from mock import Mock\nfrom thefuck.utils import sudo_support, wrap_settings\nfrom thefuck.main import Command\nfrom thefuck.conf import BaseSettings\n\n\ndef test_wrap_settings():\n    fn = lambda _, settings: settings._conf\n    assert wrap_settings({'key': 'val'})(fn)(None, BaseSettings({})) \\\n           == {'key': 'val'}\n    assert wrap_settings({'key': 'new-val'})(fn)(\n        None, BaseSettings({'key': 'val'})) == {'key': 'new-val'}\n\n\ndef test_sudo_support():\n    fn = Mock(return_value=True, __name__='')\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n    fn.assert_called_once_with(Command('ls', 'out', 'err'), None)\n\n    fn.return_value = False\n    assert not sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n\n    fn.return_value = 'pwd'\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None) == 'sudo pwd'\n\n    assert sudo_support(fn)(Command('ls', 'out', 'err'), None) == 'pwd'\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs\n\n\nclass RulesList(object):\n    """"""Wrapper a top of list for string rules names.""""""\n\n    def __init__(self, rules):\n        self.rules = rules\n\n    def __contains__(self, item):\n        return item.name in self.rules\n\n    def __getattr__(self, item):\n        return getattr(self.rules, item)\n\n    def __eq__(self, other):\n        return self.rules == other\n\n\nclass _DefaultRules(RulesList):\n    def __add__(self, items):\n        return _DefaultRules(self.rules + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRules, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRules):\n            return self.rules == other.rules\n        else:\n            return False\n\n\nDEFAULT = _DefaultRules([])\n\n\nclass BaseSettings(object):\n    def __init__(self, conf):\n        self._conf = conf\n\n    def __getattr__(self, item):\n        return self._conf.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = copy(self._conf)\n        conf.update(kwargs)\n        return BaseSettings(conf)\n\n\nclass Settings(BaseSettings):\n    """"""Settings loaded from defaults/file/env.""""""\n    defaults = {\'rules\': DEFAULT,\n                \'wait_command\': 3,\n                \'require_confirmation\': False,\n                \'no_colors\': False}\n\n    env_to_attr = {\'THEFUCK_RULES\': \'rules\',\n                   \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n                   \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n                   \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n    def __init__(self, user_dir):\n        super(Settings, self).__init__(self._load_conf(user_dir))\n\n    def _load_conf(self, user_dir):\n        conf = copy(self.defaults)\n        try:\n            conf.update(self._load_from_file(user_dir))\n        except:\n            logs.exception(""Can\'t load settings from file"",\n                           sys.exc_info(),\n                           BaseSettings(conf))\n        try:\n            conf.update(self._load_from_env())\n        except:\n            logs.exception(""Can\'t load settings from env"",\n                           sys.exc_info(),\n                           BaseSettings(conf))\n        if not isinstance(conf[\'rules\'], RulesList):\n            conf[\'rules\'] = RulesList(conf[\'rules\'])\n        return conf\n\n    def _load_from_file(self, user_dir):\n        """"""Loads settings from file.""""""\n        settings = load_source(\'settings\',\n                               text_type(user_dir.joinpath(\'settings.py\')))\n        return {key: getattr(settings, key)\n                for key in self.defaults.keys()\n                if hasattr(settings, key)}\n\n    def _load_from_env(self):\n        """"""Loads settings from env.""""""\n        return {attr: self._val_from_env(env, attr)\n                for env, attr in self.env_to_attr.items()\n                if env in os.environ}\n\n    def _val_from_env(self, env, attr):\n        """"""Transforms env-strings to python.""""""\n        val = os.environ[env]\n        if attr == \'rules\':\n            val = self._rules_from_env(val)\n        elif attr == \'wait_command\':\n            val = int(val)\n        elif attr in (\'require_confirmation\', \'no_colors\'):\n            val = val.lower() == \'true\'\n        return val\n\n    def _rules_from_env(self, val):\n        """"""Transforms rules list from env-string to python.""""""\n        val = val.split(\':\')\n        if \'DEFAULT\' in val:\n            val = DEFAULT + [rule for rule in val if rule != \'DEFAULT\']\n        return val\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom . import logs, conf\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.Settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n']","[""from mock import patch, Mock\nfrom thefuck.main import Rule\nfrom thefuck import conf\n\n\ndef test_rules_list():\n    assert conf.RulesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert conf.RulesList(['bash', 'lisp']) == conf.RulesList(['bash', 'lisp'])\n    assert Rule('lisp', None, None, False) in conf.RulesList(['lisp'])\n    assert Rule('bash', None, None, False) not in conf.RulesList(['lisp'])\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT\n    assert Rule('test', None, None, False) not in conf.DEFAULT\n    assert Rule('test', None, None, False) in (conf.DEFAULT + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.DEFAULT_SETTINGS.items():\n            assert getattr(conf.get_settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT:bash:lisp'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['bash', 'lisp']\n\n\ndef test_update_settings():\n    settings = conf.Settings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from mock import Mock\nfrom thefuck.utils import sudo_support, wrap_settings\nfrom thefuck.main import Command\nfrom thefuck.conf import Settings\n\n\ndef test_wrap_settings():\n    fn = lambda _, settings: settings._conf\n    assert wrap_settings({'key': 'val'})(fn)(None, Settings({})) \\\n           == {'key': 'val'}\n    assert wrap_settings({'key': 'new-val'})(fn)(\n        None, Settings({'key': 'val'})) == {'key': 'new-val'}\n\n\ndef test_sudo_support():\n    fn = Mock(return_value=True, __name__='')\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n    fn.assert_called_once_with(Command('ls', 'out', 'err'), None)\n\n    fn.return_value = False\n    assert not sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n\n    fn.return_value = 'pwd'\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None) == 'sudo pwd'\n\n    assert sudo_support(fn)(Command('ls', 'out', 'err'), None) == 'pwd'\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs\n\n\nclass RulesList(object):\n    """"""Wrapper a top of list for string rules names.""""""\n\n    def __init__(self, rules):\n        self.rules = rules\n\n    def __contains__(self, item):\n        return item.name in self.rules\n\n    def __getattr__(self, item):\n        return getattr(self.rules, item)\n\n    def __eq__(self, other):\n        return self.rules == other\n\n\nclass _DefaultRules(RulesList):\n    def __add__(self, items):\n        return _DefaultRules(self.rules + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRules, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRules):\n            return self.rules == other.rules\n        else:\n            return False\n\n\nDEFAULT = _DefaultRules([])\n\n\nclass Settings(object):\n    def __init__(self, conf):\n        self._conf = conf\n\n    def __getattr__(self, item):\n        return self._conf.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = copy(self._conf)\n        conf.update(kwargs)\n        return Settings(conf)\n\n\nDEFAULT_SETTINGS = {\'rules\': DEFAULT,\n                    \'wait_command\': 3,\n                    \'require_confirmation\': False,\n                    \'no_colors\': False}\n\nENV_TO_ATTR = {\'THEFUCK_RULES\': \'rules\',\n               \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n               \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n               \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n\ndef _settings_from_file(user_dir):\n    """"""Loads settings from file.""""""\n    settings = load_source(\'settings\',\n                           text_type(user_dir.joinpath(\'settings.py\')))\n    return {key: getattr(settings, key)\n            for key in DEFAULT_SETTINGS.keys()\n            if hasattr(settings, key)}\n\n\ndef _rules_from_env(val):\n    """"""Transforms rules list from env-string to python.""""""\n    val = val.split(\':\')\n    if \'DEFAULT\' in val:\n        val = DEFAULT + [rule for rule in val if rule != \'DEFAULT\']\n    return val\n\n\ndef _val_from_env(env, attr):\n    """"""Transforms env-strings to python.""""""\n    val = os.environ[env]\n    if attr == \'rules\':\n        val = _rules_from_env(val)\n    elif attr == \'wait_command\':\n        val = int(val)\n    elif attr in (\'require_confirmation\', \'no_colors\'):\n        val = val.lower() == \'true\'\n    return val\n\n\ndef _settings_from_env():\n    """"""Loads settings from env.""""""\n    return {attr: _val_from_env(env, attr)\n            for env, attr in ENV_TO_ATTR.items()\n            if env in os.environ}\n\n\ndef get_settings(user_dir):\n    """"""Returns settings filled with values from `settings.py` and env.""""""\n    conf = copy(DEFAULT_SETTINGS)\n    try:\n        conf.update(_settings_from_file(user_dir))\n    except Exception:\n        logs.exception(""Can\'t load settings from file"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    try:\n        conf.update(_settings_from_env())\n    except Exception:\n        logs.exception(""Can\'t load settings from env"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    if not isinstance(conf[\'rules\'], RulesList):\n        conf[\'rules\'] = RulesList(conf[\'rules\'])\n\n    return Settings(conf)\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom . import logs, conf\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n']","[[<pydriller.domain.commit.Method object at 0x7f1983e5c670>, <pydriller.domain.commit.Method object at 0x7f1983e5ca30>, <pydriller.domain.commit.Method object at 0x7f1983e5c520>, <pydriller.domain.commit.Method object at 0x7f1983e5cf70>, <pydriller.domain.commit.Method object at 0x7f1983e96910>, <pydriller.domain.commit.Method object at 0x7f1983e96520>, <pydriller.domain.commit.Method object at 0x7f1983e96100>, <pydriller.domain.commit.Method object at 0x7f1983e96cd0>], [<pydriller.domain.commit.Method object at 0x7f1983e4b100>, <pydriller.domain.commit.Method object at 0x7f1983e4b4f0>], [<pydriller.domain.commit.Method object at 0x7f1983eb9130>, <pydriller.domain.commit.Method object at 0x7f1983eb9100>, <pydriller.domain.commit.Method object at 0x7f1983eb9520>, <pydriller.domain.commit.Method object at 0x7f1983eb9910>, <pydriller.domain.commit.Method object at 0x7f1983eb2bb0>, <pydriller.domain.commit.Method object at 0x7f1983eb2670>, <pydriller.domain.commit.Method object at 0x7f1983eb2520>, <pydriller.domain.commit.Method object at 0x7f1983eb2250>, <pydriller.domain.commit.Method object at 0x7f1983ec0640>, <pydriller.domain.commit.Method object at 0x7f1983ec0130>, <pydriller.domain.commit.Method object at 0x7f1983ec07c0>, <pydriller.domain.commit.Method object at 0x7f1983ec0790>, <pydriller.domain.commit.Method object at 0x7f1983ec0a60>, <pydriller.domain.commit.Method object at 0x7f1983ec08e0>, <pydriller.domain.commit.Method object at 0x7f1983ec03d0>, <pydriller.domain.commit.Method object at 0x7f1983ec0a30>], [<pydriller.domain.commit.Method object at 0x7f1983f053a0>, <pydriller.domain.commit.Method object at 0x7f1983f054f0>, <pydriller.domain.commit.Method object at 0x7f1983f053d0>, <pydriller.domain.commit.Method object at 0x7f1983f05250>, <pydriller.domain.commit.Method object at 0x7f1983efebb0>, <pydriller.domain.commit.Method object at 0x7f1983efea30>, <pydriller.domain.commit.Method object at 0x7f1983efea60>, <pydriller.domain.commit.Method object at 0x7f1983efe8e0>, <pydriller.domain.commit.Method object at 0x7f1983efe910>, <pydriller.domain.commit.Method object at 0x7f1983efe790>]]","[[<pydriller.domain.commit.Method object at 0x7f1983eaed00>, <pydriller.domain.commit.Method object at 0x7f1983e294f0>, <pydriller.domain.commit.Method object at 0x7f1983eae3d0>, <pydriller.domain.commit.Method object at 0x7f1983eae790>, <pydriller.domain.commit.Method object at 0x7f1983e29a60>, <pydriller.domain.commit.Method object at 0x7f1983eae250>], [<pydriller.domain.commit.Method object at 0x7f1983e7af70>], [<pydriller.domain.commit.Method object at 0x7f1983ec07c0>, <pydriller.domain.commit.Method object at 0x7f1983ec0790>, <pydriller.domain.commit.Method object at 0x7f1983ec0a30>, <pydriller.domain.commit.Method object at 0x7f1983e62a30>, <pydriller.domain.commit.Method object at 0x7f1983e62280>, <pydriller.domain.commit.Method object at 0x7f1983e3ca30>, <pydriller.domain.commit.Method object at 0x7f1983ec08e0>, <pydriller.domain.commit.Method object at 0x7f1983e62a60>, <pydriller.domain.commit.Method object at 0x7f1983debbe0>, <pydriller.domain.commit.Method object at 0x7f1983ec0a60>, <pydriller.domain.commit.Method object at 0x7f1983ec03d0>, <pydriller.domain.commit.Method object at 0x7f1983e62cd0>], [<pydriller.domain.commit.Method object at 0x7f1983f05bb0>]]"
thefuck,20b6c4c1600e5d696c0f004242b6d21ce90ea4f0,Inherit `RulesNamesList` from `list`,2015-04-22 22:36:18+02:00,nvbn,16,25,41,3,"['test_conf.py', 'test_main.py', 'conf.py']","[""from mock import patch, Mock\nfrom thefuck.main import Rule\nfrom thefuck import conf\n\n\ndef test_rules_list():\n    assert conf.RulesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert conf.RulesList(['bash', 'lisp']) == conf.RulesList(['bash', 'lisp'])\n    assert Rule('lisp', None, None, False) in conf.RulesList(['lisp'])\n    assert Rule('bash', None, None, False) not in conf.RulesList(['lisp'])\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT\n    assert Rule('test', None, None, False) not in conf.DEFAULT\n    assert Rule('test', None, None, False) in (conf.DEFAULT + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.DEFAULT_SETTINGS.items():\n            assert getattr(conf.get_settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT:bash:lisp'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['bash', 'lisp']\n\n\ndef test_update_settings():\n    settings = conf.Settings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main, conf\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == main.Rule('bash', match, get_new_command, True)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.DEFAULT))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True),\n                   main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True)]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.RulesList(['bash'])))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('bash', 'bash', 'bash', True)]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None, True),\n             main.Rule('', lambda *_: False, None, True),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None, True)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs\n\n\nclass RulesList(object):\n    """"""Wrapper a top of list for string rules names.""""""\n\n    def __init__(self, rules):\n        self.rules = rules\n\n    def __contains__(self, item):\n        return item.name in self.rules\n\n    def __getattr__(self, item):\n        return getattr(self.rules, item)\n\n    def __eq__(self, other):\n        return self.rules == other\n\n\nclass _DefaultRules(RulesList):\n    def __add__(self, items):\n        return _DefaultRules(self.rules + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRules, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRules):\n            return self.rules == other.rules\n        else:\n            return False\n\n\nDEFAULT = _DefaultRules([])\n\n\nclass Settings(object):\n    def __init__(self, conf):\n        self._conf = conf\n\n    def __getattr__(self, item):\n        return self._conf.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = copy(self._conf)\n        conf.update(kwargs)\n        return Settings(conf)\n\n\nDEFAULT_SETTINGS = {\'rules\': DEFAULT,\n                    \'wait_command\': 3,\n                    \'require_confirmation\': False,\n                    \'no_colors\': False}\n\nENV_TO_ATTR = {\'THEFUCK_RULES\': \'rules\',\n               \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n               \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n               \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n\ndef _settings_from_file(user_dir):\n    """"""Loads settings from file.""""""\n    settings = load_source(\'settings\',\n                           text_type(user_dir.joinpath(\'settings.py\')))\n    return {key: getattr(settings, key)\n            for key in DEFAULT_SETTINGS.keys()\n            if hasattr(settings, key)}\n\n\ndef _rules_from_env(val):\n    """"""Transforms rules list from env-string to python.""""""\n    val = val.split(\':\')\n    if \'DEFAULT\' in val:\n        val = DEFAULT + [rule for rule in val if rule != \'DEFAULT\']\n    return val\n\n\ndef _val_from_env(env, attr):\n    """"""Transforms env-strings to python.""""""\n    val = os.environ[env]\n    if attr == \'rules\':\n        val = _rules_from_env(val)\n    elif attr == \'wait_command\':\n        val = int(val)\n    elif attr in (\'require_confirmation\', \'no_colors\'):\n        val = val.lower() == \'true\'\n    return val\n\n\ndef _settings_from_env():\n    """"""Loads settings from env.""""""\n    return {attr: _val_from_env(env, attr)\n            for env, attr in ENV_TO_ATTR.items()\n            if env in os.environ}\n\n\ndef get_settings(user_dir):\n    """"""Returns settings filled with values from `settings.py` and env.""""""\n    conf = copy(DEFAULT_SETTINGS)\n    try:\n        conf.update(_settings_from_file(user_dir))\n    except Exception:\n        logs.exception(""Can\'t load settings from file"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    try:\n        conf.update(_settings_from_env())\n    except Exception:\n        logs.exception(""Can\'t load settings from env"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    if not isinstance(conf[\'rules\'], RulesList):\n        conf[\'rules\'] = RulesList(conf[\'rules\'])\n\n    return Settings(conf)\n']","[""from mock import patch, Mock\nfrom thefuck.main import Rule\nfrom thefuck import conf\n\n\ndef test_rules_names_list():\n    assert conf.RulesNamesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert conf.RulesNamesList(['bash', 'lisp']) == conf.RulesNamesList(['bash', 'lisp'])\n    assert Rule('lisp', None, None, False) in conf.RulesNamesList(['lisp'])\n    assert Rule('bash', None, None, False) not in conf.RulesNamesList(['lisp'])\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT\n    assert Rule('test', None, None, False) not in conf.DEFAULT\n    assert Rule('test', None, None, False) in (conf.DEFAULT + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.DEFAULT_SETTINGS.items():\n            assert getattr(conf.get_settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT:bash:lisp'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['bash', 'lisp']\n\n\ndef test_update_settings():\n    settings = conf.Settings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main, conf\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == main.Rule('bash', match, get_new_command, True)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.DEFAULT))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True),\n                   main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True)]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.RulesNamesList(['bash'])))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('bash', 'bash', 'bash', True)]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None, True),\n             main.Rule('', lambda *_: False, None, True),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None, True)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs\n\n\nclass RulesNamesList(list):\n    """"""Wrapper a top of list for string rules names.""""""\n\n    def __contains__(self, item):\n        return super(RulesNamesList, self).__contains__(item.name)\n\n\nclass _DefaultRulesNames(RulesNamesList):\n    def __add__(self, items):\n        return _DefaultRulesNames(list(self) + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRulesNames, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRulesNames):\n            return super(_DefaultRulesNames, self).__eq__(other)\n        else:\n            return False\n\n\nDEFAULT = _DefaultRulesNames([])\n\n\nclass Settings(object):\n    def __init__(self, conf):\n        self._conf = conf\n\n    def __getattr__(self, item):\n        return self._conf.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = copy(self._conf)\n        conf.update(kwargs)\n        return Settings(conf)\n\n\nDEFAULT_SETTINGS = {\'rules\': DEFAULT,\n                    \'wait_command\': 3,\n                    \'require_confirmation\': False,\n                    \'no_colors\': False}\n\nENV_TO_ATTR = {\'THEFUCK_RULES\': \'rules\',\n               \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n               \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n               \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n\ndef _settings_from_file(user_dir):\n    """"""Loads settings from file.""""""\n    settings = load_source(\'settings\',\n                           text_type(user_dir.joinpath(\'settings.py\')))\n    return {key: getattr(settings, key)\n            for key in DEFAULT_SETTINGS.keys()\n            if hasattr(settings, key)}\n\n\ndef _rules_from_env(val):\n    """"""Transforms rules list from env-string to python.""""""\n    val = val.split(\':\')\n    if \'DEFAULT\' in val:\n        val = DEFAULT + [rule for rule in val if rule != \'DEFAULT\']\n    return val\n\n\ndef _val_from_env(env, attr):\n    """"""Transforms env-strings to python.""""""\n    val = os.environ[env]\n    if attr == \'rules\':\n        val = _rules_from_env(val)\n    elif attr == \'wait_command\':\n        val = int(val)\n    elif attr in (\'require_confirmation\', \'no_colors\'):\n        val = val.lower() == \'true\'\n    return val\n\n\ndef _settings_from_env():\n    """"""Loads settings from env.""""""\n    return {attr: _val_from_env(env, attr)\n            for env, attr in ENV_TO_ATTR.items()\n            if env in os.environ}\n\n\ndef get_settings(user_dir):\n    """"""Returns settings filled with values from `settings.py` and env.""""""\n    conf = copy(DEFAULT_SETTINGS)\n    try:\n        conf.update(_settings_from_file(user_dir))\n    except Exception:\n        logs.exception(""Can\'t load settings from file"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    try:\n        conf.update(_settings_from_env())\n    except Exception:\n        logs.exception(""Can\'t load settings from env"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    if not isinstance(conf[\'rules\'], RulesNamesList):\n        conf[\'rules\'] = RulesNamesList(conf[\'rules\'])\n\n    return Settings(conf)\n']","[[<pydriller.domain.commit.Method object at 0x7f1983ef3cd0>, <pydriller.domain.commit.Method object at 0x7f1983ef3e20>, <pydriller.domain.commit.Method object at 0x7f1983ef3d00>, <pydriller.domain.commit.Method object at 0x7f1983ef3b80>, <pydriller.domain.commit.Method object at 0x7f1983ef3670>, <pydriller.domain.commit.Method object at 0x7f1983ef34f0>, <pydriller.domain.commit.Method object at 0x7f1983ef3520>, <pydriller.domain.commit.Method object at 0x7f1983ef33a0>], [<pydriller.domain.commit.Method object at 0x7f1983efee20>, <pydriller.domain.commit.Method object at 0x7f1983efef70>, <pydriller.domain.commit.Method object at 0x7f1983efee50>, <pydriller.domain.commit.Method object at 0x7f1983efecd0>, <pydriller.domain.commit.Method object at 0x7f1983f09520>, <pydriller.domain.commit.Method object at 0x7f1983f094f0>], [<pydriller.domain.commit.Method object at 0x7f1983eb93a0>, <pydriller.domain.commit.Method object at 0x7f1983eb9670>, <pydriller.domain.commit.Method object at 0x7f1983eb9f70>, <pydriller.domain.commit.Method object at 0x7f1983eb93d0>, <pydriller.domain.commit.Method object at 0x7f1983de6fd0>, <pydriller.domain.commit.Method object at 0x7f1983de6430>, <pydriller.domain.commit.Method object at 0x7f1983de6550>, <pydriller.domain.commit.Method object at 0x7f1983ddfac0>, <pydriller.domain.commit.Method object at 0x7f1983e86520>, <pydriller.domain.commit.Method object at 0x7f1983e12130>, <pydriller.domain.commit.Method object at 0x7f1983e12640>, <pydriller.domain.commit.Method object at 0x7f1983e12100>, <pydriller.domain.commit.Method object at 0x7f1983e12d00>, <pydriller.domain.commit.Method object at 0x7f1983e123a0>, <pydriller.domain.commit.Method object at 0x7f1983e123d0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983ef3cd0>, <pydriller.domain.commit.Method object at 0x7f1983e90790>], [<pydriller.domain.commit.Method object at 0x7f1983ef87c0>], [<pydriller.domain.commit.Method object at 0x7f1983f09250>, <pydriller.domain.commit.Method object at 0x7f1983eb9f70>, <pydriller.domain.commit.Method object at 0x7f1983f05fa0>, <pydriller.domain.commit.Method object at 0x7f1983f09b80>, <pydriller.domain.commit.Method object at 0x7f1983f09100>, <pydriller.domain.commit.Method object at 0x7f1983eb93a0>]]"
thefuck,54c408a6b572e84f75b1f11133d6769a6aef3dab,Rename `DEFAULT` to `DEFAULT_RULES`,2015-04-22 22:37:11+02:00,nvbn,14,14,28,4,"['README.md', 'test_conf.py', 'test_main.py', 'conf.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""from mock import patch, Mock\nfrom thefuck.main import Rule\nfrom thefuck import conf\n\n\ndef test_rules_names_list():\n    assert conf.RulesNamesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert conf.RulesNamesList(['bash', 'lisp']) == conf.RulesNamesList(['bash', 'lisp'])\n    assert Rule('lisp', None, None, False) in conf.RulesNamesList(['lisp'])\n    assert Rule('bash', None, None, False) not in conf.RulesNamesList(['lisp'])\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT\n    assert Rule('test', None, None, False) not in conf.DEFAULT\n    assert Rule('test', None, None, False) in (conf.DEFAULT + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.DEFAULT_SETTINGS.items():\n            assert getattr(conf.get_settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT:bash:lisp'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['bash', 'lisp']\n\n\ndef test_update_settings():\n    settings = conf.Settings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main, conf\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == main.Rule('bash', match, get_new_command, True)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.DEFAULT))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True),\n                   main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True)]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.RulesNamesList(['bash'])))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('bash', 'bash', 'bash', True)]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None, True),\n             main.Rule('', lambda *_: False, None, True),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None, True)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs\n\n\nclass RulesNamesList(list):\n    """"""Wrapper a top of list for string rules names.""""""\n\n    def __contains__(self, item):\n        return super(RulesNamesList, self).__contains__(item.name)\n\n\nclass _DefaultRulesNames(RulesNamesList):\n    def __add__(self, items):\n        return _DefaultRulesNames(list(self) + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRulesNames, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRulesNames):\n            return super(_DefaultRulesNames, self).__eq__(other)\n        else:\n            return False\n\n\nDEFAULT = _DefaultRulesNames([])\n\n\nclass Settings(object):\n    def __init__(self, conf):\n        self._conf = conf\n\n    def __getattr__(self, item):\n        return self._conf.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = copy(self._conf)\n        conf.update(kwargs)\n        return Settings(conf)\n\n\nDEFAULT_SETTINGS = {\'rules\': DEFAULT,\n                    \'wait_command\': 3,\n                    \'require_confirmation\': False,\n                    \'no_colors\': False}\n\nENV_TO_ATTR = {\'THEFUCK_RULES\': \'rules\',\n               \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n               \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n               \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n\ndef _settings_from_file(user_dir):\n    """"""Loads settings from file.""""""\n    settings = load_source(\'settings\',\n                           text_type(user_dir.joinpath(\'settings.py\')))\n    return {key: getattr(settings, key)\n            for key in DEFAULT_SETTINGS.keys()\n            if hasattr(settings, key)}\n\n\ndef _rules_from_env(val):\n    """"""Transforms rules list from env-string to python.""""""\n    val = val.split(\':\')\n    if \'DEFAULT\' in val:\n        val = DEFAULT + [rule for rule in val if rule != \'DEFAULT\']\n    return val\n\n\ndef _val_from_env(env, attr):\n    """"""Transforms env-strings to python.""""""\n    val = os.environ[env]\n    if attr == \'rules\':\n        val = _rules_from_env(val)\n    elif attr == \'wait_command\':\n        val = int(val)\n    elif attr in (\'require_confirmation\', \'no_colors\'):\n        val = val.lower() == \'true\'\n    return val\n\n\ndef _settings_from_env():\n    """"""Loads settings from env.""""""\n    return {attr: _val_from_env(env, attr)\n            for env, attr in ENV_TO_ATTR.items()\n            if env in os.environ}\n\n\ndef get_settings(user_dir):\n    """"""Returns settings filled with values from `settings.py` and env.""""""\n    conf = copy(DEFAULT_SETTINGS)\n    try:\n        conf.update(_settings_from_file(user_dir))\n    except Exception:\n        logs.exception(""Can\'t load settings from file"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    try:\n        conf.update(_settings_from_env())\n    except Exception:\n        logs.exception(""Can\'t load settings from env"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    if not isinstance(conf[\'rules\'], RulesNamesList):\n        conf[\'rules\'] = RulesNamesList(conf[\'rules\'])\n\n    return Settings(conf)\n']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""from mock import patch, Mock\nfrom thefuck.main import Rule\nfrom thefuck import conf\n\n\ndef test_rules_names_list():\n    assert conf.RulesNamesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert conf.RulesNamesList(['bash', 'lisp']) == conf.RulesNamesList(['bash', 'lisp'])\n    assert Rule('lisp', None, None, False) in conf.RulesNamesList(['lisp'])\n    assert Rule('bash', None, None, False) not in conf.RulesNamesList(['lisp'])\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT_RULES\n    assert Rule('test', None, None, False) not in conf.DEFAULT_RULES\n    assert Rule('test', None, None, False) in (conf.DEFAULT_RULES + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.DEFAULT_SETTINGS.items():\n            assert getattr(conf.get_settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT_RULES + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT_RULES:bash:lisp'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['bash', 'lisp']\n\n\ndef test_update_settings():\n    settings = conf.Settings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main, conf\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == main.Rule('bash', match, get_new_command, True)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.DEFAULT_RULES))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True),\n                   main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True)]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.RulesNamesList(['bash'])))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('bash', 'bash', 'bash', True)]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None, True),\n             main.Rule('', lambda *_: False, None, True),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None, True)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs\n\n\nclass RulesNamesList(list):\n    """"""Wrapper a top of list for string rules names.""""""\n\n    def __contains__(self, item):\n        return super(RulesNamesList, self).__contains__(item.name)\n\n\nclass _DefaultRulesNames(RulesNamesList):\n    def __add__(self, items):\n        return _DefaultRulesNames(list(self) + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRulesNames, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRulesNames):\n            return super(_DefaultRulesNames, self).__eq__(other)\n        else:\n            return False\n\n\nDEFAULT_RULES = _DefaultRulesNames([])\n\n\nclass Settings(object):\n    def __init__(self, conf):\n        self._conf = conf\n\n    def __getattr__(self, item):\n        return self._conf.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = copy(self._conf)\n        conf.update(kwargs)\n        return Settings(conf)\n\n\nDEFAULT_SETTINGS = {\'rules\': DEFAULT_RULES,\n                    \'wait_command\': 3,\n                    \'require_confirmation\': False,\n                    \'no_colors\': False}\n\nENV_TO_ATTR = {\'THEFUCK_RULES\': \'rules\',\n               \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n               \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n               \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n\ndef _settings_from_file(user_dir):\n    """"""Loads settings from file.""""""\n    settings = load_source(\'settings\',\n                           text_type(user_dir.joinpath(\'settings.py\')))\n    return {key: getattr(settings, key)\n            for key in DEFAULT_SETTINGS.keys()\n            if hasattr(settings, key)}\n\n\ndef _rules_from_env(val):\n    """"""Transforms rules list from env-string to python.""""""\n    val = val.split(\':\')\n    if \'DEFAULT_RULES\' in val:\n        val = DEFAULT_RULES + [rule for rule in val if rule != \'DEFAULT_RULES\']\n    return val\n\n\ndef _val_from_env(env, attr):\n    """"""Transforms env-strings to python.""""""\n    val = os.environ[env]\n    if attr == \'rules\':\n        val = _rules_from_env(val)\n    elif attr == \'wait_command\':\n        val = int(val)\n    elif attr in (\'require_confirmation\', \'no_colors\'):\n        val = val.lower() == \'true\'\n    return val\n\n\ndef _settings_from_env():\n    """"""Loads settings from env.""""""\n    return {attr: _val_from_env(env, attr)\n            for env, attr in ENV_TO_ATTR.items()\n            if env in os.environ}\n\n\ndef get_settings(user_dir):\n    """"""Returns settings filled with values from `settings.py` and env.""""""\n    conf = copy(DEFAULT_SETTINGS)\n    try:\n        conf.update(_settings_from_file(user_dir))\n    except Exception:\n        logs.exception(""Can\'t load settings from file"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    try:\n        conf.update(_settings_from_env())\n    except Exception:\n        logs.exception(""Can\'t load settings from env"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    if not isinstance(conf[\'rules\'], RulesNamesList):\n        conf[\'rules\'] = RulesNamesList(conf[\'rules\'])\n\n    return Settings(conf)\n']","[[], [<pydriller.domain.commit.Method object at 0x7f1983e51a30>, <pydriller.domain.commit.Method object at 0x7f1983ef33d0>, <pydriller.domain.commit.Method object at 0x7f1983ef3e50>, <pydriller.domain.commit.Method object at 0x7f1983ef3250>, <pydriller.domain.commit.Method object at 0x7f1983ef3790>, <pydriller.domain.commit.Method object at 0x7f1983ef37c0>, <pydriller.domain.commit.Method object at 0x7f1983ef3640>, <pydriller.domain.commit.Method object at 0x7f1983ef3100>], [<pydriller.domain.commit.Method object at 0x7f1983ee7b80>, <pydriller.domain.commit.Method object at 0x7f1983ee7cd0>, <pydriller.domain.commit.Method object at 0x7f1983ee7bb0>, <pydriller.domain.commit.Method object at 0x7f1983ee7a30>, <pydriller.domain.commit.Method object at 0x7f1983ee7670>, <pydriller.domain.commit.Method object at 0x7f1983ee74f0>], [<pydriller.domain.commit.Method object at 0x7f1983edc790>, <pydriller.domain.commit.Method object at 0x7f1983edc8e0>, <pydriller.domain.commit.Method object at 0x7f1983edc7c0>, <pydriller.domain.commit.Method object at 0x7f1983edc640>, <pydriller.domain.commit.Method object at 0x7f1983ee7130>, <pydriller.domain.commit.Method object at 0x7f1983ee7250>, <pydriller.domain.commit.Method object at 0x7f1983ee7280>, <pydriller.domain.commit.Method object at 0x7f1983ee73d0>, <pydriller.domain.commit.Method object at 0x7f1983ee7e50>, <pydriller.domain.commit.Method object at 0x7f1983ee7fa0>, <pydriller.domain.commit.Method object at 0x7f1983ee7e20>, <pydriller.domain.commit.Method object at 0x7f1983ee7f70>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983ec5640>, <pydriller.domain.commit.Method object at 0x7f1983eaea60>, <pydriller.domain.commit.Method object at 0x7f1983e96d00>], [<pydriller.domain.commit.Method object at 0x7f1983eedbb0>], [<pydriller.domain.commit.Method object at 0x7f1983ee0100>]]"
thefuck,d3d1f992328dfaf245ef268090cf54bb492815b7,Move special data types to `types`,2015-04-22 23:04:22+02:00,nvbn,89,88,177,17,"['test_cd_parent.py', 'test_git_not_command.py', 'test_git_push.py', 'test_has_exists_script.py', 'test_mkdir_p.py', 'test_python_command.py', 'test_rm_dir.py', 'test_ssh_known_host.py', 'test_sudo.py', 'test_conf.py', 'test_main.py', 'test_types.py', 'test_utils.py', 'conf.py', 'main.py', 'types.py', 'utils.py']","[""from thefuck.main import Command\nfrom thefuck.rules.cd_parent import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('cd..', '', 'cd..: command not found'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(\n        Command('cd..', '', ''), None) == 'cd ..'\n"", 'import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.git_not_command import match, get_new_command\n\n\n@pytest.fixture\ndef git_not_command():\n    return """"""git: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\nbranch\n""""""\n\n\n@pytest.fixture\ndef git_not_command_one_of_this():\n    return """"""git: \'st\' is not a git command. See \'git --help\'.\n\nDid you mean one of these?\nstatus\nreset\nstage\nstash\nstats\n""""""\n\n\n@pytest.fixture\ndef git_command():\n    return ""* master""\n\n\ndef test_match(git_not_command, git_command, git_not_command_one_of_this):\n    assert match(Command(\'git brnch\', \'\', git_not_command), None)\n    assert match(Command(\'git st\', \'\', git_not_command_one_of_this), None)\n    assert not match(Command(\'ls brnch\', \'\', git_not_command), None)\n    assert not match(Command(\'git branch\', \'\', git_command), None)\n\n\ndef test_get_new_command(git_not_command, git_not_command_one_of_this):\n    assert get_new_command(Command(\'git brnch\', \'\', git_not_command), None)\\\n        == \'git branch\'\n    assert get_new_command(\n        Command(\'git st\', \'\', git_not_command_one_of_this), None) == \'git status\'\n', 'import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.git_push import match, get_new_command\n\n\n@pytest.fixture\ndef stderr():\n    return \'\'\'fatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\'\'\'\n\n\ndef test_match(stderr):\n    assert match(Command(\'git push master\', \'\', stderr), None)\n    assert not match(Command(\'git push master\', \'\', \'\'), None)\n    assert not match(Command(\'ls\', \'\', stderr), None)\n\n\ndef test_get_new_command(stderr):\n    assert get_new_command(Command(\'\', \'\', stderr), None)\\\n        == ""git push --set-upstream origin master""\n', ""from mock import Mock, patch\nfrom thefuck.rules. has_exists_script import match, get_new_command\n\n\ndef test_match():\n    with patch('os.path.exists', return_value=True):\n        assert match(Mock(script='main', stderr='main: command not found'),\n                     None)\n        assert match(Mock(script='main --help',\n                          stderr='main: command not found'),\n                     None)\n        assert not match(Mock(script='main', stderr=''), None)\n\n    with patch('os.path.exists', return_value=False):\n        assert not match(Mock(script='main', stderr='main: command not found'),\n                         None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Mock(script='main --help'), None) == './main --help'\n"", ""from thefuck.main import Command\nfrom thefuck.rules.mkdir_p import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('mkdir foo/bar/baz', '', 'mkdir: foo/bar: No such file or directory'), None)\n    assert not match(Command('mkdir foo/bar/baz', '', ''), None)\n    assert not match(Command('mkdir foo/bar/baz', '', 'foo bar baz'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('mkdir foo/bar/baz', '', ''), None) == 'mkdir -p foo/bar/baz'\n"", ""from thefuck.main import Command\nfrom thefuck.rules.python_command import match, get_new_command\n\ndef test_match():\n    assert match(Command('temp.py', '', 'Permission denied'), None)\n    assert not match(Command('', '', ''), None)\n\ndef test_get_new_command():\n    assert get_new_command(Command('./test_sudo.py', '', ''), None) == 'python ./test_sudo.py'\n"", ""from thefuck.main import Command\nfrom thefuck.rules.rm_dir import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('rm foo', '', 'rm: foo: is a directory'), None)\n    assert not match(Command('rm foo', '', ''), None)\n    assert not match(Command('rm foo', '', 'foo bar baz'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('rm foo', '', ''), None) == 'rm -rf foo'\n"", 'import os\nimport pytest\nfrom mock import Mock\nfrom thefuck.main import Command\nfrom thefuck.rules.ssh_known_hosts import match, get_new_command, remove_offending_keys\n\n\n@pytest.fixture\ndef ssh_error(tmpdir):\n    path = os.path.join(str(tmpdir), \'known_hosts\')\n\n    def reset(path):\n        with open(path, \'w\') as fh:\n            lines = [\n                \'123.234.567.890 asdjkasjdakjsd\\n\'\n                \'98.765.432.321 ejioweojwejrosj\\n\'\n                \'111.222.333.444 qwepoiwqepoiss\\n\'\n            ]\n            fh.writelines(lines)\n\n    def known_hosts(path):\n        with open(path, \'r\') as fh:\n            return fh.readlines()\n\n    reset(path)\n\n    errormsg = u""""""@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\nb6:cb:07:34:c0:a0:94:d3:0d:69:83:31:f4:c5:20:9b.\nPlease contact your system administrator.\nAdd correct host key in {0} to get rid of this message.\nOffending RSA key in {0}:2\nRSA host key for {1} has changed and you have requested strict checking.\nHost key verification failed."""""".format(path, \'98.765.432.321\')\n\n    return errormsg, path, reset, known_hosts\n\n\ndef test_match(ssh_error):\n    errormsg, _, _, _ = ssh_error\n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert not match(Command(\'\', \'\', errormsg), None)\n    assert not match(Command(\'notssh\', \'\', errormsg), None)\n    assert not match(Command(\'ssh\', \'\', \'\'), None)\n\n\ndef test_remove_offending_keys(ssh_error):\n    errormsg, path, reset, known_hosts = ssh_error\n    command = Command(\'ssh user@host\', \'\', errormsg)\n    remove_offending_keys(command, None)\n    expected = [\'123.234.567.890 asdjkasjdakjsd\\n\', \'111.222.333.444 qwepoiwqepoiss\\n\']\n    assert known_hosts(path) == expected\n\n\ndef test_get_new_command(ssh_error, monkeypatch):\n    errormsg, _, _, _ = ssh_error\n\n    method = Mock()\n    monkeypatch.setattr(\'thefuck.rules.ssh_known_hosts.remove_offending_keys\', method)\n    assert get_new_command(Command(\'ssh user@host\', \'\', errormsg), None) == \'ssh user@host\'\n    assert method.call_count\n', 'from thefuck.main import Command\nfrom thefuck.rules.sudo import match, get_new_command\n\n\ndef test_match():\n    assert match(Command(\'\', \'\', \'Permission denied\'), None)\n    assert match(Command(\'\', \'\', \'permission denied\'), None)\n    assert match(Command(\'\', \'\', ""npm ERR! Error: EACCES, unlink""), None)\n    assert not match(Command(\'\', \'\', \'\'), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command(\'ls\', \'\', \'\'), None) == \'sudo ls\'\n', ""from mock import patch, Mock\nfrom thefuck.main import Rule\nfrom thefuck import conf\n\n\ndef test_rules_names_list():\n    assert conf.RulesNamesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert conf.RulesNamesList(['bash', 'lisp']) == conf.RulesNamesList(['bash', 'lisp'])\n    assert Rule('lisp', None, None, False) in conf.RulesNamesList(['lisp'])\n    assert Rule('bash', None, None, False) not in conf.RulesNamesList(['lisp'])\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT_RULES\n    assert Rule('test', None, None, False) not in conf.DEFAULT_RULES\n    assert Rule('test', None, None, False) in (conf.DEFAULT_RULES + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.DEFAULT_SETTINGS.items():\n            assert getattr(conf.get_settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT_RULES + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT_RULES:bash:lisp'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['bash', 'lisp']\n\n\ndef test_update_settings():\n    settings = conf.Settings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main, conf\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == main.Rule('bash', match, get_new_command, True)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.DEFAULT_RULES))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True),\n                   main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True)]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.RulesNamesList(['bash'])))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('bash', 'bash', 'bash', True)]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None, True),\n             main.Rule('', lambda *_: False, None, True),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None, True)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", None, ""from mock import Mock\nfrom thefuck.utils import sudo_support, wrap_settings\nfrom thefuck.main import Command\nfrom thefuck.conf import Settings\n\n\ndef test_wrap_settings():\n    fn = lambda _, settings: settings._conf\n    assert wrap_settings({'key': 'val'})(fn)(None, Settings({})) \\\n           == {'key': 'val'}\n    assert wrap_settings({'key': 'new-val'})(fn)(\n        None, Settings({'key': 'val'})) == {'key': 'new-val'}\n\n\ndef test_sudo_support():\n    fn = Mock(return_value=True, __name__='')\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n    fn.assert_called_once_with(Command('ls', 'out', 'err'), None)\n\n    fn.return_value = False\n    assert not sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n\n    fn.return_value = 'pwd'\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None) == 'sudo pwd'\n\n    assert sudo_support(fn)(Command('ls', 'out', 'err'), None) == 'pwd'\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs\n\n\nclass RulesNamesList(list):\n    """"""Wrapper a top of list for string rules names.""""""\n\n    def __contains__(self, item):\n        return super(RulesNamesList, self).__contains__(item.name)\n\n\nclass _DefaultRulesNames(RulesNamesList):\n    def __add__(self, items):\n        return _DefaultRulesNames(list(self) + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRulesNames, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRulesNames):\n            return super(_DefaultRulesNames, self).__eq__(other)\n        else:\n            return False\n\n\nDEFAULT_RULES = _DefaultRulesNames([])\n\n\nclass Settings(object):\n    def __init__(self, conf):\n        self._conf = conf\n\n    def __getattr__(self, item):\n        return self._conf.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = copy(self._conf)\n        conf.update(kwargs)\n        return Settings(conf)\n\n\nDEFAULT_SETTINGS = {\'rules\': DEFAULT_RULES,\n                    \'wait_command\': 3,\n                    \'require_confirmation\': False,\n                    \'no_colors\': False}\n\nENV_TO_ATTR = {\'THEFUCK_RULES\': \'rules\',\n               \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n               \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n               \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n\ndef _settings_from_file(user_dir):\n    """"""Loads settings from file.""""""\n    settings = load_source(\'settings\',\n                           text_type(user_dir.joinpath(\'settings.py\')))\n    return {key: getattr(settings, key)\n            for key in DEFAULT_SETTINGS.keys()\n            if hasattr(settings, key)}\n\n\ndef _rules_from_env(val):\n    """"""Transforms rules list from env-string to python.""""""\n    val = val.split(\':\')\n    if \'DEFAULT_RULES\' in val:\n        val = DEFAULT_RULES + [rule for rule in val if rule != \'DEFAULT_RULES\']\n    return val\n\n\ndef _val_from_env(env, attr):\n    """"""Transforms env-strings to python.""""""\n    val = os.environ[env]\n    if attr == \'rules\':\n        val = _rules_from_env(val)\n    elif attr == \'wait_command\':\n        val = int(val)\n    elif attr in (\'require_confirmation\', \'no_colors\'):\n        val = val.lower() == \'true\'\n    return val\n\n\ndef _settings_from_env():\n    """"""Loads settings from env.""""""\n    return {attr: _val_from_env(env, attr)\n            for env, attr in ENV_TO_ATTR.items()\n            if env in os.environ}\n\n\ndef get_settings(user_dir):\n    """"""Returns settings filled with values from `settings.py` and env.""""""\n    conf = copy(DEFAULT_SETTINGS)\n    try:\n        conf.update(_settings_from_file(user_dir))\n    except Exception:\n        logs.exception(""Can\'t load settings from file"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    try:\n        conf.update(_settings_from_env())\n    except Exception:\n        logs.exception(""Can\'t load settings from env"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    if not isinstance(conf[\'rules\'], RulesNamesList):\n        conf[\'rules\'] = RulesNamesList(conf[\'rules\'])\n\n    return Settings(conf)\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom . import logs, conf\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', None, 'from functools import wraps\nimport os\nimport six\nfrom thefuck.main import Command\n\n\ndef which(program):\n    """"""Returns `program` path or `None`.""""""\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef wrap_settings(params):\n    """"""Adds default values to settings if it not presented.\n\n    Usage:\n\n        @wrap_settings({\'apt\': \'/usr/bin/apt\'})\n        def match(command, settings):\n            print(settings.apt)\n\n    """"""\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(command, settings):\n            return fn(command, settings.update(**params))\n        return wrapper\n    return decorator\n\n\ndef sudo_support(fn):\n    """"""Removes sudo before calling fn and adds it after.""""""\n    @wraps(fn)\n    def wrapper(command, settings):\n        if not command.script.startswith(\'sudo \'):\n            return fn(command, settings)\n\n        result = fn(Command(command.script[5:],\n                            command.stdout,\n                            command.stderr),\n                    settings)\n\n        if result and isinstance(result, six.string_types):\n            return u\'sudo {}\'.format(result)\n        else:\n            return result\n    return wrapper\n']","[""from thefuck.types import Command\nfrom thefuck.rules.cd_parent import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('cd..', '', 'cd..: command not found'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(\n        Command('cd..', '', ''), None) == 'cd ..'\n"", 'import pytest\nfrom thefuck.types import Command\nfrom thefuck.rules.git_not_command import match, get_new_command\n\n\n@pytest.fixture\ndef git_not_command():\n    return """"""git: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\nbranch\n""""""\n\n\n@pytest.fixture\ndef git_not_command_one_of_this():\n    return """"""git: \'st\' is not a git command. See \'git --help\'.\n\nDid you mean one of these?\nstatus\nreset\nstage\nstash\nstats\n""""""\n\n\n@pytest.fixture\ndef git_command():\n    return ""* master""\n\n\ndef test_match(git_not_command, git_command, git_not_command_one_of_this):\n    assert match(Command(\'git brnch\', \'\', git_not_command), None)\n    assert match(Command(\'git st\', \'\', git_not_command_one_of_this), None)\n    assert not match(Command(\'ls brnch\', \'\', git_not_command), None)\n    assert not match(Command(\'git branch\', \'\', git_command), None)\n\n\ndef test_get_new_command(git_not_command, git_not_command_one_of_this):\n    assert get_new_command(Command(\'git brnch\', \'\', git_not_command), None)\\\n        == \'git branch\'\n    assert get_new_command(\n        Command(\'git st\', \'\', git_not_command_one_of_this), None) == \'git status\'\n', 'import pytest\nfrom thefuck.types import Command\nfrom thefuck.rules.git_push import match, get_new_command\n\n\n@pytest.fixture\ndef stderr():\n    return \'\'\'fatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\'\'\'\n\n\ndef test_match(stderr):\n    assert match(Command(\'git push master\', \'\', stderr), None)\n    assert not match(Command(\'git push master\', \'\', \'\'), None)\n    assert not match(Command(\'ls\', \'\', stderr), None)\n\n\ndef test_get_new_command(stderr):\n    assert get_new_command(Command(\'\', \'\', stderr), None)\\\n        == ""git push --set-upstream origin master""\n', ""from mock import Mock, patch\nfrom thefuck.rules.has_exists_script import match, get_new_command\n\n\ndef test_match():\n    with patch('os.path.exists', return_value=True):\n        assert match(Mock(script='main', stderr='main: command not found'),\n                     None)\n        assert match(Mock(script='main --help',\n                          stderr='main: command not found'),\n                     None)\n        assert not match(Mock(script='main', stderr=''), None)\n\n    with patch('os.path.exists', return_value=False):\n        assert not match(Mock(script='main', stderr='main: command not found'),\n                         None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Mock(script='main --help'), None) == './main --help'\n"", ""from thefuck.types import Command\nfrom thefuck.rules.mkdir_p import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('mkdir foo/bar/baz', '', 'mkdir: foo/bar: No such file or directory'), None)\n    assert not match(Command('mkdir foo/bar/baz', '', ''), None)\n    assert not match(Command('mkdir foo/bar/baz', '', 'foo bar baz'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('mkdir foo/bar/baz', '', ''), None) == 'mkdir -p foo/bar/baz'\n"", ""from thefuck.types import Command\nfrom thefuck.rules.python_command import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('temp.py', '', 'Permission denied'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('./test_sudo.py', '', ''), None) == 'python ./test_sudo.py'\n"", ""from thefuck.types import Command\nfrom thefuck.rules.rm_dir import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('rm foo', '', 'rm: foo: is a directory'), None)\n    assert not match(Command('rm foo', '', ''), None)\n    assert not match(Command('rm foo', '', 'foo bar baz'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('rm foo', '', ''), None) == 'rm -rf foo'\n"", 'import os\nimport pytest\nfrom mock import Mock\nfrom thefuck.types import Command\nfrom thefuck.rules.ssh_known_hosts import match, get_new_command, remove_offending_keys\n\n\n@pytest.fixture\ndef ssh_error(tmpdir):\n    path = os.path.join(str(tmpdir), \'known_hosts\')\n\n    def reset(path):\n        with open(path, \'w\') as fh:\n            lines = [\n                \'123.234.567.890 asdjkasjdakjsd\\n\'\n                \'98.765.432.321 ejioweojwejrosj\\n\'\n                \'111.222.333.444 qwepoiwqepoiss\\n\'\n            ]\n            fh.writelines(lines)\n\n    def known_hosts(path):\n        with open(path, \'r\') as fh:\n            return fh.readlines()\n\n    reset(path)\n\n    errormsg = u""""""@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\nb6:cb:07:34:c0:a0:94:d3:0d:69:83:31:f4:c5:20:9b.\nPlease contact your system administrator.\nAdd correct host key in {0} to get rid of this message.\nOffending RSA key in {0}:2\nRSA host key for {1} has changed and you have requested strict checking.\nHost key verification failed."""""".format(path, \'98.765.432.321\')\n\n    return errormsg, path, reset, known_hosts\n\n\ndef test_match(ssh_error):\n    errormsg, _, _, _ = ssh_error\n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert not match(Command(\'\', \'\', errormsg), None)\n    assert not match(Command(\'notssh\', \'\', errormsg), None)\n    assert not match(Command(\'ssh\', \'\', \'\'), None)\n\n\ndef test_remove_offending_keys(ssh_error):\n    errormsg, path, reset, known_hosts = ssh_error\n    command = Command(\'ssh user@host\', \'\', errormsg)\n    remove_offending_keys(command, None)\n    expected = [\'123.234.567.890 asdjkasjdakjsd\\n\', \'111.222.333.444 qwepoiwqepoiss\\n\']\n    assert known_hosts(path) == expected\n\n\ndef test_get_new_command(ssh_error, monkeypatch):\n    errormsg, _, _, _ = ssh_error\n\n    method = Mock()\n    monkeypatch.setattr(\'thefuck.rules.ssh_known_hosts.remove_offending_keys\', method)\n    assert get_new_command(Command(\'ssh user@host\', \'\', errormsg), None) == \'ssh user@host\'\n    assert method.call_count\n', 'from thefuck.types import Command\nfrom thefuck.rules.sudo import match, get_new_command\n\n\ndef test_match():\n    assert match(Command(\'\', \'\', \'Permission denied\'), None)\n    assert match(Command(\'\', \'\', \'permission denied\'), None)\n    assert match(Command(\'\', \'\', ""npm ERR! Error: EACCES, unlink""), None)\n    assert not match(Command(\'\', \'\', \'\'), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command(\'ls\', \'\', \'\'), None) == \'sudo ls\'\n', ""from mock import patch, Mock\nfrom thefuck.types import Rule\nfrom thefuck import conf\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT_RULES\n    assert Rule('test', None, None, False) not in conf.DEFAULT_RULES\n    assert Rule('test', None, None, False) in (conf.DEFAULT_RULES + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.DEFAULT_SETTINGS.items():\n            assert getattr(conf.get_settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT_RULES + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT_RULES:bash:lisp'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['bash', 'lisp']\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main, conf, types\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == types.Rule('bash', match, get_new_command, True)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.DEFAULT_RULES))) \\\n               == [types.Rule('bash', 'bash', 'bash', True),\n                   types.Rule('lisp', 'lisp', 'lisp', True),\n                   types.Rule('bash', 'bash', 'bash', True),\n                   types.Rule('lisp', 'lisp', 'lisp', True)]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=types.RulesNamesList(['bash'])))) \\\n               == [types.Rule('bash', 'bash', 'bash', True),\n                   types.Rule('bash', 'bash', 'bash', True)]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == types.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [types.Rule('', lambda x, _: x.script == 'cd ..', None, True),\n             types.Rule('', lambda *_: False, None, True),\n             types.Rule('rule', Mock(side_effect=OSError('Denied')), None, True)]\n    assert main.get_matched_rule(types.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(types.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(types.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(types.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", ""from thefuck.types import Rule, RulesNamesList, Settings\n\n\ndef test_rules_names_list():\n    assert RulesNamesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert RulesNamesList(['bash', 'lisp']) == RulesNamesList(['bash', 'lisp'])\n    assert Rule('lisp', None, None, False) in RulesNamesList(['lisp'])\n    assert Rule('bash', None, None, False) not in RulesNamesList(['lisp'])\n\n\ndef test_update_settings():\n    settings = Settings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from mock import Mock\nfrom thefuck.utils import sudo_support, wrap_settings\nfrom thefuck.types import Command, Settings\n\n\ndef test_wrap_settings():\n    fn = lambda _, settings: settings\n    assert wrap_settings({'key': 'val'})(fn)(None, Settings({})) \\\n           == {'key': 'val'}\n    assert wrap_settings({'key': 'new-val'})(fn)(\n        None, Settings({'key': 'val'})) == {'key': 'new-val'}\n\n\ndef test_sudo_support():\n    fn = Mock(return_value=True, __name__='')\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n    fn.assert_called_once_with(Command('ls', 'out', 'err'), None)\n\n    fn.return_value = False\n    assert not sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n\n    fn.return_value = 'pwd'\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None) == 'sudo pwd'\n\n    assert sudo_support(fn)(Command('ls', 'out', 'err'), None) == 'pwd'\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs, types\n\n\nclass _DefaultRulesNames(types.RulesNamesList):\n    def __add__(self, items):\n        return _DefaultRulesNames(list(self) + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRulesNames, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRulesNames):\n            return super(_DefaultRulesNames, self).__eq__(other)\n        else:\n            return False\n\n\nDEFAULT_RULES = _DefaultRulesNames([])\n\n\nDEFAULT_SETTINGS = {\'rules\': DEFAULT_RULES,\n                    \'wait_command\': 3,\n                    \'require_confirmation\': False,\n                    \'no_colors\': False}\n\nENV_TO_ATTR = {\'THEFUCK_RULES\': \'rules\',\n               \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n               \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n               \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n\ndef _settings_from_file(user_dir):\n    """"""Loads settings from file.""""""\n    settings = load_source(\'settings\',\n                           text_type(user_dir.joinpath(\'settings.py\')))\n    return {key: getattr(settings, key)\n            for key in DEFAULT_SETTINGS.keys()\n            if hasattr(settings, key)}\n\n\ndef _rules_from_env(val):\n    """"""Transforms rules list from env-string to python.""""""\n    val = val.split(\':\')\n    if \'DEFAULT_RULES\' in val:\n        val = DEFAULT_RULES + [rule for rule in val if rule != \'DEFAULT_RULES\']\n    return val\n\n\ndef _val_from_env(env, attr):\n    """"""Transforms env-strings to python.""""""\n    val = os.environ[env]\n    if attr == \'rules\':\n        val = _rules_from_env(val)\n    elif attr == \'wait_command\':\n        val = int(val)\n    elif attr in (\'require_confirmation\', \'no_colors\'):\n        val = val.lower() == \'true\'\n    return val\n\n\ndef _settings_from_env():\n    """"""Loads settings from env.""""""\n    return {attr: _val_from_env(env, attr)\n            for env, attr in ENV_TO_ATTR.items()\n            if env in os.environ}\n\n\ndef get_settings(user_dir):\n    """"""Returns settings filled with values from `settings.py` and env.""""""\n    conf = copy(DEFAULT_SETTINGS)\n    try:\n        conf.update(_settings_from_file(user_dir))\n    except Exception:\n        logs.exception(""Can\'t load settings from file"",\n                       sys.exc_info(),\n                       types.Settings(conf))\n\n    try:\n        conf.update(_settings_from_env())\n    except Exception:\n        logs.exception(""Can\'t load settings from env"",\n                       sys.exc_info(),\n                       types.Settings(conf))\n\n    if not isinstance(conf[\'rules\'], types.RulesNamesList):\n        conf[\'rules\'] = types.RulesNamesList(conf[\'rules\'])\n\n    return types.Settings(conf)\n', 'from imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom . import logs, conf, types\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return types.Rule(rule.name[:-3], rule_module.match,\n                      rule_module.get_new_command,\n                      getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent \\\n        .joinpath(\'rules\') \\\n        .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return types.Command(script, result.stdout.read().decode(\'utf-8\'),\n                             result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', 'from collections import namedtuple\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\n\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\nclass RulesNamesList(list):\n    """"""Wrapper a top of list for string rules names.""""""\n\n    def __contains__(self, item):\n        return super(RulesNamesList, self).__contains__(item.name)\n\n\nclass Settings(dict):\n\n    def __getattr__(self, item):\n        return self.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = dict(self)\n        conf.update(kwargs)\n        return Settings(conf)\n', 'from functools import wraps\nimport os\nimport six\nfrom .types import Command\n\n\ndef which(program):\n    """"""Returns `program` path or `None`.""""""\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef wrap_settings(params):\n    """"""Adds default values to settings if it not presented.\n\n    Usage:\n\n        @wrap_settings({\'apt\': \'/usr/bin/apt\'})\n        def match(command, settings):\n            print(settings.apt)\n\n    """"""\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(command, settings):\n            return fn(command, settings.update(**params))\n        return wrapper\n    return decorator\n\n\ndef sudo_support(fn):\n    """"""Removes sudo before calling fn and adds it after.""""""\n    @wraps(fn)\n    def wrapper(command, settings):\n        if not command.script.startswith(\'sudo \'):\n            return fn(command, settings)\n\n        result = fn(Command(command.script[5:],\n                            command.stdout,\n                            command.stderr),\n                    settings)\n\n        if result and isinstance(result, six.string_types):\n            return u\'sudo {}\'.format(result)\n        else:\n            return result\n    return wrapper\n']","[[<pydriller.domain.commit.Method object at 0x7f1983eb94f0>, <pydriller.domain.commit.Method object at 0x7f1983eb9a60>], [<pydriller.domain.commit.Method object at 0x7f1983ed5d00>, <pydriller.domain.commit.Method object at 0x7f1983ed5e20>, <pydriller.domain.commit.Method object at 0x7f1983ed5e50>, <pydriller.domain.commit.Method object at 0x7f1983ed5cd0>, <pydriller.domain.commit.Method object at 0x7f1983e57a30>], [<pydriller.domain.commit.Method object at 0x7f1983ef8bb0>, <pydriller.domain.commit.Method object at 0x7f1983ef8520>, <pydriller.domain.commit.Method object at 0x7f1983ef8130>], [<pydriller.domain.commit.Method object at 0x7f1983f097c0>, <pydriller.domain.commit.Method object at 0x7f1983f093a0>], [<pydriller.domain.commit.Method object at 0x7f1983f05280>, <pydriller.domain.commit.Method object at 0x7f1983f05130>], [<pydriller.domain.commit.Method object at 0x7f1983ee0e50>, <pydriller.domain.commit.Method object at 0x7f1983ee0fa0>], [<pydriller.domain.commit.Method object at 0x7f1983eedd00>, <pydriller.domain.commit.Method object at 0x7f1983eedfa0>], [<pydriller.domain.commit.Method object at 0x7f1983ecacd0>, <pydriller.domain.commit.Method object at 0x7f1983ecae20>, <pydriller.domain.commit.Method object at 0x7f1983ecad00>, <pydriller.domain.commit.Method object at 0x7f1983ecab80>, <pydriller.domain.commit.Method object at 0x7f1983eca7c0>, <pydriller.domain.commit.Method object at 0x7f1983eca640>], [<pydriller.domain.commit.Method object at 0x7f1983f44640>, <pydriller.domain.commit.Method object at 0x7f1983f44790>], [<pydriller.domain.commit.Method object at 0x7f1983f3d100>, <pydriller.domain.commit.Method object at 0x7f1983f36f70>, <pydriller.domain.commit.Method object at 0x7f1983f36fa0>, <pydriller.domain.commit.Method object at 0x7f1983f36e20>, <pydriller.domain.commit.Method object at 0x7f1983f36910>, <pydriller.domain.commit.Method object at 0x7f1983f36790>, <pydriller.domain.commit.Method object at 0x7f1983f367c0>, <pydriller.domain.commit.Method object at 0x7f1983f36640>], [<pydriller.domain.commit.Method object at 0x7f1983f3d8e0>, <pydriller.domain.commit.Method object at 0x7f1983f3da30>, <pydriller.domain.commit.Method object at 0x7f1983f3d910>, <pydriller.domain.commit.Method object at 0x7f1983f44100>, <pydriller.domain.commit.Method object at 0x7f1983f444f0>, <pydriller.domain.commit.Method object at 0x7f1983f44910>], [], [<pydriller.domain.commit.Method object at 0x7f1983eed520>, <pydriller.domain.commit.Method object at 0x7f1983eedcd0>], [<pydriller.domain.commit.Method object at 0x7f1983efe280>, <pydriller.domain.commit.Method object at 0x7f1983f09640>, <pydriller.domain.commit.Method object at 0x7f1983f09670>, <pydriller.domain.commit.Method object at 0x7f1983f09a60>, <pydriller.domain.commit.Method object at 0x7f1983ef8280>, <pydriller.domain.commit.Method object at 0x7f1983ef84f0>, <pydriller.domain.commit.Method object at 0x7f1983ef8100>, <pydriller.domain.commit.Method object at 0x7f1983ef8d00>, <pydriller.domain.commit.Method object at 0x7f1983ef8a60>, <pydriller.domain.commit.Method object at 0x7f1983ef8e50>, <pydriller.domain.commit.Method object at 0x7f1983ef8670>, <pydriller.domain.commit.Method object at 0x7f1983ef8b80>], [<pydriller.domain.commit.Method object at 0x7f1983ed5640>, <pydriller.domain.commit.Method object at 0x7f1983ed5b80>, <pydriller.domain.commit.Method object at 0x7f1983ed54f0>, <pydriller.domain.commit.Method object at 0x7f1983ed5fa0>, <pydriller.domain.commit.Method object at 0x7f1983edca60>, <pydriller.domain.commit.Method object at 0x7f1983edcbb0>, <pydriller.domain.commit.Method object at 0x7f1983edca30>, <pydriller.domain.commit.Method object at 0x7f1983edcd00>, <pydriller.domain.commit.Method object at 0x7f1983edcb80>, <pydriller.domain.commit.Method object at 0x7f1983edccd0>], [], [<pydriller.domain.commit.Method object at 0x7f1983e90640>, <pydriller.domain.commit.Method object at 0x7f1983e96790>, <pydriller.domain.commit.Method object at 0x7f1983e96670>, <pydriller.domain.commit.Method object at 0x7f1983e967c0>, <pydriller.domain.commit.Method object at 0x7f1983e96fa0>, <pydriller.domain.commit.Method object at 0x7f1983e96e20>, <pydriller.domain.commit.Method object at 0x7f1983e96250>]]","[[], [], [], [], [], [], [], [], [], [<pydriller.domain.commit.Method object at 0x7f1983f36640>, <pydriller.domain.commit.Method object at 0x7f1983f3d100>], [<pydriller.domain.commit.Method object at 0x7f1983f36b80>, <pydriller.domain.commit.Method object at 0x7f1983f36130>, <pydriller.domain.commit.Method object at 0x7f1983f3de20>, <pydriller.domain.commit.Method object at 0x7f1983f36d00>, <pydriller.domain.commit.Method object at 0x7f1983f36cd0>], [<pydriller.domain.commit.Method object at 0x7f1983ecaa60>, <pydriller.domain.commit.Method object at 0x7f1983ecabb0>], [<pydriller.domain.commit.Method object at 0x7f1983ed0b80>], [<pydriller.domain.commit.Method object at 0x7f1983ef8100>, <pydriller.domain.commit.Method object at 0x7f1983efe280>, <pydriller.domain.commit.Method object at 0x7f1983ef84f0>, <pydriller.domain.commit.Method object at 0x7f1983ef8280>, <pydriller.domain.commit.Method object at 0x7f1983efe250>], [<pydriller.domain.commit.Method object at 0x7f1983d9c040>, <pydriller.domain.commit.Method object at 0x7f1983e0ca60>, <pydriller.domain.commit.Method object at 0x7f1983eb2d00>], [<pydriller.domain.commit.Method object at 0x7f1983ee0280>, <pydriller.domain.commit.Method object at 0x7f1983ee0cd0>, <pydriller.domain.commit.Method object at 0x7f1983ee0250>], []]"
thefuck,0272e8a8018344d0f9757e21999ffb517d199a03,Bump to 1.28,2015-04-22 23:37:02+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nVERSION = \'1.27\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.28\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,5de020bccd2a7ea6ba34087fef06f08df09ced41,unf*ck sl -> ls,2015-04-22 20:41:56-05:00,Brobin,14,0,14,1,['sl_ls.py'],[None],"['""""""\nThis happens way too often\n\nWhen typing really fast cause I\'m a 1337 H4X0R,\nI often fuck up \'ls\' and type \'sl\'. No more!\n""""""\n\n\ndef match(command, settings):\n    return command.script == \'sl\'\n\n\ndef get_new_command(command, settings):\n    return \'ls\'\n']",[[]],"[[<pydriller.domain.commit.Method object at 0x7f1983e9ce50>, <pydriller.domain.commit.Method object at 0x7f1983e9c8e0>]]"
thefuck,157e3e95fc56353d3961d1ebde7a703103e7b335,added sl_ls test :shipit:,2015-04-22 20:51:18-05:00,Brobin,12,0,12,1,['test_sl_ls.py'],[None],"[""\nfrom thefuck.types import Command\nfrom thefuck.rules.sl_ls import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('sl', '', ''), None)\n    assert not match(Command('ls', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('sl', '', ''), None) == 'ls'\n""]",[[]],"[[<pydriller.domain.commit.Method object at 0x7f1983e4b7c0>, <pydriller.domain.commit.Method object at 0x7f1983e4be20>]]"
thefuck,af2bfe7c582c588db7f2a148d46e1cf588938165,Add a support for pip unknown commands,2015-04-23 15:25:12+09:00,Namwoo Kim,39,0,39,2,"['test_pip_unknown_command.py', 'pip_unknown_command.py']","[None, None]","['import pytest\nfrom thefuck.types import Command\nfrom thefuck.rules.pip_unknown_command import match, get_new_command\n\n\n@pytest.fixture\ndef pip_unknown_cmd():\n    return \'\'\'ERROR: unknown command ""instatl"" - maybe you meant ""install""\'\'\'\n\n\n@pytest.fixture\ndef pip_unknown_cmd_without_recommend():\n    return \'\'\'ERROR: unknown command ""i""\'\'\'\n\n\ndef test_match(pip_unknown_cmd, pip_unknown_cmd_without_recommend):\n    assert match(Command(\'pip instatl\', \'\', pip_unknown_cmd), None)\n    assert not match(Command(\'pip i\', \'\', pip_unknown_cmd_without_recommend),\n                     None)\n\n\ndef test_get_new_command(pip_unknown_cmd):\n    assert get_new_command(Command(\'pip instatl\', \'\', pip_unknown_cmd), None)\\\n        == \'pip install\'\n', 'import re\n\n\ndef match(command, settings):\n    return (\'pip\' in command.script and\n            \'unknown command\' in command.stderr and\n            \'maybe you meant\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r\'ERROR: unknown command \\""([a-z]+)\\""\',\n                            command.stderr)[0]\n    new_cmd = re.findall(r\'maybe you meant \\""([a-z]+)\\""\', command.stderr)[0]\n\n    return command.script.replace(broken_cmd, new_cmd, 1)\n']","[[], []]","[[<pydriller.domain.commit.Method object at 0x7f1983ec0520>, <pydriller.domain.commit.Method object at 0x7f1983e57bb0>, <pydriller.domain.commit.Method object at 0x7f1983ec0250>, <pydriller.domain.commit.Method object at 0x7f1983e57130>], [<pydriller.domain.commit.Method object at 0x7f1983e51fa0>, <pydriller.domain.commit.Method object at 0x7f1983e513a0>]]"
thefuck,07b9aba0d0b21d4b52f471bc2c7403ad4b484d19,"MacOSX specific message

Patch for understanding macosx message.
Example case:
```
[10:24:48][bethrezen@bethrezen-mac ~]$ apachectl graceful
This operation requires root.
[10:24:54][bethrezen@bethrezen-mac ~]$ fuck
No fuck given
```",2015-04-23 10:29:34+03:00,Alexander Kozhevnikov,1,0,1,1,['sudo.py'],"[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted',\n            'root privilege',\n            'This command has to be run under the root user.',\n            'You need to be root to perform this command.']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted',\n            'root privilege',\n            'This command has to be run under the root user.',\n            'This operation requires root.',\n            'You need to be root to perform this command.']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983ccc2e0>, <pydriller.domain.commit.Method object at 0x7f1983ccc2b0>]]",[[]]
thefuck,24ce459f2cac721a08ab4e359119dc5603b03fa3,Add a support for unknown brew commands - #83,2015-04-23 17:06:05+09:00,Namwoo Kim,61,0,61,2,"['test_brew_unknown_command.py', 'brew_unknown_command.py']","[None, None]","[""import pytest\nfrom thefuck.types import Command\nfrom thefuck.rules.brew_unknown_command import match, get_new_command\nfrom thefuck.rules.brew_unknown_command import brew_commands\n\n\n@pytest.fixture\ndef brew_unknown_cmd():\n    return '''Error: Unknown command: inst'''\n\n\n@pytest.fixture\ndef brew_unknown_cmd_instaa():\n    return '''Error: Unknown command: instaa'''\n\n\ndef test_match(brew_unknown_cmd):\n    assert match(Command('brew inst', '', brew_unknown_cmd), None)\n    for command in brew_commands:\n        assert not match(Command('brew ' + command, '', ''), None)\n\n\ndef test_get_new_command(brew_unknown_cmd, brew_unknown_cmd_instaa):\n    assert get_new_command(Command('brew inst', '', brew_unknown_cmd), None)\\\n        == 'brew list'\n\n    assert get_new_command(Command('brew instaa', '', brew_unknown_cmd_instaa),\n                           None) == 'brew install'\n"", ""import difflib\nimport re\nimport thefuck.logs\n\n# This commands are based on Homebrew 0.9.5\nbrew_commands = ['info', 'home', 'options', 'install', 'uninstall', 'search',\n                 'list', 'update', 'upgrade', 'pin', 'unpin', 'doctor',\n                 'create', 'edit']\n\n\ndef _get_similar_commands(command):\n    return difflib.get_close_matches(command, brew_commands)\n\n\ndef match(command, settings):\n    is_proper_command = ('brew' in command.script and\n                         'Unknown command' in command.stderr)\n\n    has_possible_commands = False\n    if is_proper_command:\n        broken_cmd = re.findall(r'Error: Unknown command: ([a-z]+)',\n                                command.stderr)[0]\n        has_possible_commands = len(_get_similar_commands(broken_cmd)) > 0\n\n    return has_possible_commands\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r'Error: Unknown command: ([a-z]+)',\n                            command.stderr)[0]\n    new_cmd = _get_similar_commands(broken_cmd)[0]\n\n    return command.script.replace(broken_cmd, new_cmd, 1)\n""]","[[], []]","[[<pydriller.domain.commit.Method object at 0x7f1983cddbe0>, <pydriller.domain.commit.Method object at 0x7f1983cddeb0>, <pydriller.domain.commit.Method object at 0x7f1983cdd820>, <pydriller.domain.commit.Method object at 0x7f1983cdda90>], [<pydriller.domain.commit.Method object at 0x7f1983d3bd60>, <pydriller.domain.commit.Method object at 0x7f1983d3bc10>, <pydriller.domain.commit.Method object at 0x7f1983d3b430>]]"
thefuck,54b5cd61226994ebd5700fceb2e184ecfdc15f5f,Add a support for brew unavailable formulas,2015-04-23 18:16:36+09:00,Namwoo Kim,92,0,92,2,"['test_brew_install.py', 'brew_install.py']","[None, None]","[""import pytest\nfrom thefuck.types import Command\nfrom thefuck.rules.brew_install import match, get_new_command\nfrom thefuck.rules.brew_install import brew_formulas\n\n\n@pytest.fixture\ndef brew_no_available_formula():\n    return '''Error: No available formula for elsticsearch '''\n\n\n@pytest.fixture\ndef brew_install_no_argument():\n    return '''This command requires a formula argument'''\n\n\n@pytest.fixture\ndef brew_already_installed():\n    return '''Warning: git-2.3.5 already installed'''\n\n\ndef _is_not_okay_to_test():\n    if 'elasticsearch' not in brew_formulas:\n        return True\n    return False\n\n\n@pytest.mark.skipif(_is_not_okay_to_test(),\n                    reason='No need to run if there\\'s no formula')\ndef test_match(brew_no_available_formula, brew_already_installed,\n               brew_install_no_argument):\n    assert match(Command('brew install elsticsearch', '',\n                         brew_no_available_formula), None)\n    assert not match(Command('brew install git', '',\n                             brew_already_installed), None)\n    assert not match(Command('brew install', '', brew_install_no_argument),\n                     None)\n\n\n@pytest.mark.skipif(_is_not_okay_to_test(),\n                    reason='No need to run if there\\'s no formula')\ndef test_get_new_command(brew_no_available_formula):\n    assert get_new_command(Command('brew install elsticsearch', '',\n                                   brew_no_available_formula), None)\\\n        == 'brew install elasticsearch'\n\n    assert get_new_command(Command('brew install aa', '',\n                                   brew_no_available_formula),\n                           None) != 'brew install aha'\n"", ""import difflib\nimport os\nimport re\nfrom subprocess import check_output\n\nimport thefuck.logs\n\n# Formulars are base on each local system's status\nbrew_formulas = []\ntry:\n    brew_path_prefix = check_output(['brew', '--prefix']).strip()\n    brew_formula_path = brew_path_prefix + '/Library/Formula'\n\n    for file_name in os.listdir(brew_formula_path):\n        if file_name.endswith('.rb'):\n            brew_formulas.append(file_name.replace('.rb', ''))\nexcept:\n    pass\n\n\ndef _get_similar_formulars(formula_name):\n    return difflib.get_close_matches(formula_name, brew_formulas, 1, 0.85)\n\n\ndef match(command, settings):\n    is_proper_command = ('brew install' in command.script and\n                         'No available formula' in command.stderr)\n\n    has_possible_formulas = False\n    if is_proper_command:\n        formula = re.findall(r'Error: No available formula for ([a-z]+)',\n                             command.stderr)[0]\n        has_possible_formulas = len(_get_similar_formulars(formula)) > 0\n\n    return has_possible_formulas\n\n\ndef get_new_command(command, settings):\n    not_exist_formula = re.findall(r'Error: No available formula for ([a-z]+)',\n                                   command.stderr)[0]\n    exist_formula = _get_similar_formulars(not_exist_formula)[0]\n\n    return command.script.replace(not_exist_formula, exist_formula, 1)\n""]","[[], []]","[[<pydriller.domain.commit.Method object at 0x7f1983d35430>, <pydriller.domain.commit.Method object at 0x7f1983d35040>, <pydriller.domain.commit.Method object at 0x7f1983d17ac0>, <pydriller.domain.commit.Method object at 0x7f1983d352b0>, <pydriller.domain.commit.Method object at 0x7f1983d17400>, <pydriller.domain.commit.Method object at 0x7f1983d35820>], [<pydriller.domain.commit.Method object at 0x7f1983ce36d0>, <pydriller.domain.commit.Method object at 0x7f1983ce3a90>, <pydriller.domain.commit.Method object at 0x7f1983ce3970>]]"
thefuck,f1cce413b35b4a476568aa090ea1c86aff72f3bb,"Added rule for fixing Alt+Space character

Happens on the Mac a lot when typing a pipe character (Alt+7), and
keeping the Alt key pressed down for a bit too long, so instead of
Space, you're typing Alt+Space. This rule replaces the Alt+Space with a
simple Space character.

$ ps -ef | grep foo
-bash:  grep: command not found
$ fuck
ps -ef | grep foo",2015-04-23 15:19:30+02:00,Nils Winkler,34,0,34,3,"['README.md', 'test_fix_alt_space.py', 'fix_alt_space.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nOr using an OS package manager (currently supported in OSX via [brew](http://brew.sh)):\n\n```bash\nbrew install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck {\n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) {\n        $fuck.substring(5)\n    }\n    else { iex ""$fuck"" }\n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', None, None]","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nOr using an OS package manager (currently supported in OSX via [brew](http://brew.sh)):\n\n```bash\nbrew install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck {\n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) {\n        $fuck.substring(5)\n    }\n    else { iex ""$fuck"" }\n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', '# -*- encoding: utf-8 -*-\n\n\nfrom thefuck.types import Command\nfrom thefuck.rules.fix_alt_space import match, get_new_command\n\n\ndef test_match():\n    """""" The character before \'grep\' is Alt+Space, which happens frequently on the Mac when typing\n        the pipe character (Alt+7), and holding the Alt key pressed for longer than necessary. """"""\n    assert match(Command(u\'ps -ef |\xa0grep foo\', \'\', u\'-bash: \xa0grep: command not found\'), None)\n    assert not match(Command(\'ps -ef | grep foo\', \'\', \'\'), None)\n    assert not match(Command(\'\', \'\', \'\'), None)\n\n\ndef test_get_new_command():\n    """""" Replace the Alt+Space character by a simple space """"""\n    assert get_new_command(Command(u\'ps -ef |\xa0grep foo\', \'\', \'\'), None) == \'ps -ef | grep foo\'\n', ""# -*- encoding: utf-8 -*-\n\nimport re\nfrom thefuck.utils import sudo_support\n\n\n@sudo_support\ndef match(command, settings):\n    return ('command not found' in command.stderr.lower()\n            and u'\xa0' in command.script)\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return re.sub(u'\xa0', ' ', command.script)\n""]","[[], [], []]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d2e6d0>, <pydriller.domain.commit.Method object at 0x7f1983d2e820>], [<pydriller.domain.commit.Method object at 0x7f1983d51430>, <pydriller.domain.commit.Method object at 0x7f1983d51c10>]]"
thefuck,473f5e6a333d89a54813daf5495d68b17490ae8b,Add composer rule,2015-04-23 17:34:34+02:00,Rubén Simón Andreo,64,0,64,2,"['test_composer_not_command.py', 'composer_not_command.py']","[None, None]","['import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.composer_not_command import match, get_new_command\n\n\n@pytest.fixture\ndef composer_not_command():\n    return """"""\n\n                                    \n  [InvalidArgumentException]        \n  Command ""udpate"" is not defined.  \n  Did you mean this?                \n      update\n\n\n""""""\n\n\n@pytest.fixture\ndef composer_not_command_one_of_this():\n    return """"""\n                            \n\n\n  [InvalidArgumentException]       \n  Command ""pdate"" is not defined.  \n  Did you mean one of these?       \n      selfupdate                   \n      self-update                  \n      update                       \n\n\n\n""""""\n\ndef test_match(composer_not_command, composer_not_command_one_of_this):\n    assert match(Command(\'composer udpate\', \'\', composer_not_command), None)\n    assert match(Command(\'composer pdate\', \'\', composer_not_command_one_of_this), None)\n    assert not match(Command(\'ls update\', \'\', composer_not_command), None)\n    #assert not match(Command(\'composer update\', \'\', composer_command), None)\n\n\ndef test_get_new_command(composer_not_command, composer_not_command_one_of_this):\n    assert get_new_command(Command(\'composer udpate\', \'\', composer_not_command), None)\\\n        == \'composer update\'\n    assert get_new_command(\n        Command(\'composer pdate\', \'\', composer_not_command_one_of_this), None) == \'composer selfupdate\'\n', 'import re\n\ndef match(command, settings):\n    return (\'composer\' in command.script\n        and (\n        \t\'did you mean this?\' in command.stderr.lower()\n        \tor \'did you mean one of these?\' in command.stderr.lower()\n        \t)\n        )\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r""Command \\""([^\']*)\\"" is not defined"", command.stderr)[0]\n    new_cmd = re.findall(r\'Did you mean this\\?[^\\n]*\\n\\s*([^\\n]*)\', command.stderr)\n    if not new_cmd:\n    \tnew_cmd = re.findall(r\'Did you mean one of these\\?[^\\n]*\\n\\s*([^\\n]*)\', command.stderr)\n    return command.script.replace(broken_cmd, new_cmd[0].strip(), 1)']","[[], []]","[[<pydriller.domain.commit.Method object at 0x7f1983e422b0>, <pydriller.domain.commit.Method object at 0x7f1983e42e80>, <pydriller.domain.commit.Method object at 0x7f1983d1c040>, <pydriller.domain.commit.Method object at 0x7f1983e42160>], [<pydriller.domain.commit.Method object at 0x7f1983e3c520>, <pydriller.domain.commit.Method object at 0x7f1983e3cfa0>]]"
thefuck,1f96faef2cd530806310478f6e812113ed583874,#116 Fix tests,2015-04-23 21:47:46+02:00,nvbn,9,10,19,2,"['test_composer_not_command.py', 'composer_not_command.py']","['import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.composer_not_command import match, get_new_command\n\n\n@pytest.fixture\ndef composer_not_command():\n    return """"""\n\n                                    \n  [InvalidArgumentException]        \n  Command ""udpate"" is not defined.  \n  Did you mean this?                \n      update\n\n\n""""""\n\n\n@pytest.fixture\ndef composer_not_command_one_of_this():\n    return """"""\n                            \n\n\n  [InvalidArgumentException]       \n  Command ""pdate"" is not defined.  \n  Did you mean one of these?       \n      selfupdate                   \n      self-update                  \n      update                       \n\n\n\n""""""\n\ndef test_match(composer_not_command, composer_not_command_one_of_this):\n    assert match(Command(\'composer udpate\', \'\', composer_not_command), None)\n    assert match(Command(\'composer pdate\', \'\', composer_not_command_one_of_this), None)\n    assert not match(Command(\'ls update\', \'\', composer_not_command), None)\n    #assert not match(Command(\'composer update\', \'\', composer_command), None)\n\n\ndef test_get_new_command(composer_not_command, composer_not_command_one_of_this):\n    assert get_new_command(Command(\'composer udpate\', \'\', composer_not_command), None)\\\n        == \'composer update\'\n    assert get_new_command(\n        Command(\'composer pdate\', \'\', composer_not_command_one_of_this), None) == \'composer selfupdate\'\n', 'import re\n\ndef match(command, settings):\n    return (\'composer\' in command.script\n        and (\n        \t\'did you mean this?\' in command.stderr.lower()\n        \tor \'did you mean one of these?\' in command.stderr.lower()\n        \t)\n        )\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r""Command \\""([^\']*)\\"" is not defined"", command.stderr)[0]\n    new_cmd = re.findall(r\'Did you mean this\\?[^\\n]*\\n\\s*([^\\n]*)\', command.stderr)\n    if not new_cmd:\n    \tnew_cmd = re.findall(r\'Did you mean one of these\\?[^\\n]*\\n\\s*([^\\n]*)\', command.stderr)\n    return command.script.replace(broken_cmd, new_cmd[0].strip(), 1)']","['import pytest\nfrom thefuck.types import Command\nfrom thefuck.rules.composer_not_command import match, get_new_command\n\n\n@pytest.fixture\ndef composer_not_command():\n    return """"""\n\n                                    \n  [InvalidArgumentException]        \n  Command ""udpate"" is not defined.  \n  Did you mean this?                \n      update\n\n\n""""""\n\n\n@pytest.fixture\ndef composer_not_command_one_of_this():\n    return """"""\n                            \n\n\n  [InvalidArgumentException]       \n  Command ""pdate"" is not defined.  \n  Did you mean one of these?       \n      selfupdate                   \n      self-update                  \n      update                       \n\n\n\n""""""\n\n\ndef test_match(composer_not_command, composer_not_command_one_of_this):\n    assert match(Command(\'composer udpate\', \'\', composer_not_command), None)\n    assert match(Command(\'composer pdate\', \'\', composer_not_command_one_of_this), None)\n    assert not match(Command(\'ls update\', \'\', composer_not_command), None)\n\n\ndef test_get_new_command(composer_not_command, composer_not_command_one_of_this):\n    assert get_new_command(Command(\'composer udpate\', \'\', composer_not_command), None) \\\n           == \'composer update\'\n    assert get_new_command(\n        Command(\'composer pdate\', \'\', composer_not_command_one_of_this), None) == \'composer selfupdate\'\n', 'import re\n\n\ndef match(command, settings):\n    return (\'composer\' in command.script\n            and (\'did you mean this?\' in command.stderr.lower()\n                 or \'did you mean one of these?\' in command.stderr.lower()))\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r""Command \\""([^\']*)\\"" is not defined"", command.stderr)[0]\n    new_cmd = re.findall(r\'Did you mean this\\?[^\\n]*\\n\\s*([^\\n]*)\', command.stderr)\n    if not new_cmd:\n        new_cmd = re.findall(r\'Did you mean one of these\\?[^\\n]*\\n\\s*([^\\n]*)\', command.stderr)\n    return command.script.replace(broken_cmd, new_cmd[0].strip(), 1)']","[[<pydriller.domain.commit.Method object at 0x7f1983e17100>, <pydriller.domain.commit.Method object at 0x7f1983e17f70>, <pydriller.domain.commit.Method object at 0x7f1983e17e20>, <pydriller.domain.commit.Method object at 0x7f1983e17910>], [<pydriller.domain.commit.Method object at 0x7f1983d2e430>, <pydriller.domain.commit.Method object at 0x7f1983d2e190>]]","[[<pydriller.domain.commit.Method object at 0x7f1983e42130>], [<pydriller.domain.commit.Method object at 0x7f1983d51550>, <pydriller.domain.commit.Method object at 0x7f1983d512b0>]]"
thefuck,71f1f4224b267711bd9cc372a2ec69902f423a01,Initial commit,2015-04-08 18:15:49+02:00,nvbn,362,0,362,11,"['.gitignore', 'README.md', 'requirements.txt', 'setup.cfg', 'setup.py', 'test_git_push.py', 'test_sudo.py', 'test_main.py', 'main.py', 'git_push.py', 'sudo.py']","[None, None, None, None, None, None, None, None, None, None, None]","['# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nenv/\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\n*.egg-info/\n.installed.cfg\n*.egg\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*,cover\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\ntarget/\n\n.env\n.idea\n', ""# The Fuck\n\nMagnificent app which corrects your previous console command.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip3 install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip3 install -r requirements.txt\npython3 setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'pytest\n', '[egg_info]\ntag_build = dev\ntag_svn_revision = true\n', 'from setuptools import setup, find_packages\n\n\nversion = \'1\'\n\nsetup(name=\'thefuck\',\n      version=version,\n      description="""",\n      long_description=""""""\\\n"""""",\n      classifiers=[],  # Get strings from http://pypi.python.org/pypi?%3Aaction=list_classifiers\n      keywords=\'\',\n      author=\'\',\n      author_email=\'\',\n      url=\'\',\n      license=\'\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\n          # -*- Extra requirements: -*-\n      ],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\',\n      ]},\n      )\n', 'import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.git_push import match, get_new_command\n\n\n@pytest.fixture\ndef stderr():\n    return \'\'\'fatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\'\'\'\n\n\ndef test_match(stderr):\n    assert match(Command(\'git push master\', \'\', stderr))\n    assert not match(Command(\'git push master\', \'\', \'\'))\n    assert not match(Command(\'ls\', \'\', stderr))\n\n\ndef test_get_new_command(stderr):\n    assert get_new_command(Command(\'\', \'\', stderr))\\\n        == ""git push --set-upstream origin master""\n', ""from thefuck.main import Command\nfrom thefuck.rules.sudo import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('', '', 'Permission denied'))\n    assert match(Command('', '', 'permission denied'))\n    assert not match(Command('', '', ''))\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('ls', '', '')) == 'sudo ls'\n"", ""from unittest.mock import patch, Mock\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom thefuck import main\n\n\ndef test_setup_user_dir():\n    with patch('thefuck.main.Path.is_dir', return_value=False), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 2\n        assert touch.call_count == 1\n    with patch('thefuck.main.Path.is_dir', return_value=True), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 0\n        assert touch.call_count == 0\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(main.Settings(None), Path('bash.py'))\n    assert main.is_rule_enabled(main.Settings(['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(main.Settings(['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            main.Settings(None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            main.Settings(['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x: x.script == 'cd ..', None),\n             main.Rule(lambda _: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nSettings = namedtuple(\'Settings\', (\'rules\',))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir() -> Path:\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir: Path) -> Settings:\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    return Settings(getattr(settings, \'rules\', None))\n\n\ndef is_rule_enabled(settings: Settings, rule: Path) -> bool:\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule: Path) -> Rule:\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir: Path, settings: Settings) -> [Rule]:\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if is_rule_enabled(settings, rule)]\n\n\ndef get_command(args: [str]) -> Command:\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command: Command, rules: [Rule]) -> Rule:\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command):\n            return rule\n\n\ndef run_rule(rule: Rule, command: Command):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command)\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules)\n    if matched_rule:\n        run_rule(matched_rule, command)\n    else:\n        print(\'echo No fuck given\')\n', ""def match(command):\n    return ('git' in command.script\n            and 'push' in command.script\n            and 'set-upstream' in command.stderr)\n\n\ndef get_new_command(command):\n    return command.stderr.split('\\n')[-3].strip()\n"", ""def match(command):\n    return 'permission denied' in command.stderr.lower()\n\n\ndef get_new_command(command):\n    return 'sudo {}'.format(command.script)\n""]","[[], [], [], [], [], [], [], [], [], [], []]","[[], [], [], [], [], [<pydriller.domain.commit.Method object at 0x7f1983cccc10>, <pydriller.domain.commit.Method object at 0x7f1983cccac0>, <pydriller.domain.commit.Method object at 0x7f1983ccc940>], [<pydriller.domain.commit.Method object at 0x7f1983d45e80>, <pydriller.domain.commit.Method object at 0x7f1983d45fd0>], [<pydriller.domain.commit.Method object at 0x7f1983d452b0>, <pydriller.domain.commit.Method object at 0x7f1983ce9be0>, <pydriller.domain.commit.Method object at 0x7f1983ce9c10>, <pydriller.domain.commit.Method object at 0x7f1983d45400>, <pydriller.domain.commit.Method object at 0x7f1983d452e0>, <pydriller.domain.commit.Method object at 0x7f1983ce9d60>, <pydriller.domain.commit.Method object at 0x7f1983d45160>], [<pydriller.domain.commit.Method object at 0x7f1983cf02e0>, <pydriller.domain.commit.Method object at 0x7f1983ce92e0>, <pydriller.domain.commit.Method object at 0x7f1983cf0970>, <pydriller.domain.commit.Method object at 0x7f1983ce9430>, <pydriller.domain.commit.Method object at 0x7f1983cf0940>, <pydriller.domain.commit.Method object at 0x7f1983ce9190>, <pydriller.domain.commit.Method object at 0x7f1983cf0a90>, <pydriller.domain.commit.Method object at 0x7f1983cf0d60>, <pydriller.domain.commit.Method object at 0x7f1983ce9160>], [<pydriller.domain.commit.Method object at 0x7f1983cdd430>, <pydriller.domain.commit.Method object at 0x7f1983cdd2e0>], [<pydriller.domain.commit.Method object at 0x7f1983cd1400>, <pydriller.domain.commit.Method object at 0x7f1983cd1940>]]"
thefuck,327c3a0cf5647ef6ae7a8fc273f7db70a3c4ee90,Fill setup.py,2015-04-08 18:19:01+02:00,nvbn,7,21,28,2,"['setup.cfg', 'setup.py']","['[egg_info]\ntag_build = dev\ntag_svn_revision = true\n', 'from setuptools import setup, find_packages\n\n\nversion = \'1\'\n\nsetup(name=\'thefuck\',\n      version=version,\n      description="""",\n      long_description=""""""\\\n"""""",\n      classifiers=[],  # Get strings from http://pypi.python.org/pypi?%3Aaction=list_classifiers\n      keywords=\'\',\n      author=\'\',\n      author_email=\'\',\n      url=\'\',\n      license=\'\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\n          # -*- Extra requirements: -*-\n      ],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\',\n      ]},\n      )\n']","[None, 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.0,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","[[], []]","[[], []]"
thefuck,8e5cc9d73a08acafef64848a81fd63cbc89e8490,Add command not found handler,2015-04-08 19:00:03+02:00,nvbn,79,1,80,5,"['README.md', 'setup.py', 'test_no_command.py', 'main.py', 'no_command.py']","[""# The Fuck\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip3 install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip3 install -r requirements.txt\npython3 setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.0,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', None, 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nSettings = namedtuple(\'Settings\', (\'rules\',))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir() -> Path:\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir: Path) -> Settings:\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    return Settings(getattr(settings, \'rules\', None))\n\n\ndef is_rule_enabled(settings: Settings, rule: Path) -> bool:\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule: Path) -> Rule:\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir: Path, settings: Settings) -> [Rule]:\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if is_rule_enabled(settings, rule)]\n\n\ndef get_command(args: [str]) -> Command:\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command: Command, rules: [Rule]) -> Rule:\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command):\n            return rule\n\n\ndef run_rule(rule: Rule, command: Command):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command)\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules)\n    if matched_rule:\n        run_rule(matched_rule, command)\n    else:\n        print(\'echo No fuck given\')\n', None]","[""# The Fuck\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip3 install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip3 install -r requirements.txt\npython3 setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.1,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from unittest.mock import patch\nimport pytest\nfrom subprocess import PIPE\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\ndef test_match(command_found, command_not_found):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''))\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''))\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''))\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n\n\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''))\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', '')) \\\n            == 'sudo apt-get install vim'\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom os import environ\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nSettings = namedtuple(\'Settings\', (\'rules\',))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir() -> Path:\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir: Path) -> Settings:\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    return Settings(getattr(settings, \'rules\', None))\n\n\ndef is_rule_enabled(settings: Settings, rule: Path) -> bool:\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule: Path) -> Rule:\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir: Path, settings: Settings) -> [Rule]:\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if is_rule_enabled(settings, rule)]\n\n\ndef get_command(args: [str]) -> Command:\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command: Command, rules: [Rule]) -> Rule:\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command):\n            return rule\n\n\ndef run_rule(rule: Rule, command: Command):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command)\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules)\n    if matched_rule:\n        run_rule(matched_rule, command)\n    else:\n        print(\'echo No fuck given\')\n', 'from subprocess import Popen, PIPE\nimport re\n\n\ndef _get_output(command):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'/usr/lib/command-not-found {}\'.format(name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\ndef match(command):\n    output = _get_output(command)\n    return ""No command"" in output and ""from package"" in output\n\n\ndef get_new_command(command):\n    output = _get_output(command)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name)\n']","[[], [], [], [<pydriller.domain.commit.Method object at 0x7f1983d35fd0>, <pydriller.domain.commit.Method object at 0x7f1983d35e80>, <pydriller.domain.commit.Method object at 0x7f1983d35eb0>, <pydriller.domain.commit.Method object at 0x7f1983d35d30>, <pydriller.domain.commit.Method object at 0x7f1983d356a0>, <pydriller.domain.commit.Method object at 0x7f1983d356d0>, <pydriller.domain.commit.Method object at 0x7f1983d35550>, <pydriller.domain.commit.Method object at 0x7f1983d35580>, <pydriller.domain.commit.Method object at 0x7f1983d35400>], []]","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983cd76d0>, <pydriller.domain.commit.Method object at 0x7f1983cd7580>, <pydriller.domain.commit.Method object at 0x7f1983d41fd0>, <pydriller.domain.commit.Method object at 0x7f1983cd7400>], [], [<pydriller.domain.commit.Method object at 0x7f1983d2ebe0>, <pydriller.domain.commit.Method object at 0x7f1983d2eeb0>, <pydriller.domain.commit.Method object at 0x7f1983d2ed60>]]"
thefuck,173a4300b40653458614c9fdf73ed740289d7357,Fix sudo after npm errors,2015-04-08 19:16:15+02:00,nvbn,4,2,6,3,"['setup.py', 'test_sudo.py', 'sudo.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.1,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from thefuck.main import Command\nfrom thefuck.rules.sudo import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('', '', 'Permission denied'))\n    assert match(Command('', '', 'permission denied'))\n    assert not match(Command('', '', ''))\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('ls', '', '')) == 'sudo ls'\n"", ""def match(command):\n    return 'permission denied' in command.stderr.lower()\n\n\ndef get_new_command(command):\n    return 'sudo {}'.format(command.script)\n""]","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.2,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', 'from thefuck.main import Command\nfrom thefuck.rules.sudo import match, get_new_command\n\n\ndef test_match():\n    assert match(Command(\'\', \'\', \'Permission denied\'))\n    assert match(Command(\'\', \'\', \'permission denied\'))\n    assert match(Command(\'\', \'\', ""npm ERR! Error: EACCES, unlink""))\n    assert not match(Command(\'\', \'\', \'\'))\n\n\ndef test_get_new_command():\n    assert get_new_command(Command(\'ls\', \'\', \'\')) == \'sudo ls\'\n', ""def match(command):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command):\n    return 'sudo {}'.format(command.script)\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983ce3190>, <pydriller.domain.commit.Method object at 0x7f1983ce3940>], [<pydriller.domain.commit.Method object at 0x7f1983ccca90>, <pydriller.domain.commit.Method object at 0x7f1983ccce80>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d41be0>], [<pydriller.domain.commit.Method object at 0x7f1983ce3040>]]"
thefuck,9ed022d67f451331f4ac3535cd7f4041cf43a863,Pass settings to the rules,2015-04-08 21:08:35+02:00,nvbn,50,47,97,8,"['test_git_push.py', 'test_no_command.py', 'test_sudo.py', 'test_main.py', 'main.py', 'git_push.py', 'no_command.py', 'sudo.py']","['import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.git_push import match, get_new_command\n\n\n@pytest.fixture\ndef stderr():\n    return \'\'\'fatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\'\'\'\n\n\ndef test_match(stderr):\n    assert match(Command(\'git push master\', \'\', stderr))\n    assert not match(Command(\'git push master\', \'\', \'\'))\n    assert not match(Command(\'ls\', \'\', stderr))\n\n\ndef test_get_new_command(stderr):\n    assert get_new_command(Command(\'\', \'\', stderr))\\\n        == ""git push --set-upstream origin master""\n', ""from unittest.mock import patch\nimport pytest\nfrom subprocess import PIPE\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\ndef test_match(command_found, command_not_found):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''))\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''))\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''))\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n\n\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''))\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', '')) \\\n            == 'sudo apt-get install vim'\n"", 'from thefuck.main import Command\nfrom thefuck.rules.sudo import match, get_new_command\n\n\ndef test_match():\n    assert match(Command(\'\', \'\', \'Permission denied\'))\n    assert match(Command(\'\', \'\', \'permission denied\'))\n    assert match(Command(\'\', \'\', ""npm ERR! Error: EACCES, unlink""))\n    assert not match(Command(\'\', \'\', \'\'))\n\n\ndef test_get_new_command():\n    assert get_new_command(Command(\'ls\', \'\', \'\')) == \'sudo ls\'\n', ""from unittest.mock import patch, Mock\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom thefuck import main\n\n\ndef test_setup_user_dir():\n    with patch('thefuck.main.Path.is_dir', return_value=False), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 2\n        assert touch.call_count == 1\n    with patch('thefuck.main.Path.is_dir', return_value=True), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 0\n        assert touch.call_count == 0\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(main.Settings(None), Path('bash.py'))\n    assert main.is_rule_enabled(main.Settings(['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(main.Settings(['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            main.Settings(None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            main.Settings(['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x: x.script == 'cd ..', None),\n             main.Rule(lambda _: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom os import environ\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nSettings = namedtuple(\'Settings\', (\'rules\',))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir() -> Path:\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir: Path) -> Settings:\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    return Settings(getattr(settings, \'rules\', None))\n\n\ndef is_rule_enabled(settings: Settings, rule: Path) -> bool:\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule: Path) -> Rule:\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir: Path, settings: Settings) -> [Rule]:\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if is_rule_enabled(settings, rule)]\n\n\ndef get_command(args: [str]) -> Command:\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command: Command, rules: [Rule]) -> Rule:\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command):\n            return rule\n\n\ndef run_rule(rule: Rule, command: Command):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command)\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules)\n    if matched_rule:\n        run_rule(matched_rule, command)\n    else:\n        print(\'echo No fuck given\')\n', ""def match(command):\n    return ('git' in command.script\n            and 'push' in command.script\n            and 'set-upstream' in command.stderr)\n\n\ndef get_new_command(command):\n    return command.stderr.split('\\n')[-3].strip()\n"", 'from subprocess import Popen, PIPE\nimport re\n\n\ndef _get_output(command):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'/usr/lib/command-not-found {}\'.format(name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\ndef match(command):\n    output = _get_output(command)\n    return ""No command"" in output and ""from package"" in output\n\n\ndef get_new_command(command):\n    output = _get_output(command)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name)\n', ""def match(command):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command):\n    return 'sudo {}'.format(command.script)\n""]","['import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.git_push import match, get_new_command\n\n\n@pytest.fixture\ndef stderr():\n    return \'\'\'fatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\'\'\'\n\n\ndef test_match(stderr):\n    assert match(Command(\'git push master\', \'\', stderr), None)\n    assert not match(Command(\'git push master\', \'\', \'\'), None)\n    assert not match(Command(\'ls\', \'\', stderr), None)\n\n\ndef test_get_new_command(stderr):\n    assert get_new_command(Command(\'\', \'\', stderr), None)\\\n        == ""git push --set-upstream origin master""\n', ""from unittest.mock import patch, Mock\nimport pytest\nfrom subprocess import PIPE\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\ndef test_match(command_found, command_not_found):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), None)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), None)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), None)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), None) \\\n            == 'sudo apt-get install vim'\n"", 'from thefuck.main import Command\nfrom thefuck.rules.sudo import match, get_new_command\n\n\ndef test_match():\n    assert match(Command(\'\', \'\', \'Permission denied\'), None)\n    assert match(Command(\'\', \'\', \'permission denied\'), None)\n    assert match(Command(\'\', \'\', ""npm ERR! Error: EACCES, unlink""), None)\n    assert not match(Command(\'\', \'\', \'\'), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command(\'ls\', \'\', \'\'), None) == \'sudo ls\'\n', ""from unittest.mock import patch, Mock\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom thefuck import main\n\n\ndef test_setup_user_dir():\n    with patch('thefuck.main.Path.is_dir', return_value=False), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 2\n        assert touch.call_count == 1\n    with patch('thefuck.main.Path.is_dir', return_value=True), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 0\n        assert touch.call_count == 0\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda _, _: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir() -> Path:\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir: Path):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule: Path) -> bool:\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule: Path) -> Rule:\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir: Path, settings) -> [Rule]:\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if is_rule_enabled(settings, rule)]\n\n\ndef get_command(args: [str]) -> Command:\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command: Command, rules: [Rule], settings) -> Rule:\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule: Rule, command: Command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules, settings)\n    if matched_rule:\n        run_rule(matched_rule, command, settings)\n    else:\n        print(\'echo No fuck given\')\n', ""def match(command, settings):\n    return ('git' in command.script\n            and 'push' in command.script\n            and 'set-upstream' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return command.stderr.split('\\n')[-3].strip()\n"", 'from subprocess import Popen, PIPE\nimport re\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(getattr(settings, \'command_not_found\',\n                                          \'/usr/lib/command-not-found\'),\n                                  name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\ndef match(command, settings):\n    output = _get_output(command, settings)\n    return ""No command"" in output and ""from package"" in output\n\n\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name)\n', ""def match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983cdd400>, <pydriller.domain.commit.Method object at 0x7f1983cdd550>, <pydriller.domain.commit.Method object at 0x7f1983d28430>], [<pydriller.domain.commit.Method object at 0x7f1983cdd040>, <pydriller.domain.commit.Method object at 0x7f1983cdd2b0>, <pydriller.domain.commit.Method object at 0x7f1983cddd30>, <pydriller.domain.commit.Method object at 0x7f1983cd17f0>], [<pydriller.domain.commit.Method object at 0x7f1983cf07f0>, <pydriller.domain.commit.Method object at 0x7f1983ce92b0>], [<pydriller.domain.commit.Method object at 0x7f1983d45d30>, <pydriller.domain.commit.Method object at 0x7f1983d45550>, <pydriller.domain.commit.Method object at 0x7f1983d456d0>, <pydriller.domain.commit.Method object at 0x7f1983d45580>, <pydriller.domain.commit.Method object at 0x7f1983cd7d30>, <pydriller.domain.commit.Method object at 0x7f1983cd7fd0>, <pydriller.domain.commit.Method object at 0x7f1983cd7be0>], [<pydriller.domain.commit.Method object at 0x7f1983ce37f0>, <pydriller.domain.commit.Method object at 0x7f1983ce3e80>, <pydriller.domain.commit.Method object at 0x7f1983ce3400>, <pydriller.domain.commit.Method object at 0x7f1983d41a90>, <pydriller.domain.commit.Method object at 0x7f1983d41190>, <pydriller.domain.commit.Method object at 0x7f1983d41eb0>, <pydriller.domain.commit.Method object at 0x7f1983d41d30>, <pydriller.domain.commit.Method object at 0x7f1983d3be80>, <pydriller.domain.commit.Method object at 0x7f1983d3b2e0>], [<pydriller.domain.commit.Method object at 0x7f1983d35d60>, <pydriller.domain.commit.Method object at 0x7f1983d35a90>], [<pydriller.domain.commit.Method object at 0x7f1983d17c10>, <pydriller.domain.commit.Method object at 0x7f1983d17d60>, <pydriller.domain.commit.Method object at 0x7f1983d17a90>], [<pydriller.domain.commit.Method object at 0x7f1983d10400>, <pydriller.domain.commit.Method object at 0x7f1983d10550>]]","[[<pydriller.domain.commit.Method object at 0x7f1983cd16a0>, <pydriller.domain.commit.Method object at 0x7f1983cd12e0>], [<pydriller.domain.commit.Method object at 0x7f1983d1cfd0>, <pydriller.domain.commit.Method object at 0x7f1983d1ce80>], [<pydriller.domain.commit.Method object at 0x7f1983d23400>, <pydriller.domain.commit.Method object at 0x7f1983d23190>], [<pydriller.domain.commit.Method object at 0x7f1983d28be0>, <pydriller.domain.commit.Method object at 0x7f1983d28580>, <pydriller.domain.commit.Method object at 0x7f1983d28820>], [<pydriller.domain.commit.Method object at 0x7f1983d41190>, <pydriller.domain.commit.Method object at 0x7f1983ce3d30>, <pydriller.domain.commit.Method object at 0x7f1983ce32e0>, <pydriller.domain.commit.Method object at 0x7f1983ce3430>, <pydriller.domain.commit.Method object at 0x7f1983ccc6d0>, <pydriller.domain.commit.Method object at 0x7f1983ce3820>, <pydriller.domain.commit.Method object at 0x7f1983d3be80>, <pydriller.domain.commit.Method object at 0x7f1983d41d30>, <pydriller.domain.commit.Method object at 0x7f1983ce3400>, <pydriller.domain.commit.Method object at 0x7f1983cccfd0>], [<pydriller.domain.commit.Method object at 0x7f1983d3b550>, <pydriller.domain.commit.Method object at 0x7f1983d3b160>, <pydriller.domain.commit.Method object at 0x7f1983d35d60>, <pydriller.domain.commit.Method object at 0x7f1983d35a90>], [<pydriller.domain.commit.Method object at 0x7f1983d1c580>, <pydriller.domain.commit.Method object at 0x7f1983d17d60>, <pydriller.domain.commit.Method object at 0x7f1983d17c10>, <pydriller.domain.commit.Method object at 0x7f1983d1cd60>, <pydriller.domain.commit.Method object at 0x7f1983d1c550>, <pydriller.domain.commit.Method object at 0x7f1983d17a90>], [<pydriller.domain.commit.Method object at 0x7f1983d10eb0>, <pydriller.domain.commit.Method object at 0x7f1983d10d60>, <pydriller.domain.commit.Method object at 0x7f1983d10400>, <pydriller.domain.commit.Method object at 0x7f1983d10550>]]"
thefuck,e7b377a3105d1b3d59e5e8b4882a325b9909fe21,"Add handler for ""is not a git command""",2015-04-08 21:20:11+02:00,nvbn,55,2,57,5,"['README.md', 'setup.py', 'test_git_not_command.py', 'git_not_command.py', 'no_command.py']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip3 install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip3 install -r requirements.txt\npython3 setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.2,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', None, None, 'from subprocess import Popen, PIPE\nimport re\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(getattr(settings, \'command_not_found\',\n                                          \'/usr/lib/command-not-found\'),\n                                  name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\ndef match(command, settings):\n    output = _get_output(command, settings)\n    return ""No command"" in output and ""from package"" in output\n\n\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name)\n']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\n* master\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip3 install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip3 install -r requirements.txt\npython3 setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.3,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', 'import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.git_not_command import match, get_new_command\n\n\n@pytest.fixture\ndef git_not_command():\n    return """"""git: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\nbranch\n""""""\n\n\n@pytest.fixture\ndef git_command():\n    return ""* master""\n\n\ndef test_match(git_not_command, git_command):\n    assert match(Command(\'git brnch\', \'\', git_not_command), None)\n    assert not match(Command(\'ls brnch\', \'\', git_not_command), None)\n    assert not match(Command(\'git branch\', \'\', git_command), None)\n\n\ndef test_get_new_command(git_not_command):\n    assert get_new_command(Command(\'git brnch\', \'\', git_not_command), None)\\\n        == \'git branch\'\n', 'import re\n\n\ndef match(command, settings):\n    return (\'git\' in command.script\n            and "" is not a git command. See \'git --help\'."" in command.stderr\n            and \'Did you mean this?\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r""git: \'([^\']*)\' is not a git command"",\n                            command.stderr)[0]\n    new_cmd = re.findall(r\'Did you mean this\\?\\n\\s*([^\\n]*)\',\n                         command.stderr)[0]\n    return command.script.replace(broken_cmd, new_cmd, 1)\n\n', 'from subprocess import Popen, PIPE\nimport re\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(getattr(settings, \'command_not_found\',\n                                          \'/usr/lib/command-not-found\'),\n                                  name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\ndef match(command, settings):\n    output = _get_output(command, settings)\n    return ""No command"" in output and ""from package"" in output\n\n\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n']","[[], [], [], [], [<pydriller.domain.commit.Method object at 0x7f1983d85400>, <pydriller.domain.commit.Method object at 0x7f1983d85430>, <pydriller.domain.commit.Method object at 0x7f1983d85970>]]","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983d7fc10>, <pydriller.domain.commit.Method object at 0x7f1983d7fbe0>, <pydriller.domain.commit.Method object at 0x7f1983d7feb0>, <pydriller.domain.commit.Method object at 0x7f1983d7fd60>], [<pydriller.domain.commit.Method object at 0x7f1983d7afd0>, <pydriller.domain.commit.Method object at 0x7f1983d7f190>], [<pydriller.domain.commit.Method object at 0x7f1983d7fa90>]]"
thefuck,282217fd02322229d918682e9152afe79ab43a5a,Fix tests,2015-04-08 21:22:59+02:00,nvbn,1,1,2,1,['test_main.py'],"[""from unittest.mock import patch, Mock\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom thefuck import main\n\n\ndef test_setup_user_dir():\n    with patch('thefuck.main.Path.is_dir', return_value=False), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 2\n        assert touch.call_count == 1\n    with patch('thefuck.main.Path.is_dir', return_value=True), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 0\n        assert touch.call_count == 0\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda _, _: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n""]","[""from unittest.mock import patch, Mock\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom thefuck import main\n\n\ndef test_setup_user_dir():\n    with patch('thefuck.main.Path.is_dir', return_value=False), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 2\n        assert touch.call_count == 1\n    with patch('thefuck.main.Path.is_dir', return_value=True), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 0\n        assert touch.call_count == 0\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983d10e80>, <pydriller.domain.commit.Method object at 0x7f1983d102e0>, <pydriller.domain.commit.Method object at 0x7f1983d10fd0>, <pydriller.domain.commit.Method object at 0x7f1983d10a90>, <pydriller.domain.commit.Method object at 0x7f1983d176a0>, <pydriller.domain.commit.Method object at 0x7f1983d17d30>, <pydriller.domain.commit.Method object at 0x7f1983d17e80>]]",[[<pydriller.domain.commit.Method object at 0x7f1983d102b0>]]
thefuck,2eb777a5bb41527b627ed0826eca3e16890ef83a,Add python 2 support,2015-04-17 16:24:03+02:00,nvbn,19,15,34,9,"['.travis.yml', 'README.md', 'requirements.txt', 'setup.py', 'test_no_command.py', 'test_main.py', '__init__.py', 'main.py', '__init__.py']","['language: python\npython:\n  - ""3.4""\ninstall:\n  - python setup.py develop\n  - pip install -r requirements.txt\nscript: py.test\n', ""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\n* master\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip3 install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip3 install -r requirements.txt\npython3 setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'pytest\n', 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.3,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from unittest.mock import patch, Mock\nimport pytest\nfrom subprocess import PIPE\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\ndef test_match(command_found, command_not_found):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), None)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), None)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), None)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), None) \\\n            == 'sudo apt-get install vim'\n"", ""from unittest.mock import patch, Mock\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom thefuck import main\n\n\ndef test_setup_user_dir():\n    with patch('thefuck.main.Path.is_dir', return_value=False), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 2\n        assert touch.call_count == 1\n    with patch('thefuck.main.Path.is_dir', return_value=True), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 0\n        assert touch.call_count == 0\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", None, 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir() -> Path:\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir: Path):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule: Path) -> bool:\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule: Path) -> Rule:\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir: Path, settings) -> [Rule]:\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if is_rule_enabled(settings, rule)]\n\n\ndef get_command(args: [str]) -> Command:\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command: Command, rules: [Rule], settings) -> Rule:\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule: Rule, command: Command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules, settings)\n    if matched_rule:\n        run_rule(matched_rule, command, settings)\n    else:\n        print(\'echo No fuck given\')\n', None]","['language: python\npython:\n  - ""3.4""\n  - ""3.3""\n  - ""2.7""\ninstall:\n  - python setup.py develop\n  - pip install -r requirements.txt\nscript: py.test\n', ""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\n* master\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'pytest\nmock\n', 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.3,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\ndef test_match(command_found, command_not_found):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), None)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), None)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), None)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), None) \\\n            == 'sudo apt-get install vim'\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_setup_user_dir():\n    with patch('thefuck.main.Path.is_dir', return_value=False), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 2\n        assert touch.call_count == 1\n    with patch('thefuck.main.Path.is_dir', return_value=True), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 0\n        assert touch.call_count == 0\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", None, 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules, settings)\n    if matched_rule:\n        run_rule(matched_rule, command, settings)\n    else:\n        print(\'echo No fuck given\')\n', None]","[[], [], [], [], [<pydriller.domain.commit.Method object at 0x7f1983cd16d0>, <pydriller.domain.commit.Method object at 0x7f1983cd1a90>, <pydriller.domain.commit.Method object at 0x7f1983cd1430>, <pydriller.domain.commit.Method object at 0x7f1983d23820>], [<pydriller.domain.commit.Method object at 0x7f1983cf0160>, <pydriller.domain.commit.Method object at 0x7f1983cf0d30>, <pydriller.domain.commit.Method object at 0x7f1983cf0400>, <pydriller.domain.commit.Method object at 0x7f1983cf0be0>, <pydriller.domain.commit.Method object at 0x7f1983d28190>, <pydriller.domain.commit.Method object at 0x7f1983d282b0>, <pydriller.domain.commit.Method object at 0x7f1983d28160>], [], [<pydriller.domain.commit.Method object at 0x7f1983d45d60>, <pydriller.domain.commit.Method object at 0x7f1983d45ac0>, <pydriller.domain.commit.Method object at 0x7f1983d45940>, <pydriller.domain.commit.Method object at 0x7f1985075fa0>, <pydriller.domain.commit.Method object at 0x7f1983ce3be0>, <pydriller.domain.commit.Method object at 0x7f1983ce36a0>, <pydriller.domain.commit.Method object at 0x7f1983ce3c10>, <pydriller.domain.commit.Method object at 0x7f1983ce3d60>, <pydriller.domain.commit.Method object at 0x7f1983ce3ac0>], []]","[[], [], [], [], [], [], [], [<pydriller.domain.commit.Method object at 0x7f1983cd7190>, <pydriller.domain.commit.Method object at 0x7f1983d41430>, <pydriller.domain.commit.Method object at 0x7f1983d41400>, <pydriller.domain.commit.Method object at 0x7f1983ce3be0>, <pydriller.domain.commit.Method object at 0x7f1983ce3c10>, <pydriller.domain.commit.Method object at 0x7f1983cd7eb0>, <pydriller.domain.commit.Method object at 0x7f1983d45ac0>, <pydriller.domain.commit.Method object at 0x7f1983d41160>, <pydriller.domain.commit.Method object at 0x7f1983ce3d60>, <pydriller.domain.commit.Method object at 0x7f1983d41580>, <pydriller.domain.commit.Method object at 0x7f1985075fa0>, <pydriller.domain.commit.Method object at 0x7f1983cd7940>, <pydriller.domain.commit.Method object at 0x7f1983cd7a90>, <pydriller.domain.commit.Method object at 0x7f1983ce36a0>, <pydriller.domain.commit.Method object at 0x7f1983d45940>], []]"
thefuck,1503dcf294cd59f345b1ded6d24e0691f9414d32,Make `no_command` work only when apt available,2015-04-17 16:36:38+02:00,nvbn,42,9,51,3,"['test_no_command_apt.py', 'no_command_apt.py', 'utils.py']","[""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\ndef test_match(command_found, command_not_found):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), None)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), None)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), None)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), None) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(getattr(settings, \'command_not_found\',\n                                          \'/usr/lib/command-not-found\'),\n                                  name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\ndef match(command, settings):\n    output = _get_output(command, settings)\n    return ""No command"" in output and ""from package"" in output\n\n\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n', None]","[""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command_apt import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command_apt.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_match(command_found, command_not_found):\n    with patch('thefuck.rules.no_command_apt.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), None)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), None)\n\n    with patch('thefuck.rules.no_command_apt.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command_apt._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), None)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), None) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which\n\n\ndef _get_bin(settings):\n    return getattr(settings, \'command_not_found\', \'/usr/lib/command-not-found\')\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(_get_bin(settings), name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\ndef match(command, settings):\n    if which(\'apt-get\') and which(_get_bin(settings)):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n', 'import os\n\n\ndef which(program):\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n']","[[<pydriller.domain.commit.Method object at 0x7f1983d17be0>, <pydriller.domain.commit.Method object at 0x7f1983d17970>, <pydriller.domain.commit.Method object at 0x7f1983d172e0>, <pydriller.domain.commit.Method object at 0x7f1983d17190>], [<pydriller.domain.commit.Method object at 0x7f1983d7ffd0>, <pydriller.domain.commit.Method object at 0x7f1983d7f820>, <pydriller.domain.commit.Method object at 0x7f1983d7fe80>], []]","[[<pydriller.domain.commit.Method object at 0x7f1983cf0580>, <pydriller.domain.commit.Method object at 0x7f1983d1c2e0>, <pydriller.domain.commit.Method object at 0x7f1983d10be0>], [<pydriller.domain.commit.Method object at 0x7f1983d0bd60>, <pydriller.domain.commit.Method object at 0x7f1983d0b190>, <pydriller.domain.commit.Method object at 0x7f1983d0b940>], [<pydriller.domain.commit.Method object at 0x7f1983d85160>, <pydriller.domain.commit.Method object at 0x7f1983d85820>]]"
thefuck,1de9c5f77b4eab61f55d421e8baee07c0dc6f88d,"Add information about writting yourself rules, revert no_command changes",2015-04-17 17:01:30+02:00,nvbn,82,16,98,5,"['README.md', 'setup.py', 'test_no_command.py', 'no_command.py', 'utils.py']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\n* master\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.3,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command_apt import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command_apt.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_match(command_found, command_not_found):\n    with patch('thefuck.rules.no_command_apt.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), None)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), None)\n\n    with patch('thefuck.rules.no_command_apt.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command_apt._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), None)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), None) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which\n\n\ndef _get_bin(settings):\n    return getattr(settings, \'command_not_found\', \'/usr/lib/command-not-found\')\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(_get_bin(settings), name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\ndef match(command, settings):\n    if which(\'apt-get\') and which(_get_bin(settings)):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n', 'import os\n\n\ndef which(program):\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\n* master\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` have three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules]((https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py)).\n\n## Settings\n\nThe Fuck have a few settings parameters:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.4,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_match(command_found, command_not_found, settings):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), settings)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), settings)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), settings)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), settings) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n', 'from functools import wraps\nimport os\n\n\ndef which(program):\n    """"""Returns `program` path or `None`.""""""\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef wrap_settings(params):\n    """"""Adds default values to settings if it not presented.\n\n    Usage:\n\n        @wrap_settings({\'apt\': \'/usr/bin/apt\'})\n        def match(command, settings):\n            print(settings.apt)\n\n    """"""\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(command, settings):\n            for key, val in params.items():\n                if not hasattr(settings, key):\n                    setattr(settings, key, val)\n            return fn(command, settings)\n        return wrapper\n    return decorator\n']","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983d67eb0>, <pydriller.domain.commit.Method object at 0x7f1983d67940>, <pydriller.domain.commit.Method object at 0x7f1983d67d30>, <pydriller.domain.commit.Method object at 0x7f1983d67fd0>, <pydriller.domain.commit.Method object at 0x7f1983d6e550>], [<pydriller.domain.commit.Method object at 0x7f1983d85d30>, <pydriller.domain.commit.Method object at 0x7f1983d85040>, <pydriller.domain.commit.Method object at 0x7f1983d856a0>, <pydriller.domain.commit.Method object at 0x7f1983d7f940>], [<pydriller.domain.commit.Method object at 0x7f1983d106a0>, <pydriller.domain.commit.Method object at 0x7f1983d10190>]]","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983d67160>, <pydriller.domain.commit.Method object at 0x7f1983d67fd0>, <pydriller.domain.commit.Method object at 0x7f1983d67400>, <pydriller.domain.commit.Method object at 0x7f1983d676d0>, <pydriller.domain.commit.Method object at 0x7f1983d672b0>], [<pydriller.domain.commit.Method object at 0x7f1983d85d30>, <pydriller.domain.commit.Method object at 0x7f1983d74be0>, <pydriller.domain.commit.Method object at 0x7f1983d74400>], [<pydriller.domain.commit.Method object at 0x7f1983d0b550>, <pydriller.domain.commit.Method object at 0x7f1983d0b7f0>, <pydriller.domain.commit.Method object at 0x7f1983d0b2b0>, <pydriller.domain.commit.Method object at 0x7f1983d0bd30>]]"
thefuck,11cbb9e1f7c0009b9272426bf2c0f1b481a2dc3e,Print out the fucking command before running it,2015-04-17 16:07:50-04:00,Ford Hurley,6,1,7,2,"['README.md', 'main.py']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\n[sudo] password for nvbn: \nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\n* master\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` have three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck have a few settings parameters:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules, settings)\n    if matched_rule:\n        run_rule(matched_rule, command, settings)\n    else:\n        print(\'echo No fuck given\')\n']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n## Installation\n\nInstall `The Fuck`:\n\n```bash\nsudo pip install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n```\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` have three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck have a few settings parameters:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules, settings)\n    if matched_rule:\n        run_rule(matched_rule, command, settings)\n    else:\n        print(\'echo No fuck given\')\n']","[[], [<pydriller.domain.commit.Method object at 0x7f1983d2eac0>, <pydriller.domain.commit.Method object at 0x7f1983d2ee80>, <pydriller.domain.commit.Method object at 0x7f1983d2ed30>, <pydriller.domain.commit.Method object at 0x7f1983d2e970>, <pydriller.domain.commit.Method object at 0x7f1983d1c7f0>, <pydriller.domain.commit.Method object at 0x7f1983d1c820>, <pydriller.domain.commit.Method object at 0x7f1983d1c940>, <pydriller.domain.commit.Method object at 0x7f1983d1c970>, <pydriller.domain.commit.Method object at 0x7f1983d1cac0>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983ce96a0>]]"
thefuck,48831fa850307d79b786076195ece1d387a4db5f,#1 Don't fuck twice,2015-04-17 22:09:46+02:00,nvbn,16,8,24,2,"['setup.py', 'main.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.4,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    print(new_command)\n\n\ndef main():\n    command = get_command(sys.argv)\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n    rules = get_rules(user_dir, settings)\n    matched_rule = get_matched_rule(command, rules, settings)\n    if matched_rule:\n        run_rule(matched_rule, command, settings)\n    else:\n        print(\'echo No fuck given\')\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.5,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    command = get_command(sys.argv)\n    if is_second_run(command):\n        print(""echo Can\'t fuck twice"")\n    else:\n        user_dir = setup_user_dir()\n        settings = get_settings(user_dir)\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n        else:\n            print(\'echo No fuck given\')\n']","[[], [<pydriller.domain.commit.Method object at 0x7f1983d562e0>, <pydriller.domain.commit.Method object at 0x7f1983d56430>, <pydriller.domain.commit.Method object at 0x7f1983d56160>, <pydriller.domain.commit.Method object at 0x7f1983d56190>, <pydriller.domain.commit.Method object at 0x7f1983d51ac0>, <pydriller.domain.commit.Method object at 0x7f1983d51940>, <pydriller.domain.commit.Method object at 0x7f1983d51970>, <pydriller.domain.commit.Method object at 0x7f1983d517f0>, <pydriller.domain.commit.Method object at 0x7f1983d51820>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d56ac0>, <pydriller.domain.commit.Method object at 0x7f1983d56940>]]"
thefuck,99e418f852f5e6e5269cbe31cf6e7329feba379c,Added rule for misspelled cd.. command,2015-04-17 22:14:01+02:00,Lars Michelsen,14,0,14,1,['cd_parent.py'],[None],"[""# Adds the missing space between the cd command and the target directory\n# when trying to cd to the parent directory.\n#\n# Does not really save chars, but is fun :D\n#\n# Example:\n# > cd..\n# cd..: command not found\n\ndef match(command, settings):\n    return command.script == 'cd..'\n\ndef get_new_command(command, settings):\n    return 'cd ..'\n""]",[[]],"[[<pydriller.domain.commit.Method object at 0x7f1983d56d60>, <pydriller.domain.commit.Method object at 0x7f1983d516a0>]]"
thefuck,2e91158091a9deb506fc369d46ca7f34119371f2,Fixed UnicodeDecodeError,2015-04-17 16:30:46-04:00,Alex Nastetsky,2,2,4,1,['main.py'],"['from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(),\n                   result.stderr.read().decode())\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    command = get_command(sys.argv)\n    if is_second_run(command):\n        print(""echo Can\'t fuck twice"")\n    else:\n        user_dir = setup_user_dir()\n        settings = get_settings(user_dir)\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n        else:\n            print(\'echo No fuck given\')\n']","['from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(\'utf-8\'),\n                   result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    command = get_command(sys.argv)\n    if is_second_run(command):\n        print(""echo Can\'t fuck twice"")\n    else:\n        user_dir = setup_user_dir()\n        settings = get_settings(user_dir)\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n        else:\n            print(\'echo No fuck given\')\n']","[[<pydriller.domain.commit.Method object at 0x7f1983d62400>, <pydriller.domain.commit.Method object at 0x7f1983d622b0>, <pydriller.domain.commit.Method object at 0x7f1983d28c10>, <pydriller.domain.commit.Method object at 0x7f1983d28940>, <pydriller.domain.commit.Method object at 0x7f1983d7a820>, <pydriller.domain.commit.Method object at 0x7f1983d7a7f0>, <pydriller.domain.commit.Method object at 0x7f1983d7a970>, <pydriller.domain.commit.Method object at 0x7f1983d7aeb0>, <pydriller.domain.commit.Method object at 0x7f1983d7a2e0>, <pydriller.domain.commit.Method object at 0x7f1983d7aac0>]]",[[<pydriller.domain.commit.Method object at 0x7f1983d62580>]]
thefuck,73a893dc749a9430d2976c7350b7843943411d8f,Bump version,2015-04-17 22:31:10+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.5,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.6,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,bfbb8cd7d0ce90efb4178dcd0b6fda44d1a162af,Bump version,2015-04-17 22:42:18+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.6,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.7,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,14f0817a9920196019990eb5f079d23d43059494,added support for FreeBSD/PCBSD 'pkg' to sudo rule,2015-04-18 08:45:48+02:00,tpltnt,2,1,3,1,['sudo.py'],"[""def match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[""def match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr\n            or 'pkg: Insufficient privileges' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983d67d60>, <pydriller.domain.commit.Method object at 0x7f1983d67970>]]",[[<pydriller.domain.commit.Method object at 0x7f1983d74970>]]
thefuck,de343b84c1a58831fd711b1d70405aa574ae180a,improve no_command rule,2015-04-18 10:52:00-05:00,Jon Mason,22,7,29,2,"['test_no_command.py', 'no_command.py']","[""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_match(command_found, command_not_found, settings):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), settings)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), settings)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), settings)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), settings) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n']","[""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_match(command_found, command_not_found, settings):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), settings)\n        Popen.assert_called_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), settings)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), settings)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), settings) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\ndef _count_history_uses(name):\n    script = \'history | grep {}\'.format(name)\n    result = Popen(script, shell=True, stdout=PIPE)\n    return len(list(result.stdout))\n\ndef _get_candidate_commands(command, settings):\n    output = _get_output(command, settings)\n    if ""No command"" in output and ""from package"" in output:\n        fixed_names = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)\n        return filter(which, fixed_names)\n    return []\n        \n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return len(_get_candidate_commands(command, settings)) != 0\n\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    candidates = _get_candidate_commands(command, settings)\n    fixed_name = sorted(candidates, key=_count_history_uses)[0]\n    return command.script.replace(broken_name, fixed_name)\n     \n']","[[<pydriller.domain.commit.Method object at 0x7f1983dc5940>, <pydriller.domain.commit.Method object at 0x7f1983dc5a90>, <pydriller.domain.commit.Method object at 0x7f1983dc5970>, <pydriller.domain.commit.Method object at 0x7f1983dc57f0>, <pydriller.domain.commit.Method object at 0x7f1983dc5430>, <pydriller.domain.commit.Method object at 0x7f1983dc52b0>], [<pydriller.domain.commit.Method object at 0x7f1983db9fd0>, <pydriller.domain.commit.Method object at 0x7f1983db9e80>, <pydriller.domain.commit.Method object at 0x7f1983db9eb0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983d4a820>], [<pydriller.domain.commit.Method object at 0x7f1983dbe6d0>, <pydriller.domain.commit.Method object at 0x7f1983dbea90>, <pydriller.domain.commit.Method object at 0x7f1983dbed60>, <pydriller.domain.commit.Method object at 0x7f1983dbeac0>]]"
thefuck,34015ef27c59189d3c1191440c245188dc90741d,make sudo rule work with pacman,2015-04-18 15:16:15-04:00,Viktor Stanchev,1,0,1,1,['sudo.py'],"[""def match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr\n            or 'pkg: Insufficient privileges' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[""def match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr\n            or 'error: you cannot perform this operation unless you are root.' in command.stderr\n            or 'pkg: Insufficient privileges' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983d4aa90>, <pydriller.domain.commit.Method object at 0x7f1983d4a940>]]",[[<pydriller.domain.commit.Method object at 0x7f1983dc5400>]]
thefuck,9518416a2faf52c17d910726d4186068c50e96fd,#17 Fix creating configuration files/dirs,2015-04-18 21:16:49+02:00,nvbn,5,20,25,3,"['setup.py', 'test_main.py', 'main.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.7,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_setup_user_dir():\n    with patch('thefuck.main.Path.is_dir', return_value=False), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 2\n        assert touch.call_count == 1\n    with patch('thefuck.main.Path.is_dir', return_value=True), \\\n         patch('thefuck.main.Path.mkdir') as mkdir, \\\n            patch('thefuck.main.Path.touch') as touch:\n        main.setup_user_dir()\n        assert mkdir.call_count == 0\n        assert touch.call_count == 0\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    if not user_dir.is_dir():\n        user_dir.mkdir()\n        user_dir.joinpath(\'rules\').mkdir()\n        user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(\'utf-8\'),\n                   result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    command = get_command(sys.argv)\n    if is_second_run(command):\n        print(""echo Can\'t fuck twice"")\n    else:\n        user_dir = setup_user_dir()\n        settings = get_settings(user_dir)\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n        else:\n            print(\'echo No fuck given\')\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.8,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(\'utf-8\'),\n                   result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    command = get_command(sys.argv)\n    if is_second_run(command):\n        print(""echo Can\'t fuck twice"")\n    else:\n        user_dir = setup_user_dir()\n        settings = get_settings(user_dir)\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n        else:\n            print(\'echo No fuck given\')\n']","[[], [<pydriller.domain.commit.Method object at 0x7f1983ccc190>, <pydriller.domain.commit.Method object at 0x7f1983cccd60>, <pydriller.domain.commit.Method object at 0x7f1983ccc580>, <pydriller.domain.commit.Method object at 0x7f1983ccc430>, <pydriller.domain.commit.Method object at 0x7f1983ce9eb0>, <pydriller.domain.commit.Method object at 0x7f1983ce9580>, <pydriller.domain.commit.Method object at 0x7f1983ce9820>], [<pydriller.domain.commit.Method object at 0x7f1983d286a0>, <pydriller.domain.commit.Method object at 0x7f1983d28040>, <pydriller.domain.commit.Method object at 0x7f1983d286d0>, <pydriller.domain.commit.Method object at 0x7f1983d28d30>, <pydriller.domain.commit.Method object at 0x7f1983d5c820>, <pydriller.domain.commit.Method object at 0x7f1983d5c430>, <pydriller.domain.commit.Method object at 0x7f1983d5cc10>, <pydriller.domain.commit.Method object at 0x7f1983d5c940>, <pydriller.domain.commit.Method object at 0x7f1983d5cd60>, <pydriller.domain.commit.Method object at 0x7f1983d5cac0>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983ccc190>], [<pydriller.domain.commit.Method object at 0x7f1983d232b0>]]"
thefuck,235b31e176405cf8f58349580def4db198251909,#22 Get stderr and stdout with `LANG=C`,2015-04-18 21:27:43+02:00,nvbn,8,3,11,2,"['test_main.py', 'main.py']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen:\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE)\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE)\n    return Command(script, result.stdout.read().decode(\'utf-8\'),\n                   result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    command = get_command(sys.argv)\n    if is_second_run(command):\n        print(""echo Can\'t fuck twice"")\n    else:\n        user_dir = setup_user_dir()\n        settings = get_settings(user_dir)\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n        else:\n            print(\'echo No fuck given\')\n']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen,\\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    return Command(script, result.stdout.read().decode(\'utf-8\'),\n                   result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    command = get_command(sys.argv)\n    if is_second_run(command):\n        print(""echo Can\'t fuck twice"")\n    else:\n        user_dir = setup_user_dir()\n        settings = get_settings(user_dir)\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n        else:\n            print(\'echo No fuck given\')\n']","[[<pydriller.domain.commit.Method object at 0x7f1983d5c550>, <pydriller.domain.commit.Method object at 0x7f1983d5c6a0>, <pydriller.domain.commit.Method object at 0x7f1983d5cbe0>, <pydriller.domain.commit.Method object at 0x7f1983d5ca90>, <pydriller.domain.commit.Method object at 0x7f1983db9c10>, <pydriller.domain.commit.Method object at 0x7f1983db96d0>], [<pydriller.domain.commit.Method object at 0x7f1983db9a90>, <pydriller.domain.commit.Method object at 0x7f1983db9ac0>, <pydriller.domain.commit.Method object at 0x7f1983db96a0>, <pydriller.domain.commit.Method object at 0x7f1983db9d60>, <pydriller.domain.commit.Method object at 0x7f1983db9be0>, <pydriller.domain.commit.Method object at 0x7f1983d41550>, <pydriller.domain.commit.Method object at 0x7f1983cf0ac0>, <pydriller.domain.commit.Method object at 0x7f1983d566d0>, <pydriller.domain.commit.Method object at 0x7f1983d56e80>, <pydriller.domain.commit.Method object at 0x7f1983d56fd0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983d56a90>], [<pydriller.domain.commit.Method object at 0x7f1983db1550>]]"
thefuck,b0d353c699df50c0a40d21d1d0a708046af6bb9c,#22 Simplify adding patterns for the `sudo` rule,2015-04-18 21:30:48+02:00,nvbn,11,4,15,2,"['setup.py', 'sudo.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.8,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""def match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr\n            or 'pkg: Insufficient privileges' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.9,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d1cc10>, <pydriller.domain.commit.Method object at 0x7f1983d1c6d0>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d5c2b0>]]"
thefuck,a84671dd3b7505d4d73f11ee9c7d057429542e24,#20 Fix `UnicodeDecodeError` in `no_command`,2015-04-18 21:46:17+02:00,nvbn,2,2,4,2,"['setup.py', 'no_command.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.9,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.10,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode(\'utf-8\')\n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n']","[[], [<pydriller.domain.commit.Method object at 0x7f1983d74c10>, <pydriller.domain.commit.Method object at 0x7f1983d74ac0>, <pydriller.domain.commit.Method object at 0x7f1983d74a90>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d7f6a0>]]"
thefuck,e745f3d4a95ad8c8479955a45e624c1081ff2c86,#21 Add timeout for getting previous command output,2015-04-18 22:50:18+02:00,nvbn,50,22,72,4,"['README.md', 'setup.py', 'test_main.py', 'main.py']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_intall thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n# You can use wahtever you want for as an alias, like for mondays:\nalias FUCK='fuck'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions.  \n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` have three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck have a few settings parameters:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.10,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp'),\n                                     main.Rule('bash', 'bash'),\n                                     main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                         main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen,\\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(['thefuck', 'apt-get', 'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    if not hasattr(settings, \'rules\'):\n        settings.rules = None\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef get_command(args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    return Command(script, result.stdout.read().decode(\'utf-8\'),\n                   result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    command = get_command(sys.argv)\n    if is_second_run(command):\n        print(""echo Can\'t fuck twice"")\n    else:\n        user_dir = setup_user_dir()\n        settings = get_settings(user_dir)\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n        else:\n            print(\'echo No fuck given\')\n']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_intall thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n# You can use wahtever you want for as an alias, like for mondays:\nalias FUCK='fuck'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions.  \n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` have three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck have a few settings parameters:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.11,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983da8190>, <pydriller.domain.commit.Method object at 0x7f1983da82e0>, <pydriller.domain.commit.Method object at 0x7f1983da8040>, <pydriller.domain.commit.Method object at 0x7f1983da1fd0>, <pydriller.domain.commit.Method object at 0x7f1983da1a90>, <pydriller.domain.commit.Method object at 0x7f1983da1ac0>], [<pydriller.domain.commit.Method object at 0x7f1983da1c10>, <pydriller.domain.commit.Method object at 0x7f1983da1d60>, <pydriller.domain.commit.Method object at 0x7f19867bfd90>, <pydriller.domain.commit.Method object at 0x7f1983da8160>, <pydriller.domain.commit.Method object at 0x7f1983da8c10>, <pydriller.domain.commit.Method object at 0x7f1983da8a90>, <pydriller.domain.commit.Method object at 0x7f1983da8ac0>, <pydriller.domain.commit.Method object at 0x7f1983da8940>, <pydriller.domain.commit.Method object at 0x7f1983dac190>, <pydriller.domain.commit.Method object at 0x7f1983dac040>]]","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983da8d30>, <pydriller.domain.commit.Method object at 0x7f1983da8970>], [<pydriller.domain.commit.Method object at 0x7f1983da8a90>, <pydriller.domain.commit.Method object at 0x7f1983d9c970>, <pydriller.domain.commit.Method object at 0x7f1983d9c7f0>, <pydriller.domain.commit.Method object at 0x7f1983da1580>, <pydriller.domain.commit.Method object at 0x7f1983da1400>]]"
thefuck,8b2ba5762c6fa3ef9b40d1624d4c76accb40bfb1,"Add support of `lein` ""is not task""",2015-04-18 23:19:34+02:00,nvbn,49,1,50,4,"['README.md', 'setup.py', 'test_lein_not_task.py', 'lein_not_task.py']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_intall thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK='fuck'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions.  \n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` have three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck have a few settings parameters:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.11,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', None, None]","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by [@liamosaur](https://twitter.com/liamosaur/status/506975850596536320)\ntwit.\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n\n➜ lein rpl\n'rpl' is not a task. See 'lein help'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_intall thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc`:\n\n```bash\nalias fuck='$(thefuck $(fc -ln -1))'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK='fuck'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions.  \n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` have three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck have a few settings parameters:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\n"", 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.12,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""import pytest\nfrom mock import Mock\nfrom thefuck.rules.lein_not_task import match, get_new_command\n\n\n@pytest.fixture\ndef is_not_task():\n    return ''''rpl' is not a task. See 'lein help'.\n\nDid you mean this?\n         repl\n'''\n\n\ndef test_match(is_not_task):\n    assert match(Mock(script='lein rpl', stderr=is_not_task), None)\n    assert not match(Mock(script='ls', stderr=is_not_task), None)\n\n\ndef test_get_new_command(is_not_task):\n    assert get_new_command(Mock(script='lein rpl --help', stderr=is_not_task),\n                           None) == 'lein repl --help'\n"", 'import re\n\n\ndef match(command, settings):\n    return (command.script.startswith(\'lein\')\n            and ""is not a task. See \'lein help\'"" in command.stderr\n            and \'Did you mean this?\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r""\'([^\']*)\' is not a task"",\n                            command.stderr)[0]\n    new_cmd = re.findall(r\'Did you mean this\\?\\n\\s*([^\\n]*)\',\n                         command.stderr)[0]\n    return command.script.replace(broken_cmd, new_cmd, 1)\n']","[[], [], [], []]","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983d677f0>, <pydriller.domain.commit.Method object at 0x7f1983d67ac0>, <pydriller.domain.commit.Method object at 0x7f1983d67e80>], [<pydriller.domain.commit.Method object at 0x7f1983d747f0>, <pydriller.domain.commit.Method object at 0x7f1983d74820>]]"
thefuck,ac545c6f0ae6012460b4bcc45e37ad604ee60b7e,"improve no_comamnd rule, test it",2015-04-18 16:32:50-05:00,Jon Mason,44,8,52,2,"['test_no_command.py', 'no_command.py']","[""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_match(command_found, command_not_found, settings):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), settings)\n        Popen.assert_called_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), settings)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), settings)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), settings) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\ndef _count_history_uses(name):\n    script = \'history | grep {}\'.format(name)\n    result = Popen(script, shell=True, stdout=PIPE)\n    return len(list(result.stdout))\n\ndef _get_candidate_commands(command, settings):\n    output = _get_output(command, settings)\n    if ""No command"" in output and ""from package"" in output:\n        fixed_names = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)\n        return filter(which, fixed_names)\n    return []\n        \n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return len(_get_candidate_commands(command, settings)) != 0\n\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    candidates = _get_candidate_commands(command, settings)\n    fixed_name = sorted(candidates, key=_count_history_uses)[0]\n    return command.script.replace(broken_name, fixed_name)\n     \n']","['from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b\'\'\'No command \'aptget\' found, did you mean:\n Command \'apt-get\' from package \'apt\' (main)\n Command \'not-installed\' from package \'derp\' (main)\n Command \'not-really-used\' from package \'whatever\' (main)\naptget: command not found\n\'\'\'\n\n@pytest.fixture\ndef uninstalled_command_found():\n    return b\'\'\'No command \'pish\' found, did you mean:\n Command \'vish\' from package \'vish\' (universe)\n Command \'wish\' from package \'tk\' (main)\n Command \'fish\' from package \'fish\' (universe)\n Command \'pdsh\' from package \'pdsh\' (universe)\npish: command not found\n\'\'\'\n\n@pytest.fixture\ndef command_not_found():\n    return b\'\'\'No command \'vom\' found, but there are 19 similar ones\nvom: command not found\n\'\'\'\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch(\'thefuck.rules.no_command.which\',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n@pytest.fixture\ndef bin_might_exist(request):\n    def side_effect(name):\n        return name in [\'not-really-used\', \'apt-get\', \'/usr/lib/command-not-found\', \'test\']\n    p = patch(\'thefuck.rules.no_command.which\',\n              side_effect = side_effect)\n    p.start()\n    request.addfinalizer(p.stop)\n            \n\n@pytest.fixture\ndef patch_history(request):\n    def side_effect(name):\n        print(""history(\'{}\')"".format(name))\n        count = 2 if name == \'not-really-used\' else 12\n    p = patch(\'thefuck.rules.no_command._count_history_uses\',\n              side_effect = side_effect)\n    p.start()\n    request.addfinalizer(p.stop)\n    \n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures(\'bin_might_exist\', \'patch_history\')\ndef test_match(command_found, command_not_found, uninstalled_command_found, settings):\n    with patch(\'thefuck.rules.no_command.Popen\') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command(\'aptget install vim\', \'\', \'\'), settings)\n        Popen.assert_called_with(\'/usr/lib/command-not-found aptget\',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command(\'ls\', \'\', \'\'), settings)\n\n    with patch(\'thefuck.rules.no_command.Popen\') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command(\'sudo aptget install vim\', \'\', \'\'),\n                     Mock(command_not_found=\'test\'))\n        Popen.assert_called_with(\'test aptget\',\n                                      shell=True, stderr=PIPE)\n\n    with patch(\'thefuck.rules.no_command.Popen\') as Popen:\n        Popen.return_value.stderr.read.return_value = uninstalled_command_found\n        assert not match(Command(\'pish bla blah\', \'\', \'\'), settings)\n\n@pytest.mark.usefixtures(\'bin_might_exist\', \'patch_history\')\ndef test_get_new_command(command_found):\n    with patch(\'thefuck.rules.no_command._get_output\',\n               return_value=command_found.decode()):\n        assert get_new_command(Command(\'aptget install vim\', \'\', \'\'), settings)\\\n            == \'apt-get install vim\'\n        assert get_new_command(Command(\'sudo aptget install vim\', \'\', \'\'), settings) \\\n            == \'sudo apt-get install vim\'\n', 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\ndef _count_history_uses(name):\n    script = ""history | egrep \'\\\\b{}\\\\b\' | wc -l"".format(name)\n    result = Popen(script, shell=True,\n                   stdout=PIPE)\n    return int(result.stdout.read())\n\ndef _get_candidate_commands(command, settings):\n    output = _get_output(command, settings)\n    if ""No command"" in output and ""from package"" in output:\n        fixed_names = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)\n        return filter(which, fixed_names)\n    return []\n        \n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return len(_get_candidate_commands(command, settings)) != 0\n\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    candidates = _get_candidate_commands(command, settings)\n    fixed_name = sorted(candidates, key=_count_history_uses, reverse=True)[0]\n    return command.script.replace(broken_name, fixed_name)\n     \n']","[[<pydriller.domain.commit.Method object at 0x7f1983d5c7f0>, <pydriller.domain.commit.Method object at 0x7f1983d5c190>, <pydriller.domain.commit.Method object at 0x7f1983d5c040>, <pydriller.domain.commit.Method object at 0x7f1983d5ceb0>, <pydriller.domain.commit.Method object at 0x7f1983cdd160>, <pydriller.domain.commit.Method object at 0x7f1983cdd6a0>], [<pydriller.domain.commit.Method object at 0x7f1983db1580>, <pydriller.domain.commit.Method object at 0x7f1983db1430>, <pydriller.domain.commit.Method object at 0x7f1983db1d30>, <pydriller.domain.commit.Method object at 0x7f1983db1e80>, <pydriller.domain.commit.Method object at 0x7f1983d9c820>]]","[[<pydriller.domain.commit.Method object at 0x7f1983d0bbe0>, <pydriller.domain.commit.Method object at 0x7f1983d0beb0>, <pydriller.domain.commit.Method object at 0x7f1983ce32b0>, <pydriller.domain.commit.Method object at 0x7f1983d0ba90>, <pydriller.domain.commit.Method object at 0x7f1983d0b160>, <pydriller.domain.commit.Method object at 0x7f1983d74580>, <pydriller.domain.commit.Method object at 0x7f1983d0b400>, <pydriller.domain.commit.Method object at 0x7f1983cdd160>], [<pydriller.domain.commit.Method object at 0x7f1983d56820>, <pydriller.domain.commit.Method object at 0x7f1983d62040>]]"
thefuck,8a2bc75e555cec399f02f51fcc04e0f4a88f8bdb,make it python 3 friendly,2015-04-18 16:46:02-05:00,Jon Mason,1,1,2,1,['no_command.py'],"['from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\ndef _count_history_uses(name):\n    script = ""history | egrep \'\\\\b{}\\\\b\' | wc -l"".format(name)\n    result = Popen(script, shell=True,\n                   stdout=PIPE)\n    return int(result.stdout.read())\n\ndef _get_candidate_commands(command, settings):\n    output = _get_output(command, settings)\n    if ""No command"" in output and ""from package"" in output:\n        fixed_names = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)\n        return filter(which, fixed_names)\n    return []\n        \n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return len(_get_candidate_commands(command, settings)) != 0\n\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    candidates = _get_candidate_commands(command, settings)\n    fixed_name = sorted(candidates, key=_count_history_uses, reverse=True)[0]\n    return command.script.replace(broken_name, fixed_name)\n     \n']","['from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode()\n\ndef _count_history_uses(name):\n    script = ""history | egrep \'\\\\b{}\\\\b\' | wc -l"".format(name)\n    result = Popen(script, shell=True,\n                   stdout=PIPE)\n    return int(result.stdout.read())\n\ndef _get_candidate_commands(command, settings):\n    output = _get_output(command, settings)\n    if ""No command"" in output and ""from package"" in output:\n        fixed_names = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)\n        return [name for name in fixed_names if which(name)]\n    return []\n        \n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return len(_get_candidate_commands(command, settings)) != 0\n\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    candidates = _get_candidate_commands(command, settings)\n    fixed_name = sorted(candidates, key=_count_history_uses, reverse=True)[0]\n    return command.script.replace(broken_name, fixed_name)\n     \n']","[[<pydriller.domain.commit.Method object at 0x7f1983d95550>, <pydriller.domain.commit.Method object at 0x7f1983d95ac0>, <pydriller.domain.commit.Method object at 0x7f1983d952e0>, <pydriller.domain.commit.Method object at 0x7f1983d95190>, <pydriller.domain.commit.Method object at 0x7f1983d90d60>]]",[[<pydriller.domain.commit.Method object at 0x7f1983d95940>]]
thefuck,cc1a69fb6526a6b9d0e3bcab3825496eded350d3,another oopsie that was revealed in python3,2015-04-18 16:49:26-05:00,Jon Mason,1,2,3,1,['test_no_command.py'],"['from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b\'\'\'No command \'aptget\' found, did you mean:\n Command \'apt-get\' from package \'apt\' (main)\n Command \'not-installed\' from package \'derp\' (main)\n Command \'not-really-used\' from package \'whatever\' (main)\naptget: command not found\n\'\'\'\n\n@pytest.fixture\ndef uninstalled_command_found():\n    return b\'\'\'No command \'pish\' found, did you mean:\n Command \'vish\' from package \'vish\' (universe)\n Command \'wish\' from package \'tk\' (main)\n Command \'fish\' from package \'fish\' (universe)\n Command \'pdsh\' from package \'pdsh\' (universe)\npish: command not found\n\'\'\'\n\n@pytest.fixture\ndef command_not_found():\n    return b\'\'\'No command \'vom\' found, but there are 19 similar ones\nvom: command not found\n\'\'\'\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch(\'thefuck.rules.no_command.which\',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n@pytest.fixture\ndef bin_might_exist(request):\n    def side_effect(name):\n        return name in [\'not-really-used\', \'apt-get\', \'/usr/lib/command-not-found\', \'test\']\n    p = patch(\'thefuck.rules.no_command.which\',\n              side_effect = side_effect)\n    p.start()\n    request.addfinalizer(p.stop)\n            \n\n@pytest.fixture\ndef patch_history(request):\n    def side_effect(name):\n        print(""history(\'{}\')"".format(name))\n        count = 2 if name == \'not-really-used\' else 12\n    p = patch(\'thefuck.rules.no_command._count_history_uses\',\n              side_effect = side_effect)\n    p.start()\n    request.addfinalizer(p.stop)\n    \n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures(\'bin_might_exist\', \'patch_history\')\ndef test_match(command_found, command_not_found, uninstalled_command_found, settings):\n    with patch(\'thefuck.rules.no_command.Popen\') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command(\'aptget install vim\', \'\', \'\'), settings)\n        Popen.assert_called_with(\'/usr/lib/command-not-found aptget\',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command(\'ls\', \'\', \'\'), settings)\n\n    with patch(\'thefuck.rules.no_command.Popen\') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command(\'sudo aptget install vim\', \'\', \'\'),\n                     Mock(command_not_found=\'test\'))\n        Popen.assert_called_with(\'test aptget\',\n                                      shell=True, stderr=PIPE)\n\n    with patch(\'thefuck.rules.no_command.Popen\') as Popen:\n        Popen.return_value.stderr.read.return_value = uninstalled_command_found\n        assert not match(Command(\'pish bla blah\', \'\', \'\'), settings)\n\n@pytest.mark.usefixtures(\'bin_might_exist\', \'patch_history\')\ndef test_get_new_command(command_found):\n    with patch(\'thefuck.rules.no_command._get_output\',\n               return_value=command_found.decode()):\n        assert get_new_command(Command(\'aptget install vim\', \'\', \'\'), settings)\\\n            == \'apt-get install vim\'\n        assert get_new_command(Command(\'sudo aptget install vim\', \'\', \'\'), settings) \\\n            == \'sudo apt-get install vim\'\n']","[""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\n Command 'not-installed' from package 'derp' (main)\n Command 'not-really-used' from package 'whatever' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef uninstalled_command_found():\n    return b'''No command 'pish' found, did you mean:\n Command 'vish' from package 'vish' (universe)\n Command 'wish' from package 'tk' (main)\n Command 'fish' from package 'fish' (universe)\n Command 'pdsh' from package 'pdsh' (universe)\npish: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n@pytest.fixture\ndef bin_might_exist(request):\n    def side_effect(name):\n        return name in ['not-really-used', 'apt-get', '/usr/lib/command-not-found', 'test']\n    p = patch('thefuck.rules.no_command.which',\n              side_effect = side_effect)\n    p.start()\n    request.addfinalizer(p.stop)\n            \n\n@pytest.fixture\ndef patch_history(request):\n    def side_effect(name):\n        return 2 if name == 'not-really-used' else 12\n    p = patch('thefuck.rules.no_command._count_history_uses',\n              side_effect = side_effect)\n    p.start()\n    request.addfinalizer(p.stop)\n    \n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures('bin_might_exist', 'patch_history')\ndef test_match(command_found, command_not_found, uninstalled_command_found, settings):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), settings)\n        Popen.assert_called_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), settings)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = uninstalled_command_found\n        assert not match(Command('pish bla blah', '', ''), settings)\n\n@pytest.mark.usefixtures('bin_might_exist', 'patch_history')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), settings)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), settings) \\\n            == 'sudo apt-get install vim'\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983d90fd0>, <pydriller.domain.commit.Method object at 0x7f1983d906a0>, <pydriller.domain.commit.Method object at 0x7f1983d90e80>, <pydriller.domain.commit.Method object at 0x7f1983d90eb0>, <pydriller.domain.commit.Method object at 0x7f1983d95040>, <pydriller.domain.commit.Method object at 0x7f1983d95400>, <pydriller.domain.commit.Method object at 0x7f1983d95160>, <pydriller.domain.commit.Method object at 0x7f1983d952b0>, <pydriller.domain.commit.Method object at 0x7f1983d95a90>, <pydriller.domain.commit.Method object at 0x7f1983d95430>, <pydriller.domain.commit.Method object at 0x7f1983db1fd0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983e097f0>, <pydriller.domain.commit.Method object at 0x7f1983e09be0>]]"
thefuck,650c3f4e45602d0faa4376291ae1b51f92bd90be,Fixed grammar in comments for easier understanding,2015-04-19 02:09:53+02:00,Max Dietrich,2,2,4,1,['main.py'],"['from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exists.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""It\'s second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","['from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","[[<pydriller.domain.commit.Method object at 0x7f1983d23580>, <pydriller.domain.commit.Method object at 0x7f1983d236a0>, <pydriller.domain.commit.Method object at 0x7f1983d23550>, <pydriller.domain.commit.Method object at 0x7f1983d23040>, <pydriller.domain.commit.Method object at 0x7f1983d0b2e0>, <pydriller.domain.commit.Method object at 0x7f1983d0b580>, <pydriller.domain.commit.Method object at 0x7f1983d0b820>, <pydriller.domain.commit.Method object at 0x7f1983ccceb0>, <pydriller.domain.commit.Method object at 0x7f1983ccc820>, <pydriller.domain.commit.Method object at 0x7f1983d1ceb0>, <pydriller.domain.commit.Method object at 0x7f1983cd7ac0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983d56d30>, <pydriller.domain.commit.Method object at 0x7f1983d3ba90>]]"
thefuck,0d577ffa83ed7d410d2577c7d72995cf88c974f5,sudo rule: add support for mtr,2015-04-19 11:57:01+08:00,Felix Yan,2,1,3,1,['sudo.py'],"[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983d6e580>, <pydriller.domain.commit.Method object at 0x7f1983d4a040>]]",[[]]
thefuck,2a79a5e413b41bbbe3886828a97958ca824e7bdc,Create rm_root.py,2015-04-19 09:03:34+05:00,SpyCheese,8,0,8,1,['rm_root.py'],[None],"[""def match(command, settings):\n    return ('rm' in command.script\n            and '--help' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return '{} --no-preserve-root'.format(command.script)\n""]",[[]],"[[<pydriller.domain.commit.Method object at 0x7f1983d74190>, <pydriller.domain.commit.Method object at 0x7f1983d742b0>]]"
thefuck,f113bae59d97ab1cd90857680e8c6e9320b96327,Update rm_root.py,2015-04-19 09:12:19+05:00,SpyCheese,2,2,4,1,['rm_root.py'],"[""def match(command, settings):\n    return ('rm' in command.script\n            and '--help' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return '{} --no-preserve-root'.format(command.script)\n""]","[""def match(command, settings):\n    return ('/' in command.script\n            and '--no-preserve-root' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return '{} --no-preserve-root'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983dc5be0>, <pydriller.domain.commit.Method object at 0x7f1983dc5580>]]",[[<pydriller.domain.commit.Method object at 0x7f1983dbeeb0>]]
thefuck,ceeccf1cd7de156ae48ce5aa7f01366015fa6de9,"Update rm_root.py

Okay, there was an incorrect match function.",2015-04-19 10:21:46+05:00,SpyCheese,1,1,2,1,['rm_root.py'],"[""def match(command, settings):\n    return ('/' in command.script\n            and '--no-preserve-root' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return '{} --no-preserve-root'.format(command.script)\n""]","[""def match(command, settings):\n    return ('/' in command.script.split()\n            and '--no-preserve-root' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return '{} --no-preserve-root'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983e09820>, <pydriller.domain.commit.Method object at 0x7f1983e09550>]]",[[<pydriller.domain.commit.Method object at 0x7f1983da8430>]]
thefuck,ab91eaf73d2012266aaa3f82d08d05e62a82c4a4,"Revert ""Merge pull request #36 from jjmason/improve-no-command""

This reverts commit 28a5c1214b730e727b88648cf56dd36d51862ff6, reversing
changes made to 3f0cbb9326895cf516eb9f4f0f834d23200dc21e.",2015-04-19 14:58:44+02:00,nvbn,11,61,72,2,"['test_no_command.py', 'no_command.py']","[""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\n Command 'not-installed' from package 'derp' (main)\n Command 'not-really-used' from package 'whatever' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef uninstalled_command_found():\n    return b'''No command 'pish' found, did you mean:\n Command 'vish' from package 'vish' (universe)\n Command 'wish' from package 'tk' (main)\n Command 'fish' from package 'fish' (universe)\n Command 'pdsh' from package 'pdsh' (universe)\npish: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n@pytest.fixture\ndef bin_might_exist(request):\n    def side_effect(name):\n        return name in ['not-really-used', 'apt-get', '/usr/lib/command-not-found', 'test']\n    p = patch('thefuck.rules.no_command.which',\n              side_effect = side_effect)\n    p.start()\n    request.addfinalizer(p.stop)\n            \n\n@pytest.fixture\ndef patch_history(request):\n    def side_effect(name):\n        return 2 if name == 'not-really-used' else 12\n    p = patch('thefuck.rules.no_command._count_history_uses',\n              side_effect = side_effect)\n    p.start()\n    request.addfinalizer(p.stop)\n    \n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures('bin_might_exist', 'patch_history')\ndef test_match(command_found, command_not_found, uninstalled_command_found, settings):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), settings)\n        Popen.assert_called_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), settings)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = uninstalled_command_found\n        assert not match(Command('pish bla blah', '', ''), settings)\n\n@pytest.mark.usefixtures('bin_might_exist', 'patch_history')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), settings)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), settings) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode(\'utf-8\')\n\ndef _count_history_uses(name):\n    script = ""history | egrep \'\\\\b{}\\\\b\' | wc -l"".format(name)\n    result = Popen(script, shell=True,\n                   stdout=PIPE)\n    return int(result.stdout.read())\n\ndef _get_candidate_commands(command, settings):\n    output = _get_output(command, settings)\n    if ""No command"" in output and ""from package"" in output:\n        fixed_names = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)\n        return [name for name in fixed_names if which(name)]\n    return []\n        \n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return len(_get_candidate_commands(command, settings)) != 0\n\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    candidates = _get_candidate_commands(command, settings)\n    fixed_name = sorted(candidates, key=_count_history_uses, reverse=True)[0]\n    return command.script.replace(broken_name, fixed_name)\n     \n']","[""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_match(command_found, command_not_found, settings):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), settings)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), settings)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), settings)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), settings) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode(\'utf-8\')\n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n']","[[<pydriller.domain.commit.Method object at 0x7f1983dfe550>, <pydriller.domain.commit.Method object at 0x7f1983dfe6a0>, <pydriller.domain.commit.Method object at 0x7f1983dfe580>, <pydriller.domain.commit.Method object at 0x7f1983df8fd0>, <pydriller.domain.commit.Method object at 0x7f1983df8820>, <pydriller.domain.commit.Method object at 0x7f1983df86a0>, <pydriller.domain.commit.Method object at 0x7f1983df86d0>, <pydriller.domain.commit.Method object at 0x7f1983df8550>, <pydriller.domain.commit.Method object at 0x7f1983df8580>, <pydriller.domain.commit.Method object at 0x7f1983df8400>, <pydriller.domain.commit.Method object at 0x7f1983df8430>], [<pydriller.domain.commit.Method object at 0x7f1983df2430>, <pydriller.domain.commit.Method object at 0x7f1983df22b0>, <pydriller.domain.commit.Method object at 0x7f1983df2580>, <pydriller.domain.commit.Method object at 0x7f1983df8d60>, <pydriller.domain.commit.Method object at 0x7f1983df8c10>]]","[[<pydriller.domain.commit.Method object at 0x7f1983df86a0>, <pydriller.domain.commit.Method object at 0x7f1983df86d0>, <pydriller.domain.commit.Method object at 0x7f1983dfe6a0>, <pydriller.domain.commit.Method object at 0x7f1983df8400>, <pydriller.domain.commit.Method object at 0x7f1983dfe550>, <pydriller.domain.commit.Method object at 0x7f1983df8550>, <pydriller.domain.commit.Method object at 0x7f1983df8820>, <pydriller.domain.commit.Method object at 0x7f1983dfe160>], [<pydriller.domain.commit.Method object at 0x7f1983debfd0>, <pydriller.domain.commit.Method object at 0x7f1983df2580>, <pydriller.domain.commit.Method object at 0x7f1983df2160>, <pydriller.domain.commit.Method object at 0x7f1983df22b0>]]"
thefuck,a2c086ed73dd6489a2fde61902b7112a06a71904,"sudo rule: add support for ""Operation not permitted"" errors",2015-04-19 22:53:09+08:00,Felix Yan,2,1,3,1,['sudo.py'],"[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983e04d60>, <pydriller.domain.commit.Method object at 0x7f1983e04580>]]",[[]]
thefuck,f9f757f618378ed2b4ef9592c5dbc7d200b6c103,Added rule:cp_omitting_directory,2015-04-20 14:34:09+05:30,Nabeel Valapra,10,0,10,1,['cp_omitting_directory.py'],[None],"[""def match(command, settings):\n    if 'cp: omitting directory' in command.stderr.lower():\n        return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return command.script.replace('cp', 'cp -r') \n\n\n""]",[[]],"[[<pydriller.domain.commit.Method object at 0x7f1983da12b0>, <pydriller.domain.commit.Method object at 0x7f1983da16a0>]]"
thefuck,0b7fd6ae2ab20c99f9d0625f4ac7bf186bd92126,"Added rm -rf support

When someone tries to remove a directory without specifying `-rf`, e.g.

    $ mkdir foo
    $ rm foo

the shell refuses to remove the directory with an error:

    rm: foo: is a directory

Instead, you need to use

    $ rm -rf foo

This rule adds fuck support for this:

    $ mkdir foo
    $ rm foo
    rm: foo: is a directory
    $ fuck
    rm -rf foo",2015-04-20 12:32:32+02:00,Nils Winkler,22,0,22,2,"['test_rm_dir.py', 'rm_dir.py']","[None, None]","[""from thefuck.main import Command\nfrom thefuck.rules.rm_dir import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('rm foo', '', 'rm: foo: is a directory'), None)\n    assert not match(Command('rm foo', '', ''), None)\n    assert not match(Command('rm foo', '', 'foo bar baz'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('rm foo', '', ''), None) == 'rm -rf foo'\n"", ""import re\n\ndef match(command, settings):\n    return ('rm' in command.script\n            and 'is a directory' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return re.sub('^rm (.*)', 'rm -rf \\\\1', command.script)\n""]","[[], []]","[[<pydriller.domain.commit.Method object at 0x7f1983e09a90>, <pydriller.domain.commit.Method object at 0x7f1983e096a0>], [<pydriller.domain.commit.Method object at 0x7f1983dc56d0>, <pydriller.domain.commit.Method object at 0x7f1983dc52e0>]]"
thefuck,2b08a136b59c80bf4d0d04545078156a577279c3,add a rule to run the script you enter by add './' in command's prefix,2015-04-20 19:48:27+08:00,dannion,9,0,9,1,['has_exists_script.py'],[None],"[""import os\n\ndef match(command, settings):\n\texist = os.path.exists(command.script)\n\treturn exist\n\ndef get_new_command(command, settings):\n    return './{}'.format(command.script)\n\n""]",[[]],"[[<pydriller.domain.commit.Method object at 0x7f1983dbec10>, <pydriller.domain.commit.Method object at 0x7f1983dbed30>]]"
thefuck,36d9e13eceb9a3c9cb7037440538815983fa327b,#55 Add tests and check for `command not found`,2015-04-20 15:46:02+02:00,nvbn,24,2,26,2,"['test_has_exists_script.py', 'has_exists_script.py']","[None, ""import os\n\ndef match(command, settings):\n\texist = os.path.exists(command.script)\n\treturn exist\n\ndef get_new_command(command, settings):\n    return './{}'.format(command.script)\n\n""]","[""from mock import Mock, patch\nfrom thefuck.rules. has_exists_script import match, get_new_command\n\n\ndef test_match():\n    with patch('os.path.exists', return_value=True):\n        assert match(Mock(script='main', stderr='main: command not found'),\n                     None)\n        assert match(Mock(script='main --help',\n                          stderr='main: command not found'),\n                     None)\n        assert not match(Mock(script='main', stderr=''), None)\n\n    with patch('os.path.exists', return_value=False):\n        assert not match(Mock(script='main', stderr='main: command not found'),\n                         None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Mock(script='main --help'), None) == './main --help'\n"", ""import os\n\n\ndef match(command, settings):\n    return os.path.exists(command.script.split()[0]) \\\n        and 'command not found' in command.stderr\n\n\ndef get_new_command(command, settings):\n    return './{}'.format(command.script)\n\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d5cfd0>, <pydriller.domain.commit.Method object at 0x7f1983d5c2e0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983d67a90>, <pydriller.domain.commit.Method object at 0x7f1983d67820>], [<pydriller.domain.commit.Method object at 0x7f1983d7f2b0>]]"
thefuck,9ecda9a399cab6a683eed27e5dd8de7b394c581c,Bump version to 1.13,2015-04-20 15:48:17+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.12,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.13,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,411aea67f771fb2a9ba0bf253b750d05deb2c242,"A special case for 'Permission denied' error msg when trying to execute a
python scripy.

The script does not have execute permission and/or does not start with !#/usr/...
In that case, pre-pend the command with 'python' keyword.

Change-Id: Idf73ee9cf0a523f51c78672188a457b2fcedc1e6",2015-04-20 10:49:39-04:00,Sudeep Juvekar,22,1,23,3,"['test_python_command.py', 'main.py', 'python_command.py']","[None, 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in list(bundled) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n', None]","[""from thefuck.main import Command\nfrom thefuck.rules.sudo import match, get_new_command\n\ndef test_match():\n    assert match(Command('', '', 'Permission denied'), None)\n    assert not match(Command('', '', ''), None)\n\ndef test_get_new_command():\n    assert get_new_command(Command('./test_sudo.py', '', ''), None) == 'python ./test_sudo.py'\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n', ""# add 'python' suffix to the command if\n#  1) The script does not have execute permission or\n#  2) is interpreted as shell script\n\ndef match(command, settings):\n  toks = command.script.split()\n  return (toks[0].endswith('.py')\n          and ('Permission denied' in command.stderr or\n               'command not found' in command.stderr))\n\ndef get_new_command(command, settings):\n  return 'python ' + command.script\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983ddfd60>, <pydriller.domain.commit.Method object at 0x7f1983ddfeb0>, <pydriller.domain.commit.Method object at 0x7f1983ddfbe0>, <pydriller.domain.commit.Method object at 0x7f1983ddfc10>, <pydriller.domain.commit.Method object at 0x7f1983ddf430>, <pydriller.domain.commit.Method object at 0x7f1983ddf2b0>, <pydriller.domain.commit.Method object at 0x7f1983ddf2e0>, <pydriller.domain.commit.Method object at 0x7f1983ddf160>, <pydriller.domain.commit.Method object at 0x7f1983ddf190>, <pydriller.domain.commit.Method object at 0x7f1983ddf040>, <pydriller.domain.commit.Method object at 0x7f1983ddbfd0>], []]","[[<pydriller.domain.commit.Method object at 0x7f1983debeb0>, <pydriller.domain.commit.Method object at 0x7f1983debd60>], [<pydriller.domain.commit.Method object at 0x7f1983de67f0>], [<pydriller.domain.commit.Method object at 0x7f1983ddb940>, <pydriller.domain.commit.Method object at 0x7f1983ddb7f0>]]"
thefuck,17397bf30ff94e5fda0c1bcdaca75bdcac458641,"A special case for 'Permission denied' error msg when trying to execute a
python scripy.

The script does not have execute permission and/or does not start with !#/usr/...
In that case, pre-pend the command with 'python' keyword.

Change-Id: Idf73ee9cf0a523f51c78672188a457b2fcedc1e6",2015-04-20 11:00:35-04:00,Sudeep Juvekar,1,1,2,1,['test_python_command.py'],"[""from thefuck.main import Command\nfrom thefuck.rules.sudo import match, get_new_command\n\ndef test_match():\n    assert match(Command('', '', 'Permission denied'), None)\n    assert not match(Command('', '', ''), None)\n\ndef test_get_new_command():\n    assert get_new_command(Command('./test_sudo.py', '', ''), None) == 'python ./test_sudo.py'\n""]","[""from thefuck.main import Command\nfrom thefuck.rules.python_command import match, get_new_command\n\ndef test_match():\n    assert match(Command('', '', 'Permission denied'), None)\n    assert not match(Command('', '', ''), None)\n\ndef test_get_new_command():\n    assert get_new_command(Command('./test_sudo.py', '', ''), None) == 'python ./test_sudo.py'\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983dd5fd0>, <pydriller.domain.commit.Method object at 0x7f1983dd5970>]]",[[]]
thefuck,cb31a1f7d08776b5a9e42bc944b2e12a23c1613e,"A special case for 'Permission denied' error msg when trying to execute a
python scripy.

The script does not have execute permission and/or does not start with !#/usr/...
In that case, pre-pend the command with 'python' keyword.

Change-Id: Idf73ee9cf0a523f51c78672188a457b2fcedc1e6",2015-04-20 12:00:08-04:00,Sudeep Juvekar,2,1,3,1,['python_command.py'],"[""# add 'python' suffix to the command if\n#  1) The script does not have execute permission or\n#  2) is interpreted as shell script\n\ndef match(command, settings):\n  toks = command.script.split()\n  return (toks[0].endswith('.py')\n          and ('Permission denied' in command.stderr or\n               'command not found' in command.stderr))\n\ndef get_new_command(command, settings):\n  return 'python ' + command.script\n""]","[""# add 'python' suffix to the command if\n#  1) The script does not have execute permission or\n#  2) is interpreted as shell script\n\ndef match(command, settings):\n  toks = command.script.split()\n  return (len(toks) > 0\n          and toks[0].endswith('.py')\n          and ('Permission denied' in command.stderr or\n               'command not found' in command.stderr))\n\ndef get_new_command(command, settings):\n  return 'python ' + command.script\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983dd52b0>, <pydriller.domain.commit.Method object at 0x7f1983dd5160>]]",[[<pydriller.domain.commit.Method object at 0x7f1983dcf2e0>]]
thefuck,1d878243ca50dcfe371ef30eec1bad4bd6b2e4a5,"A special case for 'Permission denied' error msg when trying to execute a
python scripy.

The script does not have execute permission and/or does not start with !#/usr/...
In that case, pre-pend the command with 'python' keyword.

Change-Id: Idf73ee9cf0a523f51c78672188a457b2fcedc1e6",2015-04-20 12:11:06-04:00,Sudeep Juvekar,1,1,2,1,['test_python_command.py'],"[""from thefuck.main import Command\nfrom thefuck.rules.python_command import match, get_new_command\n\ndef test_match():\n    assert match(Command('', '', 'Permission denied'), None)\n    assert not match(Command('', '', ''), None)\n\ndef test_get_new_command():\n    assert get_new_command(Command('./test_sudo.py', '', ''), None) == 'python ./test_sudo.py'\n""]","[""from thefuck.main import Command\nfrom thefuck.rules.python_command import match, get_new_command\n\ndef test_match():\n    assert match(Command('temp.py', '', 'Permission denied'), None)\n    assert not match(Command('', '', ''), None)\n\ndef test_get_new_command():\n    assert get_new_command(Command('./test_sudo.py', '', ''), None) == 'python ./test_sudo.py'\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983ddfd30>, <pydriller.domain.commit.Method object at 0x7f1983ddf580>]]",[[<pydriller.domain.commit.Method object at 0x7f1983ddb2b0>]]
thefuck,c0c584b13a0d6f5e177e25f48d5de918f1bef7e2,"mkdir -p

When adding directories using `mkdir`, intermediate directories have to
exist, unless you specify the `-p` option:

    $ mkdir foo/bar/baz
    mkdir: foo/bar: No such file or directory
    $ fuck
    mkdir -p foo/bar/baz",2015-04-20 18:38:03+02:00,Nils Winkler,22,0,22,2,"['test_mkdir_p.py', 'mkdir_p.py']","[None, None]","[""from thefuck.main import Command\nfrom thefuck.rules.mkdir_p import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('mkdir foo/bar/baz', '', 'mkdir: foo/bar: No such file or directory'), None)\n    assert not match(Command('mkdir foo/bar/baz', '', ''), None)\n    assert not match(Command('mkdir foo/bar/baz', '', 'foo bar baz'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('mkdir foo/bar/baz', '', ''), None) == 'mkdir -p foo/bar/baz'\n"", ""import re\n\ndef match(command, settings):\n    return ('mkdir' in command.script\n            and 'No such file or directory' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return re.sub('^mkdir (.*)', 'mkdir -p \\\\1', command.script)\n""]","[[], []]","[[<pydriller.domain.commit.Method object at 0x7f1983deb2e0>, <pydriller.domain.commit.Method object at 0x7f1983debd30>], [<pydriller.domain.commit.Method object at 0x7f1983de6a90>, <pydriller.domain.commit.Method object at 0x7f1983de6ac0>]]"
thefuck,2db0a215b4006555b21281957fe8e8446da1beb7,Fix fuck when more than one git command available,2015-04-20 21:48:54+02:00,nvbn,21,5,26,3,"['setup.py', 'test_git_not_command.py', 'git_not_command.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.13,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', 'import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.git_not_command import match, get_new_command\n\n\n@pytest.fixture\ndef git_not_command():\n    return """"""git: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\nbranch\n""""""\n\n\n@pytest.fixture\ndef git_command():\n    return ""* master""\n\n\ndef test_match(git_not_command, git_command):\n    assert match(Command(\'git brnch\', \'\', git_not_command), None)\n    assert not match(Command(\'ls brnch\', \'\', git_not_command), None)\n    assert not match(Command(\'git branch\', \'\', git_command), None)\n\n\ndef test_get_new_command(git_not_command):\n    assert get_new_command(Command(\'git brnch\', \'\', git_not_command), None)\\\n        == \'git branch\'\n', 'import re\n\n\ndef match(command, settings):\n    return (\'git\' in command.script\n            and "" is not a git command. See \'git --help\'."" in command.stderr\n            and \'Did you mean this?\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r""git: \'([^\']*)\' is not a git command"",\n                            command.stderr)[0]\n    new_cmd = re.findall(r\'Did you mean this\\?\\n\\s*([^\\n]*)\',\n                         command.stderr)[0]\n    return command.script.replace(broken_cmd, new_cmd, 1)\n\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.14,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', 'import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.git_not_command import match, get_new_command\n\n\n@pytest.fixture\ndef git_not_command():\n    return """"""git: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\nbranch\n""""""\n\n\n@pytest.fixture\ndef git_not_command_one_of_this():\n    return """"""git: \'st\' is not a git command. See \'git --help\'.\n\nDid you mean one of these?\nstatus\nreset\nstage\nstash\nstats\n""""""\n\n\n@pytest.fixture\ndef git_command():\n    return ""* master""\n\n\ndef test_match(git_not_command, git_command, git_not_command_one_of_this):\n    assert match(Command(\'git brnch\', \'\', git_not_command), None)\n    assert match(Command(\'git st\', \'\', git_not_command_one_of_this), None)\n    assert not match(Command(\'ls brnch\', \'\', git_not_command), None)\n    assert not match(Command(\'git branch\', \'\', git_command), None)\n\n\ndef test_get_new_command(git_not_command, git_not_command_one_of_this):\n    assert get_new_command(Command(\'git brnch\', \'\', git_not_command), None)\\\n        == \'git branch\'\n    assert get_new_command(\n        Command(\'git st\', \'\', git_not_command_one_of_this), None) == \'git status\'\n', 'import re\n\n\ndef match(command, settings):\n    return (\'git\' in command.script\n            and "" is not a git command. See \'git --help\'."" in command.stderr\n            and \'Did you mean\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r""git: \'([^\']*)\' is not a git command"",\n                            command.stderr)[0]\n    new_cmd = re.findall(r\'Did you mean[^\\n]*\\n\\s*([^\\n]*)\',\n                         command.stderr)[0]\n    return command.script.replace(broken_cmd, new_cmd, 1)\n\n']","[[], [<pydriller.domain.commit.Method object at 0x7f1983ce9970>, <pydriller.domain.commit.Method object at 0x7f1983ce96d0>, <pydriller.domain.commit.Method object at 0x7f1983ce9550>, <pydriller.domain.commit.Method object at 0x7f1983d4afd0>], [<pydriller.domain.commit.Method object at 0x7f1983dacc10>, <pydriller.domain.commit.Method object at 0x7f1983dacbe0>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d4afd0>, <pydriller.domain.commit.Method object at 0x7f1983ce9550>, <pydriller.domain.commit.Method object at 0x7f1983d85c10>, <pydriller.domain.commit.Method object at 0x7f1983d7f160>, <pydriller.domain.commit.Method object at 0x7f1983d5c6d0>], [<pydriller.domain.commit.Method object at 0x7f1983dbe970>, <pydriller.domain.commit.Method object at 0x7f1983dbe550>]]"
thefuck,7888315196a5e97549e93d772396e85f34f65bc5,"#52 Use `cp -a`, add tests",2015-04-20 22:00:37+02:00,nvbn,20,6,26,2,"['test_cp_omitting_directory.py', 'cp_omitting_directory.py']","[None, ""def match(command, settings):\n    if 'cp: omitting directory' in command.stderr.lower():\n        return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return command.script.replace('cp', 'cp -r') \n\n\n""]","['from mock import Mock\nfrom thefuck.rules.cp_omitting_directory import match, get_new_command\n\n\ndef test_match():\n    assert match(Mock(script=\'cp dir\', stderr=""cp: omitting directory \'dir\'""),\n                 None)\n    assert not match(Mock(script=\'some dir\',\n                          stderr=""cp: omitting directory \'dir\'""), None)\n    assert not match(Mock(script=\'cp dir\', stderr=""""), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Mock(script=\'cp dir\'), None) == \'cp -a dir\'\n', ""import re\n\n\ndef match(command, settings):\n    return command.script.startswith('cp ') \\\n        and 'cp: omitting directory' in command.stderr.lower()\n\n\ndef get_new_command(command, settings):\n    return re.sub(r'^cp', 'cp -a', command.script)\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e04970>, <pydriller.domain.commit.Method object at 0x7f1983e04c10>]]","[[<pydriller.domain.commit.Method object at 0x7f1983da1820>, <pydriller.domain.commit.Method object at 0x7f1983da17f0>], [<pydriller.domain.commit.Method object at 0x7f1983e09400>, <pydriller.domain.commit.Method object at 0x7f1983e09fd0>]]"
thefuck,e822fade4c58377ed0eb3ec9759c4eddf4ecf842,#10 Add `require_confirmation` option,2015-04-21 05:30:15+02:00,nvbn,62,3,65,3,"['README.md', 'test_main.py', 'main.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    sys.stderr.write(new_command + \'\\n\')\n    print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scary to blindly run changed command, there\'s `require_confirmation`\n[settings](#Settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","[[], [<pydriller.domain.commit.Method object at 0x7f1983dfe7f0>, <pydriller.domain.commit.Method object at 0x7f1983dfed30>, <pydriller.domain.commit.Method object at 0x7f1983e096d0>, <pydriller.domain.commit.Method object at 0x7f1983e09ac0>, <pydriller.domain.commit.Method object at 0x7f1983e09e80>, <pydriller.domain.commit.Method object at 0x7f1983e092e0>], [<pydriller.domain.commit.Method object at 0x7f1983d5c400>, <pydriller.domain.commit.Method object at 0x7f1983d7f970>, <pydriller.domain.commit.Method object at 0x7f1983d7fd30>, <pydriller.domain.commit.Method object at 0x7f1983d7fac0>, <pydriller.domain.commit.Method object at 0x7f1983d56be0>, <pydriller.domain.commit.Method object at 0x7f1983d56040>, <pydriller.domain.commit.Method object at 0x7f1983d56580>, <pydriller.domain.commit.Method object at 0x7f1983d56970>, <pydriller.domain.commit.Method object at 0x7f1983d56550>, <pydriller.domain.commit.Method object at 0x7f1983d562b0>, <pydriller.domain.commit.Method object at 0x7f1983d566a0>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e42400>, <pydriller.domain.commit.Method object at 0x7f1983df2040>], [<pydriller.domain.commit.Method object at 0x7f1983d3b580>, <pydriller.domain.commit.Method object at 0x7f1983d3b040>, <pydriller.domain.commit.Method object at 0x7f1983dbe580>]]"
thefuck,0925c7966f19f02da93b2047318eb060bf022349,Bump version,2015-04-21 05:34:44+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.14,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.15,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,5ccf163594fa11239b5cb83c73aa9c63879a17f2,`command.script` now unicode,2015-04-21 06:24:40+02:00,nvbn,13,12,25,6,"['test_main.py', 'main.py', 'has_exists_script.py', 'no_command.py', 'python_command.py', 'sudo.py']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n', ""import os\n\n\ndef match(command, settings):\n    return os.path.exists(command.script.split()[0]) \\\n        and 'command not found' in command.stderr\n\n\ndef get_new_command(command, settings):\n    return './{}'.format(command.script)\n\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = \'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode(\'utf-8\')\n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n', ""# add 'python' suffix to the command if\n#  1) The script does not have execute permission or\n#  2) is interpreted as shell script\n\ndef match(command, settings):\n  toks = command.script.split()\n  return (len(toks) > 0\n          and toks[0].endswith('.py')\n          and ('Permission denied' in command.stderr or\n               'command not found' in command.stderr))\n\ndef get_new_command(command, settings):\n  return 'python ' + command.script\n"", ""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n""]","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), [b'thefuck', b'apt-get',\n                                         b'search', b'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n', ""import os\n\n\ndef match(command, settings):\n    return os.path.exists(command.script.split()[0]) \\\n        and 'command not found' in command.stderr\n\n\ndef get_new_command(command, settings):\n    return u'./{}'.format(command.script)\n\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = u\'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode(\'utf-8\')\n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n', ""# add 'python' suffix to the command if\n#  1) The script does not have execute permission or\n#  2) is interpreted as shell script\n\ndef match(command, settings):\n    toks = command.script.split()\n    return (len(toks) > 0\n            and toks[0].endswith('.py')\n            and ('Permission denied' in command.stderr or\n                 'command not found' in command.stderr))\n\n\ndef get_new_command(command, settings):\n    return 'python ' + command.script\n"", ""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983e42be0>, <pydriller.domain.commit.Method object at 0x7f1983e42d30>, <pydriller.domain.commit.Method object at 0x7f1983e42c10>, <pydriller.domain.commit.Method object at 0x7f1983e42a60>, <pydriller.domain.commit.Method object at 0x7f1983e42670>, <pydriller.domain.commit.Method object at 0x7f1983e426a0>, <pydriller.domain.commit.Method object at 0x7f1983e42d60>, <pydriller.domain.commit.Method object at 0x7f1983e42eb0>], [<pydriller.domain.commit.Method object at 0x7f1983e047f0>, <pydriller.domain.commit.Method object at 0x7f1983e42520>, <pydriller.domain.commit.Method object at 0x7f1983e42a90>, <pydriller.domain.commit.Method object at 0x7f1983e42910>, <pydriller.domain.commit.Method object at 0x7f1983e42940>, <pydriller.domain.commit.Method object at 0x7f1983e427c0>, <pydriller.domain.commit.Method object at 0x7f1983e427f0>, <pydriller.domain.commit.Method object at 0x7f1983dcf7f0>, <pydriller.domain.commit.Method object at 0x7f1983dcf160>, <pydriller.domain.commit.Method object at 0x7f1983dcfac0>, <pydriller.domain.commit.Method object at 0x7f1983dcfa90>, <pydriller.domain.commit.Method object at 0x7f1983dcf040>], [<pydriller.domain.commit.Method object at 0x7f1983dcfbe0>, <pydriller.domain.commit.Method object at 0x7f1983dcf550>], [<pydriller.domain.commit.Method object at 0x7f1983de6160>, <pydriller.domain.commit.Method object at 0x7f1983de6400>, <pydriller.domain.commit.Method object at 0x7f1983de6190>], [<pydriller.domain.commit.Method object at 0x7f1983ddf970>, <pydriller.domain.commit.Method object at 0x7f1983d95970>], [<pydriller.domain.commit.Method object at 0x7f1983d90ac0>, <pydriller.domain.commit.Method object at 0x7f1983d907f0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983dcf6d0>], [<pydriller.domain.commit.Method object at 0x7f1983dcaeb0>], [<pydriller.domain.commit.Method object at 0x7f1983dca6a0>], [<pydriller.domain.commit.Method object at 0x7f1983ddbd60>], [<pydriller.domain.commit.Method object at 0x7f1983deb430>, <pydriller.domain.commit.Method object at 0x7f1983deb550>], [<pydriller.domain.commit.Method object at 0x7f1983d9c940>]]"
thefuck,e7d5d93056e5238f24da548d578157dbc655dde9,#68 Add rule for switching layout,2015-04-21 06:26:15+02:00,nvbn,50,2,52,4,"['README.md', 'setup.py', 'test_switch_lang.py', 'switch_lang.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scary to blindly run changed command, there\'s `require_confirmation`\n[settings](#Settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.15,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', None, None]","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scary to blindly run changed command, there\'s `require_confirmation`\n[settings](#Settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.16,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""# -*- encoding: utf-8 -*-\n\nfrom mock import Mock\nfrom thefuck.rules import switch_lang\n\n\ndef test_match():\n    assert switch_lang.match(Mock(stderr='command not found: фзе-пуе',\n                                  script=u'фзе-пуе'), None)\n    assert not switch_lang.match(Mock(stderr='command not found: pat-get',\n                                      script=u'pat-get'), None)\n    assert not switch_lang.match(Mock(stderr='some info',\n                                      script=u'фзе-пуе'), None)\n\n\ndef test_get_new_command():\n    assert switch_lang.get_new_command(\n        Mock(script=u'фзе-пуе штыефдд мшь'), None) == 'apt-get install vim'\n"", '# -*- encoding: utf-8 -*-\n\ntarget_layout = \'\'\'qwertyuiop[]asdfghjkl;\'zxcvbnm,./QWERTYUIOP{}ASDFGHJKL:""ZXCVBNM<>?\'\'\'\n\nsource_layouts = [u\'\'\'йцукенгшщзхъфывапролджэячсмитьбю.ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,\'\'\']\n\n\ndef _get_matched_layout(command):\n    for source_layout in source_layouts:\n        if all([ch in source_layout or ch in \'-_\'\n                for ch in command.script.split(\' \')[0]]):\n            return source_layout\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and _get_matched_layout(command)\n\n\ndef _switch(ch, layout):\n    if ch in layout:\n        return target_layout[layout.index(ch)]\n    else:\n        return ch\n\n\ndef get_new_command(command, settings):\n    matched_layout = _get_matched_layout(command)\n    return \'\'.join(_switch(ch, matched_layout) for ch in command.script)\n\n']","[[], [], [], []]","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983d4a190>, <pydriller.domain.commit.Method object at 0x7f1983d4abe0>], [<pydriller.domain.commit.Method object at 0x7f1983d23160>, <pydriller.domain.commit.Method object at 0x7f1983dfe400>, <pydriller.domain.commit.Method object at 0x7f1983d74160>, <pydriller.domain.commit.Method object at 0x7f1983d74d60>]]"
thefuck,ab8ac23749d90f0265d29cfe3440357098b97225,Fix python 3 support,2015-04-21 06:33:51+02:00,nvbn,4,1,5,1,['main.py'],"['from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","['from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","[[<pydriller.domain.commit.Method object at 0x7f1983e34250>, <pydriller.domain.commit.Method object at 0x7f1983e343a0>, <pydriller.domain.commit.Method object at 0x7f1983e34280>, <pydriller.domain.commit.Method object at 0x7f1983e34100>, <pydriller.domain.commit.Method object at 0x7f1983e2e910>, <pydriller.domain.commit.Method object at 0x7f1983e2e790>, <pydriller.domain.commit.Method object at 0x7f1983e2e7c0>, <pydriller.domain.commit.Method object at 0x7f1983e2e640>, <pydriller.domain.commit.Method object at 0x7f1983e2e670>, <pydriller.domain.commit.Method object at 0x7f1983e2e4f0>, <pydriller.domain.commit.Method object at 0x7f1983e2e520>, <pydriller.domain.commit.Method object at 0x7f1983e2e3a0>]]",[[<pydriller.domain.commit.Method object at 0x7f1983e34cd0>]]
thefuck,8ed01fedbfcca1cb5acf1ca728a857ff93807942,Bump version,2015-04-21 06:34:03+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.16,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.17,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,360613150247c52804d0c0f00aa84e21d717f746,Fix tests,2015-04-21 06:36:51+02:00,nvbn,2,2,4,1,['test_main.py'],"[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), [b'thefuck', b'apt-get',\n                                         b'search', b'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n""]","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983e237c0>, <pydriller.domain.commit.Method object at 0x7f1983e23280>, <pydriller.domain.commit.Method object at 0x7f1983e29910>, <pydriller.domain.commit.Method object at 0x7f1983e29670>, <pydriller.domain.commit.Method object at 0x7f1983e29b80>, <pydriller.domain.commit.Method object at 0x7f1983e29e20>, <pydriller.domain.commit.Method object at 0x7f1983e29fa0>, <pydriller.domain.commit.Method object at 0x7f1983e29130>]]",[[<pydriller.domain.commit.Method object at 0x7f1983e1dfa0>]]
thefuck,e3edea05edc29bc1e0a5bdcfea4e35c2a46fd972,#24 Make `no_command` crossplatform,2015-04-21 06:55:47+02:00,nvbn,29,81,110,3,"['README.md', 'test_no_command.py', 'no_command.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scary to blindly run changed command, there\'s `require_confirmation`\n[settings](#Settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `command_not_found` &ndash; path to `command_not_found` binary,\nby default `/usr/lib/command-not-found`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""from subprocess import PIPE\nfrom mock import patch, Mock\nimport pytest\nfrom thefuck.rules.no_command import match, get_new_command\nfrom thefuck.main import Command\n\n\n@pytest.fixture\ndef command_found():\n    return b'''No command 'aptget' found, did you mean:\n Command 'apt-get' from package 'apt' (main)\naptget: command not found\n'''\n\n@pytest.fixture\ndef command_not_found():\n    return b'''No command 'vom' found, but there are 19 similar ones\nvom: command not found\n'''\n\n\n@pytest.fixture\ndef bins_exists(request):\n    p = patch('thefuck.rules.no_command.which',\n              return_value=True)\n    p.start()\n    request.addfinalizer(p.stop)\n\n\n@pytest.fixture\ndef settings():\n    class _Settings(object):\n        pass\n    return _Settings\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_match(command_found, command_not_found, settings):\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('aptget install vim', '', ''), settings)\n        Popen.assert_called_once_with('/usr/lib/command-not-found aptget',\n                                      shell=True, stderr=PIPE)\n        Popen.return_value.stderr.read.return_value = command_not_found\n        assert not match(Command('ls', '', ''), settings)\n\n    with patch('thefuck.rules.no_command.Popen') as Popen:\n        Popen.return_value.stderr.read.return_value = command_found\n        assert match(Command('sudo aptget install vim', '', ''),\n                     Mock(command_not_found='test'))\n        Popen.assert_called_once_with('test aptget',\n                                      shell=True, stderr=PIPE)\n\n\n@pytest.mark.usefixtures('bins_exists')\ndef test_get_new_command(command_found):\n    with patch('thefuck.rules.no_command._get_output',\n               return_value=command_found.decode()):\n        assert get_new_command(Command('aptget install vim', '', ''), settings)\\\n            == 'apt-get install vim'\n        assert get_new_command(Command('sudo aptget install vim', '', ''), settings) \\\n            == 'sudo apt-get install vim'\n"", 'from subprocess import Popen, PIPE\nimport re\nfrom thefuck.utils import which, wrap_settings\n\n\nlocal_settings = {\'command_not_found\': \'/usr/lib/command-not-found\'}\n\n\ndef _get_output(command, settings):\n    name = command.script.split(\' \')[command.script.startswith(\'sudo\')]\n    check_script = u\'{} {}\'.format(settings.command_not_found, name)\n    result = Popen(check_script, shell=True, stderr=PIPE)\n    return result.stderr.read().decode(\'utf-8\')\n\n\n@wrap_settings(local_settings)\ndef match(command, settings):\n    if which(settings.command_not_found):\n        output = _get_output(command, settings)\n        return ""No command"" in output and ""from package"" in output\n\n\n@wrap_settings(local_settings)\ndef get_new_command(command, settings):\n    output = _get_output(command, settings)\n    broken_name = re.findall(r""No command \'([^\']*)\' found"",\n                             output)[0]\n    fixed_name = re.findall(r""Command \'([^\']*)\' from package"",\n                            output)[0]\n    return command.script.replace(broken_name, fixed_name, 1)\n']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scary to blindly run changed command, there\'s `require_confirmation`\n[settings](#Settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""from mock import patch, Mock\nfrom thefuck.rules.no_command import match, get_new_command\n\n\ndef test_match():\n    with patch('thefuck.rules.no_command._get_all_bins',\n               return_value=['vim', 'apt-get']):\n        assert match(Mock(stderr='vom: not found', script='vom file.py'), None)\n        assert not match(Mock(stderr='qweqwe: not found', script='qweqwe'), None)\n        assert not match(Mock(stderr='some text', script='vom file.py'), None)\n\n\ndef test_get_new_command():\n    with patch('thefuck.rules.no_command._get_all_bins',\n               return_value=['vim', 'apt-get']):\n        assert get_new_command(\n            Mock(stderr='vom: not found',\n                 script='vom file.py'),\n            None) == 'vim file.py'\n"", ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ['PATH'].split(':')\n            for exe in Path(path).iterdir()\n            if exe.is_file()]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d746d0>, <pydriller.domain.commit.Method object at 0x7f1983d74e80>, <pydriller.domain.commit.Method object at 0x7f1983d746a0>, <pydriller.domain.commit.Method object at 0x7f1983e238e0>, <pydriller.domain.commit.Method object at 0x7f1983e23bb0>, <pydriller.domain.commit.Method object at 0x7f1983e23a30>], [<pydriller.domain.commit.Method object at 0x7f1983dc5550>, <pydriller.domain.commit.Method object at 0x7f1983d62160>, <pydriller.domain.commit.Method object at 0x7f1983d62430>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d74e80>, <pydriller.domain.commit.Method object at 0x7f1983e2ee20>, <pydriller.domain.commit.Method object at 0x7f1983e238e0>, <pydriller.domain.commit.Method object at 0x7f1983d746d0>, <pydriller.domain.commit.Method object at 0x7f1983e2efa0>, <pydriller.domain.commit.Method object at 0x7f1983d746a0>, <pydriller.domain.commit.Method object at 0x7f1983e23a30>, <pydriller.domain.commit.Method object at 0x7f1983e23bb0>], [<pydriller.domain.commit.Method object at 0x7f1983d4ac10>, <pydriller.domain.commit.Method object at 0x7f1983d4ad60>, <pydriller.domain.commit.Method object at 0x7f1983d4a2e0>, <pydriller.domain.commit.Method object at 0x7f1983dc5550>]]"
thefuck,e1fe7ff7d02abe9fc1a447bf49eb97b37ca7b18d,Bump version,2015-04-21 06:56:26+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.17,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.18,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,3798c341d524eb474763d4ccfc8a49e8bf106aa7,"add persian language to switch lang rule
refs #28",2015-04-21 09:42:13+04:30,fzerorubigd,1,1,2,1,['switch_lang.py'],"['# -*- encoding: utf-8 -*-\n\ntarget_layout = \'\'\'qwertyuiop[]asdfghjkl;\'zxcvbnm,./QWERTYUIOP{}ASDFGHJKL:""ZXCVBNM<>?\'\'\'\n\nsource_layouts = [u\'\'\'йцукенгшщзхъфывапролджэячсмитьбю.ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,\'\'\']\n\n\ndef _get_matched_layout(command):\n    for source_layout in source_layouts:\n        if all([ch in source_layout or ch in \'-_\'\n                for ch in command.script.split(\' \')[0]]):\n            return source_layout\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and _get_matched_layout(command)\n\n\ndef _switch(ch, layout):\n    if ch in layout:\n        return target_layout[layout.index(ch)]\n    else:\n        return ch\n\n\ndef get_new_command(command, settings):\n    matched_layout = _get_matched_layout(command)\n    return \'\'.join(_switch(ch, matched_layout) for ch in command.script)\n\n']","['# -*- encoding: utf-8 -*-\n\ntarget_layout = \'\'\'qwertyuiop[]asdfghjkl;\'zxcvbnm,./QWERTYUIOP{}ASDFGHJKL:""ZXCVBNM<>?\'\'\'\n\nsource_layouts = [u\'\'\'йцукенгшщзхъфывапролджэячсмитьбю.ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,\'\'\', u\'\'\'ضصثقفغعهخحجچشسیبلاتنمکگظطزرذدپو./ًٌٍَُِّْ][}{ؤئيإأآة»«:؛كٓژٰ\u200cٔء><؟\'\'\']\n\n\ndef _get_matched_layout(command):\n    for source_layout in source_layouts:\n        if all([ch in source_layout or ch in \'-_\'\n                for ch in command.script.split(\' \')[0]]):\n            return source_layout\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and _get_matched_layout(command)\n\n\ndef _switch(ch, layout):\n    if ch in layout:\n        return target_layout[layout.index(ch)]\n    else:\n        return ch\n\n\ndef get_new_command(command, settings):\n    matched_layout = _get_matched_layout(command)\n    return \'\'.join(_switch(ch, matched_layout) for ch in command.script)\n\n']","[[<pydriller.domain.commit.Method object at 0x7f1983ddb2e0>, <pydriller.domain.commit.Method object at 0x7f1983ddbeb0>, <pydriller.domain.commit.Method object at 0x7f1983ddb550>, <pydriller.domain.commit.Method object at 0x7f1983ddb400>]]",[[]]
thefuck,273fc097bd87058a4f303edc3149941d42264240,Update switch_lang.py,2015-04-21 07:16:36+02:00,Vladimir Iakovlev,2,1,3,1,['switch_lang.py'],"['# -*- encoding: utf-8 -*-\n\ntarget_layout = \'\'\'qwertyuiop[]asdfghjkl;\'zxcvbnm,./QWERTYUIOP{}ASDFGHJKL:""ZXCVBNM<>?\'\'\'\n\nsource_layouts = [u\'\'\'йцукенгшщзхъфывапролджэячсмитьбю.ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,\'\'\', u\'\'\'ضصثقفغعهخحجچشسیبلاتنمکگظطزرذدپو./ًٌٍَُِّْ][}{ؤئيإأآة»«:؛كٓژٰ\u200cٔء><؟\'\'\']\n\n\ndef _get_matched_layout(command):\n    for source_layout in source_layouts:\n        if all([ch in source_layout or ch in \'-_\'\n                for ch in command.script.split(\' \')[0]]):\n            return source_layout\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and _get_matched_layout(command)\n\n\ndef _switch(ch, layout):\n    if ch in layout:\n        return target_layout[layout.index(ch)]\n    else:\n        return ch\n\n\ndef get_new_command(command, settings):\n    matched_layout = _get_matched_layout(command)\n    return \'\'.join(_switch(ch, matched_layout) for ch in command.script)\n\n']","['# -*- encoding: utf-8 -*-\n\ntarget_layout = \'\'\'qwertyuiop[]asdfghjkl;\'zxcvbnm,./QWERTYUIOP{}ASDFGHJKL:""ZXCVBNM<>?\'\'\'\n\nsource_layouts = [u\'\'\'йцукенгшщзхъфывапролджэячсмитьбю.ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,\'\'\',\n                  u\'\'\'ضصثقفغعهخحجچشسیبلاتنمکگظطزرذدپو./ًٌٍَُِّْ][}{ؤئيإأآة»«:؛كٓژٰ\u200cٔء><؟\'\'\']\n\n\ndef _get_matched_layout(command):\n    for source_layout in source_layouts:\n        if all([ch in source_layout or ch in \'-_\'\n                for ch in command.script.split(\' \')[0]]):\n            return source_layout\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and _get_matched_layout(command)\n\n\ndef _switch(ch, layout):\n    if ch in layout:\n        return target_layout[layout.index(ch)]\n    else:\n        return ch\n\n\ndef get_new_command(command, settings):\n    matched_layout = _get_matched_layout(command)\n    return \'\'.join(_switch(ch, matched_layout) for ch in command.script)\n\n']","[[<pydriller.domain.commit.Method object at 0x7f1983dca2b0>, <pydriller.domain.commit.Method object at 0x7f1983dca970>, <pydriller.domain.commit.Method object at 0x7f1983dcae80>, <pydriller.domain.commit.Method object at 0x7f1983dcafd0>]]",[[]]
thefuck,478fa4cd09059eea4c89adf16ac31dcd975cfa8f,#71 Not fail on os error,2015-04-21 08:30:48+02:00,nvbn,10,3,13,2,"['setup.py', 'no_command.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.18,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ['PATH'].split(':')\n            for exe in Path(path).iterdir()\n            if exe.is_file()]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n""]","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.19,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _safe(path, method):\n    try:\n        return getattr(path, method)()\n    except OSError:\n        return []\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ['PATH'].split(':')\n            for exe in _safe(Path(path), 'iterdir')\n            if not _safe(exe, 'is_dir')]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e1de50>, <pydriller.domain.commit.Method object at 0x7f1983e1d3d0>, <pydriller.domain.commit.Method object at 0x7f1983dca580>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e1d670>, <pydriller.domain.commit.Method object at 0x7f1983e1d640>]]"
thefuck,f2392349f732060b2530545f4da37d0bfa611bb2,#71 Handle `OSError` more gratefully,2015-04-21 08:38:52+02:00,nvbn,6,6,12,2,"['setup.py', 'no_command.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.19,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _safe(path, method):\n    try:\n        return getattr(path, method)()\n    except OSError:\n        return []\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ['PATH'].split(':')\n            for exe in _safe(Path(path), 'iterdir')\n            if not _safe(exe, 'is_dir')]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n""]","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.20,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _safe(fn, fallback):\n    try:\n        return fn()\n    except OSError:\n        return fallback\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ['PATH'].split(':')\n            for exe in _safe(Path(path).iterdir, [])\n            if not _safe(exe.is_dir, True)]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983ddffd0>, <pydriller.domain.commit.Method object at 0x7f1983ddfe80>, <pydriller.domain.commit.Method object at 0x7f1983cdd6d0>, <pydriller.domain.commit.Method object at 0x7f1983ce9400>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983de6040>, <pydriller.domain.commit.Method object at 0x7f1983ddffd0>, <pydriller.domain.commit.Method object at 0x7f1983de6c10>]]"
thefuck,82e2c894720e0316d9799eb56374ee06858a8b0c,Fix version number,2015-04-21 08:40:17+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=1.20,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=""1.20"",\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,798928b5adc67cbacecc166937b6282b079ef7c1,#71 Don't fail on non-exists dir in $PATH,2015-04-21 08:45:45+02:00,nvbn,2,2,4,2,"['setup.py', 'no_command.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=""1.20"",\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _safe(fn, fallback):\n    try:\n        return fn()\n    except OSError:\n        return fallback\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ['PATH'].split(':')\n            for exe in _safe(Path(path).iterdir, [])\n            if not _safe(exe.is_dir, True)]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n""]","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=""1.21"",\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _safe(fn, fallback):\n    try:\n        return fn()\n    except OSError:\n        return fallback\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ['PATH'].split(':')\n            for exe in _safe(lambda: Path(path).iterdir(), [])\n            if not _safe(exe.is_dir, True)]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e29bb0>, <pydriller.domain.commit.Method object at 0x7f1983e297c0>, <pydriller.domain.commit.Method object at 0x7f1983e29250>, <pydriller.domain.commit.Method object at 0x7f1983e298e0>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e23d00>]]"
thefuck,bd5f5045aa208e737ce61f77b279574cd5a8e31b,#71 Handle `iterdir` iterator fails,2015-04-21 08:57:35+02:00,nvbn,3,3,6,2,"['setup.py', 'no_command.py']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=""1.21"",\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _safe(fn, fallback):\n    try:\n        return fn()\n    except OSError:\n        return fallback\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ['PATH'].split(':')\n            for exe in _safe(lambda: Path(path).iterdir(), [])\n            if not _safe(exe.is_dir, True)]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n""]","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=""1.22"",\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _safe(fn, fallback):\n    try:\n        return fn()\n    except OSError:\n        return fallback\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ.get('PATH', '').split(':')\n            for exe in _safe(lambda: list(Path(path).iterdir()), [])\n            if not _safe(exe.is_dir, True)]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e86b80>, <pydriller.domain.commit.Method object at 0x7f1983e86cd0>, <pydriller.domain.commit.Method object at 0x7f1983e86bb0>, <pydriller.domain.commit.Method object at 0x7f1983e86a30>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e0c910>]]"
thefuck,3af5c80d293c579591b58f63a5b01574f76991c9,Add 'root privilege' pattern to sudo rule.,2015-04-21 12:57:35+04:30,Soheil Rashidi,2,1,3,1,['sudo.py'],"[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted',\n            'root privilege']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983e12520>, <pydriller.domain.commit.Method object at 0x7f1983e12f70>]]",[[]]
thefuck,de4b774134ed671451a6b44c5d8628a227bf25c4,Added a string which could be thrown by Fedora's new dnf package manager.,2015-04-21 19:43:10+08:00,Dugucloud,2,1,3,1,['sudo.py'],"[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted',\n            'This command has to be run under the root user.']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983e347c0>, <pydriller.domain.commit.Method object at 0x7f1983e34e50>]]",[[]]
thefuck,d5b4bddc4cf958e362ed0ee1b8a6c474fc78e242,#74 Don't fail when runned without args,2015-04-21 14:26:45+02:00,nvbn,5,0,5,2,"['test_main.py', 'main.py']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","[[<pydriller.domain.commit.Method object at 0x7f1983d0b6a0>, <pydriller.domain.commit.Method object at 0x7f1983d902e0>, <pydriller.domain.commit.Method object at 0x7f1983d9c430>, <pydriller.domain.commit.Method object at 0x7f1983d9cac0>, <pydriller.domain.commit.Method object at 0x7f1983ce9e80>, <pydriller.domain.commit.Method object at 0x7f1983ce9fd0>, <pydriller.domain.commit.Method object at 0x7f1983d3b940>, <pydriller.domain.commit.Method object at 0x7f1983d3b7f0>], [<pydriller.domain.commit.Method object at 0x7f1983dcf820>, <pydriller.domain.commit.Method object at 0x7f1983dcf190>, <pydriller.domain.commit.Method object at 0x7f1983dcffd0>, <pydriller.domain.commit.Method object at 0x7f1983dcf970>, <pydriller.domain.commit.Method object at 0x7f1983e17130>, <pydriller.domain.commit.Method object at 0x7f1983e178e0>, <pydriller.domain.commit.Method object at 0x7f1983e17b80>, <pydriller.domain.commit.Method object at 0x7f1983e17790>, <pydriller.domain.commit.Method object at 0x7f1983e174f0>, <pydriller.domain.commit.Method object at 0x7f1983e17280>, <pydriller.domain.commit.Method object at 0x7f1983e17250>, <pydriller.domain.commit.Method object at 0x7f1983e17cd0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983e2e3d0>], [<pydriller.domain.commit.Method object at 0x7f1983ddb820>]]"
thefuck,888756d519ba1915c37e2da3e137f35c2e5e3cea,#74 Don't fail when rule throws exception,2015-04-21 14:40:52+02:00,nvbn,25,16,41,2,"['test_main.py', 'main.py']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule(match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp'),\n                                  main.Rule('bash', 'bash'),\n                                  main.Rule('lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash'),\n                                      main.Rule('bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule():\n    rules = [main.Rule(lambda x, _: x.script == 'cd ..', None),\n             main.Rule(lambda *_: False, None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule(None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule_module.match, rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        if rule.match(command, settings):\n            return rule\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule('bash', match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash', 'bash'),\n                                  main.Rule('lisp', 'lisp', 'lisp'),\n                                  main.Rule('bash', 'bash', 'bash'),\n                                  main.Rule('lisp', 'lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash', 'bash'),\n                                      main.Rule('bash', 'bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None),\n             main.Rule('', lambda *_: False, None),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0]\\\n           == '[WARN] rule: Traceback (most recent call last):'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom traceback import format_exception\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            sys.stderr.write(u\'[WARN] {}: {}---------------------\\n\\n\'.format(\n                rule.name, \'\'.join(format_exception(*sys.exc_info()))))\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","[[<pydriller.domain.commit.Method object at 0x7f1983e1df70>, <pydriller.domain.commit.Method object at 0x7f1983e1dd00>, <pydriller.domain.commit.Method object at 0x7f1983e1d100>, <pydriller.domain.commit.Method object at 0x7f1983e1da60>, <pydriller.domain.commit.Method object at 0x7f1983e04550>, <pydriller.domain.commit.Method object at 0x7f1983e04ac0>, <pydriller.domain.commit.Method object at 0x7f1983e04fd0>, <pydriller.domain.commit.Method object at 0x7f1983e04430>], [<pydriller.domain.commit.Method object at 0x7f1983deb040>, <pydriller.domain.commit.Method object at 0x7f1983deb580>, <pydriller.domain.commit.Method object at 0x7f1983deb2b0>, <pydriller.domain.commit.Method object at 0x7f1983deb6d0>, <pydriller.domain.commit.Method object at 0x7f1983e3c250>, <pydriller.domain.commit.Method object at 0x7f1983e3cbb0>, <pydriller.domain.commit.Method object at 0x7f1983e3c4f0>, <pydriller.domain.commit.Method object at 0x7f1983e3ca60>, <pydriller.domain.commit.Method object at 0x7f1983e3c8e0>, <pydriller.domain.commit.Method object at 0x7f1983e3c670>, <pydriller.domain.commit.Method object at 0x7f1983e3c3a0>, <pydriller.domain.commit.Method object at 0x7f1983e3c910>]]","[[<pydriller.domain.commit.Method object at 0x7f1983dca940>, <pydriller.domain.commit.Method object at 0x7f1983e09eb0>, <pydriller.domain.commit.Method object at 0x7f1983e04ac0>, <pydriller.domain.commit.Method object at 0x7f1983dca190>, <pydriller.domain.commit.Method object at 0x7f1983e09160>], [<pydriller.domain.commit.Method object at 0x7f1983deb970>, <pydriller.domain.commit.Method object at 0x7f1983dacd30>]]"
thefuck,54d82f9528ae9cb0b7fa62522156ad832c976ed1,Bump version,2015-04-21 14:41:28+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=""1.22"",\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=""1.23"",\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,93b6a623e1c527b8e08093a986ca23fbb189d949,"adding rule to run ""sudo apt-get install""",2015-04-21 17:59:44+02:00,Lukas Vacek,28,0,28,1,['apt_get.py'],[None],"['import sys\n\ndef match(command, settings):\n    try:\n        import CommandNotFound\n        if \'not found\' in command.stderr:\n            try:\n                c = CommandNotFound.CommandNotFound()\n                pkgs = c.getPackages(command.script.split("" "")[0])\n                name,_ = pkgs[0]\n                return True\n            except IndexError:\n                # IndexError is thrown when no matching package is found\n                return False\n    except:\n        return False\n\ndef get_new_command(command, settings):\n    try:\n        import CommandNotFound\n        c = CommandNotFound.CommandNotFound()\n        if \'not found\' in command.stderr:\n            pkgs = c.getPackages(command.script.split("" "")[0])\n            name,_ = pkgs[0]\n            return ""sudo apt-get install %s"" % name\n    except:\n        sys.stderr.write(""Can\'t apt fuck\\n"")\n        return """"\n']",[[]],"[[<pydriller.domain.commit.Method object at 0x7f1983cd7970>, <pydriller.domain.commit.Method object at 0x7f1983cd72b0>]]"
thefuck,943613a194ee76be9a73eedcb82c0036bb37b3f0,add thing for when known hosts have changed,2015-04-21 17:05:52+01:00,Nic West,112,0,112,2,"['test_ssh_known_host.py', 'ssh_known_hosts.py']","[None, None]","['import os\nimport pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.ssh_known_hosts import match, get_new_command, remove_offending_keys\n\n\n@pytest.fixture\ndef ssh_error(tmpdir):\n    path = os.path.join(str(tmpdir), \'known_hosts\')\n\n    def reset(path):\n        with open(path, \'w\') as fh:\n            lines = [\n                \'123.234.567.890 asdjkasjdakjsd\\n\'\n                \'98.765.432.321 ejioweojwejrosj\\n\'\n                \'111.222.333.444 qwepoiwqepoiss\\n\'\n            ]\n            fh.writelines(lines)\n\n    def known_hosts(path):\n        with open(path, \'r\') as fh:\n            return fh.readlines()\n\n    reset(path)\n\n    errormsg = u""""""@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\nb6:cb:07:34:c0:a0:94:d3:0d:69:83:31:f4:c5:20:9b.\nPlease contact your system administrator.\nAdd correct host key in {0} to get rid of this message.\nOffending RSA key in {0}:2\nRSA host key for {1} has changed and you have requested strict checking.\nHost key verification failed."""""".format(path, \'98.765.432.321\')\n\n    return errormsg, path, reset, known_hosts\n\n\ndef test_match(ssh_error):\n    errormsg, _, _, _ = ssh_error    \n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert not match(Command(\'\', \'\', errormsg), None)\n    assert not match(Command(\'notssh\', \'\', errormsg), None)\n    assert not match(Command(\'ssh\', \'\', \'\'), None)\n\n\ndef test_remove_offending_keys(ssh_error):\n    errormsg, path, reset, known_hosts = ssh_error\n    command = Command(\'ssh user@host\', \'\', errormsg)\n    remove_offending_keys(command, None)\n    expected =[\'123.234.567.890 asdjkasjdakjsd\\n\', \'111.222.333.444 qwepoiwqepoiss\\n\']\n    assert known_hosts(path) == expected\n\n\ndef test_get_new_command(ssh_error, monkeypatch):\n    errormsg, _, _, _ = ssh_error\n\n    class Mock:\n        was_called = False\n\n        def __call__(self, *args, **kwargs):\n            self.was_called = True\n\n    method = Mock()\n    monkeypatch.setattr(\'thefuck.rules.ssh_known_hosts.remove_offending_keys\', method)\n    assert get_new_command(Command(\'ssh user@host\', \'\', errormsg), None) == \'ssh user@host\'\n    assert method.was_called\n', 'import re\npatterns = [\n    r\'WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!\',\n    r\'WARNING: POSSIBLE DNS SPOOFING DETECTED!\',\n    r""Warning: the \\S+ host key for \'([^\']+)\' differs from the key for the IP address \'([^\']+)\'"",\n]\noffending_pattern = re.compile(\n    r\'(?:Offending (?:key for IP|\\S+ key)|Matching host key) in ([^:]+):(\\d+)\',\n    re.MULTILINE)\n\ncommands = [\'ssh\', \'scp\']\n\n\ndef match(command, settings):\n    if not command.script:\n        return False\n    if not command.script.split()[0] in commands:\n        return False\n    if not any([re.findall(pattern, command.stderr) for pattern in patterns]):\n        return False\n    return True\n\n\ndef remove_offending_keys(command, settings):\n    offending = offending_pattern.findall(command.stderr)\n    print offending\n    for filepath, lineno in offending:\n        with open(filepath, \'r\') as fh:\n            lines = fh.readlines()\n            del lines[int(lineno) - 1]\n            print lines\n        with open(filepath, \'w\') as fh:\n            fh.writelines(lines)\n\n\ndef get_new_command(command, settings):\n    remove_offending_keys(command, settings)\n    return command.script\n']","[[], []]","[[<pydriller.domain.commit.Method object at 0x7f1983dc5eb0>, <pydriller.domain.commit.Method object at 0x7f1983d9ca90>, <pydriller.domain.commit.Method object at 0x7f1983ddf550>, <pydriller.domain.commit.Method object at 0x7f1983d90430>, <pydriller.domain.commit.Method object at 0x7f1983ddf820>, <pydriller.domain.commit.Method object at 0x7f1983dc5820>, <pydriller.domain.commit.Method object at 0x7f1983d906d0>], [<pydriller.domain.commit.Method object at 0x7f1983e23520>, <pydriller.domain.commit.Method object at 0x7f1983e23130>, <pydriller.domain.commit.Method object at 0x7f1983e23790>]]"
thefuck,2a7cbef3b5e364fa6da4850178b06ed85bb5304c,add tests for cd_parent,2015-04-21 23:41:49+05:30,SanketDG,12,0,12,1,['test_cd_parent.py'],[None],"[""from thefuck.main import Command\nfrom thefuck.rules.cd_parent import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('cd..', '', 'cd..: command not found'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(\n        Command('cd..', '', ''), None) == 'cd ..'\n""]",[[]],"[[<pydriller.domain.commit.Method object at 0x7f1983e12cd0>, <pydriller.domain.commit.Method object at 0x7f1983e12fa0>]]"
thefuck,4b8d4926aa2362340f4e8b57ee55e48846ccb6c3,Add Greek to switch lang,2015-04-21 22:00:05+02:00,Dionysis Zindros,2,1,3,1,['switch_lang.py'],"['# -*- encoding: utf-8 -*-\n\ntarget_layout = \'\'\'qwertyuiop[]asdfghjkl;\'zxcvbnm,./QWERTYUIOP{}ASDFGHJKL:""ZXCVBNM<>?\'\'\'\n\nsource_layouts = [u\'\'\'йцукенгшщзхъфывапролджэячсмитьбю.ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,\'\'\',\n                  u\'\'\'ضصثقفغعهخحجچشسیبلاتنمکگظطزرذدپو./ًٌٍَُِّْ][}{ؤئيإأآة»«:؛كٓژٰ\u200cٔء><؟\'\'\']\n\n\ndef _get_matched_layout(command):\n    for source_layout in source_layouts:\n        if all([ch in source_layout or ch in \'-_\'\n                for ch in command.script.split(\' \')[0]]):\n            return source_layout\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and _get_matched_layout(command)\n\n\ndef _switch(ch, layout):\n    if ch in layout:\n        return target_layout[layout.index(ch)]\n    else:\n        return ch\n\n\ndef get_new_command(command, settings):\n    matched_layout = _get_matched_layout(command)\n    return \'\'.join(_switch(ch, matched_layout) for ch in command.script)\n\n']","['# -*- encoding: utf-8 -*-\n\ntarget_layout = \'\'\'qwertyuiop[]asdfghjkl;\'zxcvbnm,./QWERTYUIOP{}ASDFGHJKL:""ZXCVBNM<>?\'\'\'\n\nsource_layouts = [u\'\'\'йцукенгшщзхъфывапролджэячсмитьбю.ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,\'\'\',\n                  u\'\'\'ضصثقفغعهخحجچشسیبلاتنمکگظطزرذدپو./ًٌٍَُِّْ][}{ؤئيإأآة»«:؛كٓژٰ\u200cٔء><؟\'\'\',\n                  u\'\'\';ςερτυθιοπ[]ασδφγηξκλ΄ζχψωβνμ,./:΅ΕΡΤΥΘΙΟΠ{}ΑΣΔΦΓΗΞΚΛ¨""ΖΧΨΩΒΝΜ<>?\'\'\']\n\n\ndef _get_matched_layout(command):\n    for source_layout in source_layouts:\n        if all([ch in source_layout or ch in \'-_\'\n                for ch in command.script.split(\' \')[0]]):\n            return source_layout\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and _get_matched_layout(command)\n\n\ndef _switch(ch, layout):\n    if ch in layout:\n        return target_layout[layout.index(ch)]\n    else:\n        return ch\n\n\ndef get_new_command(command, settings):\n    matched_layout = _get_matched_layout(command)\n    return \'\'.join(_switch(ch, matched_layout) for ch in command.script)\n\n']","[[<pydriller.domain.commit.Method object at 0x7f1983e86e20>, <pydriller.domain.commit.Method object at 0x7f1983e86d00>, <pydriller.domain.commit.Method object at 0x7f1983e86a60>, <pydriller.domain.commit.Method object at 0x7f1983e868e0>]]",[[]]
thefuck,4f10fe647d31e455c2a43c6ea326cf6f3c1d49ac,Add tests for greek langage,2015-04-21 22:09:48+02:00,Dionysis Zindros,7,0,7,1,['test_switch_lang.py'],"[""# -*- encoding: utf-8 -*-\n\nfrom mock import Mock\nfrom thefuck.rules import switch_lang\n\n\ndef test_match():\n    assert switch_lang.match(Mock(stderr='command not found: фзе-пуе',\n                                  script=u'фзе-пуе'), None)\n    assert not switch_lang.match(Mock(stderr='command not found: pat-get',\n                                      script=u'pat-get'), None)\n    assert not switch_lang.match(Mock(stderr='some info',\n                                      script=u'фзе-пуе'), None)\n\n\ndef test_get_new_command():\n    assert switch_lang.get_new_command(\n        Mock(script=u'фзе-пуе штыефдд мшь'), None) == 'apt-get install vim'\n""]","[""# -*- encoding: utf-8 -*-\n\nfrom mock import Mock\nfrom thefuck.rules import switch_lang\n\n\ndef test_match():\n    assert switch_lang.match(Mock(stderr='command not found: фзе-пуе',\n                                  script=u'фзе-пуе'), None)\n    assert switch_lang.match(Mock(stderr='command not found: λσ',\n                                  script=u'λσ'), None)\n\n    assert not switch_lang.match(Mock(stderr='command not found: pat-get',\n                                      script=u'pat-get'), None)\n    assert not switch_lang.match(Mock(stderr='command not found: ls',\n                                      script=u'ls'), None)\n    assert not switch_lang.match(Mock(stderr='some info',\n                                      script=u'фзе-пуе'), None)\n\n\ndef test_get_new_command():\n    assert switch_lang.get_new_command(\n        Mock(script=u'фзе-пуе штыефдд мшь'), None) == 'apt-get install vim'\n    assert switch_lang.get_new_command(\n        Mock(script=u'λσ -λα'), None) == 'ls -la'\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983e7ad00>, <pydriller.domain.commit.Method object at 0x7f1983e7afa0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983e817c0>, <pydriller.domain.commit.Method object at 0x7f1983e81d00>]]"
thefuck,d1416a6c2a54cfba46675b44a2b99a0cd05d7c83,"#82 Remove unned print, fix python 3 support",2015-04-21 22:10:53+02:00,nvbn,5,11,16,2,"['test_ssh_known_host.py', 'ssh_known_hosts.py']","['import os\nimport pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.ssh_known_hosts import match, get_new_command, remove_offending_keys\n\n\n@pytest.fixture\ndef ssh_error(tmpdir):\n    path = os.path.join(str(tmpdir), \'known_hosts\')\n\n    def reset(path):\n        with open(path, \'w\') as fh:\n            lines = [\n                \'123.234.567.890 asdjkasjdakjsd\\n\'\n                \'98.765.432.321 ejioweojwejrosj\\n\'\n                \'111.222.333.444 qwepoiwqepoiss\\n\'\n            ]\n            fh.writelines(lines)\n\n    def known_hosts(path):\n        with open(path, \'r\') as fh:\n            return fh.readlines()\n\n    reset(path)\n\n    errormsg = u""""""@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\nb6:cb:07:34:c0:a0:94:d3:0d:69:83:31:f4:c5:20:9b.\nPlease contact your system administrator.\nAdd correct host key in {0} to get rid of this message.\nOffending RSA key in {0}:2\nRSA host key for {1} has changed and you have requested strict checking.\nHost key verification failed."""""".format(path, \'98.765.432.321\')\n\n    return errormsg, path, reset, known_hosts\n\n\ndef test_match(ssh_error):\n    errormsg, _, _, _ = ssh_error    \n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert not match(Command(\'\', \'\', errormsg), None)\n    assert not match(Command(\'notssh\', \'\', errormsg), None)\n    assert not match(Command(\'ssh\', \'\', \'\'), None)\n\n\ndef test_remove_offending_keys(ssh_error):\n    errormsg, path, reset, known_hosts = ssh_error\n    command = Command(\'ssh user@host\', \'\', errormsg)\n    remove_offending_keys(command, None)\n    expected =[\'123.234.567.890 asdjkasjdakjsd\\n\', \'111.222.333.444 qwepoiwqepoiss\\n\']\n    assert known_hosts(path) == expected\n\n\ndef test_get_new_command(ssh_error, monkeypatch):\n    errormsg, _, _, _ = ssh_error\n\n    class Mock:\n        was_called = False\n\n        def __call__(self, *args, **kwargs):\n            self.was_called = True\n\n    method = Mock()\n    monkeypatch.setattr(\'thefuck.rules.ssh_known_hosts.remove_offending_keys\', method)\n    assert get_new_command(Command(\'ssh user@host\', \'\', errormsg), None) == \'ssh user@host\'\n    assert method.was_called\n', 'import re\npatterns = [\n    r\'WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!\',\n    r\'WARNING: POSSIBLE DNS SPOOFING DETECTED!\',\n    r""Warning: the \\S+ host key for \'([^\']+)\' differs from the key for the IP address \'([^\']+)\'"",\n]\noffending_pattern = re.compile(\n    r\'(?:Offending (?:key for IP|\\S+ key)|Matching host key) in ([^:]+):(\\d+)\',\n    re.MULTILINE)\n\ncommands = [\'ssh\', \'scp\']\n\n\ndef match(command, settings):\n    if not command.script:\n        return False\n    if not command.script.split()[0] in commands:\n        return False\n    if not any([re.findall(pattern, command.stderr) for pattern in patterns]):\n        return False\n    return True\n\n\ndef remove_offending_keys(command, settings):\n    offending = offending_pattern.findall(command.stderr)\n    print offending\n    for filepath, lineno in offending:\n        with open(filepath, \'r\') as fh:\n            lines = fh.readlines()\n            del lines[int(lineno) - 1]\n            print lines\n        with open(filepath, \'w\') as fh:\n            fh.writelines(lines)\n\n\ndef get_new_command(command, settings):\n    remove_offending_keys(command, settings)\n    return command.script\n']","['import os\nimport pytest\nfrom mock import Mock\nfrom thefuck.main import Command\nfrom thefuck.rules.ssh_known_hosts import match, get_new_command, remove_offending_keys\n\n\n@pytest.fixture\ndef ssh_error(tmpdir):\n    path = os.path.join(str(tmpdir), \'known_hosts\')\n\n    def reset(path):\n        with open(path, \'w\') as fh:\n            lines = [\n                \'123.234.567.890 asdjkasjdakjsd\\n\'\n                \'98.765.432.321 ejioweojwejrosj\\n\'\n                \'111.222.333.444 qwepoiwqepoiss\\n\'\n            ]\n            fh.writelines(lines)\n\n    def known_hosts(path):\n        with open(path, \'r\') as fh:\n            return fh.readlines()\n\n    reset(path)\n\n    errormsg = u""""""@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\nb6:cb:07:34:c0:a0:94:d3:0d:69:83:31:f4:c5:20:9b.\nPlease contact your system administrator.\nAdd correct host key in {0} to get rid of this message.\nOffending RSA key in {0}:2\nRSA host key for {1} has changed and you have requested strict checking.\nHost key verification failed."""""".format(path, \'98.765.432.321\')\n\n    return errormsg, path, reset, known_hosts\n\n\ndef test_match(ssh_error):\n    errormsg, _, _, _ = ssh_error\n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert not match(Command(\'\', \'\', errormsg), None)\n    assert not match(Command(\'notssh\', \'\', errormsg), None)\n    assert not match(Command(\'ssh\', \'\', \'\'), None)\n\n\ndef test_remove_offending_keys(ssh_error):\n    errormsg, path, reset, known_hosts = ssh_error\n    command = Command(\'ssh user@host\', \'\', errormsg)\n    remove_offending_keys(command, None)\n    expected = [\'123.234.567.890 asdjkasjdakjsd\\n\', \'111.222.333.444 qwepoiwqepoiss\\n\']\n    assert known_hosts(path) == expected\n\n\ndef test_get_new_command(ssh_error, monkeypatch):\n    errormsg, _, _, _ = ssh_error\n\n    method = Mock()\n    monkeypatch.setattr(\'thefuck.rules.ssh_known_hosts.remove_offending_keys\', method)\n    assert get_new_command(Command(\'ssh user@host\', \'\', errormsg), None) == \'ssh user@host\'\n    assert method.call_count\n', 'import re\n\npatterns = [\n    r\'WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!\',\n    r\'WARNING: POSSIBLE DNS SPOOFING DETECTED!\',\n    r""Warning: the \\S+ host key for \'([^\']+)\' differs from the key for the IP address \'([^\']+)\'"",\n]\noffending_pattern = re.compile(\n    r\'(?:Offending (?:key for IP|\\S+ key)|Matching host key) in ([^:]+):(\\d+)\',\n    re.MULTILINE)\n\ncommands = [\'ssh\', \'scp\']\n\n\ndef match(command, settings):\n    if not command.script:\n        return False\n    if not command.script.split()[0] in commands:\n        return False\n    if not any([re.findall(pattern, command.stderr) for pattern in patterns]):\n        return False\n    return True\n\n\ndef remove_offending_keys(command, settings):\n    offending = offending_pattern.findall(command.stderr)\n    for filepath, lineno in offending:\n        with open(filepath, \'r\') as fh:\n            lines = fh.readlines()\n            del lines[int(lineno) - 1]\n        with open(filepath, \'w\') as fh:\n            fh.writelines(lines)\n\n\ndef get_new_command(command, settings):\n    remove_offending_keys(command, settings)\n    return command.script\n']","[[<pydriller.domain.commit.Method object at 0x7f1983e6ea30>, <pydriller.domain.commit.Method object at 0x7f1983e6eb80>, <pydriller.domain.commit.Method object at 0x7f1983e6ea60>, <pydriller.domain.commit.Method object at 0x7f1983e6e8e0>, <pydriller.domain.commit.Method object at 0x7f1983e6e3a0>, <pydriller.domain.commit.Method object at 0x7f1983e6e3d0>, <pydriller.domain.commit.Method object at 0x7f1983e6e250>], [<pydriller.domain.commit.Method object at 0x7f1983e68bb0>, <pydriller.domain.commit.Method object at 0x7f1983e68cd0>, <pydriller.domain.commit.Method object at 0x7f1983e68d00>]]","[[<pydriller.domain.commit.Method object at 0x7f1983e743a0>, <pydriller.domain.commit.Method object at 0x7f1983e74cd0>, <pydriller.domain.commit.Method object at 0x7f1983e6e3d0>, <pydriller.domain.commit.Method object at 0x7f1983e74a30>], [<pydriller.domain.commit.Method object at 0x7f1983e68cd0>]]"
thefuck,20f8a4ad17e4fb014d38a390b98fed872cc4ebc8,Bump to 1.24,2015-04-21 22:30:15+02:00,nvbn,36,2,38,2,"['release.py', 'setup.py']","[None, 'from setuptools import setup, find_packages\n\n\nsetup(name=\'thefuck\',\n      version=""1.23"",\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\', \'tests\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['#!/usr/bin/env python\nfrom subprocess import call\nimport re\n\n\nversion = None\n\n\ndef get_new_setup_py_lines():\n    global version\n    with open(\'setup.py\', \'r\') as sf:\n        current_setup = sf.readlines()\n    for line in current_setup:\n        if line.startswith(\'VERSION = \'):\n            major, minor = re.findall(r""VERSION = \'(\\d+)\\.(\\d+)\'"", line)[0]\n            version = ""{}.{}"".format(major, int(minor) + 1)\n            yield ""VERSION = \'{}\'\\n"".format(version)\n        else:\n            yield line\n\n\nlines = list(get_new_setup_py_lines())\nwith open(\'setup.py\', \'w\') as sf:\n    sf.writelines(lines)\n\ncall(\'git commit -am ""Bump to {}""\'.format(version), shell=True)\ncall(\'git tag {}\'.format(version), shell=True)\ncall(\'git push\', shell=True)\ncall(\'git push --tags\', shell=True)\ncall(\'python setup.py sdist upload\', shell=True)\n', 'from setuptools import setup, find_packages\n\n\nVERSION = \'1.24\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","[[], []]","[[<pydriller.domain.commit.Method object at 0x7f1983e74910>], []]"
thefuck,d1b1465f4e80dc08fd210638c05248890c974b35,Bump to 1.26,2015-04-21 22:31:01+02:00,nvbn,2,1,3,2,"['release.py', 'setup.py']","['#!/usr/bin/env python\nfrom subprocess import call\nimport re\n\n\nversion = None\n\n\ndef get_new_setup_py_lines():\n    global version\n    with open(\'setup.py\', \'r\') as sf:\n        current_setup = sf.readlines()\n    for line in current_setup:\n        if line.startswith(\'VERSION = \'):\n            major, minor = re.findall(r""VERSION = \'(\\d+)\\.(\\d+)\'"", line)[0]\n            version = ""{}.{}"".format(major, int(minor) + 1)\n            yield ""VERSION = \'{}\'\\n"".format(version)\n        else:\n            yield line\n\n\nlines = list(get_new_setup_py_lines())\nwith open(\'setup.py\', \'w\') as sf:\n    sf.writelines(lines)\n\ncall(\'git commit -am ""Bump to {}""\'.format(version), shell=True)\ncall(\'git tag {}\'.format(version), shell=True)\ncall(\'git push\', shell=True)\ncall(\'git push --tags\', shell=True)\ncall(\'python setup.py sdist upload\', shell=True)\n', 'from setuptools import setup, find_packages\n\n\nVERSION = \'1.24\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['#!/usr/bin/env python\nfrom subprocess import call\nimport re\n\n\nversion = None\n\n\ndef get_new_setup_py_lines():\n    global version\n    with open(\'setup.py\', \'r\') as sf:\n        current_setup = sf.readlines()\n    for line in current_setup:\n        if line.startswith(\'VERSION = \'):\n            major, minor = re.findall(r""VERSION = \'(\\d+)\\.(\\d+)\'"", line)[0]\n            version = ""{}.{}"".format(major, int(minor) + 1)\n            yield ""VERSION = \'{}\'\\n"".format(version)\n        else:\n            yield line\n\n\nlines = list(get_new_setup_py_lines())\nwith open(\'setup.py\', \'w\') as sf:\n    sf.writelines(lines)\n\ncall(\'git pull\', shell=True)\ncall(\'git commit -am ""Bump to {}""\'.format(version), shell=True)\ncall(\'git tag {}\'.format(version), shell=True)\ncall(\'git push\', shell=True)\ncall(\'git push --tags\', shell=True)\ncall(\'python setup.py sdist upload\', shell=True)\n', 'from setuptools import setup, find_packages\n\n\nVERSION = \'1.26\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","[[<pydriller.domain.commit.Method object at 0x7f1983e0cb80>], []]","[[], []]"
thefuck,79fb7c987cb589fb6fa296121f9ea392feb4752d,Added sudo rule for Fedora yum's output.,2015-04-22 09:26:45+08:00,Dugucloud,2,1,3,1,['sudo.py'],"[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted',\n            'root privilege',\n            'This command has to be run under the root user.']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted',\n            'root privilege',\n            'This command has to be run under the root user.',\n            'You need to be root to perform this command.']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983d90be0>, <pydriller.domain.commit.Method object at 0x7f1983d90550>]]",[[]]
thefuck,126194ec2ee0045efb3fe8a2ccf85087352ad04f,"Put errors in stderr instead of ""echo ..."" in stdout",2015-04-22 05:29:44+02:00,nvbn,2,2,4,1,['main.py'],"['from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom traceback import format_exception\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            sys.stderr.write(u\'[WARN] {}: {}---------------------\\n\\n\'.format(\n                rule.name, \'\'.join(format_exception(*sys.exc_info()))))\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            print(""echo Can\'t fuck twice"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    print(\'echo No fuck given\')\n']","['from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom traceback import format_exception\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            sys.stderr.write(u\'[WARN] {}: {}---------------------\\n\\n\'.format(\n                rule.name, \'\'.join(format_exception(*sys.exc_info()))))\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            sys.stderr.write(""Can\'t fuck twice\\n"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    sys.stderr.write(\'No fuck given\\n\')\n']","[[<pydriller.domain.commit.Method object at 0x7f1983deb940>, <pydriller.domain.commit.Method object at 0x7f1983debac0>, <pydriller.domain.commit.Method object at 0x7f1983deba90>, <pydriller.domain.commit.Method object at 0x7f1983deb6a0>, <pydriller.domain.commit.Method object at 0x7f1983e628e0>, <pydriller.domain.commit.Method object at 0x7f1983e62910>, <pydriller.domain.commit.Method object at 0x7f1983e62790>, <pydriller.domain.commit.Method object at 0x7f1983e627c0>, <pydriller.domain.commit.Method object at 0x7f1983e62640>, <pydriller.domain.commit.Method object at 0x7f1983e62670>, <pydriller.domain.commit.Method object at 0x7f1983e624f0>, <pydriller.domain.commit.Method object at 0x7f1983e62520>]]",[[<pydriller.domain.commit.Method object at 0x7f1983e1d4f0>]]
thefuck,5d424dad88c71b926c6356df6e207cceb5a05c5a,Use colorama for colored output,2015-04-22 06:03:06+02:00,nvbn,76,18,94,6,"['README.md', 'setup.py', 'test_logs.py', 'test_main.py', 'logs.py', 'main.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', 'from setuptools import setup, find_packages\n\n\nVERSION = \'1.26\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', None, ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule('bash', match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash', 'bash'),\n                                  main.Rule('lisp', 'lisp', 'lisp'),\n                                  main.Rule('bash', 'bash', 'bash'),\n                                  main.Rule('lisp', 'lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash', 'bash'),\n                                      main.Rule('bash', 'bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None),\n             main.Rule('', lambda *_: False, None),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, None) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, None) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0]\\\n           == '[WARN] rule: Traceback (most recent call last):'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True))\n        assert capsys.readouterr() == ('', 'command [Enter/Ctrl+C]Aborted\\n')\n"", None, 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom traceback import format_exception\nfrom psutil import Process, TimeoutExpired\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            sys.stderr.write(u\'[WARN] {}: {}---------------------\\n\\n\'.format(\n                rule.name, \'\'.join(format_exception(*sys.exc_info()))))\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        sys.stderr.write(new_command + \'\\n\')\n        return True\n\n    sys.stderr.write(new_command + \' [Enter/Ctrl+C]\')\n    sys.stderr.flush()\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        sys.stderr.write(\'Aborted\\n\')\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            sys.stderr.write(""Can\'t fuck twice\\n"")\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    sys.stderr.write(\'No fuck given\\n\')\n']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', 'from setuptools import setup, find_packages\n\n\nVERSION = \'1.26\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from mock import Mock\nfrom thefuck import logs\n\n\ndef test_color():\n    assert logs.color('red', Mock(no_colors=False)) == 'red'\n    assert logs.color('red', Mock(no_colors=True)) == ''\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule('bash', match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash', 'bash'),\n                                  main.Rule('lisp', 'lisp', 'lisp'),\n                                  main.Rule('bash', 'bash', 'bash'),\n                                  main.Rule('lisp', 'lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash', 'bash'),\n                                      main.Rule('bash', 'bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None),\n             main.Rule('', lambda *_: False, None),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0]\\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", 'import sys\nfrom traceback import format_exception\nimport colorama\n\n\ndef color(color_, settings):\n    """"""Utility for ability to disabling colored output.""""""\n    if settings.no_colors:\n        return \'\'\n    else:\n        return color_\n\n\ndef rule_failed(rule, exc_info, settings):\n    sys.stderr.write(\n        u\'{warn}[WARN] Rule {name}:{reset}\\n{trace}\'\n        u\'{warn}----------------------------{reset}\\n\\n\'.format(\n            warn=color(colorama.Back.RED + colorama.Fore.WHITE\n                       + colorama.Style.BRIGHT, settings),\n            reset=color(colorama.Style.RESET_ALL, settings),\n            name=rule.name,\n            trace=\'\'.join(format_exception(*exc_info))))\n\n\ndef show_command(new_command, settings):\n    sys.stderr.write(\'{bold}{command}{reset}\\n\'.format(\n        command=new_command,\n        bold=color(colorama.Style.BRIGHT, settings),\n        reset=color(colorama.Style.RESET_ALL, settings)))\n\n\ndef confirm_command(new_command, settings):\n    sys.stderr.write(\n        \'{bold}{command}{reset} [{green}enter{reset}/{red}ctrl+c{reset}]\'.format(\n            command=new_command,\n            bold=color(colorama.Style.BRIGHT, settings),\n            green=color(colorama.Fore.GREEN, settings),\n            red=color(colorama.Fore.RED, settings),\n            reset=color(colorama.Style.RESET_ALL, settings)))\n    sys.stderr.flush()\n\n\ndef failed(msg, settings):\n    sys.stderr.write(\'{red}{msg}{reset}\\n\'.format(\n        msg=msg,\n        red=color(colorama.Fore.RED, settings),\n        reset=color(colorama.Style.RESET_ALL, settings)))\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom thefuck import logs\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    settings.__dict__.setdefault(\'no_colors\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n']","[[], [], [], [<pydriller.domain.commit.Method object at 0x7f1983e17520>, <pydriller.domain.commit.Method object at 0x7f1983de62b0>, <pydriller.domain.commit.Method object at 0x7f1983de66d0>, <pydriller.domain.commit.Method object at 0x7f1983de6580>, <pydriller.domain.commit.Method object at 0x7f1983db12e0>, <pydriller.domain.commit.Method object at 0x7f1983d95c10>, <pydriller.domain.commit.Method object at 0x7f1983d956a0>, <pydriller.domain.commit.Method object at 0x7f1983e1d520>], [], [<pydriller.domain.commit.Method object at 0x7f1983e0ce50>, <pydriller.domain.commit.Method object at 0x7f1983e0c640>, <pydriller.domain.commit.Method object at 0x7f1983e86280>, <pydriller.domain.commit.Method object at 0x7f1983e86f70>, <pydriller.domain.commit.Method object at 0x7f1983e81100>, <pydriller.domain.commit.Method object at 0x7f1983e81cd0>, <pydriller.domain.commit.Method object at 0x7f1983e81790>, <pydriller.domain.commit.Method object at 0x7f1983e81fa0>, <pydriller.domain.commit.Method object at 0x7f1983e81640>, <pydriller.domain.commit.Method object at 0x7f1983e81bb0>, <pydriller.domain.commit.Method object at 0x7f1983e81e50>, <pydriller.domain.commit.Method object at 0x7f1983e81520>]]","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983e57b80>], [<pydriller.domain.commit.Method object at 0x7f1983e62fa0>, <pydriller.domain.commit.Method object at 0x7f1983debc10>], [<pydriller.domain.commit.Method object at 0x7f1983e293a0>, <pydriller.domain.commit.Method object at 0x7f1983d62be0>, <pydriller.domain.commit.Method object at 0x7f1983d62c10>, <pydriller.domain.commit.Method object at 0x7f1983d62190>, <pydriller.domain.commit.Method object at 0x7f1983d622e0>], [<pydriller.domain.commit.Method object at 0x7f1983e0c520>, <pydriller.domain.commit.Method object at 0x7f1983e0c130>, <pydriller.domain.commit.Method object at 0x7f1983e0cfa0>, <pydriller.domain.commit.Method object at 0x7f1983e23250>]]"
thefuck,957209bdb681ba169dc7b0ce4088554b51f7b6fd,Add ability to bundle disabled by default rules,2015-04-22 15:59:44+02:00,nvbn,43,25,68,2,"['test_main.py', 'main.py']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None), Path('bash.py'))\n    assert main.is_rule_enabled(Mock(rules=['bash']), Path('bash.py'))\n    assert not main.is_rule_enabled(Mock(rules=['bash']), Path('lisp.py'))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) == main.Rule('bash', match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=None)) == [main.Rule('bash', 'bash', 'bash'),\n                                  main.Rule('lisp', 'lisp', 'lisp'),\n                                  main.Rule('bash', 'bash', 'bash'),\n                                  main.Rule('lisp', 'lisp', 'lisp')]\n        assert main.get_rules(\n            Path('~'),\n            Mock(rules=['bash'])) == [main.Rule('bash', 'bash', 'bash'),\n                                      main.Rule('bash', 'bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None),\n             main.Rule('', lambda *_: False, None),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0]\\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom thefuck import logs\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    settings.__dict__.setdefault(\'no_colors\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    return settings.rules is None or rule.name[:-3] in settings.rules\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command)\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    return [load_rule(rule) for rule in sorted(list(bundled)) + list(user)\n            if rule.name != \'__init__.py\' and is_rule_enabled(settings, rule)]\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None),\n                                main.Rule('bash', None, None, True))\n    assert not main.is_rule_enabled(Mock(rules=None),\n                                    main.Rule('bash', None, None, False))\n    assert main.is_rule_enabled(Mock(rules=['bash']),\n                                main.Rule('bash', None, None, True))\n    assert not main.is_rule_enabled(Mock(rules=['bash']),\n                                    main.Rule('lisp', None, None, True))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == main.Rule('bash', match, get_new_command, True)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=None))) == [main.Rule('bash', 'bash', 'bash', True),\n                                   main.Rule('lisp', 'lisp', 'lisp', True),\n                                   main.Rule('bash', 'bash', 'bash', True),\n                                   main.Rule('lisp', 'lisp', 'lisp', True)]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=['bash']))) == [main.Rule('bash', 'bash', 'bash', True),\n                                       main.Rule('bash', 'bash', 'bash', True)]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None, True),\n             main.Rule('', lambda *_: False, None, True),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None, True)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom thefuck import logs\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    settings.__dict__.setdefault(\'no_colors\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    if settings.rules is None and rule.enabled_by_default:\n        return True\n    elif settings.rules and rule.name in settings.rules:\n        return True\n    else:\n        return False\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if is_rule_enabled(settings, loaded_rule):\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n']","[[<pydriller.domain.commit.Method object at 0x7f1983e74e50>, <pydriller.domain.commit.Method object at 0x7f1983e747c0>, <pydriller.domain.commit.Method object at 0x7f1983e74130>, <pydriller.domain.commit.Method object at 0x7f1983e748e0>, <pydriller.domain.commit.Method object at 0x7f1983e6e640>, <pydriller.domain.commit.Method object at 0x7f1983e6ecd0>, <pydriller.domain.commit.Method object at 0x7f1983e6ebb0>, <pydriller.domain.commit.Method object at 0x7f1983e6ee50>], [<pydriller.domain.commit.Method object at 0x7f1983e4ba60>, <pydriller.domain.commit.Method object at 0x7f1983e4bbb0>, <pydriller.domain.commit.Method object at 0x7f1983e4b8e0>, <pydriller.domain.commit.Method object at 0x7f1983e4b910>, <pydriller.domain.commit.Method object at 0x7f1983ec5f70>, <pydriller.domain.commit.Method object at 0x7f1983ec5fa0>, <pydriller.domain.commit.Method object at 0x7f1983ec5e20>, <pydriller.domain.commit.Method object at 0x7f1983ec5e50>, <pydriller.domain.commit.Method object at 0x7f1983ec5cd0>, <pydriller.domain.commit.Method object at 0x7f1983ec5d00>, <pydriller.domain.commit.Method object at 0x7f1983ec5b80>, <pydriller.domain.commit.Method object at 0x7f1983ec5bb0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983e7aa60>, <pydriller.domain.commit.Method object at 0x7f1983e7a640>, <pydriller.domain.commit.Method object at 0x7f1983e7aa30>, <pydriller.domain.commit.Method object at 0x7f1983e81280>, <pydriller.domain.commit.Method object at 0x7f1983e81910>], [<pydriller.domain.commit.Method object at 0x7f1983e5c8e0>, <pydriller.domain.commit.Method object at 0x7f1983e5c100>, <pydriller.domain.commit.Method object at 0x7f1983e5c250>]]"
thefuck,fa4e4522b78ccf0811e8b6b671a20fab6099c1f2,#43 Add `rm_root` as disabled by default rule,2015-04-22 16:08:54+02:00,nvbn,10,2,12,3,"['README.md', 'main.py', 'rm_root.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom thefuck import logs\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    settings.__dict__.setdefault(\'no_colors\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    if settings.rules is None and rule.enabled_by_default:\n        return True\n    elif settings.rules and rule.name in settings.rules:\n        return True\n    else:\n        return False\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if is_rule_enabled(settings, loaded_rule):\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', ""def match(command, settings):\n    return ('/' in command.script.split()\n            and '--no-preserve-root' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return '{} --no-preserve-root'.format(command.script)\n""]","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom thefuck import logs\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    settings.__dict__.setdefault(\'no_colors\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    if settings.rules is None and rule.enabled_by_default:\n        return True\n    elif settings.rules and rule.name in settings.rules:\n        return True\n    else:\n        return False\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if is_rule_enabled(settings, loaded_rule):\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = list(get_rules(user_dir, settings))\n        sys.stderr.write(str([r.name for r in rules]) + \'\\n\')\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', ""enabled_by_default = False\n\n\ndef match(command, settings):\n    return ({'rm', '/'}.issubset(command.script.split())\n            and '--no-preserve-root' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return '{} --no-preserve-root'.format(command.script)\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e6e520>, <pydriller.domain.commit.Method object at 0x7f1983e6e670>, <pydriller.domain.commit.Method object at 0x7f1983e68a60>, <pydriller.domain.commit.Method object at 0x7f1983e743d0>, <pydriller.domain.commit.Method object at 0x7f1983e74790>, <pydriller.domain.commit.Method object at 0x7f1983e74520>, <pydriller.domain.commit.Method object at 0x7f1983e74100>, <pydriller.domain.commit.Method object at 0x7f1983e7a670>, <pydriller.domain.commit.Method object at 0x7f1983e7abb0>, <pydriller.domain.commit.Method object at 0x7f1983e7a910>, <pydriller.domain.commit.Method object at 0x7f1983e7a280>, <pydriller.domain.commit.Method object at 0x7f1983e7a520>], [<pydriller.domain.commit.Method object at 0x7f1983e86640>, <pydriller.domain.commit.Method object at 0x7f1983e86790>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e5c280>], [<pydriller.domain.commit.Method object at 0x7f1983e0c3a0>]]"
thefuck,7010b3a7f601608c4f3f943a374ba0ef098fc2da,#43 Add test for `rm_root`,2015-04-22 16:22:10+02:00,nvbn,20,3,23,3,"['test_rm_root.py', 'main.py', 'rm_root.py']","[None, 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom thefuck import logs\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    settings.__dict__.setdefault(\'no_colors\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    if settings.rules is None and rule.enabled_by_default:\n        return True\n    elif settings.rules and rule.name in settings.rules:\n        return True\n    else:\n        return False\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if is_rule_enabled(settings, loaded_rule):\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = list(get_rules(user_dir, settings))\n        sys.stderr.write(str([r.name for r in rules]) + \'\\n\')\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', ""enabled_by_default = False\n\n\ndef match(command, settings):\n    return ({'rm', '/'}.issubset(command.script.split())\n            and '--no-preserve-root' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return '{} --no-preserve-root'.format(command.script)\n""]","[""from mock import Mock\nfrom thefuck.rules.rm_root import match, get_new_command\n\n\ndef test_match():\n    assert match(Mock(script='rm -rf /',\n                      stderr='add --no-preserve-root'), None)\n    assert not match(Mock(script='ls',\n                          stderr='add --no-preserve-root'), None)\n    assert not match(Mock(script='rm --no-preserve-root /',\n                          stderr='add --no-preserve-root'), None)\n    assert not match(Mock(script='rm -rf /',\n                          stderr=''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Mock(script='rm -rf /'), None) \\\n        == 'rm -rf / --no-preserve-root'\n"", 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom thefuck import logs\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    settings.__dict__.setdefault(\'no_colors\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    if settings.rules is None and rule.enabled_by_default:\n        return True\n    elif settings.rules and rule.name in settings.rules:\n        return True\n    else:\n        return False\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if is_rule_enabled(settings, loaded_rule):\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', ""enabled_by_default = False\n\n\ndef match(command, settings):\n    return ({'rm', '/'}.issubset(command.script.split())\n            and '--no-preserve-root' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return u'{} --no-preserve-root'.format(command.script)\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e62e20>, <pydriller.domain.commit.Method object at 0x7f1983de66a0>, <pydriller.domain.commit.Method object at 0x7f1983de6940>, <pydriller.domain.commit.Method object at 0x7f1983de62e0>, <pydriller.domain.commit.Method object at 0x7f1983e57100>, <pydriller.domain.commit.Method object at 0x7f1983e57e20>, <pydriller.domain.commit.Method object at 0x7f1983e57fa0>, <pydriller.domain.commit.Method object at 0x7f1983e573d0>, <pydriller.domain.commit.Method object at 0x7f1983e57250>, <pydriller.domain.commit.Method object at 0x7f1983e57280>, <pydriller.domain.commit.Method object at 0x7f1983e57e50>, <pydriller.domain.commit.Method object at 0x7f1983e57a60>], [<pydriller.domain.commit.Method object at 0x7f1983ec0d00>, <pydriller.domain.commit.Method object at 0x7f1983ec0100>]]","[[<pydriller.domain.commit.Method object at 0x7f1983e813d0>, <pydriller.domain.commit.Method object at 0x7f1983e81670>], [<pydriller.domain.commit.Method object at 0x7f1983e173d0>], [<pydriller.domain.commit.Method object at 0x7f1983e3c640>]]"
thefuck,e7b78205f4c7cb060ebe5670f1d0986dbb0cf924,Add transparent sudo support for rules where it required,2015-04-22 16:45:38+02:00,nvbn,68,1,69,11,"['setup.py', 'test_utils.py', 'cp_omitting_directory.py', 'has_exists_script.py', 'lein_not_task.py', 'mkdir_p.py', 'no_command.py', 'python_command.py', 'rm_dir.py', 'rm_root.py', 'utils.py']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.26\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', None, ""import re\n\n\ndef match(command, settings):\n    return command.script.startswith('cp ') \\\n        and 'cp: omitting directory' in command.stderr.lower()\n\n\ndef get_new_command(command, settings):\n    return re.sub(r'^cp', 'cp -a', command.script)\n"", ""import os\n\n\ndef match(command, settings):\n    return os.path.exists(command.script.split()[0]) \\\n        and 'command not found' in command.stderr\n\n\ndef get_new_command(command, settings):\n    return u'./{}'.format(command.script)\n\n"", 'import re\n\n\ndef match(command, settings):\n    return (command.script.startswith(\'lein\')\n            and ""is not a task. See \'lein help\'"" in command.stderr\n            and \'Did you mean this?\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r""\'([^\']*)\' is not a task"",\n                            command.stderr)[0]\n    new_cmd = re.findall(r\'Did you mean this\\?\\n\\s*([^\\n]*)\',\n                         command.stderr)[0]\n    return command.script.replace(broken_cmd, new_cmd, 1)\n', ""import re\n\ndef match(command, settings):\n    return ('mkdir' in command.script\n            and 'No such file or directory' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return re.sub('^mkdir (.*)', 'mkdir -p \\\\1', command.script)\n"", ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\n\n\ndef _safe(fn, fallback):\n    try:\n        return fn()\n    except OSError:\n        return fallback\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ.get('PATH', '').split(':')\n            for exe in _safe(lambda: list(Path(path).iterdir()), [])\n            if not _safe(exe.is_dir, True)]\n\n\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n"", ""# add 'python' suffix to the command if\n#  1) The script does not have execute permission or\n#  2) is interpreted as shell script\n\ndef match(command, settings):\n    toks = command.script.split()\n    return (len(toks) > 0\n            and toks[0].endswith('.py')\n            and ('Permission denied' in command.stderr or\n                 'command not found' in command.stderr))\n\n\ndef get_new_command(command, settings):\n    return 'python ' + command.script\n"", ""import re\n\ndef match(command, settings):\n    return ('rm' in command.script\n            and 'is a directory' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return re.sub('^rm (.*)', 'rm -rf \\\\1', command.script)\n"", ""enabled_by_default = False\n\n\ndef match(command, settings):\n    return ({'rm', '/'}.issubset(command.script.split())\n            and '--no-preserve-root' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return u'{} --no-preserve-root'.format(command.script)\n"", 'from functools import wraps\nimport os\n\n\ndef which(program):\n    """"""Returns `program` path or `None`.""""""\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef wrap_settings(params):\n    """"""Adds default values to settings if it not presented.\n\n    Usage:\n\n        @wrap_settings({\'apt\': \'/usr/bin/apt\'})\n        def match(command, settings):\n            print(settings.apt)\n\n    """"""\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(command, settings):\n            for key, val in params.items():\n                if not hasattr(settings, key):\n                    setattr(settings, key, val)\n            return fn(command, settings)\n        return wrapper\n    return decorator\n']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.26\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n', ""from mock import Mock\nfrom thefuck.utils import sudo_support\nfrom thefuck.main import Command\n\n\ndef test_sudo_support():\n    fn = Mock(return_value=True, __name__='')\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n    fn.assert_called_once_with(Command('ls', 'out', 'err'), None)\n\n    fn.return_value = False\n    assert not sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n\n    fn.return_value = 'pwd'\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None) == 'sudo pwd'\n\n    assert sudo_support(fn)(Command('ls', 'out', 'err'), None) == 'pwd'\n"", ""import re\nfrom thefuck.utils import sudo_support\n\n\n@sudo_support\ndef match(command, settings):\n    return command.script.startswith('cp ') \\\n        and 'cp: omitting directory' in command.stderr.lower()\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return re.sub(r'^cp', 'cp -a', command.script)\n"", ""import os\nfrom thefuck.utils import sudo_support\n\n\n@sudo_support\ndef match(command, settings):\n    return os.path.exists(command.script.split()[0]) \\\n        and 'command not found' in command.stderr\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return u'./{}'.format(command.script)\n\n"", 'import re\nfrom thefuck.utils import sudo_support\n\n\n@sudo_support\ndef match(command, settings):\n    return (command.script.startswith(\'lein\')\n            and ""is not a task. See \'lein help\'"" in command.stderr\n            and \'Did you mean this?\' in command.stderr)\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r""\'([^\']*)\' is not a task"",\n                            command.stderr)[0]\n    new_cmd = re.findall(r\'Did you mean this\\?\\n\\s*([^\\n]*)\',\n                         command.stderr)[0]\n    return command.script.replace(broken_cmd, new_cmd, 1)\n', ""import re\nfrom thefuck.utils import sudo_support\n\n\n@sudo_support\ndef match(command, settings):\n    return ('mkdir' in command.script\n            and 'No such file or directory' in command.stderr)\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return re.sub('^mkdir (.*)', 'mkdir -p \\\\1', command.script)\n"", ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\nfrom thefuck.utils import sudo_support\n\n\ndef _safe(fn, fallback):\n    try:\n        return fn()\n    except OSError:\n        return fallback\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ.get('PATH', '').split(':')\n            for exe in _safe(lambda: list(Path(path).iterdir()), [])\n            if not _safe(exe.is_dir, True)]\n\n\n@sudo_support\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n"", ""from thefuck.utils import sudo_support\n# add 'python' suffix to the command if\n#  1) The script does not have execute permission or\n#  2) is interpreted as shell script\n\n\n@sudo_support\ndef match(command, settings):\n    toks = command.script.split()\n    return (len(toks) > 0\n            and toks[0].endswith('.py')\n            and ('Permission denied' in command.stderr or\n                 'command not found' in command.stderr))\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return 'python ' + command.script\n"", ""import re\nfrom thefuck.utils import sudo_support\n\n\n@sudo_support\ndef match(command, settings):\n    return ('rm' in command.script\n            and 'is a directory' in command.stderr)\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return re.sub('^rm (.*)', 'rm -rf \\\\1', command.script)\n"", ""from thefuck.utils import sudo_support\n\n\nenabled_by_default = False\n\n\n@sudo_support\ndef match(command, settings):\n    return ({'rm', '/'}.issubset(command.script.split())\n            and '--no-preserve-root' not in command.script\n            and '--no-preserve-root' in command.stderr)\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return u'{} --no-preserve-root'.format(command.script)\n"", 'from functools import wraps\nimport os\nimport six\nfrom thefuck.main import Command\n\n\ndef which(program):\n    """"""Returns `program` path or `None`.""""""\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef wrap_settings(params):\n    """"""Adds default values to settings if it not presented.\n\n    Usage:\n\n        @wrap_settings({\'apt\': \'/usr/bin/apt\'})\n        def match(command, settings):\n            print(settings.apt)\n\n    """"""\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(command, settings):\n            for key, val in params.items():\n                if not hasattr(settings, key):\n                    setattr(settings, key, val)\n            return fn(command, settings)\n        return wrapper\n    return decorator\n\n\ndef sudo_support(fn):\n    """"""Removes sudo before calling fn and adds it after.""""""\n    @wraps(fn)\n    def wrapper(command, settings):\n        if not command.script.startswith(\'sudo \'):\n            return fn(command, settings)\n\n        result = fn(Command(command.script[5:],\n                            command.stdout,\n                            command.stderr),\n                    settings)\n\n        if result and isinstance(result, six.string_types):\n            return u\'sudo {}\'.format(result)\n        else:\n            return result\n    return wrapper\n']","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983eae670>, <pydriller.domain.commit.Method object at 0x7f1983eae7c0>], [<pydriller.domain.commit.Method object at 0x7f1983e57cd0>, <pydriller.domain.commit.Method object at 0x7f1983e57790>], [<pydriller.domain.commit.Method object at 0x7f1983e1dbb0>, <pydriller.domain.commit.Method object at 0x7f1983e1da30>], [<pydriller.domain.commit.Method object at 0x7f1983e86130>, <pydriller.domain.commit.Method object at 0x7f1983e7ae50>], [<pydriller.domain.commit.Method object at 0x7f1983e74670>, <pydriller.domain.commit.Method object at 0x7f1983e74d00>, <pydriller.domain.commit.Method object at 0x7f1983e74bb0>, <pydriller.domain.commit.Method object at 0x7f1983e74a60>], [<pydriller.domain.commit.Method object at 0x7f1983ec5130>, <pydriller.domain.commit.Method object at 0x7f1983ec5520>], [<pydriller.domain.commit.Method object at 0x7f1983e4be50>, <pydriller.domain.commit.Method object at 0x7f1983e4bfa0>], [<pydriller.domain.commit.Method object at 0x7f1983e5c4f0>, <pydriller.domain.commit.Method object at 0x7f1983e5c790>], [<pydriller.domain.commit.Method object at 0x7f1983e86910>, <pydriller.domain.commit.Method object at 0x7f1983e86250>, <pydriller.domain.commit.Method object at 0x7f1983e86fa0>, <pydriller.domain.commit.Method object at 0x7f1983e86670>, <pydriller.domain.commit.Method object at 0x7f1983e7a3d0>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983eb9cd0>], [], [], [], [], [], [], [], [], [<pydriller.domain.commit.Method object at 0x7f1983e0c280>, <pydriller.domain.commit.Method object at 0x7f1983db9400>]]"
thefuck,69ddd82baeb5ead4366c4e6a1bee7f28b4aacca1,Bump to 1.27,2015-04-22 16:46:06+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nVERSION = \'1.26\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.27\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,c788dfbc1498e3d7efae7274e986662645dd49fa,"fix rm dir rule to make it case insensitive

In bash the output for the command `rm -f foo/` is:

    rm: cannot remove ‘foo/’: Is a directory

And not:

    rm: cannot remove ‘foo/’: is a directory",2015-04-22 19:04:52+02:00,Timo Furrer,2,1,3,2,"['test_rm_dir.py', 'rm_dir.py']","[""from thefuck.main import Command\nfrom thefuck.rules.rm_dir import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('rm foo', '', 'rm: foo: is a directory'), None)\n    assert not match(Command('rm foo', '', ''), None)\n    assert not match(Command('rm foo', '', 'foo bar baz'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('rm foo', '', ''), None) == 'rm -rf foo'\n"", ""import re\nfrom thefuck.utils import sudo_support\n\n\n@sudo_support\ndef match(command, settings):\n    return ('rm' in command.script\n            and 'is a directory' in command.stderr)\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return re.sub('^rm (.*)', 'rm -rf \\\\1', command.script)\n""]","[""from thefuck.main import Command\nfrom thefuck.rules.rm_dir import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('rm foo', '', 'rm: foo: is a directory'), None)\n    assert match(Command('rm foo', '', 'rm: foo: Is a directory'), None)\n    assert not match(Command('rm foo', '', ''), None)\n    assert not match(Command('rm foo', '', 'foo bar baz'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('rm foo', '', ''), None) == 'rm -rf foo'\n"", ""import re\nfrom thefuck.utils import sudo_support\n\n\n@sudo_support\ndef match(command, settings):\n    return ('rm' in command.script\n            and 'is a directory' in command.stderr.lower())\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return re.sub('^rm (.*)', 'rm -rf \\\\1', command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983eb9d00>, <pydriller.domain.commit.Method object at 0x7f1983eb9790>], [<pydriller.domain.commit.Method object at 0x7f1983eae640>, <pydriller.domain.commit.Method object at 0x7f1983eae100>]]","[[<pydriller.domain.commit.Method object at 0x7f1983eb98e0>], [<pydriller.domain.commit.Method object at 0x7f1983ec0670>]]"
thefuck,69a95164773772262816f5f260074f1070d7f43d,Add ability to change settings via environment variables,2015-04-22 20:18:53+02:00,nvbn,233,61,294,8,"['README.md', 'test_conf.py', 'test_main.py', 'test_utils.py', 'conf.py', 'logs.py', 'main.py', 'utils.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default all;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', None, ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main\n\n\ndef test_get_settings():\n    with patch('thefuck.main.load_source', return_value=Mock(rules=['bash'])):\n        assert main.get_settings(Path('/')).rules == ['bash']\n    with patch('thefuck.main.load_source', return_value=Mock(spec=[])):\n        assert main.get_settings(Path('/')).rules is None\n\n\ndef test_is_rule_enabled():\n    assert main.is_rule_enabled(Mock(rules=None),\n                                main.Rule('bash', None, None, True))\n    assert not main.is_rule_enabled(Mock(rules=None),\n                                    main.Rule('bash', None, None, False))\n    assert main.is_rule_enabled(Mock(rules=['bash']),\n                                main.Rule('bash', None, None, True))\n    assert not main.is_rule_enabled(Mock(rules=['bash']),\n                                    main.Rule('lisp', None, None, True))\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == main.Rule('bash', match, get_new_command, True)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=None))) == [main.Rule('bash', 'bash', 'bash', True),\n                                   main.Rule('lisp', 'lisp', 'lisp', True),\n                                   main.Rule('bash', 'bash', 'bash', True),\n                                   main.Rule('lisp', 'lisp', 'lisp', True)]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=['bash']))) == [main.Rule('bash', 'bash', 'bash', True),\n                                       main.Rule('bash', 'bash', 'bash', True)]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None, True),\n             main.Rule('', lambda *_: False, None, True),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None, True)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", ""from mock import Mock\nfrom thefuck.utils import sudo_support\nfrom thefuck.main import Command\n\n\ndef test_sudo_support():\n    fn = Mock(return_value=True, __name__='')\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n    fn.assert_called_once_with(Command('ls', 'out', 'err'), None)\n\n    fn.return_value = False\n    assert not sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n\n    fn.return_value = 'pwd'\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None) == 'sudo pwd'\n\n    assert sudo_support(fn)(Command('ls', 'out', 'err'), None) == 'pwd'\n"", None, 'import sys\nfrom traceback import format_exception\nimport colorama\n\n\ndef color(color_, settings):\n    """"""Utility for ability to disabling colored output.""""""\n    if settings.no_colors:\n        return \'\'\n    else:\n        return color_\n\n\ndef rule_failed(rule, exc_info, settings):\n    sys.stderr.write(\n        u\'{warn}[WARN] Rule {name}:{reset}\\n{trace}\'\n        u\'{warn}----------------------------{reset}\\n\\n\'.format(\n            warn=color(colorama.Back.RED + colorama.Fore.WHITE\n                       + colorama.Style.BRIGHT, settings),\n            reset=color(colorama.Style.RESET_ALL, settings),\n            name=rule.name,\n            trace=\'\'.join(format_exception(*exc_info))))\n\n\ndef show_command(new_command, settings):\n    sys.stderr.write(\'{bold}{command}{reset}\\n\'.format(\n        command=new_command,\n        bold=color(colorama.Style.BRIGHT, settings),\n        reset=color(colorama.Style.RESET_ALL, settings)))\n\n\ndef confirm_command(new_command, settings):\n    sys.stderr.write(\n        \'{bold}{command}{reset} [{green}enter{reset}/{red}ctrl+c{reset}]\'.format(\n            command=new_command,\n            bold=color(colorama.Style.BRIGHT, settings),\n            green=color(colorama.Fore.GREEN, settings),\n            red=color(colorama.Fore.RED, settings),\n            reset=color(colorama.Style.RESET_ALL, settings)))\n    sys.stderr.flush()\n\n\ndef failed(msg, settings):\n    sys.stderr.write(\'{red}{msg}{reset}\\n\'.format(\n        msg=msg,\n        red=color(colorama.Fore.RED, settings),\n        reset=color(colorama.Style.RESET_ALL, settings)))\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom thefuck import logs\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef get_settings(user_dir):\n    """"""Returns prepared settings module.""""""\n    settings = load_source(\'settings\',\n                           str(user_dir.joinpath(\'settings.py\')))\n    settings.__dict__.setdefault(\'rules\', None)\n    settings.__dict__.setdefault(\'wait_command\', 3)\n    settings.__dict__.setdefault(\'require_confirmation\', False)\n    settings.__dict__.setdefault(\'no_colors\', False)\n    return settings\n\n\ndef is_rule_enabled(settings, rule):\n    """"""Returns `True` when rule mentioned in `rules` or `rules`\n    isn\'t defined.\n\n    """"""\n    if settings.rules is None and rule.enabled_by_default:\n        return True\n    elif settings.rules and rule.name in settings.rules:\n        return True\n    else:\n        return False\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if is_rule_enabled(settings, loaded_rule):\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', 'from functools import wraps\nimport os\nimport six\nfrom thefuck.main import Command\n\n\ndef which(program):\n    """"""Returns `program` path or `None`.""""""\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef wrap_settings(params):\n    """"""Adds default values to settings if it not presented.\n\n    Usage:\n\n        @wrap_settings({\'apt\': \'/usr/bin/apt\'})\n        def match(command, settings):\n            print(settings.apt)\n\n    """"""\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(command, settings):\n            for key, val in params.items():\n                if not hasattr(settings, key):\n                    setattr(settings, key, val)\n            return fn(command, settings)\n        return wrapper\n    return decorator\n\n\ndef sudo_support(fn):\n    """"""Removes sudo before calling fn and adds it after.""""""\n    @wraps(fn)\n    def wrapper(command, settings):\n        if not command.script.startswith(\'sudo \'):\n            return fn(command, settings)\n\n        result = fn(Command(command.script[5:],\n                            command.stdout,\n                            command.stderr),\n                    settings)\n\n        if result and isinstance(result, six.string_types):\n            return u\'sudo {}\'.format(result)\n        else:\n            return result\n    return wrapper\n']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""from mock import patch, Mock\nfrom thefuck.main import Rule\nfrom thefuck import conf\n\n\ndef test_rules_list():\n    assert conf.RulesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert conf.RulesList(['bash', 'lisp']) == conf.RulesList(['bash', 'lisp'])\n    assert Rule('lisp', None, None, False) in conf.RulesList(['lisp'])\n    assert Rule('bash', None, None, False) not in conf.RulesList(['lisp'])\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT\n    assert Rule('test', None, None, False) not in conf.DEFAULT\n    assert Rule('test', None, None, False) in (conf.DEFAULT + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.Settings.defaults.items():\n            assert getattr(conf.Settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.Settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.Settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.Settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT:bash:lisp'}):\n        settings = conf.Settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['bash', 'lisp']\n\n\ndef test_update_settings():\n    settings = conf.BaseSettings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main, conf\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == main.Rule('bash', match, get_new_command, True)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.DEFAULT))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True),\n                   main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True)]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.RulesList(['bash'])))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('bash', 'bash', 'bash', True)]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None, True),\n             main.Rule('', lambda *_: False, None, True),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None, True)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", ""from mock import Mock\nfrom thefuck.utils import sudo_support, wrap_settings\nfrom thefuck.main import Command\nfrom thefuck.conf import BaseSettings\n\n\ndef test_wrap_settings():\n    fn = lambda _, settings: settings._conf\n    assert wrap_settings({'key': 'val'})(fn)(None, BaseSettings({})) \\\n           == {'key': 'val'}\n    assert wrap_settings({'key': 'new-val'})(fn)(\n        None, BaseSettings({'key': 'val'})) == {'key': 'new-val'}\n\n\ndef test_sudo_support():\n    fn = Mock(return_value=True, __name__='')\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n    fn.assert_called_once_with(Command('ls', 'out', 'err'), None)\n\n    fn.return_value = False\n    assert not sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n\n    fn.return_value = 'pwd'\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None) == 'sudo pwd'\n\n    assert sudo_support(fn)(Command('ls', 'out', 'err'), None) == 'pwd'\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs\n\n\nclass RulesList(object):\n    """"""Wrapper a top of list for string rules names.""""""\n\n    def __init__(self, rules):\n        self.rules = rules\n\n    def __contains__(self, item):\n        return item.name in self.rules\n\n    def __getattr__(self, item):\n        return getattr(self.rules, item)\n\n    def __eq__(self, other):\n        return self.rules == other\n\n\nclass _DefaultRules(RulesList):\n    def __add__(self, items):\n        return _DefaultRules(self.rules + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRules, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRules):\n            return self.rules == other.rules\n        else:\n            return False\n\n\nDEFAULT = _DefaultRules([])\n\n\nclass BaseSettings(object):\n    def __init__(self, conf):\n        self._conf = conf\n\n    def __getattr__(self, item):\n        return self._conf.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = copy(self._conf)\n        conf.update(kwargs)\n        return BaseSettings(conf)\n\n\nclass Settings(BaseSettings):\n    """"""Settings loaded from defaults/file/env.""""""\n    defaults = {\'rules\': DEFAULT,\n                \'wait_command\': 3,\n                \'require_confirmation\': False,\n                \'no_colors\': False}\n\n    env_to_attr = {\'THEFUCK_RULES\': \'rules\',\n                   \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n                   \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n                   \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n    def __init__(self, user_dir):\n        super(Settings, self).__init__(self._load_conf(user_dir))\n\n    def _load_conf(self, user_dir):\n        conf = copy(self.defaults)\n        try:\n            conf.update(self._load_from_file(user_dir))\n        except:\n            logs.exception(""Can\'t load settings from file"",\n                           sys.exc_info(),\n                           BaseSettings(conf))\n        try:\n            conf.update(self._load_from_env())\n        except:\n            logs.exception(""Can\'t load settings from env"",\n                           sys.exc_info(),\n                           BaseSettings(conf))\n        if not isinstance(conf[\'rules\'], RulesList):\n            conf[\'rules\'] = RulesList(conf[\'rules\'])\n        return conf\n\n    def _load_from_file(self, user_dir):\n        """"""Loads settings from file.""""""\n        settings = load_source(\'settings\',\n                               text_type(user_dir.joinpath(\'settings.py\')))\n        return {key: getattr(settings, key)\n                for key in self.defaults.keys()\n                if hasattr(settings, key)}\n\n    def _load_from_env(self):\n        """"""Loads settings from env.""""""\n        return {attr: self._val_from_env(env, attr)\n                for env, attr in self.env_to_attr.items()\n                if env in os.environ}\n\n    def _val_from_env(self, env, attr):\n        """"""Transforms env-strings to python.""""""\n        val = os.environ[env]\n        if attr == \'rules\':\n            val = self._rules_from_env(val)\n        elif attr == \'wait_command\':\n            val = int(val)\n        elif attr in (\'require_confirmation\', \'no_colors\'):\n            val = val.lower() == \'true\'\n        return val\n\n    def _rules_from_env(self, val):\n        """"""Transforms rules list from env-string to python.""""""\n        val = val.split(\':\')\n        if \'DEFAULT\' in val:\n            val = DEFAULT + [rule for rule in val if rule != \'DEFAULT\']\n        return val\n', 'import sys\nfrom traceback import format_exception\nimport colorama\n\n\ndef color(color_, settings):\n    """"""Utility for ability to disabling colored output.""""""\n    if settings.no_colors:\n        return \'\'\n    else:\n        return color_\n\n\ndef exception(title, exc_info, settings):\n    sys.stderr.write(\n        u\'{warn}[WARN] {title}:{reset}\\n{trace}\'\n        u\'{warn}----------------------------{reset}\\n\\n\'.format(\n            warn=color(colorama.Back.RED + colorama.Fore.WHITE\n                       + colorama.Style.BRIGHT, settings),\n            reset=color(colorama.Style.RESET_ALL, settings),\n            title=title,\n            trace=\'\'.join(format_exception(*exc_info))))\n\n\ndef rule_failed(rule, exc_info, settings):\n    exception(\'Rule {}\'.format(rule.name), exc_info, settings)\n\n\ndef show_command(new_command, settings):\n    sys.stderr.write(\'{bold}{command}{reset}\\n\'.format(\n        command=new_command,\n        bold=color(colorama.Style.BRIGHT, settings),\n        reset=color(colorama.Style.RESET_ALL, settings)))\n\n\ndef confirm_command(new_command, settings):\n    sys.stderr.write(\n        \'{bold}{command}{reset} [{green}enter{reset}/{red}ctrl+c{reset}]\'.format(\n            command=new_command,\n            bold=color(colorama.Style.BRIGHT, settings),\n            green=color(colorama.Fore.GREEN, settings),\n            red=color(colorama.Fore.RED, settings),\n            reset=color(colorama.Style.RESET_ALL, settings)))\n    sys.stderr.flush()\n\n\ndef failed(msg, settings):\n    sys.stderr.write(\'{red}{msg}{reset}\\n\'.format(\n        msg=msg,\n        red=color(colorama.Fore.RED, settings),\n        reset=color(colorama.Style.RESET_ALL, settings)))\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom . import logs, conf\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.Settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', 'from functools import wraps\nimport os\nimport six\nfrom thefuck.main import Command\n\n\ndef which(program):\n    """"""Returns `program` path or `None`.""""""\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef wrap_settings(params):\n    """"""Adds default values to settings if it not presented.\n\n    Usage:\n\n        @wrap_settings({\'apt\': \'/usr/bin/apt\'})\n        def match(command, settings):\n            print(settings.apt)\n\n    """"""\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(command, settings):\n            return fn(command, settings.update(**params))\n        return wrapper\n    return decorator\n\n\ndef sudo_support(fn):\n    """"""Removes sudo before calling fn and adds it after.""""""\n    @wraps(fn)\n    def wrapper(command, settings):\n        if not command.script.startswith(\'sudo \'):\n            return fn(command, settings)\n\n        result = fn(Command(command.script[5:],\n                            command.stdout,\n                            command.stderr),\n                    settings)\n\n        if result and isinstance(result, six.string_types):\n            return u\'sudo {}\'.format(result)\n        else:\n            return result\n    return wrapper\n']","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983e9cbb0>, <pydriller.domain.commit.Method object at 0x7f1983e9ca30>, <pydriller.domain.commit.Method object at 0x7f1983e9ccd0>, <pydriller.domain.commit.Method object at 0x7f1983e9cd00>, <pydriller.domain.commit.Method object at 0x7f1983ea27c0>, <pydriller.domain.commit.Method object at 0x7f1983ea2640>, <pydriller.domain.commit.Method object at 0x7f1983ea2670>, <pydriller.domain.commit.Method object at 0x7f1983ea24f0>], [<pydriller.domain.commit.Method object at 0x7f1983ea8cd0>], [], [<pydriller.domain.commit.Method object at 0x7f1983e573a0>, <pydriller.domain.commit.Method object at 0x7f1983e57640>, <pydriller.domain.commit.Method object at 0x7f1983e574f0>, <pydriller.domain.commit.Method object at 0x7f1983e57f70>, <pydriller.domain.commit.Method object at 0x7f1983e57520>], [<pydriller.domain.commit.Method object at 0x7f1983e74b80>, <pydriller.domain.commit.Method object at 0x7f1983e74e20>, <pydriller.domain.commit.Method object at 0x7f1983e744f0>, <pydriller.domain.commit.Method object at 0x7f1983e74280>, <pydriller.domain.commit.Method object at 0x7f1983e4b3d0>, <pydriller.domain.commit.Method object at 0x7f1983e4bf70>, <pydriller.domain.commit.Method object at 0x7f1983ec5280>, <pydriller.domain.commit.Method object at 0x7f1983ec5100>, <pydriller.domain.commit.Method object at 0x7f1983ec58e0>, <pydriller.domain.commit.Method object at 0x7f1983ec5250>, <pydriller.domain.commit.Method object at 0x7f1983ec54f0>, <pydriller.domain.commit.Method object at 0x7f1983ec53d0>], [<pydriller.domain.commit.Method object at 0x7f1983eae4f0>, <pydriller.domain.commit.Method object at 0x7f1983eaea30>, <pydriller.domain.commit.Method object at 0x7f1983eaef70>, <pydriller.domain.commit.Method object at 0x7f1983eaeb80>, <pydriller.domain.commit.Method object at 0x7f1983eaecd0>, <pydriller.domain.commit.Method object at 0x7f1983eaee50>, <pydriller.domain.commit.Method object at 0x7f1983e29280>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983e9cf70>, <pydriller.domain.commit.Method object at 0x7f1983ea2a30>, <pydriller.domain.commit.Method object at 0x7f1983ea2130>, <pydriller.domain.commit.Method object at 0x7f1983ea28e0>, <pydriller.domain.commit.Method object at 0x7f1983ea2280>, <pydriller.domain.commit.Method object at 0x7f1983ea2100>, <pydriller.domain.commit.Method object at 0x7f1983ea2910>, <pydriller.domain.commit.Method object at 0x7f1983ea2790>], [<pydriller.domain.commit.Method object at 0x7f1983e9ca30>, <pydriller.domain.commit.Method object at 0x7f1983e9ca60>, <pydriller.domain.commit.Method object at 0x7f1983e9cbb0>], [<pydriller.domain.commit.Method object at 0x7f1983ea23d0>], [<pydriller.domain.commit.Method object at 0x7f1983ec0280>, <pydriller.domain.commit.Method object at 0x7f1983eb2f70>, <pydriller.domain.commit.Method object at 0x7f1983e3ccd0>, <pydriller.domain.commit.Method object at 0x7f1983e3cd00>, <pydriller.domain.commit.Method object at 0x7f1983ec0f70>, <pydriller.domain.commit.Method object at 0x7f1983eb2910>, <pydriller.domain.commit.Method object at 0x7f1983ec03a0>, <pydriller.domain.commit.Method object at 0x7f1983eb2cd0>, <pydriller.domain.commit.Method object at 0x7f1983ec0cd0>, <pydriller.domain.commit.Method object at 0x7f1983ec0b80>, <pydriller.domain.commit.Method object at 0x7f1983ec04f0>, <pydriller.domain.commit.Method object at 0x7f1983ec0910>, <pydriller.domain.commit.Method object at 0x7f1983eb2790>], [<pydriller.domain.commit.Method object at 0x7f1983eb97c0>, <pydriller.domain.commit.Method object at 0x7f1983eb9250>], [<pydriller.domain.commit.Method object at 0x7f1983e744f0>, <pydriller.domain.commit.Method object at 0x7f1983e7a790>, <pydriller.domain.commit.Method object at 0x7f1983e12a30>, <pydriller.domain.commit.Method object at 0x7f1983e74e20>], [<pydriller.domain.commit.Method object at 0x7f1983e96280>, <pydriller.domain.commit.Method object at 0x7f1983e96130>, <pydriller.domain.commit.Method object at 0x7f1983e96bb0>]]"
thefuck,0553d57ec145db4a043b3f115a5e8b7865c3a4bc,Don't mess with inheritance for filling settings,2015-04-22 22:29:23+02:00,nvbn,83,79,162,4,"['test_conf.py', 'test_utils.py', 'conf.py', 'main.py']","[""from mock import patch, Mock\nfrom thefuck.main import Rule\nfrom thefuck import conf\n\n\ndef test_rules_list():\n    assert conf.RulesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert conf.RulesList(['bash', 'lisp']) == conf.RulesList(['bash', 'lisp'])\n    assert Rule('lisp', None, None, False) in conf.RulesList(['lisp'])\n    assert Rule('bash', None, None, False) not in conf.RulesList(['lisp'])\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT\n    assert Rule('test', None, None, False) not in conf.DEFAULT\n    assert Rule('test', None, None, False) in (conf.DEFAULT + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.Settings.defaults.items():\n            assert getattr(conf.Settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.Settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.Settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.Settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT:bash:lisp'}):\n        settings = conf.Settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['bash', 'lisp']\n\n\ndef test_update_settings():\n    settings = conf.BaseSettings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from mock import Mock\nfrom thefuck.utils import sudo_support, wrap_settings\nfrom thefuck.main import Command\nfrom thefuck.conf import BaseSettings\n\n\ndef test_wrap_settings():\n    fn = lambda _, settings: settings._conf\n    assert wrap_settings({'key': 'val'})(fn)(None, BaseSettings({})) \\\n           == {'key': 'val'}\n    assert wrap_settings({'key': 'new-val'})(fn)(\n        None, BaseSettings({'key': 'val'})) == {'key': 'new-val'}\n\n\ndef test_sudo_support():\n    fn = Mock(return_value=True, __name__='')\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n    fn.assert_called_once_with(Command('ls', 'out', 'err'), None)\n\n    fn.return_value = False\n    assert not sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n\n    fn.return_value = 'pwd'\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None) == 'sudo pwd'\n\n    assert sudo_support(fn)(Command('ls', 'out', 'err'), None) == 'pwd'\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs\n\n\nclass RulesList(object):\n    """"""Wrapper a top of list for string rules names.""""""\n\n    def __init__(self, rules):\n        self.rules = rules\n\n    def __contains__(self, item):\n        return item.name in self.rules\n\n    def __getattr__(self, item):\n        return getattr(self.rules, item)\n\n    def __eq__(self, other):\n        return self.rules == other\n\n\nclass _DefaultRules(RulesList):\n    def __add__(self, items):\n        return _DefaultRules(self.rules + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRules, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRules):\n            return self.rules == other.rules\n        else:\n            return False\n\n\nDEFAULT = _DefaultRules([])\n\n\nclass BaseSettings(object):\n    def __init__(self, conf):\n        self._conf = conf\n\n    def __getattr__(self, item):\n        return self._conf.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = copy(self._conf)\n        conf.update(kwargs)\n        return BaseSettings(conf)\n\n\nclass Settings(BaseSettings):\n    """"""Settings loaded from defaults/file/env.""""""\n    defaults = {\'rules\': DEFAULT,\n                \'wait_command\': 3,\n                \'require_confirmation\': False,\n                \'no_colors\': False}\n\n    env_to_attr = {\'THEFUCK_RULES\': \'rules\',\n                   \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n                   \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n                   \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n    def __init__(self, user_dir):\n        super(Settings, self).__init__(self._load_conf(user_dir))\n\n    def _load_conf(self, user_dir):\n        conf = copy(self.defaults)\n        try:\n            conf.update(self._load_from_file(user_dir))\n        except:\n            logs.exception(""Can\'t load settings from file"",\n                           sys.exc_info(),\n                           BaseSettings(conf))\n        try:\n            conf.update(self._load_from_env())\n        except:\n            logs.exception(""Can\'t load settings from env"",\n                           sys.exc_info(),\n                           BaseSettings(conf))\n        if not isinstance(conf[\'rules\'], RulesList):\n            conf[\'rules\'] = RulesList(conf[\'rules\'])\n        return conf\n\n    def _load_from_file(self, user_dir):\n        """"""Loads settings from file.""""""\n        settings = load_source(\'settings\',\n                               text_type(user_dir.joinpath(\'settings.py\')))\n        return {key: getattr(settings, key)\n                for key in self.defaults.keys()\n                if hasattr(settings, key)}\n\n    def _load_from_env(self):\n        """"""Loads settings from env.""""""\n        return {attr: self._val_from_env(env, attr)\n                for env, attr in self.env_to_attr.items()\n                if env in os.environ}\n\n    def _val_from_env(self, env, attr):\n        """"""Transforms env-strings to python.""""""\n        val = os.environ[env]\n        if attr == \'rules\':\n            val = self._rules_from_env(val)\n        elif attr == \'wait_command\':\n            val = int(val)\n        elif attr in (\'require_confirmation\', \'no_colors\'):\n            val = val.lower() == \'true\'\n        return val\n\n    def _rules_from_env(self, val):\n        """"""Transforms rules list from env-string to python.""""""\n        val = val.split(\':\')\n        if \'DEFAULT\' in val:\n            val = DEFAULT + [rule for rule in val if rule != \'DEFAULT\']\n        return val\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom . import logs, conf\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.Settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n']","[""from mock import patch, Mock\nfrom thefuck.main import Rule\nfrom thefuck import conf\n\n\ndef test_rules_list():\n    assert conf.RulesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert conf.RulesList(['bash', 'lisp']) == conf.RulesList(['bash', 'lisp'])\n    assert Rule('lisp', None, None, False) in conf.RulesList(['lisp'])\n    assert Rule('bash', None, None, False) not in conf.RulesList(['lisp'])\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT\n    assert Rule('test', None, None, False) not in conf.DEFAULT\n    assert Rule('test', None, None, False) in (conf.DEFAULT + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.DEFAULT_SETTINGS.items():\n            assert getattr(conf.get_settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT:bash:lisp'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['bash', 'lisp']\n\n\ndef test_update_settings():\n    settings = conf.Settings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from mock import Mock\nfrom thefuck.utils import sudo_support, wrap_settings\nfrom thefuck.main import Command\nfrom thefuck.conf import Settings\n\n\ndef test_wrap_settings():\n    fn = lambda _, settings: settings._conf\n    assert wrap_settings({'key': 'val'})(fn)(None, Settings({})) \\\n           == {'key': 'val'}\n    assert wrap_settings({'key': 'new-val'})(fn)(\n        None, Settings({'key': 'val'})) == {'key': 'new-val'}\n\n\ndef test_sudo_support():\n    fn = Mock(return_value=True, __name__='')\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n    fn.assert_called_once_with(Command('ls', 'out', 'err'), None)\n\n    fn.return_value = False\n    assert not sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n\n    fn.return_value = 'pwd'\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None) == 'sudo pwd'\n\n    assert sudo_support(fn)(Command('ls', 'out', 'err'), None) == 'pwd'\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs\n\n\nclass RulesList(object):\n    """"""Wrapper a top of list for string rules names.""""""\n\n    def __init__(self, rules):\n        self.rules = rules\n\n    def __contains__(self, item):\n        return item.name in self.rules\n\n    def __getattr__(self, item):\n        return getattr(self.rules, item)\n\n    def __eq__(self, other):\n        return self.rules == other\n\n\nclass _DefaultRules(RulesList):\n    def __add__(self, items):\n        return _DefaultRules(self.rules + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRules, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRules):\n            return self.rules == other.rules\n        else:\n            return False\n\n\nDEFAULT = _DefaultRules([])\n\n\nclass Settings(object):\n    def __init__(self, conf):\n        self._conf = conf\n\n    def __getattr__(self, item):\n        return self._conf.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = copy(self._conf)\n        conf.update(kwargs)\n        return Settings(conf)\n\n\nDEFAULT_SETTINGS = {\'rules\': DEFAULT,\n                    \'wait_command\': 3,\n                    \'require_confirmation\': False,\n                    \'no_colors\': False}\n\nENV_TO_ATTR = {\'THEFUCK_RULES\': \'rules\',\n               \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n               \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n               \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n\ndef _settings_from_file(user_dir):\n    """"""Loads settings from file.""""""\n    settings = load_source(\'settings\',\n                           text_type(user_dir.joinpath(\'settings.py\')))\n    return {key: getattr(settings, key)\n            for key in DEFAULT_SETTINGS.keys()\n            if hasattr(settings, key)}\n\n\ndef _rules_from_env(val):\n    """"""Transforms rules list from env-string to python.""""""\n    val = val.split(\':\')\n    if \'DEFAULT\' in val:\n        val = DEFAULT + [rule for rule in val if rule != \'DEFAULT\']\n    return val\n\n\ndef _val_from_env(env, attr):\n    """"""Transforms env-strings to python.""""""\n    val = os.environ[env]\n    if attr == \'rules\':\n        val = _rules_from_env(val)\n    elif attr == \'wait_command\':\n        val = int(val)\n    elif attr in (\'require_confirmation\', \'no_colors\'):\n        val = val.lower() == \'true\'\n    return val\n\n\ndef _settings_from_env():\n    """"""Loads settings from env.""""""\n    return {attr: _val_from_env(env, attr)\n            for env, attr in ENV_TO_ATTR.items()\n            if env in os.environ}\n\n\ndef get_settings(user_dir):\n    """"""Returns settings filled with values from `settings.py` and env.""""""\n    conf = copy(DEFAULT_SETTINGS)\n    try:\n        conf.update(_settings_from_file(user_dir))\n    except Exception:\n        logs.exception(""Can\'t load settings from file"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    try:\n        conf.update(_settings_from_env())\n    except Exception:\n        logs.exception(""Can\'t load settings from env"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    if not isinstance(conf[\'rules\'], RulesList):\n        conf[\'rules\'] = RulesList(conf[\'rules\'])\n\n    return Settings(conf)\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom . import logs, conf\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n']","[[<pydriller.domain.commit.Method object at 0x7f1983e5c670>, <pydriller.domain.commit.Method object at 0x7f1983e5ca30>, <pydriller.domain.commit.Method object at 0x7f1983e5c520>, <pydriller.domain.commit.Method object at 0x7f1983e5cf70>, <pydriller.domain.commit.Method object at 0x7f1983e96910>, <pydriller.domain.commit.Method object at 0x7f1983e96520>, <pydriller.domain.commit.Method object at 0x7f1983e96100>, <pydriller.domain.commit.Method object at 0x7f1983e96cd0>], [<pydriller.domain.commit.Method object at 0x7f1983e4b100>, <pydriller.domain.commit.Method object at 0x7f1983e4b4f0>], [<pydriller.domain.commit.Method object at 0x7f1983eb9130>, <pydriller.domain.commit.Method object at 0x7f1983eb9100>, <pydriller.domain.commit.Method object at 0x7f1983eb9520>, <pydriller.domain.commit.Method object at 0x7f1983eb9910>, <pydriller.domain.commit.Method object at 0x7f1983eb2bb0>, <pydriller.domain.commit.Method object at 0x7f1983eb2670>, <pydriller.domain.commit.Method object at 0x7f1983eb2520>, <pydriller.domain.commit.Method object at 0x7f1983eb2250>, <pydriller.domain.commit.Method object at 0x7f1983ec0640>, <pydriller.domain.commit.Method object at 0x7f1983ec0130>, <pydriller.domain.commit.Method object at 0x7f1983ec07c0>, <pydriller.domain.commit.Method object at 0x7f1983ec0790>, <pydriller.domain.commit.Method object at 0x7f1983ec0a60>, <pydriller.domain.commit.Method object at 0x7f1983ec08e0>, <pydriller.domain.commit.Method object at 0x7f1983ec03d0>, <pydriller.domain.commit.Method object at 0x7f1983ec0a30>], [<pydriller.domain.commit.Method object at 0x7f1983f053a0>, <pydriller.domain.commit.Method object at 0x7f1983f054f0>, <pydriller.domain.commit.Method object at 0x7f1983f053d0>, <pydriller.domain.commit.Method object at 0x7f1983f05250>, <pydriller.domain.commit.Method object at 0x7f1983efebb0>, <pydriller.domain.commit.Method object at 0x7f1983efea30>, <pydriller.domain.commit.Method object at 0x7f1983efea60>, <pydriller.domain.commit.Method object at 0x7f1983efe8e0>, <pydriller.domain.commit.Method object at 0x7f1983efe910>, <pydriller.domain.commit.Method object at 0x7f1983efe790>]]","[[<pydriller.domain.commit.Method object at 0x7f1983eaed00>, <pydriller.domain.commit.Method object at 0x7f1983e294f0>, <pydriller.domain.commit.Method object at 0x7f1983eae3d0>, <pydriller.domain.commit.Method object at 0x7f1983eae790>, <pydriller.domain.commit.Method object at 0x7f1983e29a60>, <pydriller.domain.commit.Method object at 0x7f1983eae250>], [<pydriller.domain.commit.Method object at 0x7f1983e7af70>], [<pydriller.domain.commit.Method object at 0x7f1983ec07c0>, <pydriller.domain.commit.Method object at 0x7f1983ec0790>, <pydriller.domain.commit.Method object at 0x7f1983ec0a30>, <pydriller.domain.commit.Method object at 0x7f1983e62a30>, <pydriller.domain.commit.Method object at 0x7f1983e62280>, <pydriller.domain.commit.Method object at 0x7f1983e3ca30>, <pydriller.domain.commit.Method object at 0x7f1983ec08e0>, <pydriller.domain.commit.Method object at 0x7f1983e62a60>, <pydriller.domain.commit.Method object at 0x7f1983debbe0>, <pydriller.domain.commit.Method object at 0x7f1983ec0a60>, <pydriller.domain.commit.Method object at 0x7f1983ec03d0>, <pydriller.domain.commit.Method object at 0x7f1983e62cd0>], [<pydriller.domain.commit.Method object at 0x7f1983f05bb0>]]"
thefuck,20b6c4c1600e5d696c0f004242b6d21ce90ea4f0,Inherit `RulesNamesList` from `list`,2015-04-22 22:36:18+02:00,nvbn,16,25,41,3,"['test_conf.py', 'test_main.py', 'conf.py']","[""from mock import patch, Mock\nfrom thefuck.main import Rule\nfrom thefuck import conf\n\n\ndef test_rules_list():\n    assert conf.RulesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert conf.RulesList(['bash', 'lisp']) == conf.RulesList(['bash', 'lisp'])\n    assert Rule('lisp', None, None, False) in conf.RulesList(['lisp'])\n    assert Rule('bash', None, None, False) not in conf.RulesList(['lisp'])\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT\n    assert Rule('test', None, None, False) not in conf.DEFAULT\n    assert Rule('test', None, None, False) in (conf.DEFAULT + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.DEFAULT_SETTINGS.items():\n            assert getattr(conf.get_settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT:bash:lisp'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['bash', 'lisp']\n\n\ndef test_update_settings():\n    settings = conf.Settings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main, conf\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == main.Rule('bash', match, get_new_command, True)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.DEFAULT))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True),\n                   main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True)]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.RulesList(['bash'])))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('bash', 'bash', 'bash', True)]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None, True),\n             main.Rule('', lambda *_: False, None, True),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None, True)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs\n\n\nclass RulesList(object):\n    """"""Wrapper a top of list for string rules names.""""""\n\n    def __init__(self, rules):\n        self.rules = rules\n\n    def __contains__(self, item):\n        return item.name in self.rules\n\n    def __getattr__(self, item):\n        return getattr(self.rules, item)\n\n    def __eq__(self, other):\n        return self.rules == other\n\n\nclass _DefaultRules(RulesList):\n    def __add__(self, items):\n        return _DefaultRules(self.rules + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRules, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRules):\n            return self.rules == other.rules\n        else:\n            return False\n\n\nDEFAULT = _DefaultRules([])\n\n\nclass Settings(object):\n    def __init__(self, conf):\n        self._conf = conf\n\n    def __getattr__(self, item):\n        return self._conf.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = copy(self._conf)\n        conf.update(kwargs)\n        return Settings(conf)\n\n\nDEFAULT_SETTINGS = {\'rules\': DEFAULT,\n                    \'wait_command\': 3,\n                    \'require_confirmation\': False,\n                    \'no_colors\': False}\n\nENV_TO_ATTR = {\'THEFUCK_RULES\': \'rules\',\n               \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n               \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n               \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n\ndef _settings_from_file(user_dir):\n    """"""Loads settings from file.""""""\n    settings = load_source(\'settings\',\n                           text_type(user_dir.joinpath(\'settings.py\')))\n    return {key: getattr(settings, key)\n            for key in DEFAULT_SETTINGS.keys()\n            if hasattr(settings, key)}\n\n\ndef _rules_from_env(val):\n    """"""Transforms rules list from env-string to python.""""""\n    val = val.split(\':\')\n    if \'DEFAULT\' in val:\n        val = DEFAULT + [rule for rule in val if rule != \'DEFAULT\']\n    return val\n\n\ndef _val_from_env(env, attr):\n    """"""Transforms env-strings to python.""""""\n    val = os.environ[env]\n    if attr == \'rules\':\n        val = _rules_from_env(val)\n    elif attr == \'wait_command\':\n        val = int(val)\n    elif attr in (\'require_confirmation\', \'no_colors\'):\n        val = val.lower() == \'true\'\n    return val\n\n\ndef _settings_from_env():\n    """"""Loads settings from env.""""""\n    return {attr: _val_from_env(env, attr)\n            for env, attr in ENV_TO_ATTR.items()\n            if env in os.environ}\n\n\ndef get_settings(user_dir):\n    """"""Returns settings filled with values from `settings.py` and env.""""""\n    conf = copy(DEFAULT_SETTINGS)\n    try:\n        conf.update(_settings_from_file(user_dir))\n    except Exception:\n        logs.exception(""Can\'t load settings from file"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    try:\n        conf.update(_settings_from_env())\n    except Exception:\n        logs.exception(""Can\'t load settings from env"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    if not isinstance(conf[\'rules\'], RulesList):\n        conf[\'rules\'] = RulesList(conf[\'rules\'])\n\n    return Settings(conf)\n']","[""from mock import patch, Mock\nfrom thefuck.main import Rule\nfrom thefuck import conf\n\n\ndef test_rules_names_list():\n    assert conf.RulesNamesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert conf.RulesNamesList(['bash', 'lisp']) == conf.RulesNamesList(['bash', 'lisp'])\n    assert Rule('lisp', None, None, False) in conf.RulesNamesList(['lisp'])\n    assert Rule('bash', None, None, False) not in conf.RulesNamesList(['lisp'])\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT\n    assert Rule('test', None, None, False) not in conf.DEFAULT\n    assert Rule('test', None, None, False) in (conf.DEFAULT + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.DEFAULT_SETTINGS.items():\n            assert getattr(conf.get_settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT:bash:lisp'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['bash', 'lisp']\n\n\ndef test_update_settings():\n    settings = conf.Settings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main, conf\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == main.Rule('bash', match, get_new_command, True)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.DEFAULT))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True),\n                   main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True)]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.RulesNamesList(['bash'])))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('bash', 'bash', 'bash', True)]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None, True),\n             main.Rule('', lambda *_: False, None, True),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None, True)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs\n\n\nclass RulesNamesList(list):\n    """"""Wrapper a top of list for string rules names.""""""\n\n    def __contains__(self, item):\n        return super(RulesNamesList, self).__contains__(item.name)\n\n\nclass _DefaultRulesNames(RulesNamesList):\n    def __add__(self, items):\n        return _DefaultRulesNames(list(self) + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRulesNames, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRulesNames):\n            return super(_DefaultRulesNames, self).__eq__(other)\n        else:\n            return False\n\n\nDEFAULT = _DefaultRulesNames([])\n\n\nclass Settings(object):\n    def __init__(self, conf):\n        self._conf = conf\n\n    def __getattr__(self, item):\n        return self._conf.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = copy(self._conf)\n        conf.update(kwargs)\n        return Settings(conf)\n\n\nDEFAULT_SETTINGS = {\'rules\': DEFAULT,\n                    \'wait_command\': 3,\n                    \'require_confirmation\': False,\n                    \'no_colors\': False}\n\nENV_TO_ATTR = {\'THEFUCK_RULES\': \'rules\',\n               \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n               \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n               \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n\ndef _settings_from_file(user_dir):\n    """"""Loads settings from file.""""""\n    settings = load_source(\'settings\',\n                           text_type(user_dir.joinpath(\'settings.py\')))\n    return {key: getattr(settings, key)\n            for key in DEFAULT_SETTINGS.keys()\n            if hasattr(settings, key)}\n\n\ndef _rules_from_env(val):\n    """"""Transforms rules list from env-string to python.""""""\n    val = val.split(\':\')\n    if \'DEFAULT\' in val:\n        val = DEFAULT + [rule for rule in val if rule != \'DEFAULT\']\n    return val\n\n\ndef _val_from_env(env, attr):\n    """"""Transforms env-strings to python.""""""\n    val = os.environ[env]\n    if attr == \'rules\':\n        val = _rules_from_env(val)\n    elif attr == \'wait_command\':\n        val = int(val)\n    elif attr in (\'require_confirmation\', \'no_colors\'):\n        val = val.lower() == \'true\'\n    return val\n\n\ndef _settings_from_env():\n    """"""Loads settings from env.""""""\n    return {attr: _val_from_env(env, attr)\n            for env, attr in ENV_TO_ATTR.items()\n            if env in os.environ}\n\n\ndef get_settings(user_dir):\n    """"""Returns settings filled with values from `settings.py` and env.""""""\n    conf = copy(DEFAULT_SETTINGS)\n    try:\n        conf.update(_settings_from_file(user_dir))\n    except Exception:\n        logs.exception(""Can\'t load settings from file"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    try:\n        conf.update(_settings_from_env())\n    except Exception:\n        logs.exception(""Can\'t load settings from env"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    if not isinstance(conf[\'rules\'], RulesNamesList):\n        conf[\'rules\'] = RulesNamesList(conf[\'rules\'])\n\n    return Settings(conf)\n']","[[<pydriller.domain.commit.Method object at 0x7f1983ef3cd0>, <pydriller.domain.commit.Method object at 0x7f1983ef3e20>, <pydriller.domain.commit.Method object at 0x7f1983ef3d00>, <pydriller.domain.commit.Method object at 0x7f1983ef3b80>, <pydriller.domain.commit.Method object at 0x7f1983ef3670>, <pydriller.domain.commit.Method object at 0x7f1983ef34f0>, <pydriller.domain.commit.Method object at 0x7f1983ef3520>, <pydriller.domain.commit.Method object at 0x7f1983ef33a0>], [<pydriller.domain.commit.Method object at 0x7f1983efee20>, <pydriller.domain.commit.Method object at 0x7f1983efef70>, <pydriller.domain.commit.Method object at 0x7f1983efee50>, <pydriller.domain.commit.Method object at 0x7f1983efecd0>, <pydriller.domain.commit.Method object at 0x7f1983f09520>, <pydriller.domain.commit.Method object at 0x7f1983f094f0>], [<pydriller.domain.commit.Method object at 0x7f1983eb93a0>, <pydriller.domain.commit.Method object at 0x7f1983eb9670>, <pydriller.domain.commit.Method object at 0x7f1983eb9f70>, <pydriller.domain.commit.Method object at 0x7f1983eb93d0>, <pydriller.domain.commit.Method object at 0x7f1983de6fd0>, <pydriller.domain.commit.Method object at 0x7f1983de6430>, <pydriller.domain.commit.Method object at 0x7f1983de6550>, <pydriller.domain.commit.Method object at 0x7f1983ddfac0>, <pydriller.domain.commit.Method object at 0x7f1983e86520>, <pydriller.domain.commit.Method object at 0x7f1983e12130>, <pydriller.domain.commit.Method object at 0x7f1983e12640>, <pydriller.domain.commit.Method object at 0x7f1983e12100>, <pydriller.domain.commit.Method object at 0x7f1983e12d00>, <pydriller.domain.commit.Method object at 0x7f1983e123a0>, <pydriller.domain.commit.Method object at 0x7f1983e123d0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983ef3cd0>, <pydriller.domain.commit.Method object at 0x7f1983e90790>], [<pydriller.domain.commit.Method object at 0x7f1983ef87c0>], [<pydriller.domain.commit.Method object at 0x7f1983f09250>, <pydriller.domain.commit.Method object at 0x7f1983eb9f70>, <pydriller.domain.commit.Method object at 0x7f1983f05fa0>, <pydriller.domain.commit.Method object at 0x7f1983f09b80>, <pydriller.domain.commit.Method object at 0x7f1983f09100>, <pydriller.domain.commit.Method object at 0x7f1983eb93a0>]]"
thefuck,54c408a6b572e84f75b1f11133d6769a6aef3dab,Rename `DEFAULT` to `DEFAULT_RULES`,2015-04-22 22:37:11+02:00,nvbn,14,14,28,4,"['README.md', 'test_conf.py', 'test_main.py', 'conf.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""from mock import patch, Mock\nfrom thefuck.main import Rule\nfrom thefuck import conf\n\n\ndef test_rules_names_list():\n    assert conf.RulesNamesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert conf.RulesNamesList(['bash', 'lisp']) == conf.RulesNamesList(['bash', 'lisp'])\n    assert Rule('lisp', None, None, False) in conf.RulesNamesList(['lisp'])\n    assert Rule('bash', None, None, False) not in conf.RulesNamesList(['lisp'])\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT\n    assert Rule('test', None, None, False) not in conf.DEFAULT\n    assert Rule('test', None, None, False) in (conf.DEFAULT + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.DEFAULT_SETTINGS.items():\n            assert getattr(conf.get_settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT:bash:lisp'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT + ['bash', 'lisp']\n\n\ndef test_update_settings():\n    settings = conf.Settings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main, conf\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == main.Rule('bash', match, get_new_command, True)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.DEFAULT))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True),\n                   main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True)]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.RulesNamesList(['bash'])))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('bash', 'bash', 'bash', True)]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None, True),\n             main.Rule('', lambda *_: False, None, True),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None, True)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs\n\n\nclass RulesNamesList(list):\n    """"""Wrapper a top of list for string rules names.""""""\n\n    def __contains__(self, item):\n        return super(RulesNamesList, self).__contains__(item.name)\n\n\nclass _DefaultRulesNames(RulesNamesList):\n    def __add__(self, items):\n        return _DefaultRulesNames(list(self) + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRulesNames, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRulesNames):\n            return super(_DefaultRulesNames, self).__eq__(other)\n        else:\n            return False\n\n\nDEFAULT = _DefaultRulesNames([])\n\n\nclass Settings(object):\n    def __init__(self, conf):\n        self._conf = conf\n\n    def __getattr__(self, item):\n        return self._conf.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = copy(self._conf)\n        conf.update(kwargs)\n        return Settings(conf)\n\n\nDEFAULT_SETTINGS = {\'rules\': DEFAULT,\n                    \'wait_command\': 3,\n                    \'require_confirmation\': False,\n                    \'no_colors\': False}\n\nENV_TO_ATTR = {\'THEFUCK_RULES\': \'rules\',\n               \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n               \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n               \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n\ndef _settings_from_file(user_dir):\n    """"""Loads settings from file.""""""\n    settings = load_source(\'settings\',\n                           text_type(user_dir.joinpath(\'settings.py\')))\n    return {key: getattr(settings, key)\n            for key in DEFAULT_SETTINGS.keys()\n            if hasattr(settings, key)}\n\n\ndef _rules_from_env(val):\n    """"""Transforms rules list from env-string to python.""""""\n    val = val.split(\':\')\n    if \'DEFAULT\' in val:\n        val = DEFAULT + [rule for rule in val if rule != \'DEFAULT\']\n    return val\n\n\ndef _val_from_env(env, attr):\n    """"""Transforms env-strings to python.""""""\n    val = os.environ[env]\n    if attr == \'rules\':\n        val = _rules_from_env(val)\n    elif attr == \'wait_command\':\n        val = int(val)\n    elif attr in (\'require_confirmation\', \'no_colors\'):\n        val = val.lower() == \'true\'\n    return val\n\n\ndef _settings_from_env():\n    """"""Loads settings from env.""""""\n    return {attr: _val_from_env(env, attr)\n            for env, attr in ENV_TO_ATTR.items()\n            if env in os.environ}\n\n\ndef get_settings(user_dir):\n    """"""Returns settings filled with values from `settings.py` and env.""""""\n    conf = copy(DEFAULT_SETTINGS)\n    try:\n        conf.update(_settings_from_file(user_dir))\n    except Exception:\n        logs.exception(""Can\'t load settings from file"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    try:\n        conf.update(_settings_from_env())\n    except Exception:\n        logs.exception(""Can\'t load settings from env"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    if not isinstance(conf[\'rules\'], RulesNamesList):\n        conf[\'rules\'] = RulesNamesList(conf[\'rules\'])\n\n    return Settings(conf)\n']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'$(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck { \n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) { \n        $fuck.substring(5) \n    } \n    else { iex ""$fuck"" } \n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is `~/.thefuck/settings.py`.\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`; \n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""from mock import patch, Mock\nfrom thefuck.main import Rule\nfrom thefuck import conf\n\n\ndef test_rules_names_list():\n    assert conf.RulesNamesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert conf.RulesNamesList(['bash', 'lisp']) == conf.RulesNamesList(['bash', 'lisp'])\n    assert Rule('lisp', None, None, False) in conf.RulesNamesList(['lisp'])\n    assert Rule('bash', None, None, False) not in conf.RulesNamesList(['lisp'])\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT_RULES\n    assert Rule('test', None, None, False) not in conf.DEFAULT_RULES\n    assert Rule('test', None, None, False) in (conf.DEFAULT_RULES + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.DEFAULT_SETTINGS.items():\n            assert getattr(conf.get_settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT_RULES + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT_RULES:bash:lisp'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['bash', 'lisp']\n\n\ndef test_update_settings():\n    settings = conf.Settings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main, conf\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == main.Rule('bash', match, get_new_command, True)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.DEFAULT_RULES))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True),\n                   main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True)]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.RulesNamesList(['bash'])))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('bash', 'bash', 'bash', True)]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None, True),\n             main.Rule('', lambda *_: False, None, True),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None, True)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs\n\n\nclass RulesNamesList(list):\n    """"""Wrapper a top of list for string rules names.""""""\n\n    def __contains__(self, item):\n        return super(RulesNamesList, self).__contains__(item.name)\n\n\nclass _DefaultRulesNames(RulesNamesList):\n    def __add__(self, items):\n        return _DefaultRulesNames(list(self) + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRulesNames, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRulesNames):\n            return super(_DefaultRulesNames, self).__eq__(other)\n        else:\n            return False\n\n\nDEFAULT_RULES = _DefaultRulesNames([])\n\n\nclass Settings(object):\n    def __init__(self, conf):\n        self._conf = conf\n\n    def __getattr__(self, item):\n        return self._conf.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = copy(self._conf)\n        conf.update(kwargs)\n        return Settings(conf)\n\n\nDEFAULT_SETTINGS = {\'rules\': DEFAULT_RULES,\n                    \'wait_command\': 3,\n                    \'require_confirmation\': False,\n                    \'no_colors\': False}\n\nENV_TO_ATTR = {\'THEFUCK_RULES\': \'rules\',\n               \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n               \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n               \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n\ndef _settings_from_file(user_dir):\n    """"""Loads settings from file.""""""\n    settings = load_source(\'settings\',\n                           text_type(user_dir.joinpath(\'settings.py\')))\n    return {key: getattr(settings, key)\n            for key in DEFAULT_SETTINGS.keys()\n            if hasattr(settings, key)}\n\n\ndef _rules_from_env(val):\n    """"""Transforms rules list from env-string to python.""""""\n    val = val.split(\':\')\n    if \'DEFAULT_RULES\' in val:\n        val = DEFAULT_RULES + [rule for rule in val if rule != \'DEFAULT_RULES\']\n    return val\n\n\ndef _val_from_env(env, attr):\n    """"""Transforms env-strings to python.""""""\n    val = os.environ[env]\n    if attr == \'rules\':\n        val = _rules_from_env(val)\n    elif attr == \'wait_command\':\n        val = int(val)\n    elif attr in (\'require_confirmation\', \'no_colors\'):\n        val = val.lower() == \'true\'\n    return val\n\n\ndef _settings_from_env():\n    """"""Loads settings from env.""""""\n    return {attr: _val_from_env(env, attr)\n            for env, attr in ENV_TO_ATTR.items()\n            if env in os.environ}\n\n\ndef get_settings(user_dir):\n    """"""Returns settings filled with values from `settings.py` and env.""""""\n    conf = copy(DEFAULT_SETTINGS)\n    try:\n        conf.update(_settings_from_file(user_dir))\n    except Exception:\n        logs.exception(""Can\'t load settings from file"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    try:\n        conf.update(_settings_from_env())\n    except Exception:\n        logs.exception(""Can\'t load settings from env"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    if not isinstance(conf[\'rules\'], RulesNamesList):\n        conf[\'rules\'] = RulesNamesList(conf[\'rules\'])\n\n    return Settings(conf)\n']","[[], [<pydriller.domain.commit.Method object at 0x7f1983e51a30>, <pydriller.domain.commit.Method object at 0x7f1983ef33d0>, <pydriller.domain.commit.Method object at 0x7f1983ef3e50>, <pydriller.domain.commit.Method object at 0x7f1983ef3250>, <pydriller.domain.commit.Method object at 0x7f1983ef3790>, <pydriller.domain.commit.Method object at 0x7f1983ef37c0>, <pydriller.domain.commit.Method object at 0x7f1983ef3640>, <pydriller.domain.commit.Method object at 0x7f1983ef3100>], [<pydriller.domain.commit.Method object at 0x7f1983ee7b80>, <pydriller.domain.commit.Method object at 0x7f1983ee7cd0>, <pydriller.domain.commit.Method object at 0x7f1983ee7bb0>, <pydriller.domain.commit.Method object at 0x7f1983ee7a30>, <pydriller.domain.commit.Method object at 0x7f1983ee7670>, <pydriller.domain.commit.Method object at 0x7f1983ee74f0>], [<pydriller.domain.commit.Method object at 0x7f1983edc790>, <pydriller.domain.commit.Method object at 0x7f1983edc8e0>, <pydriller.domain.commit.Method object at 0x7f1983edc7c0>, <pydriller.domain.commit.Method object at 0x7f1983edc640>, <pydriller.domain.commit.Method object at 0x7f1983ee7130>, <pydriller.domain.commit.Method object at 0x7f1983ee7250>, <pydriller.domain.commit.Method object at 0x7f1983ee7280>, <pydriller.domain.commit.Method object at 0x7f1983ee73d0>, <pydriller.domain.commit.Method object at 0x7f1983ee7e50>, <pydriller.domain.commit.Method object at 0x7f1983ee7fa0>, <pydriller.domain.commit.Method object at 0x7f1983ee7e20>, <pydriller.domain.commit.Method object at 0x7f1983ee7f70>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983ec5640>, <pydriller.domain.commit.Method object at 0x7f1983eaea60>, <pydriller.domain.commit.Method object at 0x7f1983e96d00>], [<pydriller.domain.commit.Method object at 0x7f1983eedbb0>], [<pydriller.domain.commit.Method object at 0x7f1983ee0100>]]"
thefuck,d3d1f992328dfaf245ef268090cf54bb492815b7,Move special data types to `types`,2015-04-22 23:04:22+02:00,nvbn,89,88,177,17,"['test_cd_parent.py', 'test_git_not_command.py', 'test_git_push.py', 'test_has_exists_script.py', 'test_mkdir_p.py', 'test_python_command.py', 'test_rm_dir.py', 'test_ssh_known_host.py', 'test_sudo.py', 'test_conf.py', 'test_main.py', 'test_types.py', 'test_utils.py', 'conf.py', 'main.py', 'types.py', 'utils.py']","[""from thefuck.main import Command\nfrom thefuck.rules.cd_parent import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('cd..', '', 'cd..: command not found'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(\n        Command('cd..', '', ''), None) == 'cd ..'\n"", 'import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.git_not_command import match, get_new_command\n\n\n@pytest.fixture\ndef git_not_command():\n    return """"""git: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\nbranch\n""""""\n\n\n@pytest.fixture\ndef git_not_command_one_of_this():\n    return """"""git: \'st\' is not a git command. See \'git --help\'.\n\nDid you mean one of these?\nstatus\nreset\nstage\nstash\nstats\n""""""\n\n\n@pytest.fixture\ndef git_command():\n    return ""* master""\n\n\ndef test_match(git_not_command, git_command, git_not_command_one_of_this):\n    assert match(Command(\'git brnch\', \'\', git_not_command), None)\n    assert match(Command(\'git st\', \'\', git_not_command_one_of_this), None)\n    assert not match(Command(\'ls brnch\', \'\', git_not_command), None)\n    assert not match(Command(\'git branch\', \'\', git_command), None)\n\n\ndef test_get_new_command(git_not_command, git_not_command_one_of_this):\n    assert get_new_command(Command(\'git brnch\', \'\', git_not_command), None)\\\n        == \'git branch\'\n    assert get_new_command(\n        Command(\'git st\', \'\', git_not_command_one_of_this), None) == \'git status\'\n', 'import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.git_push import match, get_new_command\n\n\n@pytest.fixture\ndef stderr():\n    return \'\'\'fatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\'\'\'\n\n\ndef test_match(stderr):\n    assert match(Command(\'git push master\', \'\', stderr), None)\n    assert not match(Command(\'git push master\', \'\', \'\'), None)\n    assert not match(Command(\'ls\', \'\', stderr), None)\n\n\ndef test_get_new_command(stderr):\n    assert get_new_command(Command(\'\', \'\', stderr), None)\\\n        == ""git push --set-upstream origin master""\n', ""from mock import Mock, patch\nfrom thefuck.rules. has_exists_script import match, get_new_command\n\n\ndef test_match():\n    with patch('os.path.exists', return_value=True):\n        assert match(Mock(script='main', stderr='main: command not found'),\n                     None)\n        assert match(Mock(script='main --help',\n                          stderr='main: command not found'),\n                     None)\n        assert not match(Mock(script='main', stderr=''), None)\n\n    with patch('os.path.exists', return_value=False):\n        assert not match(Mock(script='main', stderr='main: command not found'),\n                         None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Mock(script='main --help'), None) == './main --help'\n"", ""from thefuck.main import Command\nfrom thefuck.rules.mkdir_p import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('mkdir foo/bar/baz', '', 'mkdir: foo/bar: No such file or directory'), None)\n    assert not match(Command('mkdir foo/bar/baz', '', ''), None)\n    assert not match(Command('mkdir foo/bar/baz', '', 'foo bar baz'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('mkdir foo/bar/baz', '', ''), None) == 'mkdir -p foo/bar/baz'\n"", ""from thefuck.main import Command\nfrom thefuck.rules.python_command import match, get_new_command\n\ndef test_match():\n    assert match(Command('temp.py', '', 'Permission denied'), None)\n    assert not match(Command('', '', ''), None)\n\ndef test_get_new_command():\n    assert get_new_command(Command('./test_sudo.py', '', ''), None) == 'python ./test_sudo.py'\n"", ""from thefuck.main import Command\nfrom thefuck.rules.rm_dir import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('rm foo', '', 'rm: foo: is a directory'), None)\n    assert not match(Command('rm foo', '', ''), None)\n    assert not match(Command('rm foo', '', 'foo bar baz'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('rm foo', '', ''), None) == 'rm -rf foo'\n"", 'import os\nimport pytest\nfrom mock import Mock\nfrom thefuck.main import Command\nfrom thefuck.rules.ssh_known_hosts import match, get_new_command, remove_offending_keys\n\n\n@pytest.fixture\ndef ssh_error(tmpdir):\n    path = os.path.join(str(tmpdir), \'known_hosts\')\n\n    def reset(path):\n        with open(path, \'w\') as fh:\n            lines = [\n                \'123.234.567.890 asdjkasjdakjsd\\n\'\n                \'98.765.432.321 ejioweojwejrosj\\n\'\n                \'111.222.333.444 qwepoiwqepoiss\\n\'\n            ]\n            fh.writelines(lines)\n\n    def known_hosts(path):\n        with open(path, \'r\') as fh:\n            return fh.readlines()\n\n    reset(path)\n\n    errormsg = u""""""@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\nb6:cb:07:34:c0:a0:94:d3:0d:69:83:31:f4:c5:20:9b.\nPlease contact your system administrator.\nAdd correct host key in {0} to get rid of this message.\nOffending RSA key in {0}:2\nRSA host key for {1} has changed and you have requested strict checking.\nHost key verification failed."""""".format(path, \'98.765.432.321\')\n\n    return errormsg, path, reset, known_hosts\n\n\ndef test_match(ssh_error):\n    errormsg, _, _, _ = ssh_error\n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert not match(Command(\'\', \'\', errormsg), None)\n    assert not match(Command(\'notssh\', \'\', errormsg), None)\n    assert not match(Command(\'ssh\', \'\', \'\'), None)\n\n\ndef test_remove_offending_keys(ssh_error):\n    errormsg, path, reset, known_hosts = ssh_error\n    command = Command(\'ssh user@host\', \'\', errormsg)\n    remove_offending_keys(command, None)\n    expected = [\'123.234.567.890 asdjkasjdakjsd\\n\', \'111.222.333.444 qwepoiwqepoiss\\n\']\n    assert known_hosts(path) == expected\n\n\ndef test_get_new_command(ssh_error, monkeypatch):\n    errormsg, _, _, _ = ssh_error\n\n    method = Mock()\n    monkeypatch.setattr(\'thefuck.rules.ssh_known_hosts.remove_offending_keys\', method)\n    assert get_new_command(Command(\'ssh user@host\', \'\', errormsg), None) == \'ssh user@host\'\n    assert method.call_count\n', 'from thefuck.main import Command\nfrom thefuck.rules.sudo import match, get_new_command\n\n\ndef test_match():\n    assert match(Command(\'\', \'\', \'Permission denied\'), None)\n    assert match(Command(\'\', \'\', \'permission denied\'), None)\n    assert match(Command(\'\', \'\', ""npm ERR! Error: EACCES, unlink""), None)\n    assert not match(Command(\'\', \'\', \'\'), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command(\'ls\', \'\', \'\'), None) == \'sudo ls\'\n', ""from mock import patch, Mock\nfrom thefuck.main import Rule\nfrom thefuck import conf\n\n\ndef test_rules_names_list():\n    assert conf.RulesNamesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert conf.RulesNamesList(['bash', 'lisp']) == conf.RulesNamesList(['bash', 'lisp'])\n    assert Rule('lisp', None, None, False) in conf.RulesNamesList(['lisp'])\n    assert Rule('bash', None, None, False) not in conf.RulesNamesList(['lisp'])\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT_RULES\n    assert Rule('test', None, None, False) not in conf.DEFAULT_RULES\n    assert Rule('test', None, None, False) in (conf.DEFAULT_RULES + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.DEFAULT_SETTINGS.items():\n            assert getattr(conf.get_settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT_RULES + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT_RULES:bash:lisp'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['bash', 'lisp']\n\n\ndef test_update_settings():\n    settings = conf.Settings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main, conf\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == main.Rule('bash', match, get_new_command, True)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.DEFAULT_RULES))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True),\n                   main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('lisp', 'lisp', 'lisp', True)]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.RulesNamesList(['bash'])))) \\\n               == [main.Rule('bash', 'bash', 'bash', True),\n                   main.Rule('bash', 'bash', 'bash', True)]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == main.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [main.Rule('', lambda x, _: x.script == 'cd ..', None, True),\n             main.Rule('', lambda *_: False, None, True),\n             main.Rule('rule', Mock(side_effect=OSError('Denied')), None, True)]\n    assert main.get_matched_rule(main.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(main.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(main.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", None, ""from mock import Mock\nfrom thefuck.utils import sudo_support, wrap_settings\nfrom thefuck.main import Command\nfrom thefuck.conf import Settings\n\n\ndef test_wrap_settings():\n    fn = lambda _, settings: settings._conf\n    assert wrap_settings({'key': 'val'})(fn)(None, Settings({})) \\\n           == {'key': 'val'}\n    assert wrap_settings({'key': 'new-val'})(fn)(\n        None, Settings({'key': 'val'})) == {'key': 'new-val'}\n\n\ndef test_sudo_support():\n    fn = Mock(return_value=True, __name__='')\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n    fn.assert_called_once_with(Command('ls', 'out', 'err'), None)\n\n    fn.return_value = False\n    assert not sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n\n    fn.return_value = 'pwd'\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None) == 'sudo pwd'\n\n    assert sudo_support(fn)(Command('ls', 'out', 'err'), None) == 'pwd'\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs\n\n\nclass RulesNamesList(list):\n    """"""Wrapper a top of list for string rules names.""""""\n\n    def __contains__(self, item):\n        return super(RulesNamesList, self).__contains__(item.name)\n\n\nclass _DefaultRulesNames(RulesNamesList):\n    def __add__(self, items):\n        return _DefaultRulesNames(list(self) + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRulesNames, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRulesNames):\n            return super(_DefaultRulesNames, self).__eq__(other)\n        else:\n            return False\n\n\nDEFAULT_RULES = _DefaultRulesNames([])\n\n\nclass Settings(object):\n    def __init__(self, conf):\n        self._conf = conf\n\n    def __getattr__(self, item):\n        return self._conf.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = copy(self._conf)\n        conf.update(kwargs)\n        return Settings(conf)\n\n\nDEFAULT_SETTINGS = {\'rules\': DEFAULT_RULES,\n                    \'wait_command\': 3,\n                    \'require_confirmation\': False,\n                    \'no_colors\': False}\n\nENV_TO_ATTR = {\'THEFUCK_RULES\': \'rules\',\n               \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n               \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n               \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n\ndef _settings_from_file(user_dir):\n    """"""Loads settings from file.""""""\n    settings = load_source(\'settings\',\n                           text_type(user_dir.joinpath(\'settings.py\')))\n    return {key: getattr(settings, key)\n            for key in DEFAULT_SETTINGS.keys()\n            if hasattr(settings, key)}\n\n\ndef _rules_from_env(val):\n    """"""Transforms rules list from env-string to python.""""""\n    val = val.split(\':\')\n    if \'DEFAULT_RULES\' in val:\n        val = DEFAULT_RULES + [rule for rule in val if rule != \'DEFAULT_RULES\']\n    return val\n\n\ndef _val_from_env(env, attr):\n    """"""Transforms env-strings to python.""""""\n    val = os.environ[env]\n    if attr == \'rules\':\n        val = _rules_from_env(val)\n    elif attr == \'wait_command\':\n        val = int(val)\n    elif attr in (\'require_confirmation\', \'no_colors\'):\n        val = val.lower() == \'true\'\n    return val\n\n\ndef _settings_from_env():\n    """"""Loads settings from env.""""""\n    return {attr: _val_from_env(env, attr)\n            for env, attr in ENV_TO_ATTR.items()\n            if env in os.environ}\n\n\ndef get_settings(user_dir):\n    """"""Returns settings filled with values from `settings.py` and env.""""""\n    conf = copy(DEFAULT_SETTINGS)\n    try:\n        conf.update(_settings_from_file(user_dir))\n    except Exception:\n        logs.exception(""Can\'t load settings from file"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    try:\n        conf.update(_settings_from_env())\n    except Exception:\n        logs.exception(""Can\'t load settings from env"",\n                       sys.exc_info(),\n                       Settings(conf))\n\n    if not isinstance(conf[\'rules\'], RulesNamesList):\n        conf[\'rules\'] = RulesNamesList(conf[\'rules\'])\n\n    return Settings(conf)\n', 'from collections import namedtuple\nfrom imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom . import logs, conf\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return Rule(rule.name[:-3], rule_module.match,\n                rule_module.get_new_command,\n                getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent\\\n                            .joinpath(\'rules\')\\\n                            .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return Command(script, result.stdout.read().decode(\'utf-8\'),\n                       result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', None, 'from functools import wraps\nimport os\nimport six\nfrom thefuck.main import Command\n\n\ndef which(program):\n    """"""Returns `program` path or `None`.""""""\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef wrap_settings(params):\n    """"""Adds default values to settings if it not presented.\n\n    Usage:\n\n        @wrap_settings({\'apt\': \'/usr/bin/apt\'})\n        def match(command, settings):\n            print(settings.apt)\n\n    """"""\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(command, settings):\n            return fn(command, settings.update(**params))\n        return wrapper\n    return decorator\n\n\ndef sudo_support(fn):\n    """"""Removes sudo before calling fn and adds it after.""""""\n    @wraps(fn)\n    def wrapper(command, settings):\n        if not command.script.startswith(\'sudo \'):\n            return fn(command, settings)\n\n        result = fn(Command(command.script[5:],\n                            command.stdout,\n                            command.stderr),\n                    settings)\n\n        if result and isinstance(result, six.string_types):\n            return u\'sudo {}\'.format(result)\n        else:\n            return result\n    return wrapper\n']","[""from thefuck.types import Command\nfrom thefuck.rules.cd_parent import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('cd..', '', 'cd..: command not found'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(\n        Command('cd..', '', ''), None) == 'cd ..'\n"", 'import pytest\nfrom thefuck.types import Command\nfrom thefuck.rules.git_not_command import match, get_new_command\n\n\n@pytest.fixture\ndef git_not_command():\n    return """"""git: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\nbranch\n""""""\n\n\n@pytest.fixture\ndef git_not_command_one_of_this():\n    return """"""git: \'st\' is not a git command. See \'git --help\'.\n\nDid you mean one of these?\nstatus\nreset\nstage\nstash\nstats\n""""""\n\n\n@pytest.fixture\ndef git_command():\n    return ""* master""\n\n\ndef test_match(git_not_command, git_command, git_not_command_one_of_this):\n    assert match(Command(\'git brnch\', \'\', git_not_command), None)\n    assert match(Command(\'git st\', \'\', git_not_command_one_of_this), None)\n    assert not match(Command(\'ls brnch\', \'\', git_not_command), None)\n    assert not match(Command(\'git branch\', \'\', git_command), None)\n\n\ndef test_get_new_command(git_not_command, git_not_command_one_of_this):\n    assert get_new_command(Command(\'git brnch\', \'\', git_not_command), None)\\\n        == \'git branch\'\n    assert get_new_command(\n        Command(\'git st\', \'\', git_not_command_one_of_this), None) == \'git status\'\n', 'import pytest\nfrom thefuck.types import Command\nfrom thefuck.rules.git_push import match, get_new_command\n\n\n@pytest.fixture\ndef stderr():\n    return \'\'\'fatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\'\'\'\n\n\ndef test_match(stderr):\n    assert match(Command(\'git push master\', \'\', stderr), None)\n    assert not match(Command(\'git push master\', \'\', \'\'), None)\n    assert not match(Command(\'ls\', \'\', stderr), None)\n\n\ndef test_get_new_command(stderr):\n    assert get_new_command(Command(\'\', \'\', stderr), None)\\\n        == ""git push --set-upstream origin master""\n', ""from mock import Mock, patch\nfrom thefuck.rules.has_exists_script import match, get_new_command\n\n\ndef test_match():\n    with patch('os.path.exists', return_value=True):\n        assert match(Mock(script='main', stderr='main: command not found'),\n                     None)\n        assert match(Mock(script='main --help',\n                          stderr='main: command not found'),\n                     None)\n        assert not match(Mock(script='main', stderr=''), None)\n\n    with patch('os.path.exists', return_value=False):\n        assert not match(Mock(script='main', stderr='main: command not found'),\n                         None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Mock(script='main --help'), None) == './main --help'\n"", ""from thefuck.types import Command\nfrom thefuck.rules.mkdir_p import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('mkdir foo/bar/baz', '', 'mkdir: foo/bar: No such file or directory'), None)\n    assert not match(Command('mkdir foo/bar/baz', '', ''), None)\n    assert not match(Command('mkdir foo/bar/baz', '', 'foo bar baz'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('mkdir foo/bar/baz', '', ''), None) == 'mkdir -p foo/bar/baz'\n"", ""from thefuck.types import Command\nfrom thefuck.rules.python_command import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('temp.py', '', 'Permission denied'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('./test_sudo.py', '', ''), None) == 'python ./test_sudo.py'\n"", ""from thefuck.types import Command\nfrom thefuck.rules.rm_dir import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('rm foo', '', 'rm: foo: is a directory'), None)\n    assert not match(Command('rm foo', '', ''), None)\n    assert not match(Command('rm foo', '', 'foo bar baz'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('rm foo', '', ''), None) == 'rm -rf foo'\n"", 'import os\nimport pytest\nfrom mock import Mock\nfrom thefuck.types import Command\nfrom thefuck.rules.ssh_known_hosts import match, get_new_command, remove_offending_keys\n\n\n@pytest.fixture\ndef ssh_error(tmpdir):\n    path = os.path.join(str(tmpdir), \'known_hosts\')\n\n    def reset(path):\n        with open(path, \'w\') as fh:\n            lines = [\n                \'123.234.567.890 asdjkasjdakjsd\\n\'\n                \'98.765.432.321 ejioweojwejrosj\\n\'\n                \'111.222.333.444 qwepoiwqepoiss\\n\'\n            ]\n            fh.writelines(lines)\n\n    def known_hosts(path):\n        with open(path, \'r\') as fh:\n            return fh.readlines()\n\n    reset(path)\n\n    errormsg = u""""""@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\nb6:cb:07:34:c0:a0:94:d3:0d:69:83:31:f4:c5:20:9b.\nPlease contact your system administrator.\nAdd correct host key in {0} to get rid of this message.\nOffending RSA key in {0}:2\nRSA host key for {1} has changed and you have requested strict checking.\nHost key verification failed."""""".format(path, \'98.765.432.321\')\n\n    return errormsg, path, reset, known_hosts\n\n\ndef test_match(ssh_error):\n    errormsg, _, _, _ = ssh_error\n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert not match(Command(\'\', \'\', errormsg), None)\n    assert not match(Command(\'notssh\', \'\', errormsg), None)\n    assert not match(Command(\'ssh\', \'\', \'\'), None)\n\n\ndef test_remove_offending_keys(ssh_error):\n    errormsg, path, reset, known_hosts = ssh_error\n    command = Command(\'ssh user@host\', \'\', errormsg)\n    remove_offending_keys(command, None)\n    expected = [\'123.234.567.890 asdjkasjdakjsd\\n\', \'111.222.333.444 qwepoiwqepoiss\\n\']\n    assert known_hosts(path) == expected\n\n\ndef test_get_new_command(ssh_error, monkeypatch):\n    errormsg, _, _, _ = ssh_error\n\n    method = Mock()\n    monkeypatch.setattr(\'thefuck.rules.ssh_known_hosts.remove_offending_keys\', method)\n    assert get_new_command(Command(\'ssh user@host\', \'\', errormsg), None) == \'ssh user@host\'\n    assert method.call_count\n', 'from thefuck.types import Command\nfrom thefuck.rules.sudo import match, get_new_command\n\n\ndef test_match():\n    assert match(Command(\'\', \'\', \'Permission denied\'), None)\n    assert match(Command(\'\', \'\', \'permission denied\'), None)\n    assert match(Command(\'\', \'\', ""npm ERR! Error: EACCES, unlink""), None)\n    assert not match(Command(\'\', \'\', \'\'), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command(\'ls\', \'\', \'\'), None) == \'sudo ls\'\n', ""from mock import patch, Mock\nfrom thefuck.types import Rule\nfrom thefuck import conf\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT_RULES\n    assert Rule('test', None, None, False) not in conf.DEFAULT_RULES\n    assert Rule('test', None, None, False) in (conf.DEFAULT_RULES + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.DEFAULT_SETTINGS.items():\n            assert getattr(conf.get_settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT_RULES + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT_RULES:bash:lisp'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['bash', 'lisp']\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main, conf, types\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == types.Rule('bash', match, get_new_command, True)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.DEFAULT_RULES))) \\\n               == [types.Rule('bash', 'bash', 'bash', True),\n                   types.Rule('lisp', 'lisp', 'lisp', True),\n                   types.Rule('bash', 'bash', 'bash', True),\n                   types.Rule('lisp', 'lisp', 'lisp', True)]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=types.RulesNamesList(['bash'])))) \\\n               == [types.Rule('bash', 'bash', 'bash', True),\n                   types.Rule('bash', 'bash', 'bash', True)]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == types.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [types.Rule('', lambda x, _: x.script == 'cd ..', None, True),\n             types.Rule('', lambda *_: False, None, True),\n             types.Rule('rule', Mock(side_effect=OSError('Denied')), None, True)]\n    assert main.get_matched_rule(types.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(types.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(types.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(types.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", ""from thefuck.types import Rule, RulesNamesList, Settings\n\n\ndef test_rules_names_list():\n    assert RulesNamesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert RulesNamesList(['bash', 'lisp']) == RulesNamesList(['bash', 'lisp'])\n    assert Rule('lisp', None, None, False) in RulesNamesList(['lisp'])\n    assert Rule('bash', None, None, False) not in RulesNamesList(['lisp'])\n\n\ndef test_update_settings():\n    settings = Settings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from mock import Mock\nfrom thefuck.utils import sudo_support, wrap_settings\nfrom thefuck.types import Command, Settings\n\n\ndef test_wrap_settings():\n    fn = lambda _, settings: settings\n    assert wrap_settings({'key': 'val'})(fn)(None, Settings({})) \\\n           == {'key': 'val'}\n    assert wrap_settings({'key': 'new-val'})(fn)(\n        None, Settings({'key': 'val'})) == {'key': 'new-val'}\n\n\ndef test_sudo_support():\n    fn = Mock(return_value=True, __name__='')\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n    fn.assert_called_once_with(Command('ls', 'out', 'err'), None)\n\n    fn.return_value = False\n    assert not sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n\n    fn.return_value = 'pwd'\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None) == 'sudo pwd'\n\n    assert sudo_support(fn)(Command('ls', 'out', 'err'), None) == 'pwd'\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs, types\n\n\nclass _DefaultRulesNames(types.RulesNamesList):\n    def __add__(self, items):\n        return _DefaultRulesNames(list(self) + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRulesNames, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRulesNames):\n            return super(_DefaultRulesNames, self).__eq__(other)\n        else:\n            return False\n\n\nDEFAULT_RULES = _DefaultRulesNames([])\n\n\nDEFAULT_SETTINGS = {\'rules\': DEFAULT_RULES,\n                    \'wait_command\': 3,\n                    \'require_confirmation\': False,\n                    \'no_colors\': False}\n\nENV_TO_ATTR = {\'THEFUCK_RULES\': \'rules\',\n               \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n               \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n               \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n\ndef _settings_from_file(user_dir):\n    """"""Loads settings from file.""""""\n    settings = load_source(\'settings\',\n                           text_type(user_dir.joinpath(\'settings.py\')))\n    return {key: getattr(settings, key)\n            for key in DEFAULT_SETTINGS.keys()\n            if hasattr(settings, key)}\n\n\ndef _rules_from_env(val):\n    """"""Transforms rules list from env-string to python.""""""\n    val = val.split(\':\')\n    if \'DEFAULT_RULES\' in val:\n        val = DEFAULT_RULES + [rule for rule in val if rule != \'DEFAULT_RULES\']\n    return val\n\n\ndef _val_from_env(env, attr):\n    """"""Transforms env-strings to python.""""""\n    val = os.environ[env]\n    if attr == \'rules\':\n        val = _rules_from_env(val)\n    elif attr == \'wait_command\':\n        val = int(val)\n    elif attr in (\'require_confirmation\', \'no_colors\'):\n        val = val.lower() == \'true\'\n    return val\n\n\ndef _settings_from_env():\n    """"""Loads settings from env.""""""\n    return {attr: _val_from_env(env, attr)\n            for env, attr in ENV_TO_ATTR.items()\n            if env in os.environ}\n\n\ndef get_settings(user_dir):\n    """"""Returns settings filled with values from `settings.py` and env.""""""\n    conf = copy(DEFAULT_SETTINGS)\n    try:\n        conf.update(_settings_from_file(user_dir))\n    except Exception:\n        logs.exception(""Can\'t load settings from file"",\n                       sys.exc_info(),\n                       types.Settings(conf))\n\n    try:\n        conf.update(_settings_from_env())\n    except Exception:\n        logs.exception(""Can\'t load settings from env"",\n                       sys.exc_info(),\n                       types.Settings(conf))\n\n    if not isinstance(conf[\'rules\'], types.RulesNamesList):\n        conf[\'rules\'] = types.RulesNamesList(conf[\'rules\'])\n\n    return types.Settings(conf)\n', 'from imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom . import logs, conf, types\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return types.Rule(rule.name[:-3], rule_module.match,\n                      rule_module.get_new_command,\n                      getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent \\\n        .joinpath(\'rules\') \\\n        .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return types.Command(script, result.stdout.read().decode(\'utf-8\'),\n                             result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', 'from collections import namedtuple\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\n\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\nclass RulesNamesList(list):\n    """"""Wrapper a top of list for string rules names.""""""\n\n    def __contains__(self, item):\n        return super(RulesNamesList, self).__contains__(item.name)\n\n\nclass Settings(dict):\n\n    def __getattr__(self, item):\n        return self.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = dict(self)\n        conf.update(kwargs)\n        return Settings(conf)\n', 'from functools import wraps\nimport os\nimport six\nfrom .types import Command\n\n\ndef which(program):\n    """"""Returns `program` path or `None`.""""""\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef wrap_settings(params):\n    """"""Adds default values to settings if it not presented.\n\n    Usage:\n\n        @wrap_settings({\'apt\': \'/usr/bin/apt\'})\n        def match(command, settings):\n            print(settings.apt)\n\n    """"""\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(command, settings):\n            return fn(command, settings.update(**params))\n        return wrapper\n    return decorator\n\n\ndef sudo_support(fn):\n    """"""Removes sudo before calling fn and adds it after.""""""\n    @wraps(fn)\n    def wrapper(command, settings):\n        if not command.script.startswith(\'sudo \'):\n            return fn(command, settings)\n\n        result = fn(Command(command.script[5:],\n                            command.stdout,\n                            command.stderr),\n                    settings)\n\n        if result and isinstance(result, six.string_types):\n            return u\'sudo {}\'.format(result)\n        else:\n            return result\n    return wrapper\n']","[[<pydriller.domain.commit.Method object at 0x7f1983eb94f0>, <pydriller.domain.commit.Method object at 0x7f1983eb9a60>], [<pydriller.domain.commit.Method object at 0x7f1983ed5d00>, <pydriller.domain.commit.Method object at 0x7f1983ed5e20>, <pydriller.domain.commit.Method object at 0x7f1983ed5e50>, <pydriller.domain.commit.Method object at 0x7f1983ed5cd0>, <pydriller.domain.commit.Method object at 0x7f1983e57a30>], [<pydriller.domain.commit.Method object at 0x7f1983ef8bb0>, <pydriller.domain.commit.Method object at 0x7f1983ef8520>, <pydriller.domain.commit.Method object at 0x7f1983ef8130>], [<pydriller.domain.commit.Method object at 0x7f1983f097c0>, <pydriller.domain.commit.Method object at 0x7f1983f093a0>], [<pydriller.domain.commit.Method object at 0x7f1983f05280>, <pydriller.domain.commit.Method object at 0x7f1983f05130>], [<pydriller.domain.commit.Method object at 0x7f1983ee0e50>, <pydriller.domain.commit.Method object at 0x7f1983ee0fa0>], [<pydriller.domain.commit.Method object at 0x7f1983eedd00>, <pydriller.domain.commit.Method object at 0x7f1983eedfa0>], [<pydriller.domain.commit.Method object at 0x7f1983ecacd0>, <pydriller.domain.commit.Method object at 0x7f1983ecae20>, <pydriller.domain.commit.Method object at 0x7f1983ecad00>, <pydriller.domain.commit.Method object at 0x7f1983ecab80>, <pydriller.domain.commit.Method object at 0x7f1983eca7c0>, <pydriller.domain.commit.Method object at 0x7f1983eca640>], [<pydriller.domain.commit.Method object at 0x7f1983f44640>, <pydriller.domain.commit.Method object at 0x7f1983f44790>], [<pydriller.domain.commit.Method object at 0x7f1983f3d100>, <pydriller.domain.commit.Method object at 0x7f1983f36f70>, <pydriller.domain.commit.Method object at 0x7f1983f36fa0>, <pydriller.domain.commit.Method object at 0x7f1983f36e20>, <pydriller.domain.commit.Method object at 0x7f1983f36910>, <pydriller.domain.commit.Method object at 0x7f1983f36790>, <pydriller.domain.commit.Method object at 0x7f1983f367c0>, <pydriller.domain.commit.Method object at 0x7f1983f36640>], [<pydriller.domain.commit.Method object at 0x7f1983f3d8e0>, <pydriller.domain.commit.Method object at 0x7f1983f3da30>, <pydriller.domain.commit.Method object at 0x7f1983f3d910>, <pydriller.domain.commit.Method object at 0x7f1983f44100>, <pydriller.domain.commit.Method object at 0x7f1983f444f0>, <pydriller.domain.commit.Method object at 0x7f1983f44910>], [], [<pydriller.domain.commit.Method object at 0x7f1983eed520>, <pydriller.domain.commit.Method object at 0x7f1983eedcd0>], [<pydriller.domain.commit.Method object at 0x7f1983efe280>, <pydriller.domain.commit.Method object at 0x7f1983f09640>, <pydriller.domain.commit.Method object at 0x7f1983f09670>, <pydriller.domain.commit.Method object at 0x7f1983f09a60>, <pydriller.domain.commit.Method object at 0x7f1983ef8280>, <pydriller.domain.commit.Method object at 0x7f1983ef84f0>, <pydriller.domain.commit.Method object at 0x7f1983ef8100>, <pydriller.domain.commit.Method object at 0x7f1983ef8d00>, <pydriller.domain.commit.Method object at 0x7f1983ef8a60>, <pydriller.domain.commit.Method object at 0x7f1983ef8e50>, <pydriller.domain.commit.Method object at 0x7f1983ef8670>, <pydriller.domain.commit.Method object at 0x7f1983ef8b80>], [<pydriller.domain.commit.Method object at 0x7f1983ed5640>, <pydriller.domain.commit.Method object at 0x7f1983ed5b80>, <pydriller.domain.commit.Method object at 0x7f1983ed54f0>, <pydriller.domain.commit.Method object at 0x7f1983ed5fa0>, <pydriller.domain.commit.Method object at 0x7f1983edca60>, <pydriller.domain.commit.Method object at 0x7f1983edcbb0>, <pydriller.domain.commit.Method object at 0x7f1983edca30>, <pydriller.domain.commit.Method object at 0x7f1983edcd00>, <pydriller.domain.commit.Method object at 0x7f1983edcb80>, <pydriller.domain.commit.Method object at 0x7f1983edccd0>], [], [<pydriller.domain.commit.Method object at 0x7f1983e90640>, <pydriller.domain.commit.Method object at 0x7f1983e96790>, <pydriller.domain.commit.Method object at 0x7f1983e96670>, <pydriller.domain.commit.Method object at 0x7f1983e967c0>, <pydriller.domain.commit.Method object at 0x7f1983e96fa0>, <pydriller.domain.commit.Method object at 0x7f1983e96e20>, <pydriller.domain.commit.Method object at 0x7f1983e96250>]]","[[], [], [], [], [], [], [], [], [], [<pydriller.domain.commit.Method object at 0x7f1983f36640>, <pydriller.domain.commit.Method object at 0x7f1983f3d100>], [<pydriller.domain.commit.Method object at 0x7f1983f36b80>, <pydriller.domain.commit.Method object at 0x7f1983f36130>, <pydriller.domain.commit.Method object at 0x7f1983f3de20>, <pydriller.domain.commit.Method object at 0x7f1983f36d00>, <pydriller.domain.commit.Method object at 0x7f1983f36cd0>], [<pydriller.domain.commit.Method object at 0x7f1983ecaa60>, <pydriller.domain.commit.Method object at 0x7f1983ecabb0>], [<pydriller.domain.commit.Method object at 0x7f1983ed0b80>], [<pydriller.domain.commit.Method object at 0x7f1983ef8100>, <pydriller.domain.commit.Method object at 0x7f1983efe280>, <pydriller.domain.commit.Method object at 0x7f1983ef84f0>, <pydriller.domain.commit.Method object at 0x7f1983ef8280>, <pydriller.domain.commit.Method object at 0x7f1983efe250>], [<pydriller.domain.commit.Method object at 0x7f1983d9c040>, <pydriller.domain.commit.Method object at 0x7f1983e0ca60>, <pydriller.domain.commit.Method object at 0x7f1983eb2d00>], [<pydriller.domain.commit.Method object at 0x7f1983ee0280>, <pydriller.domain.commit.Method object at 0x7f1983ee0cd0>, <pydriller.domain.commit.Method object at 0x7f1983ee0250>], []]"
thefuck,0272e8a8018344d0f9757e21999ffb517d199a03,Bump to 1.28,2015-04-22 23:37:02+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nVERSION = \'1.27\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.28\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,5de020bccd2a7ea6ba34087fef06f08df09ced41,unf*ck sl -> ls,2015-04-22 20:41:56-05:00,Brobin,14,0,14,1,['sl_ls.py'],[None],"['""""""\nThis happens way too often\n\nWhen typing really fast cause I\'m a 1337 H4X0R,\nI often fuck up \'ls\' and type \'sl\'. No more!\n""""""\n\n\ndef match(command, settings):\n    return command.script == \'sl\'\n\n\ndef get_new_command(command, settings):\n    return \'ls\'\n']",[[]],"[[<pydriller.domain.commit.Method object at 0x7f1983e9ce50>, <pydriller.domain.commit.Method object at 0x7f1983e9c8e0>]]"
thefuck,157e3e95fc56353d3961d1ebde7a703103e7b335,added sl_ls test :shipit:,2015-04-22 20:51:18-05:00,Brobin,12,0,12,1,['test_sl_ls.py'],[None],"[""\nfrom thefuck.types import Command\nfrom thefuck.rules.sl_ls import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('sl', '', ''), None)\n    assert not match(Command('ls', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('sl', '', ''), None) == 'ls'\n""]",[[]],"[[<pydriller.domain.commit.Method object at 0x7f1983e4b7c0>, <pydriller.domain.commit.Method object at 0x7f1983e4be20>]]"
thefuck,af2bfe7c582c588db7f2a148d46e1cf588938165,Add a support for pip unknown commands,2015-04-23 15:25:12+09:00,Namwoo Kim,39,0,39,2,"['test_pip_unknown_command.py', 'pip_unknown_command.py']","[None, None]","['import pytest\nfrom thefuck.types import Command\nfrom thefuck.rules.pip_unknown_command import match, get_new_command\n\n\n@pytest.fixture\ndef pip_unknown_cmd():\n    return \'\'\'ERROR: unknown command ""instatl"" - maybe you meant ""install""\'\'\'\n\n\n@pytest.fixture\ndef pip_unknown_cmd_without_recommend():\n    return \'\'\'ERROR: unknown command ""i""\'\'\'\n\n\ndef test_match(pip_unknown_cmd, pip_unknown_cmd_without_recommend):\n    assert match(Command(\'pip instatl\', \'\', pip_unknown_cmd), None)\n    assert not match(Command(\'pip i\', \'\', pip_unknown_cmd_without_recommend),\n                     None)\n\n\ndef test_get_new_command(pip_unknown_cmd):\n    assert get_new_command(Command(\'pip instatl\', \'\', pip_unknown_cmd), None)\\\n        == \'pip install\'\n', 'import re\n\n\ndef match(command, settings):\n    return (\'pip\' in command.script and\n            \'unknown command\' in command.stderr and\n            \'maybe you meant\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r\'ERROR: unknown command \\""([a-z]+)\\""\',\n                            command.stderr)[0]\n    new_cmd = re.findall(r\'maybe you meant \\""([a-z]+)\\""\', command.stderr)[0]\n\n    return command.script.replace(broken_cmd, new_cmd, 1)\n']","[[], []]","[[<pydriller.domain.commit.Method object at 0x7f1983ec0520>, <pydriller.domain.commit.Method object at 0x7f1983e57bb0>, <pydriller.domain.commit.Method object at 0x7f1983ec0250>, <pydriller.domain.commit.Method object at 0x7f1983e57130>], [<pydriller.domain.commit.Method object at 0x7f1983e51fa0>, <pydriller.domain.commit.Method object at 0x7f1983e513a0>]]"
thefuck,07b9aba0d0b21d4b52f471bc2c7403ad4b484d19,"MacOSX specific message

Patch for understanding macosx message.
Example case:
```
[10:24:48][bethrezen@bethrezen-mac ~]$ apachectl graceful
This operation requires root.
[10:24:54][bethrezen@bethrezen-mac ~]$ fuck
No fuck given
```",2015-04-23 10:29:34+03:00,Alexander Kozhevnikov,1,0,1,1,['sudo.py'],"[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted',\n            'root privilege',\n            'This command has to be run under the root user.',\n            'You need to be root to perform this command.']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted',\n            'root privilege',\n            'This command has to be run under the root user.',\n            'This operation requires root.',\n            'You need to be root to perform this command.']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983ccc2e0>, <pydriller.domain.commit.Method object at 0x7f1983ccc2b0>]]",[[]]
thefuck,24ce459f2cac721a08ab4e359119dc5603b03fa3,Add a support for unknown brew commands - #83,2015-04-23 17:06:05+09:00,Namwoo Kim,61,0,61,2,"['test_brew_unknown_command.py', 'brew_unknown_command.py']","[None, None]","[""import pytest\nfrom thefuck.types import Command\nfrom thefuck.rules.brew_unknown_command import match, get_new_command\nfrom thefuck.rules.brew_unknown_command import brew_commands\n\n\n@pytest.fixture\ndef brew_unknown_cmd():\n    return '''Error: Unknown command: inst'''\n\n\n@pytest.fixture\ndef brew_unknown_cmd_instaa():\n    return '''Error: Unknown command: instaa'''\n\n\ndef test_match(brew_unknown_cmd):\n    assert match(Command('brew inst', '', brew_unknown_cmd), None)\n    for command in brew_commands:\n        assert not match(Command('brew ' + command, '', ''), None)\n\n\ndef test_get_new_command(brew_unknown_cmd, brew_unknown_cmd_instaa):\n    assert get_new_command(Command('brew inst', '', brew_unknown_cmd), None)\\\n        == 'brew list'\n\n    assert get_new_command(Command('brew instaa', '', brew_unknown_cmd_instaa),\n                           None) == 'brew install'\n"", ""import difflib\nimport re\nimport thefuck.logs\n\n# This commands are based on Homebrew 0.9.5\nbrew_commands = ['info', 'home', 'options', 'install', 'uninstall', 'search',\n                 'list', 'update', 'upgrade', 'pin', 'unpin', 'doctor',\n                 'create', 'edit']\n\n\ndef _get_similar_commands(command):\n    return difflib.get_close_matches(command, brew_commands)\n\n\ndef match(command, settings):\n    is_proper_command = ('brew' in command.script and\n                         'Unknown command' in command.stderr)\n\n    has_possible_commands = False\n    if is_proper_command:\n        broken_cmd = re.findall(r'Error: Unknown command: ([a-z]+)',\n                                command.stderr)[0]\n        has_possible_commands = len(_get_similar_commands(broken_cmd)) > 0\n\n    return has_possible_commands\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r'Error: Unknown command: ([a-z]+)',\n                            command.stderr)[0]\n    new_cmd = _get_similar_commands(broken_cmd)[0]\n\n    return command.script.replace(broken_cmd, new_cmd, 1)\n""]","[[], []]","[[<pydriller.domain.commit.Method object at 0x7f1983cddbe0>, <pydriller.domain.commit.Method object at 0x7f1983cddeb0>, <pydriller.domain.commit.Method object at 0x7f1983cdd820>, <pydriller.domain.commit.Method object at 0x7f1983cdda90>], [<pydriller.domain.commit.Method object at 0x7f1983d3bd60>, <pydriller.domain.commit.Method object at 0x7f1983d3bc10>, <pydriller.domain.commit.Method object at 0x7f1983d3b430>]]"
thefuck,54b5cd61226994ebd5700fceb2e184ecfdc15f5f,Add a support for brew unavailable formulas,2015-04-23 18:16:36+09:00,Namwoo Kim,92,0,92,2,"['test_brew_install.py', 'brew_install.py']","[None, None]","[""import pytest\nfrom thefuck.types import Command\nfrom thefuck.rules.brew_install import match, get_new_command\nfrom thefuck.rules.brew_install import brew_formulas\n\n\n@pytest.fixture\ndef brew_no_available_formula():\n    return '''Error: No available formula for elsticsearch '''\n\n\n@pytest.fixture\ndef brew_install_no_argument():\n    return '''This command requires a formula argument'''\n\n\n@pytest.fixture\ndef brew_already_installed():\n    return '''Warning: git-2.3.5 already installed'''\n\n\ndef _is_not_okay_to_test():\n    if 'elasticsearch' not in brew_formulas:\n        return True\n    return False\n\n\n@pytest.mark.skipif(_is_not_okay_to_test(),\n                    reason='No need to run if there\\'s no formula')\ndef test_match(brew_no_available_formula, brew_already_installed,\n               brew_install_no_argument):\n    assert match(Command('brew install elsticsearch', '',\n                         brew_no_available_formula), None)\n    assert not match(Command('brew install git', '',\n                             brew_already_installed), None)\n    assert not match(Command('brew install', '', brew_install_no_argument),\n                     None)\n\n\n@pytest.mark.skipif(_is_not_okay_to_test(),\n                    reason='No need to run if there\\'s no formula')\ndef test_get_new_command(brew_no_available_formula):\n    assert get_new_command(Command('brew install elsticsearch', '',\n                                   brew_no_available_formula), None)\\\n        == 'brew install elasticsearch'\n\n    assert get_new_command(Command('brew install aa', '',\n                                   brew_no_available_formula),\n                           None) != 'brew install aha'\n"", ""import difflib\nimport os\nimport re\nfrom subprocess import check_output\n\nimport thefuck.logs\n\n# Formulars are base on each local system's status\nbrew_formulas = []\ntry:\n    brew_path_prefix = check_output(['brew', '--prefix']).strip()\n    brew_formula_path = brew_path_prefix + '/Library/Formula'\n\n    for file_name in os.listdir(brew_formula_path):\n        if file_name.endswith('.rb'):\n            brew_formulas.append(file_name.replace('.rb', ''))\nexcept:\n    pass\n\n\ndef _get_similar_formulars(formula_name):\n    return difflib.get_close_matches(formula_name, brew_formulas, 1, 0.85)\n\n\ndef match(command, settings):\n    is_proper_command = ('brew install' in command.script and\n                         'No available formula' in command.stderr)\n\n    has_possible_formulas = False\n    if is_proper_command:\n        formula = re.findall(r'Error: No available formula for ([a-z]+)',\n                             command.stderr)[0]\n        has_possible_formulas = len(_get_similar_formulars(formula)) > 0\n\n    return has_possible_formulas\n\n\ndef get_new_command(command, settings):\n    not_exist_formula = re.findall(r'Error: No available formula for ([a-z]+)',\n                                   command.stderr)[0]\n    exist_formula = _get_similar_formulars(not_exist_formula)[0]\n\n    return command.script.replace(not_exist_formula, exist_formula, 1)\n""]","[[], []]","[[<pydriller.domain.commit.Method object at 0x7f1983d35430>, <pydriller.domain.commit.Method object at 0x7f1983d35040>, <pydriller.domain.commit.Method object at 0x7f1983d17ac0>, <pydriller.domain.commit.Method object at 0x7f1983d352b0>, <pydriller.domain.commit.Method object at 0x7f1983d17400>, <pydriller.domain.commit.Method object at 0x7f1983d35820>], [<pydriller.domain.commit.Method object at 0x7f1983ce36d0>, <pydriller.domain.commit.Method object at 0x7f1983ce3a90>, <pydriller.domain.commit.Method object at 0x7f1983ce3970>]]"
thefuck,f1cce413b35b4a476568aa090ea1c86aff72f3bb,"Added rule for fixing Alt+Space character

Happens on the Mac a lot when typing a pipe character (Alt+7), and
keeping the Alt key pressed down for a bit too long, so instead of
Space, you're typing Alt+Space. This rule replaces the Alt+Space with a
simple Space character.

$ ps -ef | grep foo
-bash:  grep: command not found
$ fuck
ps -ef | grep foo",2015-04-23 15:19:30+02:00,Nils Winkler,34,0,34,3,"['README.md', 'test_fix_alt_space.py', 'fix_alt_space.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nOr using an OS package manager (currently supported in OSX via [brew](http://brew.sh)):\n\n```bash\nbrew install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck {\n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) {\n        $fuck.substring(5)\n    }\n    else { iex ""$fuck"" }\n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', None, None]","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nOr using an OS package manager (currently supported in OSX via [brew](http://brew.sh)):\n\n```bash\nbrew install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck {\n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) {\n        $fuck.substring(5)\n    }\n    else { iex ""$fuck"" }\n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', '# -*- encoding: utf-8 -*-\n\n\nfrom thefuck.types import Command\nfrom thefuck.rules.fix_alt_space import match, get_new_command\n\n\ndef test_match():\n    """""" The character before \'grep\' is Alt+Space, which happens frequently on the Mac when typing\n        the pipe character (Alt+7), and holding the Alt key pressed for longer than necessary. """"""\n    assert match(Command(u\'ps -ef |\xa0grep foo\', \'\', u\'-bash: \xa0grep: command not found\'), None)\n    assert not match(Command(\'ps -ef | grep foo\', \'\', \'\'), None)\n    assert not match(Command(\'\', \'\', \'\'), None)\n\n\ndef test_get_new_command():\n    """""" Replace the Alt+Space character by a simple space """"""\n    assert get_new_command(Command(u\'ps -ef |\xa0grep foo\', \'\', \'\'), None) == \'ps -ef | grep foo\'\n', ""# -*- encoding: utf-8 -*-\n\nimport re\nfrom thefuck.utils import sudo_support\n\n\n@sudo_support\ndef match(command, settings):\n    return ('command not found' in command.stderr.lower()\n            and u'\xa0' in command.script)\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return re.sub(u'\xa0', ' ', command.script)\n""]","[[], [], []]","[[], [<pydriller.domain.commit.Method object at 0x7f1983d2e6d0>, <pydriller.domain.commit.Method object at 0x7f1983d2e820>], [<pydriller.domain.commit.Method object at 0x7f1983d51430>, <pydriller.domain.commit.Method object at 0x7f1983d51c10>]]"
thefuck,473f5e6a333d89a54813daf5495d68b17490ae8b,Add composer rule,2015-04-23 17:34:34+02:00,Rubén Simón Andreo,64,0,64,2,"['test_composer_not_command.py', 'composer_not_command.py']","[None, None]","['import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.composer_not_command import match, get_new_command\n\n\n@pytest.fixture\ndef composer_not_command():\n    return """"""\n\n                                    \n  [InvalidArgumentException]        \n  Command ""udpate"" is not defined.  \n  Did you mean this?                \n      update\n\n\n""""""\n\n\n@pytest.fixture\ndef composer_not_command_one_of_this():\n    return """"""\n                            \n\n\n  [InvalidArgumentException]       \n  Command ""pdate"" is not defined.  \n  Did you mean one of these?       \n      selfupdate                   \n      self-update                  \n      update                       \n\n\n\n""""""\n\ndef test_match(composer_not_command, composer_not_command_one_of_this):\n    assert match(Command(\'composer udpate\', \'\', composer_not_command), None)\n    assert match(Command(\'composer pdate\', \'\', composer_not_command_one_of_this), None)\n    assert not match(Command(\'ls update\', \'\', composer_not_command), None)\n    #assert not match(Command(\'composer update\', \'\', composer_command), None)\n\n\ndef test_get_new_command(composer_not_command, composer_not_command_one_of_this):\n    assert get_new_command(Command(\'composer udpate\', \'\', composer_not_command), None)\\\n        == \'composer update\'\n    assert get_new_command(\n        Command(\'composer pdate\', \'\', composer_not_command_one_of_this), None) == \'composer selfupdate\'\n', 'import re\n\ndef match(command, settings):\n    return (\'composer\' in command.script\n        and (\n        \t\'did you mean this?\' in command.stderr.lower()\n        \tor \'did you mean one of these?\' in command.stderr.lower()\n        \t)\n        )\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r""Command \\""([^\']*)\\"" is not defined"", command.stderr)[0]\n    new_cmd = re.findall(r\'Did you mean this\\?[^\\n]*\\n\\s*([^\\n]*)\', command.stderr)\n    if not new_cmd:\n    \tnew_cmd = re.findall(r\'Did you mean one of these\\?[^\\n]*\\n\\s*([^\\n]*)\', command.stderr)\n    return command.script.replace(broken_cmd, new_cmd[0].strip(), 1)']","[[], []]","[[<pydriller.domain.commit.Method object at 0x7f1983e422b0>, <pydriller.domain.commit.Method object at 0x7f1983e42e80>, <pydriller.domain.commit.Method object at 0x7f1983d1c040>, <pydriller.domain.commit.Method object at 0x7f1983e42160>], [<pydriller.domain.commit.Method object at 0x7f1983e3c520>, <pydriller.domain.commit.Method object at 0x7f1983e3cfa0>]]"
thefuck,1f96faef2cd530806310478f6e812113ed583874,#116 Fix tests,2015-04-23 21:47:46+02:00,nvbn,9,10,19,2,"['test_composer_not_command.py', 'composer_not_command.py']","['import pytest\nfrom thefuck.main import Command\nfrom thefuck.rules.composer_not_command import match, get_new_command\n\n\n@pytest.fixture\ndef composer_not_command():\n    return """"""\n\n                                    \n  [InvalidArgumentException]        \n  Command ""udpate"" is not defined.  \n  Did you mean this?                \n      update\n\n\n""""""\n\n\n@pytest.fixture\ndef composer_not_command_one_of_this():\n    return """"""\n                            \n\n\n  [InvalidArgumentException]       \n  Command ""pdate"" is not defined.  \n  Did you mean one of these?       \n      selfupdate                   \n      self-update                  \n      update                       \n\n\n\n""""""\n\ndef test_match(composer_not_command, composer_not_command_one_of_this):\n    assert match(Command(\'composer udpate\', \'\', composer_not_command), None)\n    assert match(Command(\'composer pdate\', \'\', composer_not_command_one_of_this), None)\n    assert not match(Command(\'ls update\', \'\', composer_not_command), None)\n    #assert not match(Command(\'composer update\', \'\', composer_command), None)\n\n\ndef test_get_new_command(composer_not_command, composer_not_command_one_of_this):\n    assert get_new_command(Command(\'composer udpate\', \'\', composer_not_command), None)\\\n        == \'composer update\'\n    assert get_new_command(\n        Command(\'composer pdate\', \'\', composer_not_command_one_of_this), None) == \'composer selfupdate\'\n', 'import re\n\ndef match(command, settings):\n    return (\'composer\' in command.script\n        and (\n        \t\'did you mean this?\' in command.stderr.lower()\n        \tor \'did you mean one of these?\' in command.stderr.lower()\n        \t)\n        )\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r""Command \\""([^\']*)\\"" is not defined"", command.stderr)[0]\n    new_cmd = re.findall(r\'Did you mean this\\?[^\\n]*\\n\\s*([^\\n]*)\', command.stderr)\n    if not new_cmd:\n    \tnew_cmd = re.findall(r\'Did you mean one of these\\?[^\\n]*\\n\\s*([^\\n]*)\', command.stderr)\n    return command.script.replace(broken_cmd, new_cmd[0].strip(), 1)']","['import pytest\nfrom thefuck.types import Command\nfrom thefuck.rules.composer_not_command import match, get_new_command\n\n\n@pytest.fixture\ndef composer_not_command():\n    return """"""\n\n                                    \n  [InvalidArgumentException]        \n  Command ""udpate"" is not defined.  \n  Did you mean this?                \n      update\n\n\n""""""\n\n\n@pytest.fixture\ndef composer_not_command_one_of_this():\n    return """"""\n                            \n\n\n  [InvalidArgumentException]       \n  Command ""pdate"" is not defined.  \n  Did you mean one of these?       \n      selfupdate                   \n      self-update                  \n      update                       \n\n\n\n""""""\n\n\ndef test_match(composer_not_command, composer_not_command_one_of_this):\n    assert match(Command(\'composer udpate\', \'\', composer_not_command), None)\n    assert match(Command(\'composer pdate\', \'\', composer_not_command_one_of_this), None)\n    assert not match(Command(\'ls update\', \'\', composer_not_command), None)\n\n\ndef test_get_new_command(composer_not_command, composer_not_command_one_of_this):\n    assert get_new_command(Command(\'composer udpate\', \'\', composer_not_command), None) \\\n           == \'composer update\'\n    assert get_new_command(\n        Command(\'composer pdate\', \'\', composer_not_command_one_of_this), None) == \'composer selfupdate\'\n', 'import re\n\n\ndef match(command, settings):\n    return (\'composer\' in command.script\n            and (\'did you mean this?\' in command.stderr.lower()\n                 or \'did you mean one of these?\' in command.stderr.lower()))\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r""Command \\""([^\']*)\\"" is not defined"", command.stderr)[0]\n    new_cmd = re.findall(r\'Did you mean this\\?[^\\n]*\\n\\s*([^\\n]*)\', command.stderr)\n    if not new_cmd:\n        new_cmd = re.findall(r\'Did you mean one of these\\?[^\\n]*\\n\\s*([^\\n]*)\', command.stderr)\n    return command.script.replace(broken_cmd, new_cmd[0].strip(), 1)']","[[<pydriller.domain.commit.Method object at 0x7f1983e17100>, <pydriller.domain.commit.Method object at 0x7f1983e17f70>, <pydriller.domain.commit.Method object at 0x7f1983e17e20>, <pydriller.domain.commit.Method object at 0x7f1983e17910>], [<pydriller.domain.commit.Method object at 0x7f1983d2e430>, <pydriller.domain.commit.Method object at 0x7f1983d2e190>]]","[[<pydriller.domain.commit.Method object at 0x7f1983e42130>], [<pydriller.domain.commit.Method object at 0x7f1983d51550>, <pydriller.domain.commit.Method object at 0x7f1983d512b0>]]"
thefuck,48ec853436a7e4dd4caa12ccca7dc3ba374f2ae5,Bump to 1.29,2015-04-23 21:50:38+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nVERSION = \'1.28\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.29\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,a454438939e8c021a37ebe081d0b2dd4fef39667,"Fuck, I wanted ls -lah",2015-04-23 20:28:19-04:00,Joseph Henrich,20,0,20,2,"['test_ls_lah.py', 'ls_lah.py']","[None, None]","[""from mock import patch, Mock\nfrom thefuck.rules.ls_lah import match, get_new_command\n\n\ndef test_match():\n        assert match(Mock(script='ls file.py'), None)\n        assert match(Mock(script='ls /opt'), None)\n        assert not match(Mock(script='ls -lah /opt'), None)\n\n\ndef test_get_new_command():\n        assert get_new_command( Mock(script='ls file.py'), None) == 'ls -lah file.py'\n        assert get_new_command( Mock(script='ls'), None) == 'ls -lah'\n"", ""def match(command, settings):\n    return ('ls' in command.script and not ('ls -' in command.script))\n\ndef get_new_command(command, settings):\n    command = command.script.split(' ')\n    command[0] = 'ls -lah'\n    return ' '.join(command)\n""]","[[], []]","[[<pydriller.domain.commit.Method object at 0x7f1983dcfeb0>, <pydriller.domain.commit.Method object at 0x7f1983dcf940>], [<pydriller.domain.commit.Method object at 0x7f1983df8160>, <pydriller.domain.commit.Method object at 0x7f1983df8a90>]]"
thefuck,e55423899613ce62c530774dd02b6ef8d0d50202,#78 Disable when can't import `CommandNotFound`,2015-04-24 05:22:19+02:00,nvbn,19,24,43,1,['apt_get.py'],"['import sys\n\ndef match(command, settings):\n    try:\n        import CommandNotFound\n        if \'not found\' in command.stderr:\n            try:\n                c = CommandNotFound.CommandNotFound()\n                pkgs = c.getPackages(command.script.split("" "")[0])\n                name,_ = pkgs[0]\n                return True\n            except IndexError:\n                # IndexError is thrown when no matching package is found\n                return False\n    except:\n        return False\n\ndef get_new_command(command, settings):\n    try:\n        import CommandNotFound\n        c = CommandNotFound.CommandNotFound()\n        if \'not found\' in command.stderr:\n            pkgs = c.getPackages(command.script.split("" "")[0])\n            name,_ = pkgs[0]\n            return ""sudo apt-get install %s"" % name\n    except:\n        sys.stderr.write(""Can\'t apt fuck\\n"")\n        return """"\n']","['try:\n    import CommandNotFound\nexcept ImportError:\n    enabled_by_default = False\n\n\ndef match(command, settings):\n    if \'not found\' in command.stderr:\n        try:\n            c = CommandNotFound.CommandNotFound()\n            pkgs = c.getPackages(command.script.split("" "")[0])\n            name, _ = pkgs[0]\n            return True\n        except IndexError:\n            # IndexError is thrown when no matching package is found\n            return False\n\n\ndef get_new_command(command, settings):\n    c = CommandNotFound.CommandNotFound()\n    pkgs = c.getPackages(command.script.split("" "")[0])\n    name, _ = pkgs[0]\n    return ""sudo apt-get install {} && {}"".format(name, command.script)\n']","[[<pydriller.domain.commit.Method object at 0x7f1983ef3f70>, <pydriller.domain.commit.Method object at 0x7f1983ef3280>]]","[[<pydriller.domain.commit.Method object at 0x7f1983e34640>, <pydriller.domain.commit.Method object at 0x7f1983e23910>]]"
thefuck,58069f0a3eed25adf64efe8159b8f889dd17b1a1,"conf: initialize a settings file if it doesn't exist (fix #111)

Signed-off-by: Pablo Santiago Blum de Aguiar <scorphus@gmail.com>",2015-04-24 00:38:59-03:00,Pablo Santiago Blum de Aguiar,51,1,52,3,"['test_conf.py', 'conf.py', 'main.py']","[""from mock import patch, Mock\nfrom thefuck.types import Rule\nfrom thefuck import conf\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT_RULES\n    assert Rule('test', None, None, False) not in conf.DEFAULT_RULES\n    assert Rule('test', None, None, False) in (conf.DEFAULT_RULES + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.DEFAULT_SETTINGS.items():\n            assert getattr(conf.get_settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT_RULES + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT_RULES:bash:lisp'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['bash', 'lisp']\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs, types\n\n\nclass _DefaultRulesNames(types.RulesNamesList):\n    def __add__(self, items):\n        return _DefaultRulesNames(list(self) + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRulesNames, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRulesNames):\n            return super(_DefaultRulesNames, self).__eq__(other)\n        else:\n            return False\n\n\nDEFAULT_RULES = _DefaultRulesNames([])\n\n\nDEFAULT_SETTINGS = {\'rules\': DEFAULT_RULES,\n                    \'wait_command\': 3,\n                    \'require_confirmation\': False,\n                    \'no_colors\': False}\n\nENV_TO_ATTR = {\'THEFUCK_RULES\': \'rules\',\n               \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n               \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n               \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n\ndef _settings_from_file(user_dir):\n    """"""Loads settings from file.""""""\n    settings = load_source(\'settings\',\n                           text_type(user_dir.joinpath(\'settings.py\')))\n    return {key: getattr(settings, key)\n            for key in DEFAULT_SETTINGS.keys()\n            if hasattr(settings, key)}\n\n\ndef _rules_from_env(val):\n    """"""Transforms rules list from env-string to python.""""""\n    val = val.split(\':\')\n    if \'DEFAULT_RULES\' in val:\n        val = DEFAULT_RULES + [rule for rule in val if rule != \'DEFAULT_RULES\']\n    return val\n\n\ndef _val_from_env(env, attr):\n    """"""Transforms env-strings to python.""""""\n    val = os.environ[env]\n    if attr == \'rules\':\n        val = _rules_from_env(val)\n    elif attr == \'wait_command\':\n        val = int(val)\n    elif attr in (\'require_confirmation\', \'no_colors\'):\n        val = val.lower() == \'true\'\n    return val\n\n\ndef _settings_from_env():\n    """"""Loads settings from env.""""""\n    return {attr: _val_from_env(env, attr)\n            for env, attr in ENV_TO_ATTR.items()\n            if env in os.environ}\n\n\ndef get_settings(user_dir):\n    """"""Returns settings filled with values from `settings.py` and env.""""""\n    conf = copy(DEFAULT_SETTINGS)\n    try:\n        conf.update(_settings_from_file(user_dir))\n    except Exception:\n        logs.exception(""Can\'t load settings from file"",\n                       sys.exc_info(),\n                       types.Settings(conf))\n\n    try:\n        conf.update(_settings_from_env())\n    except Exception:\n        logs.exception(""Can\'t load settings from env"",\n                       sys.exc_info(),\n                       types.Settings(conf))\n\n    if not isinstance(conf[\'rules\'], types.RulesNamesList):\n        conf[\'rules\'] = types.RulesNamesList(conf[\'rules\'])\n\n    return types.Settings(conf)\n', 'from imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom . import logs, conf, types\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    user_dir.joinpath(\'settings.py\').touch()\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return types.Rule(rule.name[:-3], rule_module.match,\n                      rule_module.get_new_command,\n                      getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent \\\n        .joinpath(\'rules\') \\\n        .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return types.Command(script, result.stdout.read().decode(\'utf-8\'),\n                             result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n']","[""import six\nfrom mock import patch, Mock\nfrom thefuck.types import Rule\nfrom thefuck import conf\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT_RULES\n    assert Rule('test', None, None, False) not in conf.DEFAULT_RULES\n    assert Rule('test', None, None, False) in (conf.DEFAULT_RULES + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.DEFAULT_SETTINGS.items():\n            assert getattr(conf.get_settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT_RULES + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT_RULES:bash:lisp'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['bash', 'lisp']\n\n\ndef test_initialize_settings_file_ignore_if_exists():\n    settings_path_mock = Mock(is_file=Mock(return_value=True), open=Mock())\n    user_dir_mock = Mock(joinpath=Mock(return_value=settings_path_mock))\n    conf.initialize_settings_file(user_dir_mock)\n    assert settings_path_mock.is_file.call_count == 1\n    assert not settings_path_mock.open.called\n\n\ndef test_initialize_settings_file_create_if_exists_not():\n    settings_file = six.StringIO()\n    settings_path_mock = Mock(\n        is_file=Mock(return_value=False),\n        open=Mock(return_value=Mock(\n            __exit__=lambda *args: None, __enter__=lambda *args: settings_file\n        )),\n    )\n    user_dir_mock = Mock(joinpath=Mock(return_value=settings_path_mock))\n    conf.initialize_settings_file(user_dir_mock)\n    settings_file_contents = settings_file.getvalue()\n    assert settings_path_mock.is_file.call_count == 1\n    assert settings_path_mock.open.call_count == 1\n    assert conf.SETTINGS_HEADER in settings_file_contents\n    for setting in conf.DEFAULT_SETTINGS.items():\n        assert '# {} = {}\\n'.format(*setting) in settings_file_contents\n    settings_file.close()\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs, types\n\n\nclass _DefaultRulesNames(types.RulesNamesList):\n    def __add__(self, items):\n        return _DefaultRulesNames(list(self) + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRulesNames, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRulesNames):\n            return super(_DefaultRulesNames, self).__eq__(other)\n        else:\n            return False\n\n\nDEFAULT_RULES = _DefaultRulesNames([])\n\n\nDEFAULT_SETTINGS = {\'rules\': DEFAULT_RULES,\n                    \'wait_command\': 3,\n                    \'require_confirmation\': False,\n                    \'no_colors\': False}\n\nENV_TO_ATTR = {\'THEFUCK_RULES\': \'rules\',\n               \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n               \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n               \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n\nSETTINGS_HEADER = u""""""# ~/.thefuck/settings.py: The Fuck settings file\n#\n# The rules are defined as in the example bellow:\n#\n# rules = [\'cd_parent\', \'git_push\', \'python_command\', \'sudo\']\n#\n# The default values are as follows. Uncomment and change to fit your needs.\n# See https://github.com/nvbn/thefuck#settings for more information.\n#\n\n""""""\n\n\ndef _settings_from_file(user_dir):\n    """"""Loads settings from file.""""""\n    settings = load_source(\'settings\',\n                           text_type(user_dir.joinpath(\'settings.py\')))\n    return {key: getattr(settings, key)\n            for key in DEFAULT_SETTINGS.keys()\n            if hasattr(settings, key)}\n\n\ndef _rules_from_env(val):\n    """"""Transforms rules list from env-string to python.""""""\n    val = val.split(\':\')\n    if \'DEFAULT_RULES\' in val:\n        val = DEFAULT_RULES + [rule for rule in val if rule != \'DEFAULT_RULES\']\n    return val\n\n\ndef _val_from_env(env, attr):\n    """"""Transforms env-strings to python.""""""\n    val = os.environ[env]\n    if attr == \'rules\':\n        val = _rules_from_env(val)\n    elif attr == \'wait_command\':\n        val = int(val)\n    elif attr in (\'require_confirmation\', \'no_colors\'):\n        val = val.lower() == \'true\'\n    return val\n\n\ndef _settings_from_env():\n    """"""Loads settings from env.""""""\n    return {attr: _val_from_env(env, attr)\n            for env, attr in ENV_TO_ATTR.items()\n            if env in os.environ}\n\n\ndef get_settings(user_dir):\n    """"""Returns settings filled with values from `settings.py` and env.""""""\n    conf = copy(DEFAULT_SETTINGS)\n    try:\n        conf.update(_settings_from_file(user_dir))\n    except Exception:\n        logs.exception(""Can\'t load settings from file"",\n                       sys.exc_info(),\n                       types.Settings(conf))\n\n    try:\n        conf.update(_settings_from_env())\n    except Exception:\n        logs.exception(""Can\'t load settings from env"",\n                       sys.exc_info(),\n                       types.Settings(conf))\n\n    if not isinstance(conf[\'rules\'], types.RulesNamesList):\n        conf[\'rules\'] = types.RulesNamesList(conf[\'rules\'])\n\n    return types.Settings(conf)\n\n\ndef initialize_settings_file(user_dir):\n    settings_path = user_dir.joinpath(\'settings.py\')\n    if not settings_path.is_file():\n        with settings_path.open(mode=\'w\') as settings_file:\n            settings_file.write(SETTINGS_HEADER)\n            for setting in DEFAULT_SETTINGS.items():\n                settings_file.write(u\'# {} = {}\\n\'.format(*setting))\n', 'from imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom . import logs, conf, types\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    conf.initialize_settings_file(user_dir)\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return types.Rule(rule.name[:-3], rule_module.match,\n                      rule_module.get_new_command,\n                      getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent \\\n        .joinpath(\'rules\') \\\n        .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return types.Command(script, result.stdout.read().decode(\'utf-8\'),\n                             result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n']","[[<pydriller.domain.commit.Method object at 0x7f1983e68a30>, <pydriller.domain.commit.Method object at 0x7f1983e68520>, <pydriller.domain.commit.Method object at 0x7f1983e68e50>, <pydriller.domain.commit.Method object at 0x7f1983e68fa0>, <pydriller.domain.commit.Method object at 0x7f1983df8190>, <pydriller.domain.commit.Method object at 0x7f1983e1db80>], [<pydriller.domain.commit.Method object at 0x7f1983d6eeb0>, <pydriller.domain.commit.Method object at 0x7f1983d6ebe0>, <pydriller.domain.commit.Method object at 0x7f1983d6ee80>, <pydriller.domain.commit.Method object at 0x7f1983d74040>, <pydriller.domain.commit.Method object at 0x7f1983e09d60>, <pydriller.domain.commit.Method object at 0x7f1983e09040>, <pydriller.domain.commit.Method object at 0x7f1983cf0040>, <pydriller.domain.commit.Method object at 0x7f1983cf0190>], [<pydriller.domain.commit.Method object at 0x7f1983da82b0>, <pydriller.domain.commit.Method object at 0x7f1983da8550>, <pydriller.domain.commit.Method object at 0x7f1983da8be0>, <pydriller.domain.commit.Method object at 0x7f1983da86a0>, <pydriller.domain.commit.Method object at 0x7f1983e3c7c0>, <pydriller.domain.commit.Method object at 0x7f1983e3cb80>, <pydriller.domain.commit.Method object at 0x7f1983e3c130>, <pydriller.domain.commit.Method object at 0x7f1983e3c790>, <pydriller.domain.commit.Method object at 0x7f1983e3c100>, <pydriller.domain.commit.Method object at 0x7f1983da1eb0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983dacac0>, <pydriller.domain.commit.Method object at 0x7f1983dac7f0>], [<pydriller.domain.commit.Method object at 0x7f1983d6e7f0>], [<pydriller.domain.commit.Method object at 0x7f1983d2e550>]]"
thefuck,d12a8bcdd83dc53665b618814ed37a5e32ea05fa,"Added cd_mkdir rule

This fixes #50 and #98.

```bash
$ cd foo/bar/baz
cd: foo: No such file or directory
$ fuck
mkdir -p foo/bar/baz && cd foo/bar/baz
```

Added matchers for both Bash and sh error messages. Depending on your
default shell, the messages might be slightly different.",2015-04-24 08:52:39+02:00,Nils Winkler,34,0,34,3,"['README.md', 'test_cd_mkdir.py', 'cd_mkdir.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nOr using an OS package manager (currently supported in OSX via [brew](http://brew.sh)):\n\n```bash\nbrew install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[2])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck {\n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) {\n        $fuck.substring(5)\n    }\n    else { iex ""$fuck"" }\n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', None, None]","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\nIf it fails try to use `easy_install`:\n\n```bash\nsudo easy_install thefuck\n```\n\nOr using an OS package manager (currently supported in OSX via [brew](http://brew.sh)):\n\n```bash\nbrew install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[2])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck {\n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) {\n        $fuck.substring(5)\n    }\n    else { iex ""$fuck"" }\n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""from mock import Mock\nfrom thefuck.rules.cd_mkdir import match, get_new_command\n\n\ndef test_match():\n    assert match(Mock(script='cd foo', stderr='cd: foo: No such file or directory'),\n                 None)\n    assert match(Mock(script='cd foo/bar/baz', stderr='cd: foo: No such file or directory'),\n                 None)\n    assert match(Mock(script='cd foo/bar/baz', stderr='cd: can\\'t cd to foo/bar/baz'),\n                 None)\n    assert not match(Mock(script='cd foo',\n                          stderr=''), None)\n    assert not match(Mock(script='', stderr=''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Mock(script='cd foo'), None) == 'mkdir -p foo && cd foo'\n    assert get_new_command(Mock(script='cd foo/bar/baz'), None) == 'mkdir -p foo/bar/baz && cd foo/bar/baz'\n"", ""import re\nfrom thefuck.utils import sudo_support\n\n\n@sudo_support\ndef match(command, settings):\n    return (command.script.startswith('cd ')\n        and ('no such file or directory' in command.stderr.lower()\n            or 'cd: can\\'t cd to' in command.stderr.lower()))\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return re.sub(r'^cd (.*)', 'mkdir -p \\\\1 && cd \\\\1', command.script)\n""]","[[], [], []]","[[], [<pydriller.domain.commit.Method object at 0x7f1983dace80>, <pydriller.domain.commit.Method object at 0x7f1983e17d00>], [<pydriller.domain.commit.Method object at 0x7f1983db97f0>, <pydriller.domain.commit.Method object at 0x7f1983db9430>]]"
thefuck,0009fb0588a19bb71450691286fa72eec393f9d5,Bump to 1.30,2015-04-25 02:04:38+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nVERSION = \'1.29\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.30\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,b7cb407637166f9a17c738eb6c2d58977ba5e7cf,Add useful constructors for `Rule` and `Command` for tests,2015-04-25 02:35:26+02:00,nvbn,141,115,256,18,"['test_brew_install.py', 'test_brew_unknown_command.py', 'test_cd_parent.py', 'test_composer_not_command.py', 'test_fix_alt_space.py', 'test_git_not_command.py', 'test_git_push.py', 'test_mkdir_p.py', 'test_pip_unknown_command.py', 'test_python_command.py', 'test_rm_dir.py', 'test_sl_ls.py', 'test_ssh_known_host.py', 'test_sudo.py', 'test_conf.py', 'test_main.py', 'test_utils.py', 'utils.py']","[""import pytest\nfrom thefuck.types import Command\nfrom thefuck.rules.brew_install import match, get_new_command\nfrom thefuck.rules.brew_install import brew_formulas\n\n\n@pytest.fixture\ndef brew_no_available_formula():\n    return '''Error: No available formula for elsticsearch '''\n\n\n@pytest.fixture\ndef brew_install_no_argument():\n    return '''This command requires a formula argument'''\n\n\n@pytest.fixture\ndef brew_already_installed():\n    return '''Warning: git-2.3.5 already installed'''\n\n\ndef _is_not_okay_to_test():\n    if 'elasticsearch' not in brew_formulas:\n        return True\n    return False\n\n\n@pytest.mark.skipif(_is_not_okay_to_test(),\n                    reason='No need to run if there\\'s no formula')\ndef test_match(brew_no_available_formula, brew_already_installed,\n               brew_install_no_argument):\n    assert match(Command('brew install elsticsearch', '',\n                         brew_no_available_formula), None)\n    assert not match(Command('brew install git', '',\n                             brew_already_installed), None)\n    assert not match(Command('brew install', '', brew_install_no_argument),\n                     None)\n\n\n@pytest.mark.skipif(_is_not_okay_to_test(),\n                    reason='No need to run if there\\'s no formula')\ndef test_get_new_command(brew_no_available_formula):\n    assert get_new_command(Command('brew install elsticsearch', '',\n                                   brew_no_available_formula), None)\\\n        == 'brew install elasticsearch'\n\n    assert get_new_command(Command('brew install aa', '',\n                                   brew_no_available_formula),\n                           None) != 'brew install aha'\n"", ""import pytest\nfrom thefuck.types import Command\nfrom thefuck.rules.brew_unknown_command import match, get_new_command\nfrom thefuck.rules.brew_unknown_command import brew_commands\n\n\n@pytest.fixture\ndef brew_unknown_cmd():\n    return '''Error: Unknown command: inst'''\n\n\n@pytest.fixture\ndef brew_unknown_cmd_instaa():\n    return '''Error: Unknown command: instaa'''\n\n\ndef test_match(brew_unknown_cmd):\n    assert match(Command('brew inst', '', brew_unknown_cmd), None)\n    for command in brew_commands:\n        assert not match(Command('brew ' + command, '', ''), None)\n\n\ndef test_get_new_command(brew_unknown_cmd, brew_unknown_cmd_instaa):\n    assert get_new_command(Command('brew inst', '', brew_unknown_cmd), None)\\\n        == 'brew list'\n\n    assert get_new_command(Command('brew instaa', '', brew_unknown_cmd_instaa),\n                           None) == 'brew install'\n"", ""from thefuck.types import Command\nfrom thefuck.rules.cd_parent import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('cd..', '', 'cd..: command not found'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(\n        Command('cd..', '', ''), None) == 'cd ..'\n"", 'import pytest\nfrom thefuck.types import Command\nfrom thefuck.rules.composer_not_command import match, get_new_command\n\n\n@pytest.fixture\ndef composer_not_command():\n    return """"""\n\n                                    \n  [InvalidArgumentException]        \n  Command ""udpate"" is not defined.  \n  Did you mean this?                \n      update\n\n\n""""""\n\n\n@pytest.fixture\ndef composer_not_command_one_of_this():\n    return """"""\n                            \n\n\n  [InvalidArgumentException]       \n  Command ""pdate"" is not defined.  \n  Did you mean one of these?       \n      selfupdate                   \n      self-update                  \n      update                       \n\n\n\n""""""\n\n\ndef test_match(composer_not_command, composer_not_command_one_of_this):\n    assert match(Command(\'composer udpate\', \'\', composer_not_command), None)\n    assert match(Command(\'composer pdate\', \'\', composer_not_command_one_of_this), None)\n    assert not match(Command(\'ls update\', \'\', composer_not_command), None)\n\n\ndef test_get_new_command(composer_not_command, composer_not_command_one_of_this):\n    assert get_new_command(Command(\'composer udpate\', \'\', composer_not_command), None) \\\n           == \'composer update\'\n    assert get_new_command(\n        Command(\'composer pdate\', \'\', composer_not_command_one_of_this), None) == \'composer selfupdate\'\n', '# -*- encoding: utf-8 -*-\n\n\nfrom thefuck.types import Command\nfrom thefuck.rules.fix_alt_space import match, get_new_command\n\n\ndef test_match():\n    """""" The character before \'grep\' is Alt+Space, which happens frequently on the Mac when typing\n        the pipe character (Alt+7), and holding the Alt key pressed for longer than necessary. """"""\n    assert match(Command(u\'ps -ef |\xa0grep foo\', \'\', u\'-bash: \xa0grep: command not found\'), None)\n    assert not match(Command(\'ps -ef | grep foo\', \'\', \'\'), None)\n    assert not match(Command(\'\', \'\', \'\'), None)\n\n\ndef test_get_new_command():\n    """""" Replace the Alt+Space character by a simple space """"""\n    assert get_new_command(Command(u\'ps -ef |\xa0grep foo\', \'\', \'\'), None) == \'ps -ef | grep foo\'\n', 'import pytest\nfrom thefuck.types import Command\nfrom thefuck.rules.git_not_command import match, get_new_command\n\n\n@pytest.fixture\ndef git_not_command():\n    return """"""git: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\nbranch\n""""""\n\n\n@pytest.fixture\ndef git_not_command_one_of_this():\n    return """"""git: \'st\' is not a git command. See \'git --help\'.\n\nDid you mean one of these?\nstatus\nreset\nstage\nstash\nstats\n""""""\n\n\n@pytest.fixture\ndef git_command():\n    return ""* master""\n\n\ndef test_match(git_not_command, git_command, git_not_command_one_of_this):\n    assert match(Command(\'git brnch\', \'\', git_not_command), None)\n    assert match(Command(\'git st\', \'\', git_not_command_one_of_this), None)\n    assert not match(Command(\'ls brnch\', \'\', git_not_command), None)\n    assert not match(Command(\'git branch\', \'\', git_command), None)\n\n\ndef test_get_new_command(git_not_command, git_not_command_one_of_this):\n    assert get_new_command(Command(\'git brnch\', \'\', git_not_command), None)\\\n        == \'git branch\'\n    assert get_new_command(\n        Command(\'git st\', \'\', git_not_command_one_of_this), None) == \'git status\'\n', 'import pytest\nfrom thefuck.types import Command\nfrom thefuck.rules.git_push import match, get_new_command\n\n\n@pytest.fixture\ndef stderr():\n    return \'\'\'fatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\'\'\'\n\n\ndef test_match(stderr):\n    assert match(Command(\'git push master\', \'\', stderr), None)\n    assert not match(Command(\'git push master\', \'\', \'\'), None)\n    assert not match(Command(\'ls\', \'\', stderr), None)\n\n\ndef test_get_new_command(stderr):\n    assert get_new_command(Command(\'\', \'\', stderr), None)\\\n        == ""git push --set-upstream origin master""\n', ""from thefuck.types import Command\nfrom thefuck.rules.mkdir_p import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('mkdir foo/bar/baz', '', 'mkdir: foo/bar: No such file or directory'), None)\n    assert not match(Command('mkdir foo/bar/baz', '', ''), None)\n    assert not match(Command('mkdir foo/bar/baz', '', 'foo bar baz'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('mkdir foo/bar/baz', '', ''), None) == 'mkdir -p foo/bar/baz'\n"", 'import pytest\nfrom thefuck.types import Command\nfrom thefuck.rules.pip_unknown_command import match, get_new_command\n\n\n@pytest.fixture\ndef pip_unknown_cmd():\n    return \'\'\'ERROR: unknown command ""instatl"" - maybe you meant ""install""\'\'\'\n\n\n@pytest.fixture\ndef pip_unknown_cmd_without_recommend():\n    return \'\'\'ERROR: unknown command ""i""\'\'\'\n\n\ndef test_match(pip_unknown_cmd, pip_unknown_cmd_without_recommend):\n    assert match(Command(\'pip instatl\', \'\', pip_unknown_cmd), None)\n    assert not match(Command(\'pip i\', \'\', pip_unknown_cmd_without_recommend),\n                     None)\n\n\ndef test_get_new_command(pip_unknown_cmd):\n    assert get_new_command(Command(\'pip instatl\', \'\', pip_unknown_cmd), None)\\\n        == \'pip install\'\n', ""from thefuck.types import Command\nfrom thefuck.rules.python_command import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('temp.py', '', 'Permission denied'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('./test_sudo.py', '', ''), None) == 'python ./test_sudo.py'\n"", ""from thefuck.types import Command\nfrom thefuck.rules.rm_dir import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('rm foo', '', 'rm: foo: is a directory'), None)\n    assert match(Command('rm foo', '', 'rm: foo: Is a directory'), None)\n    assert not match(Command('rm foo', '', ''), None)\n    assert not match(Command('rm foo', '', 'foo bar baz'), None)\n    assert not match(Command('', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('rm foo', '', ''), None) == 'rm -rf foo'\n"", ""\nfrom thefuck.types import Command\nfrom thefuck.rules.sl_ls import match, get_new_command\n\n\ndef test_match():\n    assert match(Command('sl', '', ''), None)\n    assert not match(Command('ls', '', ''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('sl', '', ''), None) == 'ls'\n"", 'import os\nimport pytest\nfrom mock import Mock\nfrom thefuck.types import Command\nfrom thefuck.rules.ssh_known_hosts import match, get_new_command, remove_offending_keys\n\n\n@pytest.fixture\ndef ssh_error(tmpdir):\n    path = os.path.join(str(tmpdir), \'known_hosts\')\n\n    def reset(path):\n        with open(path, \'w\') as fh:\n            lines = [\n                \'123.234.567.890 asdjkasjdakjsd\\n\'\n                \'98.765.432.321 ejioweojwejrosj\\n\'\n                \'111.222.333.444 qwepoiwqepoiss\\n\'\n            ]\n            fh.writelines(lines)\n\n    def known_hosts(path):\n        with open(path, \'r\') as fh:\n            return fh.readlines()\n\n    reset(path)\n\n    errormsg = u""""""@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\nb6:cb:07:34:c0:a0:94:d3:0d:69:83:31:f4:c5:20:9b.\nPlease contact your system administrator.\nAdd correct host key in {0} to get rid of this message.\nOffending RSA key in {0}:2\nRSA host key for {1} has changed and you have requested strict checking.\nHost key verification failed."""""".format(path, \'98.765.432.321\')\n\n    return errormsg, path, reset, known_hosts\n\n\ndef test_match(ssh_error):\n    errormsg, _, _, _ = ssh_error\n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'ssh\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert match(Command(\'scp something something\', \'\', errormsg), None)\n    assert not match(Command(\'\', \'\', errormsg), None)\n    assert not match(Command(\'notssh\', \'\', errormsg), None)\n    assert not match(Command(\'ssh\', \'\', \'\'), None)\n\n\ndef test_remove_offending_keys(ssh_error):\n    errormsg, path, reset, known_hosts = ssh_error\n    command = Command(\'ssh user@host\', \'\', errormsg)\n    remove_offending_keys(command, None)\n    expected = [\'123.234.567.890 asdjkasjdakjsd\\n\', \'111.222.333.444 qwepoiwqepoiss\\n\']\n    assert known_hosts(path) == expected\n\n\ndef test_get_new_command(ssh_error, monkeypatch):\n    errormsg, _, _, _ = ssh_error\n\n    method = Mock()\n    monkeypatch.setattr(\'thefuck.rules.ssh_known_hosts.remove_offending_keys\', method)\n    assert get_new_command(Command(\'ssh user@host\', \'\', errormsg), None) == \'ssh user@host\'\n    assert method.call_count\n', 'from thefuck.types import Command\nfrom thefuck.rules.sudo import match, get_new_command\n\n\ndef test_match():\n    assert match(Command(\'\', \'\', \'Permission denied\'), None)\n    assert match(Command(\'\', \'\', \'permission denied\'), None)\n    assert match(Command(\'\', \'\', ""npm ERR! Error: EACCES, unlink""), None)\n    assert not match(Command(\'\', \'\', \'\'), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command(\'ls\', \'\', \'\'), None) == \'sudo ls\'\n', ""import six\nfrom mock import patch, Mock\nfrom thefuck.types import Rule\nfrom thefuck import conf\n\n\ndef test_default():\n    assert Rule('test', None, None, True) in conf.DEFAULT_RULES\n    assert Rule('test', None, None, False) not in conf.DEFAULT_RULES\n    assert Rule('test', None, None, False) in (conf.DEFAULT_RULES + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.DEFAULT_SETTINGS.items():\n            assert getattr(conf.get_settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT_RULES + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT_RULES:bash:lisp'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['bash', 'lisp']\n\n\ndef test_initialize_settings_file_ignore_if_exists():\n    settings_path_mock = Mock(is_file=Mock(return_value=True), open=Mock())\n    user_dir_mock = Mock(joinpath=Mock(return_value=settings_path_mock))\n    conf.initialize_settings_file(user_dir_mock)\n    assert settings_path_mock.is_file.call_count == 1\n    assert not settings_path_mock.open.called\n\n\ndef test_initialize_settings_file_create_if_exists_not():\n    settings_file = six.StringIO()\n    settings_path_mock = Mock(\n        is_file=Mock(return_value=False),\n        open=Mock(return_value=Mock(\n            __exit__=lambda *args: None, __enter__=lambda *args: settings_file\n        )),\n    )\n    user_dir_mock = Mock(joinpath=Mock(return_value=settings_path_mock))\n    conf.initialize_settings_file(user_dir_mock)\n    settings_file_contents = settings_file.getvalue()\n    assert settings_path_mock.is_file.call_count == 1\n    assert settings_path_mock.open.call_count == 1\n    assert conf.SETTINGS_HEADER in settings_file_contents\n    for setting in conf.DEFAULT_SETTINGS.items():\n        assert '# {} = {}\\n'.format(*setting) in settings_file_contents\n    settings_file.close()\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main, conf, types\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == types.Rule('bash', match, get_new_command, True)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.DEFAULT_RULES))) \\\n               == [types.Rule('bash', 'bash', 'bash', True),\n                   types.Rule('lisp', 'lisp', 'lisp', True),\n                   types.Rule('bash', 'bash', 'bash', True),\n                   types.Rule('lisp', 'lisp', 'lisp', True)]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=types.RulesNamesList(['bash'])))) \\\n               == [types.Rule('bash', 'bash', 'bash', True),\n                   types.Rule('bash', 'bash', 'bash', True)]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == types.Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [types.Rule('', lambda x, _: x.script == 'cd ..', None, True),\n             types.Rule('', lambda *_: False, None, True),\n             types.Rule('rule', Mock(side_effect=OSError('Denied')), None, True)]\n    assert main.get_matched_rule(types.Command('ls', '', ''),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(types.Command('cd ..', '', ''),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(types.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(types.Rule('', None, lambda *_: 'new-command', True),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", ""from mock import Mock\nfrom thefuck.utils import sudo_support, wrap_settings\nfrom thefuck.types import Command, Settings\n\n\ndef test_wrap_settings():\n    fn = lambda _, settings: settings\n    assert wrap_settings({'key': 'val'})(fn)(None, Settings({})) \\\n           == {'key': 'val'}\n    assert wrap_settings({'key': 'new-val'})(fn)(\n        None, Settings({'key': 'val'})) == {'key': 'new-val'}\n\n\ndef test_sudo_support():\n    fn = Mock(return_value=True, __name__='')\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n    fn.assert_called_once_with(Command('ls', 'out', 'err'), None)\n\n    fn.return_value = False\n    assert not sudo_support(fn)(Command('sudo ls', 'out', 'err'), None)\n\n    fn.return_value = 'pwd'\n    assert sudo_support(fn)(Command('sudo ls', 'out', 'err'), None) == 'sudo pwd'\n\n    assert sudo_support(fn)(Command('ls', 'out', 'err'), None) == 'pwd'\n"", None]","[""import pytest\nfrom thefuck.rules.brew_install import match, get_new_command\nfrom thefuck.rules.brew_install import brew_formulas\nfrom tests.utils import Command\n\n\n@pytest.fixture\ndef brew_no_available_formula():\n    return '''Error: No available formula for elsticsearch '''\n\n\n@pytest.fixture\ndef brew_install_no_argument():\n    return '''This command requires a formula argument'''\n\n\n@pytest.fixture\ndef brew_already_installed():\n    return '''Warning: git-2.3.5 already installed'''\n\n\ndef _is_not_okay_to_test():\n    if 'elasticsearch' not in brew_formulas:\n        return True\n    return False\n\n\n@pytest.mark.skipif(_is_not_okay_to_test(),\n                    reason='No need to run if there\\'s no formula')\ndef test_match(brew_no_available_formula, brew_already_installed,\n               brew_install_no_argument):\n    assert match(Command('brew install elsticsearch',\n                         stderr=brew_no_available_formula), None)\n    assert not match(Command('brew install git',\n                             stderr=brew_already_installed), None)\n    assert not match(Command('brew install', stderr=brew_install_no_argument),\n                     None)\n\n\n@pytest.mark.skipif(_is_not_okay_to_test(),\n                    reason='No need to run if there\\'s no formula')\ndef test_get_new_command(brew_no_available_formula):\n    assert get_new_command(Command('brew install elsticsearch',\n                                   stderr=brew_no_available_formula), None)\\\n        == 'brew install elasticsearch'\n\n    assert get_new_command(Command('brew install aa',\n                                   stderr=brew_no_available_formula),\n                           None) != 'brew install aha'\n"", ""import pytest\nfrom thefuck.rules.brew_unknown_command import match, get_new_command\nfrom thefuck.rules.brew_unknown_command import brew_commands\nfrom tests.utils import Command\n\n\n@pytest.fixture\ndef brew_unknown_cmd():\n    return '''Error: Unknown command: inst'''\n\n\n@pytest.fixture\ndef brew_unknown_cmd_instaa():\n    return '''Error: Unknown command: instaa'''\n\n\ndef test_match(brew_unknown_cmd):\n    assert match(Command('brew inst', stderr=brew_unknown_cmd), None)\n    for command in brew_commands:\n        assert not match(Command('brew ' + command), None)\n\n\ndef test_get_new_command(brew_unknown_cmd, brew_unknown_cmd_instaa):\n    assert get_new_command(Command('brew inst', stderr=brew_unknown_cmd), None)\\\n        == 'brew list'\n\n    assert get_new_command(Command('brew instaa', stderr=brew_unknown_cmd_instaa),\n                           None) == 'brew install'\n"", ""from thefuck.rules.cd_parent import match, get_new_command\nfrom tests.utils import Command\n\n\ndef test_match():\n    assert match(Command('cd..', stderr='cd..: command not found'), None)\n    assert not match(Command(), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(\n        Command('cd..'), None) == 'cd ..'\n"", 'import pytest\nfrom thefuck.rules.composer_not_command import match, get_new_command\nfrom tests.utils import Command\n\n\n@pytest.fixture\ndef composer_not_command():\n    return """"""\n\n                                    \n  [InvalidArgumentException]        \n  Command ""udpate"" is not defined.  \n  Did you mean this?                \n      update\n\n\n""""""\n\n\n@pytest.fixture\ndef composer_not_command_one_of_this():\n    return """"""\n                            \n\n\n  [InvalidArgumentException]       \n  Command ""pdate"" is not defined.  \n  Did you mean one of these?       \n      selfupdate                   \n      self-update                  \n      update                       \n\n\n\n""""""\n\n\ndef test_match(composer_not_command, composer_not_command_one_of_this):\n    assert match(Command(\'composer udpate\',\n                         stderr=composer_not_command), None)\n    assert match(Command(\'composer pdate\',\n                         stderr=composer_not_command_one_of_this), None)\n    assert not match(Command(\'ls update\', stderr=composer_not_command),\n                     None)\n\n\ndef test_get_new_command(composer_not_command, composer_not_command_one_of_this):\n    assert get_new_command(Command(\'composer udpate\',\n                                   stderr=composer_not_command), None) \\\n           == \'composer update\'\n    assert get_new_command(\n        Command(\'composer pdate\', stderr=composer_not_command_one_of_this),\n        None) == \'composer selfupdate\'\n', 'from thefuck.rules.fix_alt_space import match, get_new_command\nfrom tests.utils import Command\n\n\ndef test_match():\n    """"""The character before \'grep\' is Alt+Space, which happens frequently\n    on the Mac when typing the pipe character (Alt+7), and holding the Alt\n    key pressed for longer than necessary.\n\n    """"""\n    assert match(Command(u\'ps -ef |\xa0grep foo\',\n                         stderr=u\'-bash: \xa0grep: command not found\'), None)\n    assert not match(Command(\'ps -ef | grep foo\'), None)\n    assert not match(Command(), None)\n\n\ndef test_get_new_command():\n    """""" Replace the Alt+Space character by a simple space """"""\n    assert get_new_command(Command(u\'ps -ef |\xa0grep foo\'), None)\\\n           == \'ps -ef | grep foo\'\n', 'import pytest\nfrom thefuck.rules.git_not_command import match, get_new_command\nfrom tests.utils import Command\n\n\n@pytest.fixture\ndef git_not_command():\n    return """"""git: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\nbranch\n""""""\n\n\n@pytest.fixture\ndef git_not_command_one_of_this():\n    return """"""git: \'st\' is not a git command. See \'git --help\'.\n\nDid you mean one of these?\nstatus\nreset\nstage\nstash\nstats\n""""""\n\n\n@pytest.fixture\ndef git_command():\n    return ""* master""\n\n\ndef test_match(git_not_command, git_command, git_not_command_one_of_this):\n    assert match(Command(\'git brnch\', stderr=git_not_command), None)\n    assert match(Command(\'git st\', stderr=git_not_command_one_of_this), None)\n    assert not match(Command(\'ls brnch\', stderr=git_not_command), None)\n    assert not match(Command(\'git branch\', stderr=git_command), None)\n\n\ndef test_get_new_command(git_not_command, git_not_command_one_of_this):\n    assert get_new_command(Command(\'git brnch\', stderr=git_not_command), None)\\\n        == \'git branch\'\n    assert get_new_command(Command(\'git st\', stderr=git_not_command_one_of_this),\n                           None) == \'git status\'\n', 'import pytest\nfrom thefuck.rules.git_push import match, get_new_command\nfrom tests.utils import Command\n\n\n@pytest.fixture\ndef stderr():\n    return \'\'\'fatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\'\'\'\n\n\ndef test_match(stderr):\n    assert match(Command(\'git push master\', stderr=stderr), None)\n    assert not match(Command(\'git push master\'), None)\n    assert not match(Command(\'ls\', stderr=stderr), None)\n\n\ndef test_get_new_command(stderr):\n    assert get_new_command(Command(stderr=stderr), None)\\\n        == ""git push --set-upstream origin master""\n', ""from thefuck.rules.mkdir_p import match, get_new_command\nfrom tests.utils import Command\n\n\ndef test_match():\n    assert match(Command('mkdir foo/bar/baz',\n                         stderr='mkdir: foo/bar: No such file or directory'),\n                 None)\n    assert not match(Command('mkdir foo/bar/baz'), None)\n    assert not match(Command('mkdir foo/bar/baz', stderr='foo bar baz'), None)\n    assert not match(Command(), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('mkdir foo/bar/baz'), None)\\\n           == 'mkdir -p foo/bar/baz'\n"", 'import pytest\nfrom thefuck.rules.pip_unknown_command import match, get_new_command\nfrom tests.utils import Command\n\n\n@pytest.fixture\ndef pip_unknown_cmd():\n    return \'\'\'ERROR: unknown command ""instatl"" - maybe you meant ""install""\'\'\'\n\n\n@pytest.fixture\ndef pip_unknown_cmd_without_recommend():\n    return \'\'\'ERROR: unknown command ""i""\'\'\'\n\n\ndef test_match(pip_unknown_cmd, pip_unknown_cmd_without_recommend):\n    assert match(Command(\'pip instatl\', stderr=pip_unknown_cmd), None)\n    assert not match(Command(\'pip i\',\n                             stderr=pip_unknown_cmd_without_recommend),\n                     None)\n\n\ndef test_get_new_command(pip_unknown_cmd):\n    assert get_new_command(Command(\'pip instatl\', stderr=pip_unknown_cmd),\n                           None) == \'pip install\'\n', ""from thefuck.rules.python_command import match, get_new_command\nfrom tests.utils import Command\n\n\ndef test_match():\n    assert match(Command('temp.py', stderr='Permission denied'), None)\n    assert not match(Command(), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('./test_sudo.py'), None)\\\n           == 'python ./test_sudo.py'\n"", ""from thefuck.rules.rm_dir import match, get_new_command\nfrom tests.utils import Command\n\n\ndef test_match():\n    assert match(Command('rm foo', stderr='rm: foo: is a directory'), None)\n    assert match(Command('rm foo', stderr='rm: foo: Is a directory'), None)\n    assert not match(Command('rm foo'), None)\n    assert not match(Command('rm foo', stderr='foo bar baz'), None)\n    assert not match(Command(), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('rm foo', '', ''), None) == 'rm -rf foo'\n"", ""\nfrom thefuck.rules.sl_ls import match, get_new_command\nfrom tests.utils import Command\n\n\ndef test_match():\n    assert match(Command('sl'), None)\n    assert not match(Command('ls'), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('sl'), None) == 'ls'\n"", 'import os\nimport pytest\nfrom mock import Mock\nfrom thefuck.rules.ssh_known_hosts import match, get_new_command,\\\n    remove_offending_keys\nfrom tests.utils import Command\n\n\n@pytest.fixture\ndef ssh_error(tmpdir):\n    path = os.path.join(str(tmpdir), \'known_hosts\')\n\n    def reset(path):\n        with open(path, \'w\') as fh:\n            lines = [\n                \'123.234.567.890 asdjkasjdakjsd\\n\'\n                \'98.765.432.321 ejioweojwejrosj\\n\'\n                \'111.222.333.444 qwepoiwqepoiss\\n\'\n            ]\n            fh.writelines(lines)\n\n    def known_hosts(path):\n        with open(path, \'r\') as fh:\n            return fh.readlines()\n\n    reset(path)\n\n    errormsg = u""""""@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\nb6:cb:07:34:c0:a0:94:d3:0d:69:83:31:f4:c5:20:9b.\nPlease contact your system administrator.\nAdd correct host key in {0} to get rid of this message.\nOffending RSA key in {0}:2\nRSA host key for {1} has changed and you have requested strict checking.\nHost key verification failed."""""".format(path, \'98.765.432.321\')\n\n    return errormsg, path, reset, known_hosts\n\n\ndef test_match(ssh_error):\n    errormsg, _, _, _ = ssh_error\n    assert match(Command(\'ssh\', stderr=errormsg), None)\n    assert match(Command(\'ssh\', stderr=errormsg), None)\n    assert match(Command(\'scp something something\', stderr=errormsg), None)\n    assert match(Command(\'scp something something\', stderr=errormsg), None)\n    assert not match(Command(stderr=errormsg), None)\n    assert not match(Command(\'notssh\', stderr=errormsg), None)\n    assert not match(Command(\'ssh\'), None)\n\n\ndef test_remove_offending_keys(ssh_error):\n    errormsg, path, reset, known_hosts = ssh_error\n    command = Command(\'ssh user@host\', stderr=errormsg)\n    remove_offending_keys(command, None)\n    expected = [\'123.234.567.890 asdjkasjdakjsd\\n\', \'111.222.333.444 qwepoiwqepoiss\\n\']\n    assert known_hosts(path) == expected\n\n\ndef test_get_new_command(ssh_error, monkeypatch):\n    errormsg, _, _, _ = ssh_error\n\n    method = Mock()\n    monkeypatch.setattr(\'thefuck.rules.ssh_known_hosts.remove_offending_keys\', method)\n    assert get_new_command(Command(\'ssh user@host\', stderr=errormsg), None) == \'ssh user@host\'\n    assert method.call_count\n', 'from thefuck.rules.sudo import match, get_new_command\nfrom tests.utils import Command\n\n\ndef test_match():\n    assert match(Command(stderr=\'Permission denied\'), None)\n    assert match(Command(stderr=\'permission denied\'), None)\n    assert match(Command(stderr=""npm ERR! Error: EACCES, unlink""), None)\n    assert not match(Command(), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command(\'ls\'), None) == \'sudo ls\'\n', ""import six\nfrom mock import patch, Mock\nfrom thefuck import conf\nfrom tests.utils import Rule\n\n\ndef test_default():\n    assert Rule('test', enabled_by_default=True) in conf.DEFAULT_RULES\n    assert Rule('test', enabled_by_default=False) not in conf.DEFAULT_RULES\n    assert Rule('test', enabled_by_default=False) in (conf.DEFAULT_RULES + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.DEFAULT_SETTINGS.items():\n            assert getattr(conf.get_settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT_RULES + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT_RULES:bash:lisp'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['bash', 'lisp']\n\n\ndef test_initialize_settings_file_ignore_if_exists():\n    settings_path_mock = Mock(is_file=Mock(return_value=True), open=Mock())\n    user_dir_mock = Mock(joinpath=Mock(return_value=settings_path_mock))\n    conf.initialize_settings_file(user_dir_mock)\n    assert settings_path_mock.is_file.call_count == 1\n    assert not settings_path_mock.open.called\n\n\ndef test_initialize_settings_file_create_if_exists_not():\n    settings_file = six.StringIO()\n    settings_path_mock = Mock(\n        is_file=Mock(return_value=False),\n        open=Mock(return_value=Mock(\n            __exit__=lambda *args: None, __enter__=lambda *args: settings_file\n        )),\n    )\n    user_dir_mock = Mock(joinpath=Mock(return_value=settings_path_mock))\n    conf.initialize_settings_file(user_dir_mock)\n    settings_file_contents = settings_file.getvalue()\n    assert settings_path_mock.is_file.call_count == 1\n    assert settings_path_mock.open.call_count == 1\n    assert conf.SETTINGS_HEADER in settings_file_contents\n    for setting in conf.DEFAULT_SETTINGS.items():\n        assert '# {} = {}\\n'.format(*setting) in settings_file_contents\n    settings_file.close()\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main, conf, types\nfrom tests.utils import Rule, Command\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == Rule('bash', match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.DEFAULT_RULES))) \\\n               == [Rule('bash', 'bash', 'bash'),\n                   Rule('lisp', 'lisp', 'lisp'),\n                   Rule('bash', 'bash', 'bash'),\n                   Rule('lisp', 'lisp', 'lisp')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=types.RulesNamesList(['bash'])))) \\\n               == [Rule('bash', 'bash', 'bash'),\n                   Rule('bash', 'bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [Rule('', lambda x, _: x.script == 'cd ..'),\n             Rule('', lambda *_: False),\n             Rule('rule', Mock(side_effect=OSError('Denied')))]\n    assert main.get_matched_rule(Command('ls'),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(Command('cd ..'),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", ""from mock import Mock\nfrom thefuck.utils import sudo_support, wrap_settings\nfrom thefuck.types import Settings\nfrom tests.utils import Command\n\n\ndef test_wrap_settings():\n    fn = lambda _, settings: settings\n    assert wrap_settings({'key': 'val'})(fn)(None, Settings({})) \\\n           == {'key': 'val'}\n    assert wrap_settings({'key': 'new-val'})(fn)(\n        None, Settings({'key': 'val'})) == {'key': 'new-val'}\n\n\ndef test_sudo_support():\n    fn = Mock(return_value=True, __name__='')\n    assert sudo_support(fn)(Command('sudo ls'), None)\n    fn.assert_called_once_with(Command('ls'), None)\n\n    fn.return_value = False\n    assert not sudo_support(fn)(Command('sudo ls'), None)\n\n    fn.return_value = 'pwd'\n    assert sudo_support(fn)(Command('sudo ls'), None) == 'sudo pwd'\n\n    assert sudo_support(fn)(Command('ls'), None) == 'pwd'\n"", ""from thefuck import types\n\n\ndef Command(script='', stdout='', stderr=''):\n    return types.Command(script, stdout, stderr)\n\n\ndef Rule(name='', match=lambda *_: True,\n         get_new_command=lambda *_: '',\n         enabled_by_default=True):\n    return types.Rule(name, match, get_new_command, enabled_by_default)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983d1c160>, <pydriller.domain.commit.Method object at 0x7f1983d1cbe0>, <pydriller.domain.commit.Method object at 0x7f1983d1c2b0>, <pydriller.domain.commit.Method object at 0x7f1983e42280>, <pydriller.domain.commit.Method object at 0x7f1983e96f70>, <pydriller.domain.commit.Method object at 0x7f1983e904f0>], [<pydriller.domain.commit.Method object at 0x7f1983e5ce50>, <pydriller.domain.commit.Method object at 0x7f1983e5cbb0>, <pydriller.domain.commit.Method object at 0x7f1983e5c640>, <pydriller.domain.commit.Method object at 0x7f1983e5c910>], [<pydriller.domain.commit.Method object at 0x7f1983ee0910>, <pydriller.domain.commit.Method object at 0x7f1983ee08e0>], [<pydriller.domain.commit.Method object at 0x7f1983e74640>, <pydriller.domain.commit.Method object at 0x7f1983e74fa0>, <pydriller.domain.commit.Method object at 0x7f1983e74250>, <pydriller.domain.commit.Method object at 0x7f1983e51100>], [<pydriller.domain.commit.Method object at 0x7f1983e2e100>, <pydriller.domain.commit.Method object at 0x7f1983e2ea30>], [<pydriller.domain.commit.Method object at 0x7f1983d51d60>, <pydriller.domain.commit.Method object at 0x7f1983d51400>, <pydriller.domain.commit.Method object at 0x7f1983d51040>, <pydriller.domain.commit.Method object at 0x7f1983d51190>, <pydriller.domain.commit.Method object at 0x7f1983d6e940>], [<pydriller.domain.commit.Method object at 0x7f1983dc5d60>, <pydriller.domain.commit.Method object at 0x7f1983e1d280>, <pydriller.domain.commit.Method object at 0x7f1983e34a30>], [<pydriller.domain.commit.Method object at 0x7f1983dd56a0>, <pydriller.domain.commit.Method object at 0x7f1983e23e50>], [<pydriller.domain.commit.Method object at 0x7f1983e29790>, <pydriller.domain.commit.Method object at 0x7f1983e81b80>, <pydriller.domain.commit.Method object at 0x7f1983e81a30>, <pydriller.domain.commit.Method object at 0x7f1983e818e0>], [<pydriller.domain.commit.Method object at 0x7f1983ed5bb0>, <pydriller.domain.commit.Method object at 0x7f1983ed5100>], [<pydriller.domain.commit.Method object at 0x7f1983deb190>, <pydriller.domain.commit.Method object at 0x7f1983debe80>], [<pydriller.domain.commit.Method object at 0x7f1983e1d250>, <pydriller.domain.commit.Method object at 0x7f1983e1dcd0>], [<pydriller.domain.commit.Method object at 0x7f1983e17bb0>, <pydriller.domain.commit.Method object at 0x7f1983e173a0>, <pydriller.domain.commit.Method object at 0x7f1983da8d60>, <pydriller.domain.commit.Method object at 0x7f1983da86d0>, <pydriller.domain.commit.Method object at 0x7f1983e9c130>, <pydriller.domain.commit.Method object at 0x7f1983e9cfa0>], [<pydriller.domain.commit.Method object at 0x7f1983e51640>, <pydriller.domain.commit.Method object at 0x7f1983d9c580>], [<pydriller.domain.commit.Method object at 0x7f1983e4bd00>, <pydriller.domain.commit.Method object at 0x7f1983e4b250>, <pydriller.domain.commit.Method object at 0x7f1983e4b280>, <pydriller.domain.commit.Method object at 0x7f1983e4b670>, <pydriller.domain.commit.Method object at 0x7f1983e90cd0>, <pydriller.domain.commit.Method object at 0x7f1983e908e0>, <pydriller.domain.commit.Method object at 0x7f1983e903a0>, <pydriller.domain.commit.Method object at 0x7f1983e90e20>], [<pydriller.domain.commit.Method object at 0x7f1983edce20>, <pydriller.domain.commit.Method object at 0x7f1983edc130>, <pydriller.domain.commit.Method object at 0x7f1983edce50>, <pydriller.domain.commit.Method object at 0x7f1983edcf70>, <pydriller.domain.commit.Method object at 0x7f1983db1be0>, <pydriller.domain.commit.Method object at 0x7f1983db1400>], [<pydriller.domain.commit.Method object at 0x7f1983efed00>, <pydriller.domain.commit.Method object at 0x7f1983efe100>], []]","[[<pydriller.domain.commit.Method object at 0x7f1983d2e6a0>, <pydriller.domain.commit.Method object at 0x7f1983d2e160>], [<pydriller.domain.commit.Method object at 0x7f1983ea2bb0>, <pydriller.domain.commit.Method object at 0x7f1983ea2f70>], [<pydriller.domain.commit.Method object at 0x7f1983ea8e20>, <pydriller.domain.commit.Method object at 0x7f1983ea8b80>], [<pydriller.domain.commit.Method object at 0x7f1983d9ceb0>, <pydriller.domain.commit.Method object at 0x7f1983d9cd30>], [<pydriller.domain.commit.Method object at 0x7f1983e51280>, <pydriller.domain.commit.Method object at 0x7f1983e51130>], [<pydriller.domain.commit.Method object at 0x7f1983e9c3d0>, <pydriller.domain.commit.Method object at 0x7f1983e9cb80>], [<pydriller.domain.commit.Method object at 0x7f1983ddb580>, <pydriller.domain.commit.Method object at 0x7f1983e09430>], [<pydriller.domain.commit.Method object at 0x7f1983e62f70>, <pydriller.domain.commit.Method object at 0x7f1983e623a0>], [<pydriller.domain.commit.Method object at 0x7f1983dac820>, <pydriller.domain.commit.Method object at 0x7f1983dac400>], [<pydriller.domain.commit.Method object at 0x7f1983ed53a0>, <pydriller.domain.commit.Method object at 0x7f1983ed58e0>], [<pydriller.domain.commit.Method object at 0x7f1983e813a0>], [<pydriller.domain.commit.Method object at 0x7f1983e62250>, <pydriller.domain.commit.Method object at 0x7f1983e23640>], [<pydriller.domain.commit.Method object at 0x7f1983d51be0>, <pydriller.domain.commit.Method object at 0x7f1983d51eb0>, <pydriller.domain.commit.Method object at 0x7f1983d10040>], [<pydriller.domain.commit.Method object at 0x7f1983e6e910>, <pydriller.domain.commit.Method object at 0x7f1983e51790>], [<pydriller.domain.commit.Method object at 0x7f1983ee0f70>], [<pydriller.domain.commit.Method object at 0x7f1983e3c280>, <pydriller.domain.commit.Method object at 0x7f1983ea2b80>, <pydriller.domain.commit.Method object at 0x7f1983d2e2e0>, <pydriller.domain.commit.Method object at 0x7f1983e3ce50>, <pydriller.domain.commit.Method object at 0x7f1983ea2e20>], [<pydriller.domain.commit.Method object at 0x7f1983e0c3d0>], [<pydriller.domain.commit.Method object at 0x7f1983f098e0>, <pydriller.domain.commit.Method object at 0x7f1983f09130>]]"
thefuck,698451f65dd35c3dc0a150118f421548b71a0d51,Use parametrized tests where it possible,2015-04-25 02:54:39+02:00,nvbn,84,55,139,6,"['test_cd_mkdir.py', 'test_mkdir_p.py', 'test_rm_dir.py', 'test_rm_root.py', 'test_sudo.py', 'test_switch_lang.py']","[""from mock import Mock\nfrom thefuck.rules.cd_mkdir import match, get_new_command\n\n\ndef test_match():\n    assert match(Mock(script='cd foo', stderr='cd: foo: No such file or directory'),\n                 None)\n    assert match(Mock(script='cd foo/bar/baz', stderr='cd: foo: No such file or directory'),\n                 None)\n    assert match(Mock(script='cd foo/bar/baz', stderr='cd: can\\'t cd to foo/bar/baz'),\n                 None)\n    assert not match(Mock(script='cd foo',\n                          stderr=''), None)\n    assert not match(Mock(script='', stderr=''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Mock(script='cd foo'), None) == 'mkdir -p foo && cd foo'\n    assert get_new_command(Mock(script='cd foo/bar/baz'), None) == 'mkdir -p foo/bar/baz && cd foo/bar/baz'\n"", ""from thefuck.rules.mkdir_p import match, get_new_command\nfrom tests.utils import Command\n\n\ndef test_match():\n    assert match(Command('mkdir foo/bar/baz',\n                         stderr='mkdir: foo/bar: No such file or directory'),\n                 None)\n    assert not match(Command('mkdir foo/bar/baz'), None)\n    assert not match(Command('mkdir foo/bar/baz', stderr='foo bar baz'), None)\n    assert not match(Command(), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('mkdir foo/bar/baz'), None)\\\n           == 'mkdir -p foo/bar/baz'\n"", ""from thefuck.rules.rm_dir import match, get_new_command\nfrom tests.utils import Command\n\n\ndef test_match():\n    assert match(Command('rm foo', stderr='rm: foo: is a directory'), None)\n    assert match(Command('rm foo', stderr='rm: foo: Is a directory'), None)\n    assert not match(Command('rm foo'), None)\n    assert not match(Command('rm foo', stderr='foo bar baz'), None)\n    assert not match(Command(), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('rm foo', '', ''), None) == 'rm -rf foo'\n"", ""from mock import Mock\nfrom thefuck.rules.rm_root import match, get_new_command\n\n\ndef test_match():\n    assert match(Mock(script='rm -rf /',\n                      stderr='add --no-preserve-root'), None)\n    assert not match(Mock(script='ls',\n                          stderr='add --no-preserve-root'), None)\n    assert not match(Mock(script='rm --no-preserve-root /',\n                          stderr='add --no-preserve-root'), None)\n    assert not match(Mock(script='rm -rf /',\n                          stderr=''), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Mock(script='rm -rf /'), None) \\\n        == 'rm -rf / --no-preserve-root'\n"", 'from thefuck.rules.sudo import match, get_new_command\nfrom tests.utils import Command\n\n\ndef test_match():\n    assert match(Command(stderr=\'Permission denied\'), None)\n    assert match(Command(stderr=\'permission denied\'), None)\n    assert match(Command(stderr=""npm ERR! Error: EACCES, unlink""), None)\n    assert not match(Command(), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command(\'ls\'), None) == \'sudo ls\'\n', ""# -*- encoding: utf-8 -*-\n\nfrom mock import Mock\nfrom thefuck.rules import switch_lang\n\n\ndef test_match():\n    assert switch_lang.match(Mock(stderr='command not found: фзе-пуе',\n                                  script=u'фзе-пуе'), None)\n    assert switch_lang.match(Mock(stderr='command not found: λσ',\n                                  script=u'λσ'), None)\n\n    assert not switch_lang.match(Mock(stderr='command not found: pat-get',\n                                      script=u'pat-get'), None)\n    assert not switch_lang.match(Mock(stderr='command not found: ls',\n                                      script=u'ls'), None)\n    assert not switch_lang.match(Mock(stderr='some info',\n                                      script=u'фзе-пуе'), None)\n\n\ndef test_get_new_command():\n    assert switch_lang.get_new_command(\n        Mock(script=u'фзе-пуе штыефдд мшь'), None) == 'apt-get install vim'\n    assert switch_lang.get_new_command(\n        Mock(script=u'λσ -λα'), None) == 'ls -la'\n""]","[""import pytest\nfrom thefuck.rules.cd_mkdir import match, get_new_command\nfrom tests.utils import Command\n\n\n@pytest.mark.parametrize('command', [\n    Command(script='cd foo', stderr='cd: foo: No such file or directory'),\n    Command(script='cd foo/bar/baz',\n            stderr='cd: foo: No such file or directory'),\n    Command(script='cd foo/bar/baz', stderr='cd: can\\'t cd to foo/bar/baz')])\ndef test_match(command):\n    assert match(command, None)\n\n\n@pytest.mark.parametrize('command', [\n    Command(script='cd foo', stderr=''), Command()])\ndef test_not_match(command):\n    assert not match(command, None)\n\n\n@pytest.mark.parametrize('command, new_command', [\n    (Command('cd foo'), 'mkdir -p foo && cd foo'),\n    (Command('cd foo/bar/baz'), 'mkdir -p foo/bar/baz && cd foo/bar/baz')])\ndef test_get_new_command(command, new_command):\n    assert get_new_command(command, None) == new_command\n"", ""import pytest\nfrom thefuck.rules.mkdir_p import match, get_new_command\nfrom tests.utils import Command\n\n\ndef test_match():\n    assert match(Command('mkdir foo/bar/baz',\n                         stderr='mkdir: foo/bar: No such file or directory'),\n                 None)\n\n\n@pytest.mark.parametrize('command', [\n    Command('mkdir foo/bar/baz'),\n    Command('mkdir foo/bar/baz', stderr='foo bar baz'),\n    Command()])\ndef test_not_match(command):\n    assert not match(command, None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('mkdir foo/bar/baz'), None)\\\n           == 'mkdir -p foo/bar/baz'\n"", ""import pytest\nfrom thefuck.rules.rm_dir import match, get_new_command\nfrom tests.utils import Command\n\n\n@pytest.mark.parametrize('command', [\n    Command('rm foo', stderr='rm: foo: is a directory'),\n    Command('rm foo', stderr='rm: foo: Is a directory')])\ndef test_match(command):\n    assert match(command, None)\n    assert match(command, None)\n\n\n@pytest.mark.parametrize('command', [\n    Command('rm foo'), Command('rm foo'), Command()])\ndef test_not_match(command):\n    assert not match(command, None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command('rm foo', '', ''), None) == 'rm -rf foo'\n"", ""import pytest\nfrom thefuck.rules.rm_root import match, get_new_command\nfrom tests.utils import Command\n\n\ndef test_match():\n    assert match(Command(script='rm -rf /',\n                         stderr='add --no-preserve-root'), None)\n\n\n@pytest.mark.parametrize('command', [\n    Command(script='ls', stderr='add --no-preserve-root'),\n    Command(script='rm --no-preserve-root /', stderr='add --no-preserve-root'),\n    Command(script='rm -rf /', stderr='')])\ndef test_not_match(command):\n    assert not match(command, None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command(script='rm -rf /'), None) \\\n           == 'rm -rf / --no-preserve-root'\n"", 'import pytest\nfrom thefuck.rules.sudo import match, get_new_command\nfrom tests.utils import Command\n\n\n@pytest.mark.parametrize(\'stderr\', [\'Permission denied\',\n                                    \'permission denied\',\n                                    ""npm ERR! Error: EACCES, unlink""])\ndef test_match(stderr):\n    assert match(Command(stderr=stderr), None)\n\n\ndef test_not_match():\n    assert not match(Command(), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command(\'ls\'), None) == \'sudo ls\'\n', ""# -*- encoding: utf-8 -*-\n\nimport pytest\nfrom thefuck.rules import switch_lang\nfrom tests.utils import Command\n\n\n@pytest.mark.parametrize('command', [\n    Command(stderr='command not found: фзе-пуе', script=u'фзе-пуе'),\n    Command(stderr='command not found: λσ', script=u'λσ')])\ndef test_match(command):\n    assert switch_lang.match(command, None)\n\n\n@pytest.mark.parametrize('command', [\n    Command(stderr='command not found: pat-get', script=u'pat-get'),\n    Command(stderr='command not found: ls', script=u'ls'),\n    Command(stderr='some info', script=u'фзе-пуе')])\ndef test_not_match(command):\n    assert not switch_lang.match(command, None)\n\n\n@pytest.mark.parametrize('command, new_command', [\n    (Command(u'фзе-пуе штыефдд мшь'), 'apt-get install vim'),\n    (Command(u'λσ -λα'), 'ls -la')])\ndef test_get_new_command(command, new_command):\n    assert switch_lang.get_new_command(command, None) == new_command\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983ef8a30>, <pydriller.domain.commit.Method object at 0x7f1983ef8910>], [<pydriller.domain.commit.Method object at 0x7f1983e0c670>, <pydriller.domain.commit.Method object at 0x7f1983e0ce20>], [<pydriller.domain.commit.Method object at 0x7f1983e90d00>, <pydriller.domain.commit.Method object at 0x7f1983e3c3d0>], [<pydriller.domain.commit.Method object at 0x7f1983ee0d00>, <pydriller.domain.commit.Method object at 0x7f1983ee03d0>], [<pydriller.domain.commit.Method object at 0x7f1983e51e50>, <pydriller.domain.commit.Method object at 0x7f1983e51520>], [<pydriller.domain.commit.Method object at 0x7f1983e9c7c0>, <pydriller.domain.commit.Method object at 0x7f1983e9c4f0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983ee7640>, <pydriller.domain.commit.Method object at 0x7f1983ef8910>, <pydriller.domain.commit.Method object at 0x7f1983ef8a30>, <pydriller.domain.commit.Method object at 0x7f1983eed8e0>, <pydriller.domain.commit.Method object at 0x7f1983ee7910>], [<pydriller.domain.commit.Method object at 0x7f1983e0c670>, <pydriller.domain.commit.Method object at 0x7f1983f09910>], [<pydriller.domain.commit.Method object at 0x7f1983e90d00>, <pydriller.domain.commit.Method object at 0x7f1983db1d60>, <pydriller.domain.commit.Method object at 0x7f1983db17f0>], [<pydriller.domain.commit.Method object at 0x7f1983e5cb80>, <pydriller.domain.commit.Method object at 0x7f1983e4bb80>, <pydriller.domain.commit.Method object at 0x7f1983e5cd00>], [<pydriller.domain.commit.Method object at 0x7f1983e51e50>, <pydriller.domain.commit.Method object at 0x7f1983d9c2b0>, <pydriller.domain.commit.Method object at 0x7f1983d9cfd0>], [<pydriller.domain.commit.Method object at 0x7f1983d6e400>, <pydriller.domain.commit.Method object at 0x7f1983e9c4f0>, <pydriller.domain.commit.Method object at 0x7f1983e9c7c0>, <pydriller.domain.commit.Method object at 0x7f1983d6eac0>, <pydriller.domain.commit.Method object at 0x7f1983d6e160>]]"
thefuck,2f04a953baa2e1c3f4b37bc46e804d92185ceb50,Fix tests with python 2,2015-04-25 03:13:57+02:00,nvbn,2,0,2,2,"['__init__.py', 'test_fix_alt_space.py']","[None, 'from thefuck.rules.fix_alt_space import match, get_new_command\nfrom tests.utils import Command\n\n\ndef test_match():\n    """"""The character before \'grep\' is Alt+Space, which happens frequently\n    on the Mac when typing the pipe character (Alt+7), and holding the Alt\n    key pressed for longer than necessary.\n\n    """"""\n    assert match(Command(u\'ps -ef |\xa0grep foo\',\n                         stderr=u\'-bash: \xa0grep: command not found\'), None)\n    assert not match(Command(\'ps -ef | grep foo\'), None)\n    assert not match(Command(), None)\n\n\ndef test_get_new_command():\n    """""" Replace the Alt+Space character by a simple space """"""\n    assert get_new_command(Command(u\'ps -ef |\xa0grep foo\'), None)\\\n           == \'ps -ef | grep foo\'\n']","[None, '# -*- encoding: utf-8 -*-\n\nfrom thefuck.rules.fix_alt_space import match, get_new_command\nfrom tests.utils import Command\n\n\ndef test_match():\n    """"""The character before \'grep\' is Alt+Space, which happens frequently\n    on the Mac when typing the pipe character (Alt+7), and holding the Alt\n    key pressed for longer than necessary.\n\n    """"""\n    assert match(Command(u\'ps -ef |\xa0grep foo\',\n                         stderr=u\'-bash: \xa0grep: command not found\'), None)\n    assert not match(Command(\'ps -ef | grep foo\'), None)\n    assert not match(Command(), None)\n\n\ndef test_get_new_command():\n    """""" Replace the Alt+Space character by a simple space """"""\n    assert get_new_command(Command(u\'ps -ef |\xa0grep foo\'), None)\\\n           == \'ps -ef | grep foo\'\n']","[[], [<pydriller.domain.commit.Method object at 0x7f1983dca040>, <pydriller.domain.commit.Method object at 0x7f1983dcad60>]]","[[], []]"
thefuck,419878f526c35a9caf5f4665693d9170b638081e,#118 Make `ls_lah` disabled by default,2015-04-25 03:42:36+02:00,nvbn,11,7,18,3,"['README.md', 'test_ls_lah.py', 'ls_lah.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n**Unoffical**: Or using an OS package manager (currently supported in OSX via [brew](http://brew.sh)):\n\n```bash\nbrew install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck {\n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) {\n        $fuck.substring(5)\n    }\n    else { iex ""$fuck"" }\n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `ls_lah` &ndash; adds -lah to ls;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""from mock import patch, Mock\nfrom thefuck.rules.ls_lah import match, get_new_command\n\n\ndef test_match():\n        assert match(Mock(script='ls file.py'), None)\n        assert match(Mock(script='ls /opt'), None)\n        assert not match(Mock(script='ls -lah /opt'), None)\n\n\ndef test_get_new_command():\n        assert get_new_command( Mock(script='ls file.py'), None) == 'ls -lah file.py'\n        assert get_new_command( Mock(script='ls'), None) == 'ls -lah'\n"", ""def match(command, settings):\n    return ('ls' in command.script and not ('ls -' in command.script))\n\ndef get_new_command(command, settings):\n    command = command.script.split(' ')\n    command[0] = 'ls -lah'\n    return ' '.join(command)\n""]","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- pip\n- python\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n**Unoffical**: Or using an OS package manager (currently supported in OSX via [brew](http://brew.sh)):\n\n```bash\nbrew install thefuck\n```\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in `config.fish`:\n\n```fish\nfunction fuck\n    eval (thefuck $history[1])\nend\n```\n\nOr in your Powershell `$PROFILE` on Windows:\n\n```powershell\nfunction fuck {\n    $fuck = $(thefuck (get-history -count 1).commandline)\n    if($fuck.startswith(""echo"")) {\n        $fuck.substring(5)\n    }\n    else { iex ""$fuck"" }\n}\n```\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en.\n\nBundled, but not enabled by default:\n\n* `ls_lah` &ndash; adds -lah to ls;\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`.\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""from mock import patch, Mock\nfrom thefuck.rules.ls_lah import match, get_new_command\n\n\ndef test_match():\n    assert match(Mock(script='ls file.py'), None)\n    assert match(Mock(script='ls /opt'), None)\n    assert not match(Mock(script='ls -lah /opt'), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Mock(script='ls file.py'), None) == 'ls -lah file.py'\n    assert get_new_command(Mock(script='ls'), None) == 'ls -lah'\n"", ""enabled_by_default = False\n\n\ndef match(command, settings):\n    return 'ls' in command.script and not ('ls -' in command.script)\n\n\ndef get_new_command(command, settings):\n    command = command.script.split(' ')\n    command[0] = 'ls -lah'\n    return ' '.join(command)\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983dacfd0>, <pydriller.domain.commit.Method object at 0x7f1983dac940>], [<pydriller.domain.commit.Method object at 0x7f1983ed0f70>, <pydriller.domain.commit.Method object at 0x7f1983ed0520>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983f05520>, <pydriller.domain.commit.Method object at 0x7f1983f05640>], [<pydriller.domain.commit.Method object at 0x7f1983eca520>]]"
thefuck,a2ac15da56e6d08c734f91f97e13e09e59f8c5a2,"Added dpkg rule

For example, when using ```dpkg -i some-pkg.deb```",2015-04-27 17:45:59-05:00,Trace,2,1,3,1,['sudo.py'],"[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted',\n            'root privilege',\n            'This command has to be run under the root user.',\n            'This operation requires root.',\n            'You need to be root to perform this command.']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted',\n            'root privilege',\n            'This command has to be run under the root user.',\n            'This operation requires root.',\n            'You need to be root to perform this command.',\n            'requested operation requires superuser privilege']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983edc100>, <pydriller.domain.commit.Method object at 0x7f1983edc520>]]",[[]]
thefuck,bc2c87e8fe2c1ac19dc9e58e8a9003b17aa784bc,"Add a support for pip install with sudo

- Fixes #136",2015-04-28 15:52:09+09:00,Namwoo Kim,71,0,71,2,"['test_pip_install_sudo.py', 'pip_install_sudo.py']","[None, None]","['import pytest\nfrom thefuck.rules.pip_install_sudo import match, get_new_command\nfrom tests.utils import Command\n\n\n@pytest.fixture\ndef stdout_success():\n    return \'\'\'\n    Collecting thefuck\n      Downloading thefuck-1.30.tar.gz\n    Requirement already satisfied (use --upgrade to upgrade): pathlib in /usr/local/lib/python2.7/site-packages/pathlib-1.0.1-py2.7.egg (from thefuck)\n    Requirement already satisfied (use --upgrade to upgrade): psutil in /usr/local/lib/python2.7/site-packages/psutil-2.2.1-py2.7-macosx-10.10-x86_64.egg (from thefuck)\n    Requirement already satisfied (use --upgrade to upgrade): colorama in /usr/local/lib/python2.7/site-packages/colorama-0.3.3-py2.7.egg (from thefuck)\n    Requirement already satisfied (use --upgrade to upgrade): six in /usr/local/lib/python2.7/site-packages (from thefuck)\n    Installing collected packages: thefuck\n      Running setup.py install for thefuck\n    Successfully installed thefuck-1.30\n    \'\'\'\n\n\n@pytest.fixture\ndef stdout():\n    return \'\'\'\n    Collecting ipaddr\n      Using cached ipaddr-2.1.11.tar.gz\n    Installing collected packages: ipaddr\n      Running setup.py install for ipaddr\n        Complete output from command /usr/bin/python -c ""import setuptools, tokenize;__file__=\'/tmp/pip-build-usOyBh/ipaddr/setup.py\';exec(compile(getattr(tokenize, \'open\', open)(__file__).read().replace(\'\\r\\n\', \'\\n\'), __file__, \'exec\'))"" install --record /tmp/pip-ghPfAW-record/install-record.txt --single-version-externally-managed --compile:\n        running install\n        running build\n        running build_py\n        creating build\n        creating build/lib.linux-x86_64-2.7\n        copying ipaddr.py -> build/lib.linux-x86_64-2.7\n        running install_lib\n        copying build/lib.linux-x86_64-2.7/ipaddr.py -> /usr/local/lib/python2.7/dist-packages\n        error: [Errno 13] Permission denied: \'/usr/local/lib/python2.7/dist-packages/ipaddr.py\'\n    \'\'\'\n\n\n@pytest.fixture\ndef stderr():\n    return \'\'\'\n    Command ""/usr/bin/python -c ""import setuptools, tokenize;__file__=\'/tmp/pip-build-usOyBh/ipaddr/setup.py\';exec(compile(getattr(tokenize, \'open\', open)(__file__).read().replace(\'\\r\\n\', \'\\n\'), __file__, \'exec\'))"" install --record /tmp/pip-ghPfAW-record/install-record.txt --single-version-externally-managed --compile"" failed with error code 1 in /tmp/pip-build-usOyBh/ipaddr\n    \'\'\'\n\n\ndef test_match(stdout, stdout_success, stderr):\n    assert match(Command(\'pip install ipaddr\', stdout=stdout, stderr=stderr),\n                 None)\n    assert not match(Command(\'pip install thefuck\', stdout=stdout_success),\n                     None)\n\n\ndef test_get_new_command(stdout, stdout_success, stderr):\n    assert get_new_command(Command(\'pip install ipaddr\', stdout=stdout,\n                                   stderr=stderr), None)\\\n            == \'sudo pip install ipaddr\'\n', ""import re\nfrom thefuck.utils import sudo_support\n\n\ndef match(command, settings):\n    return (('pip' in command.script and 'install' in command.script) and\n            'failed with error code 1' in command.stderr and\n            ('Errno 13' in command.stdout or\n             'Permission denied' in command.stdout))\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[[], []]","[[<pydriller.domain.commit.Method object at 0x7f1983d51a90>, <pydriller.domain.commit.Method object at 0x7f1983e81a60>, <pydriller.domain.commit.Method object at 0x7f1983dfeeb0>, <pydriller.domain.commit.Method object at 0x7f1983dca550>, <pydriller.domain.commit.Method object at 0x7f1983e814f0>], [<pydriller.domain.commit.Method object at 0x7f1983ddb190>, <pydriller.domain.commit.Method object at 0x7f1983ddb160>]]"
thefuck,d3295e6a4e18b6e0be45f08fa95d413f4d1c871c,"Hoping this fixes the issue of it not working.

Still new to this project. My problem of it not working (I admit to being at fault) was that I had not added the same rule to the test case.",2015-04-28 11:59:15-05:00,Trace,2,1,3,1,['test_sudo.py'],"['import pytest\nfrom thefuck.rules.sudo import match, get_new_command\nfrom tests.utils import Command\n\n\n@pytest.mark.parametrize(\'stderr\', [\'Permission denied\',\n                                    \'permission denied\',\n                                    ""npm ERR! Error: EACCES, unlink""])\ndef test_match(stderr):\n    assert match(Command(stderr=stderr), None)\n\n\ndef test_not_match():\n    assert not match(Command(), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command(\'ls\'), None) == \'sudo ls\'\n']","['import pytest\nfrom thefuck.rules.sudo import match, get_new_command\nfrom tests.utils import Command\n\n\n@pytest.mark.parametrize(\'stderr\', [\'Permission denied\',\n                                    \'permission denied\',\n                                    ""npm ERR! Error: EACCES, unlink"",\n                                    \'requested operation requires superuser privilege\'])\ndef test_match(stderr):\n    assert match(Command(stderr=stderr), None)\n\n\ndef test_not_match():\n    assert not match(Command(), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command(\'ls\'), None) == \'sudo ls\'\n']","[[<pydriller.domain.commit.Method object at 0x7f1983ec5a60>, <pydriller.domain.commit.Method object at 0x7f1983ec5910>, <pydriller.domain.commit.Method object at 0x7f1983d9ce80>]]",[[]]
thefuck,99d9c9aff7fde129279a6a4ee58cb1e6df109e34,#132 Merge `pip_install_sudo` rule with `sudo` rule,2015-04-29 05:01:30+02:00,nvbn,10,78,88,4,"['test_pip_install_sudo.py', 'test_sudo.py', 'pip_install_sudo.py', 'sudo.py']","['import pytest\nfrom thefuck.rules.pip_install_sudo import match, get_new_command\nfrom tests.utils import Command\n\n\n@pytest.fixture\ndef stdout_success():\n    return \'\'\'\n    Collecting thefuck\n      Downloading thefuck-1.30.tar.gz\n    Requirement already satisfied (use --upgrade to upgrade): pathlib in /usr/local/lib/python2.7/site-packages/pathlib-1.0.1-py2.7.egg (from thefuck)\n    Requirement already satisfied (use --upgrade to upgrade): psutil in /usr/local/lib/python2.7/site-packages/psutil-2.2.1-py2.7-macosx-10.10-x86_64.egg (from thefuck)\n    Requirement already satisfied (use --upgrade to upgrade): colorama in /usr/local/lib/python2.7/site-packages/colorama-0.3.3-py2.7.egg (from thefuck)\n    Requirement already satisfied (use --upgrade to upgrade): six in /usr/local/lib/python2.7/site-packages (from thefuck)\n    Installing collected packages: thefuck\n      Running setup.py install for thefuck\n    Successfully installed thefuck-1.30\n    \'\'\'\n\n\n@pytest.fixture\ndef stdout():\n    return \'\'\'\n    Collecting ipaddr\n      Using cached ipaddr-2.1.11.tar.gz\n    Installing collected packages: ipaddr\n      Running setup.py install for ipaddr\n        Complete output from command /usr/bin/python -c ""import setuptools, tokenize;__file__=\'/tmp/pip-build-usOyBh/ipaddr/setup.py\';exec(compile(getattr(tokenize, \'open\', open)(__file__).read().replace(\'\\r\\n\', \'\\n\'), __file__, \'exec\'))"" install --record /tmp/pip-ghPfAW-record/install-record.txt --single-version-externally-managed --compile:\n        running install\n        running build\n        running build_py\n        creating build\n        creating build/lib.linux-x86_64-2.7\n        copying ipaddr.py -> build/lib.linux-x86_64-2.7\n        running install_lib\n        copying build/lib.linux-x86_64-2.7/ipaddr.py -> /usr/local/lib/python2.7/dist-packages\n        error: [Errno 13] Permission denied: \'/usr/local/lib/python2.7/dist-packages/ipaddr.py\'\n    \'\'\'\n\n\n@pytest.fixture\ndef stderr():\n    return \'\'\'\n    Command ""/usr/bin/python -c ""import setuptools, tokenize;__file__=\'/tmp/pip-build-usOyBh/ipaddr/setup.py\';exec(compile(getattr(tokenize, \'open\', open)(__file__).read().replace(\'\\r\\n\', \'\\n\'), __file__, \'exec\'))"" install --record /tmp/pip-ghPfAW-record/install-record.txt --single-version-externally-managed --compile"" failed with error code 1 in /tmp/pip-build-usOyBh/ipaddr\n    \'\'\'\n\n\ndef test_match(stdout, stdout_success, stderr):\n    assert match(Command(\'pip install ipaddr\', stdout=stdout, stderr=stderr),\n                 None)\n    assert not match(Command(\'pip install thefuck\', stdout=stdout_success),\n                     None)\n\n\ndef test_get_new_command(stdout, stdout_success, stderr):\n    assert get_new_command(Command(\'pip install ipaddr\', stdout=stdout,\n                                   stderr=stderr), None)\\\n            == \'sudo pip install ipaddr\'\n', 'import pytest\nfrom thefuck.rules.sudo import match, get_new_command\nfrom tests.utils import Command\n\n\n@pytest.mark.parametrize(\'stderr\', [\'Permission denied\',\n                                    \'permission denied\',\n                                    ""npm ERR! Error: EACCES, unlink"",\n                                    \'requested operation requires superuser privilege\'])\ndef test_match(stderr):\n    assert match(Command(stderr=stderr), None)\n\n\ndef test_not_match():\n    assert not match(Command(), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command(\'ls\'), None) == \'sudo ls\'\n', ""import re\nfrom thefuck.utils import sudo_support\n\n\ndef match(command, settings):\n    return (('pip' in command.script and 'install' in command.script) and\n            'failed with error code 1' in command.stderr and\n            ('Errno 13' in command.stdout or\n             'Permission denied' in command.stdout))\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n"", ""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted',\n            'root privilege',\n            'This command has to be run under the root user.',\n            'This operation requires root.',\n            'You need to be root to perform this command.',\n            'requested operation requires superuser privilege']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[None, 'import pytest\nfrom thefuck.rules.sudo import match, get_new_command\nfrom tests.utils import Command\n\n\n@pytest.mark.parametrize(\'stderr, stdout\', [\n    (\'Permission denied\', \'\'),\n    (\'permission denied\', \'\'),\n    (""npm ERR! Error: EACCES, unlink"", \'\'),\n    (\'requested operation requires superuser privilege\', \'\'),\n    (\'\', ""error: [Errno 13] Permission denied: \'/usr/local/lib/python2.7/dist-packages/ipaddr.py\'"")])\ndef test_match(stderr, stdout):\n    assert match(Command(stderr=stderr, stdout=stdout), None)\n\n\ndef test_not_match():\n    assert not match(Command(), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command(\'ls\'), None) == \'sudo ls\'\n', None, ""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted',\n            'root privilege',\n            'This command has to be run under the root user.',\n            'This operation requires root.',\n            'You need to be root to perform this command.',\n            'requested operation requires superuser privilege']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower()\\\n                or pattern.lower() in command.stdout.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983e96b80>, <pydriller.domain.commit.Method object at 0x7f1983f09cd0>, <pydriller.domain.commit.Method object at 0x7f1983f09bb0>, <pydriller.domain.commit.Method object at 0x7f1983f09f70>, <pydriller.domain.commit.Method object at 0x7f1983f09e20>], [<pydriller.domain.commit.Method object at 0x7f1983efefa0>, <pydriller.domain.commit.Method object at 0x7f1983eed250>, <pydriller.domain.commit.Method object at 0x7f1983eed670>], [<pydriller.domain.commit.Method object at 0x7f1983ee7520>, <pydriller.domain.commit.Method object at 0x7f1983ee78e0>], [<pydriller.domain.commit.Method object at 0x7f1983ed0130>, <pydriller.domain.commit.Method object at 0x7f1983ed08e0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983f09cd0>, <pydriller.domain.commit.Method object at 0x7f1983f09f70>, <pydriller.domain.commit.Method object at 0x7f1983f09e20>, <pydriller.domain.commit.Method object at 0x7f1983e96b80>, <pydriller.domain.commit.Method object at 0x7f1983f09bb0>], [<pydriller.domain.commit.Method object at 0x7f1983efefa0>, <pydriller.domain.commit.Method object at 0x7f1983ee0a30>], [<pydriller.domain.commit.Method object at 0x7f1983ee78e0>, <pydriller.domain.commit.Method object at 0x7f1983ee7520>], [<pydriller.domain.commit.Method object at 0x7f1983ed03a0>]]"
thefuck,b80f3ea6e4c77cee3fc02dcbbd0ff5a34ac0ee0f,Bump to 1.31,2015-04-29 05:02:32+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nVERSION = \'1.30\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.31\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']",[[]],[[]]
thefuck,9bf910a2ddc86dee90876651e668f18c46259ec3,Improve a logic to get recommended command based on local environment,2015-04-29 15:18:48+09:00,Namwoo Kim,75,9,84,2,"['test_brew_unknown_command.py', 'brew_unknown_command.py']","[""import pytest\nfrom thefuck.rules.brew_unknown_command import match, get_new_command\nfrom thefuck.rules.brew_unknown_command import brew_commands\nfrom tests.utils import Command\n\n\n@pytest.fixture\ndef brew_unknown_cmd():\n    return '''Error: Unknown command: inst'''\n\n\n@pytest.fixture\ndef brew_unknown_cmd_instaa():\n    return '''Error: Unknown command: instaa'''\n\n\ndef test_match(brew_unknown_cmd):\n    assert match(Command('brew inst', stderr=brew_unknown_cmd), None)\n    for command in brew_commands:\n        assert not match(Command('brew ' + command), None)\n\n\ndef test_get_new_command(brew_unknown_cmd, brew_unknown_cmd_instaa):\n    assert get_new_command(Command('brew inst', stderr=brew_unknown_cmd), None)\\\n        == 'brew list'\n\n    assert get_new_command(Command('brew instaa', stderr=brew_unknown_cmd_instaa),\n                           None) == 'brew install'\n"", ""import difflib\nimport re\nimport thefuck.logs\n\n# This commands are based on Homebrew 0.9.5\nbrew_commands = ['info', 'home', 'options', 'install', 'uninstall', 'search',\n                 'list', 'update', 'upgrade', 'pin', 'unpin', 'doctor',\n                 'create', 'edit']\n\n\ndef _get_similar_commands(command):\n    return difflib.get_close_matches(command, brew_commands)\n\n\ndef match(command, settings):\n    is_proper_command = ('brew' in command.script and\n                         'Unknown command' in command.stderr)\n\n    has_possible_commands = False\n    if is_proper_command:\n        broken_cmd = re.findall(r'Error: Unknown command: ([a-z]+)',\n                                command.stderr)[0]\n        has_possible_commands = len(_get_similar_commands(broken_cmd)) > 0\n\n    return has_possible_commands\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r'Error: Unknown command: ([a-z]+)',\n                            command.stderr)[0]\n    new_cmd = _get_similar_commands(broken_cmd)[0]\n\n    return command.script.replace(broken_cmd, new_cmd, 1)\n""]","[""import pytest\nfrom thefuck.rules.brew_unknown_command import match, get_new_command\nfrom thefuck.rules.brew_unknown_command import brew_commands\nfrom tests.utils import Command\n\n\n@pytest.fixture\ndef brew_unknown_cmd():\n    return '''Error: Unknown command: inst'''\n\n\n@pytest.fixture\ndef brew_unknown_cmd2():\n    return '''Error: Unknown command: instaa'''\n\n\ndef test_match(brew_unknown_cmd):\n    assert match(Command('brew inst', stderr=brew_unknown_cmd), None)\n    for command in brew_commands:\n        assert not match(Command('brew ' + command), None)\n\n\ndef test_get_new_command(brew_unknown_cmd, brew_unknown_cmd2):\n    assert get_new_command(Command('brew inst', stderr=brew_unknown_cmd),\n                           None) == 'brew list'\n\n    assert get_new_command(Command('brew instaa', stderr=brew_unknown_cmd2),\n                           None) == 'brew install'\n"", ""import difflib\nimport os\nimport re\nimport subprocess\nimport thefuck.logs\n\nBREW_CMD_PATH = '/Library/Homebrew/cmd'\nTAP_PATH = '/Library/Taps'\nTAP_CMD_PATH = '/%s/%s/cmd'\n\n\ndef _get_brew_path_prefix():\n    '''To get brew path'''\n    try:\n        return subprocess.check_output(['brew', '--prefix']).strip()\n    except:\n        return None\n\n\ndef _get_brew_commands(brew_path_prefix):\n    '''To get brew default commands on local environment'''\n    brew_cmd_path = brew_path_prefix + BREW_CMD_PATH\n\n    commands = (name.replace('.rb', '') for name in os.listdir(brew_cmd_path)\n                if name.endswith('.rb'))\n\n    return commands\n\n\ndef _get_brew_tap_specific_commands(brew_path_prefix):\n    '''To get tap's specific commands\n    https://github.com/Homebrew/homebrew/blob/master/Library/brew.rb#L115'''\n    commands = []\n    brew_taps_path = brew_path_prefix + TAP_PATH\n\n    for user in _get_directory_names_only(brew_taps_path):\n        taps = _get_directory_names_only(brew_taps_path + '/%s' % user)\n\n        # Brew Taps's naming rule\n        # https://github.com/Homebrew/homebrew/blob/master/share/doc/homebrew/brew-tap.md#naming-conventions-and-limitations\n        taps = (tap for tap in taps if tap.startswith('homebrew-'))\n        for tap in taps:\n            tap_cmd_path = brew_taps_path + TAP_CMD_PATH % (user, tap)\n\n            if os.path.isdir(tap_cmd_path):\n                commands += (name.replace('brew-', '').replace('.rb', '')\n                             for name in os.listdir(tap_cmd_path)\n                             if _is_brew_tap_cmd_naming(name))\n\n    return commands\n\n\ndef _is_brew_tap_cmd_naming(name):\n    if name.startswith('brew-') and name.endswith('.rb'):\n        return True\n\n    return False\n\n\ndef _get_directory_names_only(path):\n    return [d for d in os.listdir(path)\n            if os.path.isdir(os.path.join(path, d))]\n\nbrew_commands = []\nbrew_path_prefix = _get_brew_path_prefix()\n\nif brew_path_prefix:\n    brew_commands += _get_brew_commands(brew_path_prefix)\n    brew_commands += _get_brew_tap_specific_commands(brew_path_prefix)\nelse:\n    # Failback commands for testing (Based on Homebrew 0.9.5)\n    brew_commands = ['info', 'home', 'options', 'install', 'uninstall',\n                     'search', 'list', 'update', 'upgrade', 'pin', 'unpin',\n                     'doctor', 'create', 'edit']\n\n\ndef _get_similar_commands(command):\n    return difflib.get_close_matches(command, brew_commands)\n\n\ndef match(command, settings):\n    is_proper_command = ('brew' in command.script and\n                         'Unknown command' in command.stderr)\n\n    has_possible_commands = False\n    if is_proper_command:\n        broken_cmd = re.findall(r'Error: Unknown command: ([a-z]+)',\n                                command.stderr)[0]\n        has_possible_commands = len(_get_similar_commands(broken_cmd)) > 0\n\n    return has_possible_commands\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r'Error: Unknown command: ([a-z]+)',\n                            command.stderr)[0]\n    new_cmd = _get_similar_commands(broken_cmd)[0]\n\n    return command.script.replace(broken_cmd, new_cmd, 1)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983e5c3d0>, <pydriller.domain.commit.Method object at 0x7f1983e5c130>, <pydriller.domain.commit.Method object at 0x7f1983e4b790>, <pydriller.domain.commit.Method object at 0x7f1983e4b640>], [<pydriller.domain.commit.Method object at 0x7f1983d9cbe0>, <pydriller.domain.commit.Method object at 0x7f1983d9cd60>, <pydriller.domain.commit.Method object at 0x7f1983d9cc10>]]","[[<pydriller.domain.commit.Method object at 0x7f1983f09280>, <pydriller.domain.commit.Method object at 0x7f1983e4b640>, <pydriller.domain.commit.Method object at 0x7f1983f09790>, <pydriller.domain.commit.Method object at 0x7f1983e5c130>], [<pydriller.domain.commit.Method object at 0x7f1983eb28e0>, <pydriller.domain.commit.Method object at 0x7f1983ee07c0>, <pydriller.domain.commit.Method object at 0x7f1983ee0130>, <pydriller.domain.commit.Method object at 0x7f1983ee0520>, <pydriller.domain.commit.Method object at 0x7f1983eb9fa0>]]"
thefuck,be9446635be7efa24431c7859357533cd26f9fe5,"Add more patterns to sudo.py

These patterns cover commands like
`reboot`
or
`dpkg-reconfigure something`",2015-04-30 13:54:02+01:00,Daniele,3,1,4,1,['sudo.py'],"[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted',\n            'root privilege',\n            'This command has to be run under the root user.',\n            'This operation requires root.',\n            'You need to be root to perform this command.',\n            'requested operation requires superuser privilege']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower()\\\n                or pattern.lower() in command.stdout.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted',\n            'root privilege',\n            'This command has to be run under the root user.',\n            'This operation requires root.',\n            'You need to be root to perform this command.',\n            'requested operation requires superuser privilege',\n            'must be run as root',\n            'must be superuser']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower()\\\n                or pattern.lower() in command.stdout.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983f05f70>, <pydriller.domain.commit.Method object at 0x7f1983f05790>]]",[[]]
thefuck,55cfdda203a639727b5b73f7f9c068802e29b134,add rule for shutdown command,2015-04-30 19:50:37+05:30,SanketDG,2,1,3,1,['sudo.py'],"[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted',\n            'root privilege',\n            'This command has to be run under the root user.',\n            'This operation requires root.',\n            'You need to be root to perform this command.',\n            'requested operation requires superuser privilege']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower()\\\n                or pattern.lower() in command.stdout.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[""patterns = ['permission denied',\n            'EACCES',\n            'pkg: Insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'Operation not permitted',\n            'root privilege',\n            'This command has to be run under the root user.',\n            'This operation requires root.',\n            'You need to be root to perform this command.',\n            'requested operation requires superuser privilege',\n            'Need to be root']\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if pattern.lower() in command.stderr.lower()\\\n                or pattern.lower() in command.stdout.lower():\n            return True\n    return False\n\n\ndef get_new_command(command, settings):\n    return u'sudo {}'.format(command.script)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983f36520>, <pydriller.domain.commit.Method object at 0x7f1983f36100>]]",[[]]
thefuck,4276e1b991ea923a2a3bdd227bb3d98ced1fd4e2,add alias function,2015-05-01 00:12:30+05:30,SanketDG,4,0,4,1,['main.py'],"['from imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom . import logs, conf, types\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    conf.initialize_settings_file(user_dir)\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return types.Rule(rule.name[:-3], rule_module.match,\n                      rule_module.get_new_command,\n                      getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent \\\n        .joinpath(\'rules\') \\\n        .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return types.Command(script, result.stdout.read().decode(\'utf-8\'),\n                             result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n']","['from imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom . import logs, conf, types\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    conf.initialize_settings_file(user_dir)\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return types.Rule(rule.name[:-3], rule_module.match,\n                      rule_module.get_new_command,\n                      getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent \\\n        .joinpath(\'rules\') \\\n        .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return types.Command(script, result.stdout.read().decode(\'utf-8\'),\n                             result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef alias():\n    print(""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n"")\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n']","[[<pydriller.domain.commit.Method object at 0x7f1983f32e50>, <pydriller.domain.commit.Method object at 0x7f1983f32fa0>, <pydriller.domain.commit.Method object at 0x7f1983f32d00>, <pydriller.domain.commit.Method object at 0x7f1983f32b80>, <pydriller.domain.commit.Method object at 0x7f1983f32520>, <pydriller.domain.commit.Method object at 0x7f1983f323a0>, <pydriller.domain.commit.Method object at 0x7f1983f323d0>, <pydriller.domain.commit.Method object at 0x7f1983f32250>, <pydriller.domain.commit.Method object at 0x7f1983f32280>, <pydriller.domain.commit.Method object at 0x7f1983f32100>]]",[[<pydriller.domain.commit.Method object at 0x7f1983d62d60>]]
thefuck,8a49b40f6a7dea32f72ccf733eca7b6e84c03686,add entry point,2015-05-01 00:12:43+05:30,SanketDG,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nVERSION = \'1.31\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\']})\n']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.31\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\', \'thefuck-alias = thefuck.main:alias\']})\n']",[[]],[[]]
thefuck,b985dfbffc51e21078c1fceb96abfcd71ea22d0e,#102 Add support of rules with side effects,2015-05-01 04:39:37+02:00,nvbn,49,21,70,6,"['test_main.py', 'test_types.py', 'utils.py', 'logs.py', 'main.py', 'types.py']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main, conf, types\nfrom tests.utils import Rule, Command\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == Rule('bash', match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.DEFAULT_RULES))) \\\n               == [Rule('bash', 'bash', 'bash'),\n                   Rule('lisp', 'lisp', 'lisp'),\n                   Rule('bash', 'bash', 'bash'),\n                   Rule('lisp', 'lisp', 'lisp')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=types.RulesNamesList(['bash'])))) \\\n               == [Rule('bash', 'bash', 'bash'),\n                   Rule('bash', 'bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [Rule('', lambda x, _: x.script == 'cd ..'),\n             Rule('', lambda *_: False),\n             Rule('rule', Mock(side_effect=OSError('Denied')))]\n    assert main.get_matched_rule(Command('ls'),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(Command('cd ..'),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm('command', Mock(require_confirmation=True,\n                                            no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', Mock(require_confirmation=True,\n                                                no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", ""from thefuck.types import Rule, RulesNamesList, Settings\n\n\ndef test_rules_names_list():\n    assert RulesNamesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert RulesNamesList(['bash', 'lisp']) == RulesNamesList(['bash', 'lisp'])\n    assert Rule('lisp', None, None, False) in RulesNamesList(['lisp'])\n    assert Rule('bash', None, None, False) not in RulesNamesList(['lisp'])\n\n\ndef test_update_settings():\n    settings = Settings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from thefuck import types\n\n\ndef Command(script='', stdout='', stderr=''):\n    return types.Command(script, stdout, stderr)\n\n\ndef Rule(name='', match=lambda *_: True,\n         get_new_command=lambda *_: '',\n         enabled_by_default=True):\n    return types.Rule(name, match, get_new_command, enabled_by_default)\n"", 'import sys\nfrom traceback import format_exception\nimport colorama\n\n\ndef color(color_, settings):\n    """"""Utility for ability to disabling colored output.""""""\n    if settings.no_colors:\n        return \'\'\n    else:\n        return color_\n\n\ndef exception(title, exc_info, settings):\n    sys.stderr.write(\n        u\'{warn}[WARN] {title}:{reset}\\n{trace}\'\n        u\'{warn}----------------------------{reset}\\n\\n\'.format(\n            warn=color(colorama.Back.RED + colorama.Fore.WHITE\n                       + colorama.Style.BRIGHT, settings),\n            reset=color(colorama.Style.RESET_ALL, settings),\n            title=title,\n            trace=\'\'.join(format_exception(*exc_info))))\n\n\ndef rule_failed(rule, exc_info, settings):\n    exception(\'Rule {}\'.format(rule.name), exc_info, settings)\n\n\ndef show_command(new_command, settings):\n    sys.stderr.write(\'{bold}{command}{reset}\\n\'.format(\n        command=new_command,\n        bold=color(colorama.Style.BRIGHT, settings),\n        reset=color(colorama.Style.RESET_ALL, settings)))\n\n\ndef confirm_command(new_command, settings):\n    sys.stderr.write(\n        \'{bold}{command}{reset} [{green}enter{reset}/{red}ctrl+c{reset}]\'.format(\n            command=new_command,\n            bold=color(colorama.Style.BRIGHT, settings),\n            green=color(colorama.Fore.GREEN, settings),\n            red=color(colorama.Fore.RED, settings),\n            reset=color(colorama.Style.RESET_ALL, settings)))\n    sys.stderr.flush()\n\n\ndef failed(msg, settings):\n    sys.stderr.write(\'{red}{msg}{reset}\\n\'.format(\n        msg=msg,\n        red=color(colorama.Fore.RED, settings),\n        reset=color(colorama.Style.RESET_ALL, settings)))\n', 'from imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom . import logs, conf, types\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    conf.initialize_settings_file(user_dir)\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return types.Rule(rule.name[:-3], rule_module.match,\n                      rule_module.get_new_command,\n                      getattr(rule_module, \'enabled_by_default\', True))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent \\\n        .joinpath(\'rules\') \\\n        .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return types.Command(script, result.stdout.read().decode(\'utf-8\'),\n                             result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, settings)\n        return True\n\n    logs.confirm_command(new_command, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, settings):\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef alias():\n    print(""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n"")\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', 'from collections import namedtuple\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\n\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\'))\n\n\nclass RulesNamesList(list):\n    """"""Wrapper a top of list for string rules names.""""""\n\n    def __contains__(self, item):\n        return super(RulesNamesList, self).__contains__(item.name)\n\n\nclass Settings(dict):\n\n    def __getattr__(self, item):\n        return self.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = dict(self)\n        conf.update(kwargs)\n        return Settings(conf)\n']","[""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main, conf, types\nfrom tests.utils import Rule, Command\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == Rule('bash', match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.DEFAULT_RULES))) \\\n               == [Rule('bash', 'bash', 'bash'),\n                   Rule('lisp', 'lisp', 'lisp'),\n                   Rule('bash', 'bash', 'bash'),\n                   Rule('lisp', 'lisp', 'lisp')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=types.RulesNamesList(['bash'])))) \\\n               == [Rule('bash', 'bash', 'bash'),\n                   Rule('bash', 'bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [Rule('', lambda x, _: x.script == 'cd ..'),\n             Rule('', lambda *_: False),\n             Rule('rule', Mock(side_effect=OSError('Denied')))]\n    assert main.get_matched_rule(Command('ls'),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(Command('cd ..'),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n        # With side effect:\n        side_effect = Mock()\n        settings = Mock()\n        command = Mock()\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command',\n                           side_effect=side_effect),\n                      command, settings)\n        assert capsys.readouterr() == ('new-command\\n', '')\n        side_effect.assert_called_once_with(command, settings)\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', None, Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # With side effect and without confirmation:\n    assert main.confirm('command', Mock(), Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command*\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm(\n            'command', None, Mock(require_confirmation=True,\n                                  no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n        # With side effect:\n        assert main.confirm(\n            'command', Mock(), Mock(require_confirmation=True,\n                                    no_colors=True))\n        assert capsys.readouterr() == ('', 'command* [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', None,\n                                Mock(require_confirmation=True,\n                                     no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", ""from thefuck.types import RulesNamesList, Settings\nfrom tests.utils import Rule\n\n\ndef test_rules_names_list():\n    assert RulesNamesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert RulesNamesList(['bash', 'lisp']) == RulesNamesList(['bash', 'lisp'])\n    assert Rule('lisp') in RulesNamesList(['lisp'])\n    assert Rule('bash') not in RulesNamesList(['lisp'])\n\n\ndef test_update_settings():\n    settings = Settings({'key': 'val'})\n    new_settings = settings.update(key='new-val')\n    assert new_settings.key == 'new-val'\n    assert settings.key == 'val'\n"", ""from thefuck import types\n\n\ndef Command(script='', stdout='', stderr=''):\n    return types.Command(script, stdout, stderr)\n\n\ndef Rule(name='', match=lambda *_: True,\n         get_new_command=lambda *_: '',\n         enabled_by_default=True,\n         side_effect=None):\n    return types.Rule(name, match, get_new_command,\n                      enabled_by_default, side_effect)\n"", 'import sys\nfrom traceback import format_exception\nimport colorama\n\n\ndef color(color_, settings):\n    """"""Utility for ability to disabling colored output.""""""\n    if settings.no_colors:\n        return \'\'\n    else:\n        return color_\n\n\ndef exception(title, exc_info, settings):\n    sys.stderr.write(\n        u\'{warn}[WARN] {title}:{reset}\\n{trace}\'\n        u\'{warn}----------------------------{reset}\\n\\n\'.format(\n            warn=color(colorama.Back.RED + colorama.Fore.WHITE\n                       + colorama.Style.BRIGHT, settings),\n            reset=color(colorama.Style.RESET_ALL, settings),\n            title=title,\n            trace=\'\'.join(format_exception(*exc_info))))\n\n\ndef rule_failed(rule, exc_info, settings):\n    exception(\'Rule {}\'.format(rule.name), exc_info, settings)\n\n\ndef show_command(new_command, side_effect, settings):\n    sys.stderr.write(\'{bold}{command}{side_effect}{reset}\\n\'.format(\n        command=new_command,\n        side_effect=\'*\' if side_effect else \'\',\n        bold=color(colorama.Style.BRIGHT, settings),\n        reset=color(colorama.Style.RESET_ALL, settings)))\n\n\ndef confirm_command(new_command, side_effect, settings):\n    sys.stderr.write(\n        \'{bold}{command}{side_effect}{reset} \'\n        \'[{green}enter{reset}/{red}ctrl+c{reset}]\'.format(\n            command=new_command,\n            side_effect=\'*\' if side_effect else \'\',\n            bold=color(colorama.Style.BRIGHT, settings),\n            green=color(colorama.Fore.GREEN, settings),\n            red=color(colorama.Fore.RED, settings),\n            reset=color(colorama.Style.RESET_ALL, settings)))\n    sys.stderr.flush()\n\n\ndef failed(msg, settings):\n    sys.stderr.write(\'{red}{msg}{reset}\\n\'.format(\n        msg=msg,\n        red=color(colorama.Fore.RED, settings),\n        reset=color(colorama.Style.RESET_ALL, settings)))\n', 'from imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom . import logs, conf, types\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    conf.initialize_settings_file(user_dir)\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return types.Rule(rule.name[:-3], rule_module.match,\n                      rule_module.get_new_command,\n                      getattr(rule_module, \'enabled_by_default\', True),\n                      getattr(rule_module, \'side_effect\', None))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent \\\n        .joinpath(\'rules\') \\\n        .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return types.Command(script, result.stdout.read().decode(\'utf-8\'),\n                             result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, side_effect, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, side_effect, settings)\n        return True\n\n    logs.confirm_command(new_command, side_effect, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, rule.side_effect, settings):\n        if rule.side_effect:\n            rule.side_effect(command, settings)\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef alias():\n    print(""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n"")\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', 'from collections import namedtuple\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\n\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\', \'side_effect\'))\n\n\nclass RulesNamesList(list):\n    """"""Wrapper a top of list for storing rules names.""""""\n\n    def __contains__(self, item):\n        return super(RulesNamesList, self).__contains__(item.name)\n\n\nclass Settings(dict):\n\n    def __getattr__(self, item):\n        return self.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = dict(self)\n        conf.update(kwargs)\n        return Settings(conf)\n']","[[<pydriller.domain.commit.Method object at 0x7f1983eca3a0>, <pydriller.domain.commit.Method object at 0x7f1983ecafa0>, <pydriller.domain.commit.Method object at 0x7f1983eca670>, <pydriller.domain.commit.Method object at 0x7f1983eca100>, <pydriller.domain.commit.Method object at 0x7f1983ef3a30>, <pydriller.domain.commit.Method object at 0x7f1983f05670>], [<pydriller.domain.commit.Method object at 0x7f1983ea2cd0>, <pydriller.domain.commit.Method object at 0x7f1983ea23a0>], [<pydriller.domain.commit.Method object at 0x7f1983eed280>, <pydriller.domain.commit.Method object at 0x7f1983eeda60>], [<pydriller.domain.commit.Method object at 0x7f1983ed0bb0>, <pydriller.domain.commit.Method object at 0x7f1983ed0250>, <pydriller.domain.commit.Method object at 0x7f1983ed0cd0>, <pydriller.domain.commit.Method object at 0x7f1983ed04f0>, <pydriller.domain.commit.Method object at 0x7f1983ed0790>, <pydriller.domain.commit.Method object at 0x7f1983ed0e50>], [<pydriller.domain.commit.Method object at 0x7f1983f27130>, <pydriller.domain.commit.Method object at 0x7f1983f27280>, <pydriller.domain.commit.Method object at 0x7f1983f20f70>, <pydriller.domain.commit.Method object at 0x7f1983f20fa0>, <pydriller.domain.commit.Method object at 0x7f1983f207c0>, <pydriller.domain.commit.Method object at 0x7f1983f20640>, <pydriller.domain.commit.Method object at 0x7f1983f20670>, <pydriller.domain.commit.Method object at 0x7f1983f204f0>, <pydriller.domain.commit.Method object at 0x7f1983f20520>, <pydriller.domain.commit.Method object at 0x7f1983f27250>, <pydriller.domain.commit.Method object at 0x7f1983f273a0>], [<pydriller.domain.commit.Method object at 0x7f1983ee7100>, <pydriller.domain.commit.Method object at 0x7f1983ee7790>, <pydriller.domain.commit.Method object at 0x7f1983ee7a60>]]","[[<pydriller.domain.commit.Method object at 0x7f1983f2b670>, <pydriller.domain.commit.Method object at 0x7f1983f2bb80>], [<pydriller.domain.commit.Method object at 0x7f1983ea8520>], [<pydriller.domain.commit.Method object at 0x7f1983d2e2b0>, <pydriller.domain.commit.Method object at 0x7f1983eeda60>], [<pydriller.domain.commit.Method object at 0x7f1983ed04f0>, <pydriller.domain.commit.Method object at 0x7f1983ed0790>, <pydriller.domain.commit.Method object at 0x7f1983ef8e20>, <pydriller.domain.commit.Method object at 0x7f1983e0ca30>], [<pydriller.domain.commit.Method object at 0x7f1983f27f70>, <pydriller.domain.commit.Method object at 0x7f1983f20670>, <pydriller.domain.commit.Method object at 0x7f1983f44e50>, <pydriller.domain.commit.Method object at 0x7f1983f27910>], []]"
thefuck,5eeb9d704ca285198cdbf61121532f3054fed535,#102 Use `side_effect` in `ssh_known_host` rule,2015-05-01 04:41:33+02:00,nvbn,8,13,21,2,"['test_ssh_known_host.py', 'ssh_known_hosts.py']","['import os\nimport pytest\nfrom mock import Mock\nfrom thefuck.rules.ssh_known_hosts import match, get_new_command,\\\n    remove_offending_keys\nfrom tests.utils import Command\n\n\n@pytest.fixture\ndef ssh_error(tmpdir):\n    path = os.path.join(str(tmpdir), \'known_hosts\')\n\n    def reset(path):\n        with open(path, \'w\') as fh:\n            lines = [\n                \'123.234.567.890 asdjkasjdakjsd\\n\'\n                \'98.765.432.321 ejioweojwejrosj\\n\'\n                \'111.222.333.444 qwepoiwqepoiss\\n\'\n            ]\n            fh.writelines(lines)\n\n    def known_hosts(path):\n        with open(path, \'r\') as fh:\n            return fh.readlines()\n\n    reset(path)\n\n    errormsg = u""""""@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\nb6:cb:07:34:c0:a0:94:d3:0d:69:83:31:f4:c5:20:9b.\nPlease contact your system administrator.\nAdd correct host key in {0} to get rid of this message.\nOffending RSA key in {0}:2\nRSA host key for {1} has changed and you have requested strict checking.\nHost key verification failed."""""".format(path, \'98.765.432.321\')\n\n    return errormsg, path, reset, known_hosts\n\n\ndef test_match(ssh_error):\n    errormsg, _, _, _ = ssh_error\n    assert match(Command(\'ssh\', stderr=errormsg), None)\n    assert match(Command(\'ssh\', stderr=errormsg), None)\n    assert match(Command(\'scp something something\', stderr=errormsg), None)\n    assert match(Command(\'scp something something\', stderr=errormsg), None)\n    assert not match(Command(stderr=errormsg), None)\n    assert not match(Command(\'notssh\', stderr=errormsg), None)\n    assert not match(Command(\'ssh\'), None)\n\n\ndef test_remove_offending_keys(ssh_error):\n    errormsg, path, reset, known_hosts = ssh_error\n    command = Command(\'ssh user@host\', stderr=errormsg)\n    remove_offending_keys(command, None)\n    expected = [\'123.234.567.890 asdjkasjdakjsd\\n\', \'111.222.333.444 qwepoiwqepoiss\\n\']\n    assert known_hosts(path) == expected\n\n\ndef test_get_new_command(ssh_error, monkeypatch):\n    errormsg, _, _, _ = ssh_error\n\n    method = Mock()\n    monkeypatch.setattr(\'thefuck.rules.ssh_known_hosts.remove_offending_keys\', method)\n    assert get_new_command(Command(\'ssh user@host\', stderr=errormsg), None) == \'ssh user@host\'\n    assert method.call_count\n', 'import re\n\npatterns = [\n    r\'WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!\',\n    r\'WARNING: POSSIBLE DNS SPOOFING DETECTED!\',\n    r""Warning: the \\S+ host key for \'([^\']+)\' differs from the key for the IP address \'([^\']+)\'"",\n]\noffending_pattern = re.compile(\n    r\'(?:Offending (?:key for IP|\\S+ key)|Matching host key) in ([^:]+):(\\d+)\',\n    re.MULTILINE)\n\ncommands = [\'ssh\', \'scp\']\n\n\ndef match(command, settings):\n    if not command.script:\n        return False\n    if not command.script.split()[0] in commands:\n        return False\n    if not any([re.findall(pattern, command.stderr) for pattern in patterns]):\n        return False\n    return True\n\n\ndef remove_offending_keys(command, settings):\n    offending = offending_pattern.findall(command.stderr)\n    for filepath, lineno in offending:\n        with open(filepath, \'r\') as fh:\n            lines = fh.readlines()\n            del lines[int(lineno) - 1]\n        with open(filepath, \'w\') as fh:\n            fh.writelines(lines)\n\n\ndef get_new_command(command, settings):\n    remove_offending_keys(command, settings)\n    return command.script\n']","['import os\nimport pytest\nfrom mock import Mock\nfrom thefuck.rules.ssh_known_hosts import match, get_new_command,\\\n    side_effect\nfrom tests.utils import Command\n\n\n@pytest.fixture\ndef ssh_error(tmpdir):\n    path = os.path.join(str(tmpdir), \'known_hosts\')\n\n    def reset(path):\n        with open(path, \'w\') as fh:\n            lines = [\n                \'123.234.567.890 asdjkasjdakjsd\\n\'\n                \'98.765.432.321 ejioweojwejrosj\\n\'\n                \'111.222.333.444 qwepoiwqepoiss\\n\'\n            ]\n            fh.writelines(lines)\n\n    def known_hosts(path):\n        with open(path, \'r\') as fh:\n            return fh.readlines()\n\n    reset(path)\n\n    errormsg = u""""""@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\nb6:cb:07:34:c0:a0:94:d3:0d:69:83:31:f4:c5:20:9b.\nPlease contact your system administrator.\nAdd correct host key in {0} to get rid of this message.\nOffending RSA key in {0}:2\nRSA host key for {1} has changed and you have requested strict checking.\nHost key verification failed."""""".format(path, \'98.765.432.321\')\n\n    return errormsg, path, reset, known_hosts\n\n\ndef test_match(ssh_error):\n    errormsg, _, _, _ = ssh_error\n    assert match(Command(\'ssh\', stderr=errormsg), None)\n    assert match(Command(\'ssh\', stderr=errormsg), None)\n    assert match(Command(\'scp something something\', stderr=errormsg), None)\n    assert match(Command(\'scp something something\', stderr=errormsg), None)\n    assert not match(Command(stderr=errormsg), None)\n    assert not match(Command(\'notssh\', stderr=errormsg), None)\n    assert not match(Command(\'ssh\'), None)\n\n\ndef test_side_effect(ssh_error):\n    errormsg, path, reset, known_hosts = ssh_error\n    command = Command(\'ssh user@host\', stderr=errormsg)\n    side_effect(command, None)\n    expected = [\'123.234.567.890 asdjkasjdakjsd\\n\', \'111.222.333.444 qwepoiwqepoiss\\n\']\n    assert known_hosts(path) == expected\n\n\ndef test_get_new_command(ssh_error, monkeypatch):\n    errormsg, _, _, _ = ssh_error\n    assert get_new_command(Command(\'ssh user@host\', stderr=errormsg), None) == \'ssh user@host\'\n', 'import re\n\npatterns = [\n    r\'WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!\',\n    r\'WARNING: POSSIBLE DNS SPOOFING DETECTED!\',\n    r""Warning: the \\S+ host key for \'([^\']+)\' differs from the key for the IP address \'([^\']+)\'"",\n]\noffending_pattern = re.compile(\n    r\'(?:Offending (?:key for IP|\\S+ key)|Matching host key) in ([^:]+):(\\d+)\',\n    re.MULTILINE)\n\ncommands = [\'ssh\', \'scp\']\n\n\ndef match(command, settings):\n    if not command.script:\n        return False\n    if not command.script.split()[0] in commands:\n        return False\n    if not any([re.findall(pattern, command.stderr) for pattern in patterns]):\n        return False\n    return True\n\n\ndef get_new_command(command, settings):\n    return command.script\n\n\ndef side_effect(command, settings):\n    offending = offending_pattern.findall(command.stderr)\n    for filepath, lineno in offending:\n        with open(filepath, \'r\') as fh:\n            lines = fh.readlines()\n            del lines[int(lineno) - 1]\n        with open(filepath, \'w\') as fh:\n            fh.writelines(lines)\n']","[[<pydriller.domain.commit.Method object at 0x7f1983eed910>, <pydriller.domain.commit.Method object at 0x7f1983eed100>, <pydriller.domain.commit.Method object at 0x7f1983eed130>, <pydriller.domain.commit.Method object at 0x7f1983eeda30>, <pydriller.domain.commit.Method object at 0x7f1983eb27c0>, <pydriller.domain.commit.Method object at 0x7f1983eb2640>], [<pydriller.domain.commit.Method object at 0x7f1983eca910>, <pydriller.domain.commit.Method object at 0x7f1983ecaf70>, <pydriller.domain.commit.Method object at 0x7f1983eca250>]]","[[<pydriller.domain.commit.Method object at 0x7f1983eb2640>, <pydriller.domain.commit.Method object at 0x7f1983eb27c0>, <pydriller.domain.commit.Method object at 0x7f1983eb9e20>], [<pydriller.domain.commit.Method object at 0x7f1983f05b80>, <pydriller.domain.commit.Method object at 0x7f1983ecaf70>, <pydriller.domain.commit.Method object at 0x7f1983f058e0>]]"
thefuck,fb7376f5a56e04be5dcaa81bcb19599ee650abbe,Bump to 1.32,2015-05-01 04:47:25+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nVERSION = \'1.31\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\', \'thefuck-alias = thefuck.main:alias\']})\n']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.32\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\', \'thefuck-alias = thefuck.main:alias\']})\n']",[[]],[[]]
thefuck,ba601644d697ef5f54198ae4d041eabb8792ad8d,"#1 Add history of last commands, allow fuck more than once",2015-05-01 08:38:38+02:00,nvbn,110,20,130,4,"['test_history.py', 'test_main.py', 'history.py', 'main.py']","[None, ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main, conf, types\nfrom tests.utils import Rule, Command\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == Rule('bash', match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.DEFAULT_RULES))) \\\n               == [Rule('bash', 'bash', 'bash'),\n                   Rule('lisp', 'lisp', 'lisp'),\n                   Rule('bash', 'bash', 'bash'),\n                   Rule('lisp', 'lisp', 'lisp')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=types.RulesNamesList(['bash'])))) \\\n               == [Rule('bash', 'bash', 'bash'),\n                   Rule('bash', 'bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), ['thefuck', 'apt-get',\n                                         'search', 'vim']) \\\n               == Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), ['']) is None\n\n\ndef test_get_matched_rule(capsys):\n    rules = [Rule('', lambda x, _: x.script == 'cd ..'),\n             Rule('', lambda *_: False),\n             Rule('rule', Mock(side_effect=OSError('Denied')))]\n    assert main.get_matched_rule(Command('ls'),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(Command('cd ..'),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n        # With side effect:\n        side_effect = Mock()\n        settings = Mock()\n        command = Mock()\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command',\n                           side_effect=side_effect),\n                      command, settings)\n        assert capsys.readouterr() == ('new-command\\n', '')\n        side_effect.assert_called_once_with(command, settings)\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      None, None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', None, Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # With side effect and without confirmation:\n    assert main.confirm('command', Mock(), Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command*\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm(\n            'command', None, Mock(require_confirmation=True,\n                                  no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n        # With side effect:\n        assert main.confirm(\n            'command', Mock(), Mock(require_confirmation=True,\n                                    no_colors=True))\n        assert capsys.readouterr() == ('', 'command* [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', None,\n                                Mock(require_confirmation=True,\n                                     no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", None, 'from imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom . import logs, conf, types\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    conf.initialize_settings_file(user_dir)\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return types.Rule(rule.name[:-3], rule_module.match,\n                      rule_module.get_new_command,\n                      getattr(rule_module, \'enabled_by_default\', True),\n                      getattr(rule_module, \'side_effect\', None))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent \\\n        .joinpath(\'rules\') \\\n        .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return types.Command(script, result.stdout.read().decode(\'utf-8\'),\n                             result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, side_effect, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, side_effect, settings)\n        return True\n\n    logs.confirm_command(new_command, side_effect, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, rule.side_effect, settings):\n        if rule.side_effect:\n            rule.side_effect(command, settings)\n        print(new_command)\n\n\ndef is_second_run(command):\n    """"""Is it the second run of `fuck`?""""""\n    return command.script.startswith(\'fuck\')\n\n\ndef alias():\n    print(""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n"")\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        if is_second_run(command):\n            logs.failed(""Can\'t fuck twice"", settings)\n            return\n\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n']","[""import pytest\nfrom mock import patch, Mock\nfrom thefuck.history import History\n\n\n@pytest.fixture\ndef process(monkeypatch):\n    Process = Mock()\n    Process.return_value.parent.return_value.pid = 1\n    monkeypatch.setattr('thefuck.history.Process', Process)\n\n\n@pytest.fixture\ndef db(monkeypatch):\n    class DBMock(dict):\n        def __init__(self):\n            super(DBMock, self).__init__()\n            self.sync = Mock()\n\n        def __call__(self, *args, **kwargs):\n            return self\n\n    db = DBMock()\n    monkeypatch.setattr('thefuck.history.shelve.open', db)\n    return db\n\n\n@pytest.mark.usefixtures('process')\nclass TestHistory(object):\n    def test_set(self, db):\n        history = History()\n        history.update(last_script='ls',\n                       last_fixed_script=None)\n        assert db == {'1-last_script': 'ls',\n                      '1-last_fixed_script': None}\n\n    def test_get(self, db):\n        history = History()\n        db['1-last_script'] = 'cd ..'\n        assert history.last_script == 'cd ..'\n\n    def test_get_without_value(self, db):\n        history = History()\n        assert history.last_script is None\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main, conf, types\nfrom tests.utils import Rule, Command\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == Rule('bash', match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.DEFAULT_RULES))) \\\n               == [Rule('bash', 'bash', 'bash'),\n                   Rule('lisp', 'lisp', 'lisp'),\n                   Rule('bash', 'bash', 'bash'),\n                   Rule('lisp', 'lisp', 'lisp')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=types.RulesNamesList(['bash'])))) \\\n               == [Rule('bash', 'bash', 'bash'),\n                   Rule('bash', 'bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), Mock(),\n            ['thefuck', 'apt-get', 'search', 'vim']) \\\n               == Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), Mock(), ['']) is None\n        # When command is `fuck`:\n        assert main.get_command(\n            Mock(),\n            Mock(last_script='ls', last_fixed_script='ls -la'),\n            ['thefuck', 'fuck']).script == 'ls -la'\n        # When command equals to last command:\n        assert main.get_command(\n            Mock(),\n            Mock(last_script='ls', last_fixed_script='ls -la'),\n            ['thefuck', 'ls']).script == 'ls -la'\n        # When last command is `fuck` and no last fixed script:\n        assert main.get_command(\n            Mock(),\n            Mock(last_script='ls', last_fixed_script=''),\n            ['thefuck', 'ls']).script == 'ls'\n\n\ndef test_get_matched_rule(capsys):\n    rules = [Rule('', lambda x, _: x.script == 'cd ..'),\n             Rule('', lambda *_: False),\n             Rule('rule', Mock(side_effect=OSError('Denied')))]\n    assert main.get_matched_rule(Command('ls'),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(Command('cd ..'),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), Mock(), None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n        # With side effect:\n        side_effect = Mock()\n        settings = Mock()\n        command = Mock(script='ls')\n        history = Mock()\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command',\n                           side_effect=side_effect),\n                      command, history, settings)\n        assert capsys.readouterr() == ('new-command\\n', '')\n        side_effect.assert_called_once_with(command, settings)\n        # Ensure that history updated:\n        history.update.assert_called_once_with(last_script='ls',\n                                               last_fixed_script='new-command')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), Mock(), None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', None, Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # With side effect and without confirmation:\n    assert main.confirm('command', Mock(), Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command*\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm(\n            'command', None, Mock(require_confirmation=True,\n                                  no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n        # With side effect:\n        assert main.confirm(\n            'command', Mock(), Mock(require_confirmation=True,\n                                    no_colors=True))\n        assert capsys.readouterr() == ('', 'command* [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', None,\n                                Mock(require_confirmation=True,\n                                     no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", 'import os\nimport shelve\nfrom tempfile import gettempdir\nfrom psutil import Process\n\n\nclass History(object):\n    """"""Temporary history of commands/fixed-commands dependent on\n    current shell instance.\n\n    """"""\n\n    def __init__(self):\n        self._path = os.path.join(gettempdir(), \'.thefuck_history\')\n        self._pid = Process(os.getpid()).parent().pid\n        self._db = shelve.open(self._path)\n\n    def _prepare_key(self, key):\n        return \'{}-{}\'.format(self._pid, key)\n\n    def update(self, **kwargs):\n        self._db.update({self._prepare_key(k): v for k,v in kwargs.items()})\n        self._db.sync()\n        return self\n\n    def __getattr__(self, item):\n        return self._db.get(self._prepare_key(item))\n', 'from imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom .history import History\nfrom . import logs, conf, types\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    conf.initialize_settings_file(user_dir)\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return types.Rule(rule.name[:-3], rule_module.match,\n                      rule_module.get_new_command,\n                      getattr(rule_module, \'enabled_by_default\', True),\n                      getattr(rule_module, \'side_effect\', None))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent \\\n        .joinpath(\'rules\') \\\n        .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, history, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if script == \'fuck\' or script == history.last_script:\n        script = history.last_fixed_script or history.last_script\n\n    if not script:\n        return\n\n    history.update(last_script=script,\n                   last_fixed_script=None)\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return types.Command(script, result.stdout.read().decode(\'utf-8\'),\n                             result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, side_effect, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, side_effect, settings)\n        return True\n\n    logs.confirm_command(new_command, side_effect, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, history, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, rule.side_effect, settings):\n        if rule.side_effect:\n            rule.side_effect(command, settings)\n        history.update(last_script=command.script,\n                       last_fixed_script=new_command)\n        print(new_command)\n\n\ndef alias():\n    print(""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n"")\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n    history = History()\n\n    command = get_command(settings, history, sys.argv)\n    if command:\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, history, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n']","[[], [<pydriller.domain.commit.Method object at 0x7f1983f15790>, <pydriller.domain.commit.Method object at 0x7f1983f15640>, <pydriller.domain.commit.Method object at 0x7f1983f158e0>, <pydriller.domain.commit.Method object at 0x7f1983f157c0>, <pydriller.domain.commit.Method object at 0x7f1983f15280>, <pydriller.domain.commit.Method object at 0x7f1983f15100>], [], [<pydriller.domain.commit.Method object at 0x7f1983f0a640>, <pydriller.domain.commit.Method object at 0x7f1983f0a670>, <pydriller.domain.commit.Method object at 0x7f1983f0a910>, <pydriller.domain.commit.Method object at 0x7f1983f0a790>, <pydriller.domain.commit.Method object at 0x7f1983f15b80>, <pydriller.domain.commit.Method object at 0x7f1983f15cd0>, <pydriller.domain.commit.Method object at 0x7f1983f15e20>, <pydriller.domain.commit.Method object at 0x7f1983f15e50>, <pydriller.domain.commit.Method object at 0x7f1983f15670>, <pydriller.domain.commit.Method object at 0x7f1983f154f0>, <pydriller.domain.commit.Method object at 0x7f1983f15520>]]","[[<pydriller.domain.commit.Method object at 0x7f1983d7a160>, <pydriller.domain.commit.Method object at 0x7f1983d7a6a0>, <pydriller.domain.commit.Method object at 0x7f1983d7abe0>, <pydriller.domain.commit.Method object at 0x7f1983d7a2b0>, <pydriller.domain.commit.Method object at 0x7f1983d7a550>, <pydriller.domain.commit.Method object at 0x7f1983d7a190>, <pydriller.domain.commit.Method object at 0x7f1983f1bf70>], [<pydriller.domain.commit.Method object at 0x7f1983f15f70>, <pydriller.domain.commit.Method object at 0x7f1983f20280>], [<pydriller.domain.commit.Method object at 0x7f1983f0e280>, <pydriller.domain.commit.Method object at 0x7f1983f0e3d0>, <pydriller.domain.commit.Method object at 0x7f1983f0e100>, <pydriller.domain.commit.Method object at 0x7f1983f0e130>], [<pydriller.domain.commit.Method object at 0x7f1983f15670>, <pydriller.domain.commit.Method object at 0x7f1983f828e0>, <pydriller.domain.commit.Method object at 0x7f1983f82bb0>, <pydriller.domain.commit.Method object at 0x7f1983f82790>, <pydriller.domain.commit.Method object at 0x7f1983f15b80>, <pydriller.domain.commit.Method object at 0x7f1983f15e50>]]"
thefuck,dd1861955cdaa18ac05d83810c1a9e67707396c4,Refine tests,2015-05-02 04:29:55+02:00,nvbn,246,200,446,4,"['test_conf.py', 'test_history.py', 'test_main.py', 'test_utils.py']","[""import six\nfrom mock import patch, Mock\nfrom thefuck import conf\nfrom tests.utils import Rule\n\n\ndef test_default():\n    assert Rule('test', enabled_by_default=True) in conf.DEFAULT_RULES\n    assert Rule('test', enabled_by_default=False) not in conf.DEFAULT_RULES\n    assert Rule('test', enabled_by_default=False) in (conf.DEFAULT_RULES + ['test'])\n\n\ndef test_settings_defaults():\n    with patch('thefuck.conf.load_source', return_value=object()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        for key, val in conf.DEFAULT_SETTINGS.items():\n            assert getattr(conf.get_settings(Mock()), key) == val\n\n\ndef test_settings_from_file():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n\ndef test_settings_from_file_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=conf.DEFAULT_RULES + ['test'],\n                                                             wait_command=10,\n                                                             require_confirmation=True,\n                                                             no_colors=True)), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['test']\n\n\ndef test_settings_from_env():\n    with patch('thefuck.conf.load_source', return_value=Mock(rules=['test'],\n                                                             wait_command=10)), \\\n         patch('thefuck.conf.os.environ',\n               new_callable=lambda: {'THEFUCK_RULES': 'bash:lisp',\n                                     'THEFUCK_WAIT_COMMAND': '55',\n                                     'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                                     'THEFUCK_NO_COLORS': 'false'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n\ndef test_settings_from_env_with_DEFAULT():\n    with patch('thefuck.conf.load_source', return_value=Mock()), \\\n         patch('thefuck.conf.os.environ', new_callable=lambda: {'THEFUCK_RULES': 'DEFAULT_RULES:bash:lisp'}):\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['bash', 'lisp']\n\n\ndef test_initialize_settings_file_ignore_if_exists():\n    settings_path_mock = Mock(is_file=Mock(return_value=True), open=Mock())\n    user_dir_mock = Mock(joinpath=Mock(return_value=settings_path_mock))\n    conf.initialize_settings_file(user_dir_mock)\n    assert settings_path_mock.is_file.call_count == 1\n    assert not settings_path_mock.open.called\n\n\ndef test_initialize_settings_file_create_if_exists_not():\n    settings_file = six.StringIO()\n    settings_path_mock = Mock(\n        is_file=Mock(return_value=False),\n        open=Mock(return_value=Mock(\n            __exit__=lambda *args: None, __enter__=lambda *args: settings_file\n        )),\n    )\n    user_dir_mock = Mock(joinpath=Mock(return_value=settings_path_mock))\n    conf.initialize_settings_file(user_dir_mock)\n    settings_file_contents = settings_file.getvalue()\n    assert settings_path_mock.is_file.call_count == 1\n    assert settings_path_mock.open.call_count == 1\n    assert conf.SETTINGS_HEADER in settings_file_contents\n    for setting in conf.DEFAULT_SETTINGS.items():\n        assert '# {} = {}\\n'.format(*setting) in settings_file_contents\n    settings_file.close()\n"", ""import pytest\nfrom mock import patch, Mock\nfrom thefuck.history import History\n\n\n@pytest.fixture\ndef process(monkeypatch):\n    Process = Mock()\n    Process.return_value.parent.return_value.pid = 1\n    monkeypatch.setattr('thefuck.history.Process', Process)\n\n\n@pytest.fixture\ndef db(monkeypatch):\n    class DBMock(dict):\n        def __init__(self):\n            super(DBMock, self).__init__()\n            self.sync = Mock()\n\n        def __call__(self, *args, **kwargs):\n            return self\n\n    db = DBMock()\n    monkeypatch.setattr('thefuck.history.shelve.open', db)\n    return db\n\n\n@pytest.mark.usefixtures('process')\nclass TestHistory(object):\n    def test_set(self, db):\n        history = History()\n        history.update(last_script='ls',\n                       last_fixed_script=None)\n        assert db == {'1-last_script': 'ls',\n                      '1-last_fixed_script': None}\n\n    def test_get(self, db):\n        history = History()\n        db['1-last_script'] = 'cd ..'\n        assert history.last_script == 'cd ..'\n\n    def test_get_without_value(self, db):\n        history = History()\n        assert history.last_script is None\n"", ""from subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import patch, Mock\nfrom thefuck import main, conf, types\nfrom tests.utils import Rule, Command\n\n\ndef test_load_rule():\n    match = object()\n    get_new_command = object()\n    with patch('thefuck.main.load_source',\n               return_value=Mock(\n                   match=match,\n                   get_new_command=get_new_command,\n                   enabled_by_default=True)) as load_source:\n        assert main.load_rule(Path('/rules/bash.py')) \\\n               == Rule('bash', match, get_new_command)\n        load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\ndef test_get_rules():\n    with patch('thefuck.main.Path.glob') as glob, \\\n            patch('thefuck.main.load_source',\n                  lambda x, _: Mock(match=x, get_new_command=x,\n                                    enabled_by_default=True)):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=conf.DEFAULT_RULES))) \\\n               == [Rule('bash', 'bash', 'bash'),\n                   Rule('lisp', 'lisp', 'lisp'),\n                   Rule('bash', 'bash', 'bash'),\n                   Rule('lisp', 'lisp', 'lisp')]\n        assert list(main.get_rules(\n            Path('~'),\n            Mock(rules=types.RulesNamesList(['bash'])))) \\\n               == [Rule('bash', 'bash', 'bash'),\n                   Rule('bash', 'bash', 'bash')]\n\n\ndef test_get_command():\n    with patch('thefuck.main.Popen') as Popen, \\\n            patch('thefuck.main.os.environ',\n                  new_callable=lambda: {}), \\\n            patch('thefuck.main.wait_output',\n                  return_value=True):\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        assert main.get_command(Mock(), Mock(),\n            ['thefuck', 'apt-get', 'search', 'vim']) \\\n               == Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n        assert main.get_command(Mock(), Mock(), ['']) is None\n        # When command is `fuck`:\n        assert main.get_command(\n            Mock(),\n            Mock(last_script='ls', last_fixed_script='ls -la'),\n            ['thefuck', 'fuck']).script == 'ls -la'\n        # When command equals to last command:\n        assert main.get_command(\n            Mock(),\n            Mock(last_script='ls', last_fixed_script='ls -la'),\n            ['thefuck', 'ls']).script == 'ls -la'\n        # When last command is `fuck` and no last fixed script:\n        assert main.get_command(\n            Mock(),\n            Mock(last_script='ls', last_fixed_script=''),\n            ['thefuck', 'ls']).script == 'ls'\n\n\ndef test_get_matched_rule(capsys):\n    rules = [Rule('', lambda x, _: x.script == 'cd ..'),\n             Rule('', lambda *_: False),\n             Rule('rule', Mock(side_effect=OSError('Denied')))]\n    assert main.get_matched_rule(Command('ls'),\n                                 rules, Mock(no_colors=True)) is None\n    assert main.get_matched_rule(Command('cd ..'),\n                                 rules, Mock(no_colors=True)) == rules[0]\n    assert capsys.readouterr()[1].split('\\n')[0] \\\n           == '[WARN] Rule rule:'\n\n\ndef test_run_rule(capsys):\n    with patch('thefuck.main.confirm', return_value=True):\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), Mock(), None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n        # With side effect:\n        side_effect = Mock()\n        settings = Mock()\n        command = Mock(script='ls')\n        history = Mock()\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command',\n                           side_effect=side_effect),\n                      command, history, settings)\n        assert capsys.readouterr() == ('new-command\\n', '')\n        side_effect.assert_called_once_with(command, settings)\n        # Ensure that history updated:\n        history.update.assert_called_once_with(last_script='ls',\n                                               last_fixed_script='new-command')\n    with patch('thefuck.main.confirm', return_value=False):\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), Mock(), None)\n        assert capsys.readouterr() == ('', '')\n\n\ndef test_confirm(capsys):\n    # When confirmation not required:\n    assert main.confirm('command', None, Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command\\n')\n    # With side effect and without confirmation:\n    assert main.confirm('command', Mock(), Mock(require_confirmation=False))\n    assert capsys.readouterr() == ('', 'command*\\n')\n    # When confirmation required and confirmed:\n    with patch('thefuck.main.sys.stdin.read', return_value='\\n'):\n        assert main.confirm(\n            'command', None, Mock(require_confirmation=True,\n                                  no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n        # With side effect:\n        assert main.confirm(\n            'command', Mock(), Mock(require_confirmation=True,\n                                    no_colors=True))\n        assert capsys.readouterr() == ('', 'command* [enter/ctrl+c]')\n    # When confirmation required and ctrl+c:\n    with patch('thefuck.main.sys.stdin.read', side_effect=KeyboardInterrupt):\n        assert not main.confirm('command', None,\n                                Mock(require_confirmation=True,\n                                     no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", ""from mock import Mock\nfrom thefuck.utils import sudo_support, wrap_settings\nfrom thefuck.types import Settings\nfrom tests.utils import Command\n\n\ndef test_wrap_settings():\n    fn = lambda _, settings: settings\n    assert wrap_settings({'key': 'val'})(fn)(None, Settings({})) \\\n           == {'key': 'val'}\n    assert wrap_settings({'key': 'new-val'})(fn)(\n        None, Settings({'key': 'val'})) == {'key': 'new-val'}\n\n\ndef test_sudo_support():\n    fn = Mock(return_value=True, __name__='')\n    assert sudo_support(fn)(Command('sudo ls'), None)\n    fn.assert_called_once_with(Command('ls'), None)\n\n    fn.return_value = False\n    assert not sudo_support(fn)(Command('sudo ls'), None)\n\n    fn.return_value = 'pwd'\n    assert sudo_support(fn)(Command('sudo ls'), None) == 'sudo pwd'\n\n    assert sudo_support(fn)(Command('ls'), None) == 'pwd'\n""]","[""import pytest\nimport six\nfrom mock import Mock\nfrom thefuck import conf\nfrom tests.utils import Rule\n\n\n@pytest.mark.parametrize('enabled, rules, result', [\n    (True, conf.DEFAULT_RULES, True),\n    (False, conf.DEFAULT_RULES, False),\n    (False, conf.DEFAULT_RULES + ['test'], True)])\ndef test_default(enabled, rules, result):\n    assert (Rule('test', enabled_by_default=enabled) in rules) == result\n\n\n@pytest.fixture\ndef load_source(monkeypatch):\n    mock = Mock()\n    monkeypatch.setattr('thefuck.conf.load_source', mock)\n    return mock\n\n\n@pytest.fixture\ndef environ(monkeypatch):\n    data = {}\n    monkeypatch.setattr('thefuck.conf.os.environ', data)\n    return data\n\n\n@pytest.mark.usefixture('environ')\ndef test_settings_defaults(load_source):\n    load_source.return_value = object()\n    for key, val in conf.DEFAULT_SETTINGS.items():\n        assert getattr(conf.get_settings(Mock()), key) == val\n\n\n@pytest.mark.usefixture('environ')\nclass TestSettingsFromFile(object):\n    def test_from_file(self, load_source):\n        load_source.return_value = Mock(rules=['test'],\n                                        wait_command=10,\n                                        require_confirmation=True,\n                                        no_colors=True)\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n    def test_from_file_with_DEFAULT(self, load_source):\n        load_source.return_value = Mock(rules=conf.DEFAULT_RULES + ['test'],\n                                        wait_command=10,\n                                        require_confirmation=True,\n                                        no_colors=True)\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['test']\n\n\n@pytest.mark.usefixture('load_source')\nclass TestSettingsFromEnv(object):\n    def test_from_env(self, environ):\n        environ.update({'THEFUCK_RULES': 'bash:lisp',\n                        'THEFUCK_WAIT_COMMAND': '55',\n                        'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                        'THEFUCK_NO_COLORS': 'false'})\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n    def test_from_env_with_DEFAULT(self, environ):\n        environ.update({'THEFUCK_RULES': 'DEFAULT_RULES:bash:lisp'})\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['bash', 'lisp']\n\n\nclass TestInitializeSettingsFile(object):\n    def test_ignore_if_exists(self):\n        settings_path_mock = Mock(is_file=Mock(return_value=True), open=Mock())\n        user_dir_mock = Mock(joinpath=Mock(return_value=settings_path_mock))\n        conf.initialize_settings_file(user_dir_mock)\n        assert settings_path_mock.is_file.call_count == 1\n        assert not settings_path_mock.open.called\n\n    def test_create_if_doesnt_exists(self):\n        settings_file = six.StringIO()\n        settings_path_mock = Mock(\n            is_file=Mock(return_value=False),\n            open=Mock(return_value=Mock(\n                __exit__=lambda *args: None, __enter__=lambda *args: settings_file)))\n        user_dir_mock = Mock(joinpath=Mock(return_value=settings_path_mock))\n        conf.initialize_settings_file(user_dir_mock)\n        settings_file_contents = settings_file.getvalue()\n        assert settings_path_mock.is_file.call_count == 1\n        assert settings_path_mock.open.call_count == 1\n        assert conf.SETTINGS_HEADER in settings_file_contents\n        for setting in conf.DEFAULT_SETTINGS.items():\n            assert '# {} = {}\\n'.format(*setting) in settings_file_contents\n        settings_file.close()\n"", ""import pytest\nfrom mock import Mock\nfrom thefuck.history import History\n\n\nclass TestHistory(object):\n    @pytest.fixture(autouse=True)\n    def process(self, monkeypatch):\n        Process = Mock()\n        Process.return_value.parent.return_value.pid = 1\n        monkeypatch.setattr('thefuck.history.Process', Process)\n        return Process\n\n    @pytest.fixture(autouse=True)\n    def db(self, monkeypatch):\n        class DBMock(dict):\n            def __init__(self):\n                super(DBMock, self).__init__()\n                self.sync = Mock()\n\n            def __call__(self, *args, **kwargs):\n                return self\n\n        db = DBMock()\n        monkeypatch.setattr('thefuck.history.shelve.open', db)\n        return db\n\n    def test_set(self, db):\n        history = History()\n        history.update(last_script='ls',\n                       last_fixed_script=None)\n        assert db == {'1-last_script': 'ls',\n                      '1-last_fixed_script': None}\n\n    def test_get(self, db):\n        history = History()\n        db['1-last_script'] = 'cd ..'\n        assert history.last_script == 'cd ..'\n\n    def test_get_without_value(self):\n        history = History()\n        assert history.last_script is None\n"", ""import pytest\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import Mock\nfrom thefuck import main, conf, types\nfrom tests.utils import Rule, Command\n\n\ndef test_load_rule(monkeypatch):\n    match = object()\n    get_new_command = object()\n    load_source = Mock()\n    load_source.return_value = Mock(match=match,\n                                    get_new_command=get_new_command,\n                                    enabled_by_default=True)\n    monkeypatch.setattr('thefuck.main.load_source', load_source)\n    assert main.load_rule(Path('/rules/bash.py')) \\\n           == Rule('bash', match, get_new_command)\n    load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\n@pytest.mark.parametrize('conf_rules, rules', [\n    (conf.DEFAULT_RULES, [Rule('bash', 'bash', 'bash'),\n                          Rule('lisp', 'lisp', 'lisp'),\n                          Rule('bash', 'bash', 'bash'),\n                          Rule('lisp', 'lisp', 'lisp')]),\n    (types.RulesNamesList(['bash']), [Rule('bash', 'bash', 'bash'),\n                                      Rule('bash', 'bash', 'bash')])])\ndef test_get_rules(monkeypatch, conf_rules, rules):\n    monkeypatch.setattr(\n        'thefuck.main.Path.glob',\n        lambda *_: [PosixPath('bash.py'), PosixPath('lisp.py')])\n    monkeypatch.setattr('thefuck.main.load_source',\n                        lambda x, _: Mock(match=x, get_new_command=x,\n                                          enabled_by_default=True))\n    assert list(main.get_rules(Path('~'), Mock(rules=conf_rules))) == rules\n\n\nclass TestGetCommand(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, monkeypatch):\n        Popen = Mock()\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        monkeypatch.setattr('thefuck.main.Popen', Popen)\n        return Popen\n\n    @pytest.fixture(autouse=True)\n    def prepare(self, monkeypatch):\n        monkeypatch.setattr('thefuck.main.os.environ', {})\n        monkeypatch.setattr('thefuck.main.wait_output', lambda *_: True)\n\n    def test_get_command_calls(self, Popen):\n        assert main.get_command(Mock(), Mock(),\n            ['thefuck', 'apt-get', 'search', 'vim']) \\\n               == Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n    @pytest.mark.parametrize('history, args, result', [\n        (Mock(), [''], None),\n        (Mock(last_script='ls', last_fixed_script='ls -la'),\n         ['thefuck', 'fuck'], 'ls -la'),\n        (Mock(last_script='ls', last_fixed_script='ls -la'),\n         ['thefuck', 'ls'], 'ls -la'),\n        (Mock(last_script='ls', last_fixed_script=''),\n         ['thefuck', 'ls'], 'ls'),\n        (Mock(last_script='ls', last_fixed_script=''),\n         ['thefuck', 'fuck'], 'ls')])\n    def test_get_command_script(self, history, args, result):\n        if result:\n            assert main.get_command(Mock(), history, args).script == result\n        else:\n            assert main.get_command(Mock(), history, args) is None\n\n\nclass TestGetMatchedRule(object):\n    @pytest.fixture\n    def rules(self):\n        return [Rule('', lambda x, _: x.script == 'cd ..'),\n                Rule('', lambda *_: False),\n                Rule('rule', Mock(side_effect=OSError('Denied')))]\n\n    def test_no_match(self):\n        assert main.get_matched_rule(\n            Command('ls'), [Rule('', lambda *_: False)],\n            Mock(no_colors=True)) is None\n\n    def test_match(self):\n        rule = Rule('', lambda x, _: x.script == 'cd ..')\n        assert main.get_matched_rule(\n            Command('cd ..'), [rule], Mock(no_colors=True)) == rule\n\n    def test_when_rule_failed(self, capsys):\n        main.get_matched_rule(\n            Command('ls'), [Rule('test', Mock(side_effect=OSError('Denied')))],\n            Mock(no_colors=True))\n        assert capsys.readouterr()[1].split('\\n')[0] == '[WARN] Rule test:'\n\n\nclass TestRunRule(object):\n    @pytest.fixture(autouse=True)\n    def confirm(self, monkeypatch):\n        mock = Mock(return_value=True)\n        monkeypatch.setattr('thefuck.main.confirm', mock)\n        return mock\n\n    def test_run_rule(self, capsys):\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), Mock(), None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n\n    def test_run_rule_with_side_effect(self, capsys):\n        side_effect = Mock()\n        settings = Mock()\n        command = Command()\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command',\n                           side_effect=side_effect),\n                      command, Mock(), settings)\n        assert capsys.readouterr() == ('new-command\\n', '')\n        side_effect.assert_called_once_with(command, settings)\n\n    def test_hisotry_updated(self):\n        history = Mock()\n        main.run_rule(Rule(get_new_command=lambda *_: 'ls -lah'),\n                      Command('ls'), history, None)\n        history.update.assert_called_once_with(last_script='ls',\n                                               last_fixed_script='ls -lah')\n\n    def test_when_not_comfirmed(self, capsys, confirm):\n        confirm.return_value = False\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), Mock(), None)\n        assert capsys.readouterr() == ('', '')\n\n\nclass TestConfirm(object):\n    @pytest.fixture\n    def stdin(self, monkeypatch):\n        mock = Mock(return_value='\\n')\n        monkeypatch.setattr('sys.stdin.read', mock)\n        return mock\n\n    def test_when_not_required(self, capsys):\n        assert main.confirm('command', None, Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command\\n')\n\n    def test_with_side_effect_and_without_confirmation(self, capsys):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command*\\n')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed(self, capsys, stdin):\n        assert main.confirm('command', None, Mock(require_confirmation=True,\n                                                  no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed_with_side_effect(self, capsys, stdin):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=True,\n                                                    no_colors=True))\n        assert capsys.readouterr() == ('', 'command* [enter/ctrl+c]')\n\n    def test_when_confirmation_required_and_aborted(self, capsys, stdin):\n        stdin.side_effect = KeyboardInterrupt\n        assert not main.confirm('command', None, Mock(require_confirmation=True,\n                                                      no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", ""import pytest\nfrom mock import Mock\nfrom thefuck.utils import sudo_support, wrap_settings\nfrom thefuck.types import Settings\nfrom tests.utils import Command\n\n\n@pytest.mark.parametrize('override, old, new', [\n    ({'key': 'val'}, {}, {'key': 'val'}),\n    ({'key': 'new-val'}, {'key': 'val'}, {'key': 'new-val'})])\ndef test_wrap_settings(override, old, new):\n    fn = lambda _, settings: settings\n    assert wrap_settings(override)(fn)(None, Settings(old)) == new\n\n\n@pytest.mark.parametrize('return_value, command, called, result', [\n    ('ls -lah', 'sudo ls', 'ls', 'sudo ls -lah'),\n    ('ls -lah', 'ls', 'ls', 'ls -lah'),\n    (True, 'sudo ls', 'ls', True),\n    (True, 'ls', 'ls', True),\n    (False, 'sudo ls', 'ls', False),\n    (False, 'ls', 'ls', False)])\ndef test_sudo_support(return_value, command, called, result):\n    fn = Mock(return_value=return_value, __name__='')\n    assert sudo_support(fn)(Command(command), None) == result\n    fn.assert_called_once_with(Command(called), None)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983eca3d0>, <pydriller.domain.commit.Method object at 0x7f1983eca280>, <pydriller.domain.commit.Method object at 0x7f1983eca8e0>, <pydriller.domain.commit.Method object at 0x7f1983eca790>, <pydriller.domain.commit.Method object at 0x7f1983f36bb0>, <pydriller.domain.commit.Method object at 0x7f1983f363d0>, <pydriller.domain.commit.Method object at 0x7f1983ea8bb0>, <pydriller.domain.commit.Method object at 0x7f1983ea83a0>], [<pydriller.domain.commit.Method object at 0x7f1983d2e040>, <pydriller.domain.commit.Method object at 0x7f1983ef8790>, <pydriller.domain.commit.Method object at 0x7f1983ef8fa0>, <pydriller.domain.commit.Method object at 0x7f1983ef8cd0>, <pydriller.domain.commit.Method object at 0x7f1983ed03d0>, <pydriller.domain.commit.Method object at 0x7f1983ed0e20>, <pydriller.domain.commit.Method object at 0x7f1983ed0280>], [<pydriller.domain.commit.Method object at 0x7f1983f76a60>, <pydriller.domain.commit.Method object at 0x7f1983f76910>, <pydriller.domain.commit.Method object at 0x7f1983f76bb0>, <pydriller.domain.commit.Method object at 0x7f1983f768e0>, <pydriller.domain.commit.Method object at 0x7f1983f763a0>, <pydriller.domain.commit.Method object at 0x7f1983f763d0>], [<pydriller.domain.commit.Method object at 0x7f1983eca130>, <pydriller.domain.commit.Method object at 0x7f1983eca4f0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983f3d3d0>, <pydriller.domain.commit.Method object at 0x7f1983f3d4f0>, <pydriller.domain.commit.Method object at 0x7f1983d62fd0>, <pydriller.domain.commit.Method object at 0x7f1983f3df70>, <pydriller.domain.commit.Method object at 0x7f1983eca3d0>, <pydriller.domain.commit.Method object at 0x7f1983f363d0>, <pydriller.domain.commit.Method object at 0x7f1983d62a90>, <pydriller.domain.commit.Method object at 0x7f1983d62820>, <pydriller.domain.commit.Method object at 0x7f1983eca8e0>, <pydriller.domain.commit.Method object at 0x7f1983ea8bb0>, <pydriller.domain.commit.Method object at 0x7f1983d627f0>, <pydriller.domain.commit.Method object at 0x7f1983ea83a0>, <pydriller.domain.commit.Method object at 0x7f1983f3d3a0>, <pydriller.domain.commit.Method object at 0x7f1983f36bb0>, <pydriller.domain.commit.Method object at 0x7f1983d62940>, <pydriller.domain.commit.Method object at 0x7f1983eca280>, <pydriller.domain.commit.Method object at 0x7f1983eca790>, <pydriller.domain.commit.Method object at 0x7f1983d62970>], [<pydriller.domain.commit.Method object at 0x7f1983f2ba30>, <pydriller.domain.commit.Method object at 0x7f1983f2b3a0>, <pydriller.domain.commit.Method object at 0x7f1983ed0280>, <pydriller.domain.commit.Method object at 0x7f1983efe3a0>, <pydriller.domain.commit.Method object at 0x7f1983ef8cd0>, <pydriller.domain.commit.Method object at 0x7f1983d2e040>, <pydriller.domain.commit.Method object at 0x7f1983f2bcd0>, <pydriller.domain.commit.Method object at 0x7f1983f2b130>], [<pydriller.domain.commit.Method object at 0x7f1983f7d910>, <pydriller.domain.commit.Method object at 0x7f1983f7d3a0>, <pydriller.domain.commit.Method object at 0x7f1983f763d0>, <pydriller.domain.commit.Method object at 0x7f1983f7d250>, <pydriller.domain.commit.Method object at 0x7f1983f7d280>, <pydriller.domain.commit.Method object at 0x7f1983f7db80>, <pydriller.domain.commit.Method object at 0x7f1983f7d670>, <pydriller.domain.commit.Method object at 0x7f1983f76910>, <pydriller.domain.commit.Method object at 0x7f1983f7d640>, <pydriller.domain.commit.Method object at 0x7f1983f7d7c0>, <pydriller.domain.commit.Method object at 0x7f1983f763a0>, <pydriller.domain.commit.Method object at 0x7f1983f82f70>, <pydriller.domain.commit.Method object at 0x7f1983f7da30>, <pydriller.domain.commit.Method object at 0x7f1983f76a60>, <pydriller.domain.commit.Method object at 0x7f1983f7d3d0>, <pydriller.domain.commit.Method object at 0x7f1983f7da60>, <pydriller.domain.commit.Method object at 0x7f1983f82b80>, <pydriller.domain.commit.Method object at 0x7f1983f7d100>, <pydriller.domain.commit.Method object at 0x7f1983f82fa0>, <pydriller.domain.commit.Method object at 0x7f1983f7d4f0>, <pydriller.domain.commit.Method object at 0x7f1983f7d520>, <pydriller.domain.commit.Method object at 0x7f1983f76bb0>, <pydriller.domain.commit.Method object at 0x7f1983f82a60>, <pydriller.domain.commit.Method object at 0x7f1983f768e0>, <pydriller.domain.commit.Method object at 0x7f1983f7dbb0>, <pydriller.domain.commit.Method object at 0x7f1983f7d8e0>, <pydriller.domain.commit.Method object at 0x7f1983f7d790>], [<pydriller.domain.commit.Method object at 0x7f1983e423d0>, <pydriller.domain.commit.Method object at 0x7f1983eca4f0>, <pydriller.domain.commit.Method object at 0x7f1983eca130>, <pydriller.domain.commit.Method object at 0x7f1983eb2e50>]]"
thefuck,2acfea3350101b77e8bb5a638d96d4ffc9f52749,"#1 s/last_script/last_command/, s/last_fixed_script/last_fixed_command/",2015-05-02 04:32:07+02:00,nvbn,19,19,38,3,"['test_history.py', 'test_main.py', 'main.py']","[""import pytest\nfrom mock import Mock\nfrom thefuck.history import History\n\n\nclass TestHistory(object):\n    @pytest.fixture(autouse=True)\n    def process(self, monkeypatch):\n        Process = Mock()\n        Process.return_value.parent.return_value.pid = 1\n        monkeypatch.setattr('thefuck.history.Process', Process)\n        return Process\n\n    @pytest.fixture(autouse=True)\n    def db(self, monkeypatch):\n        class DBMock(dict):\n            def __init__(self):\n                super(DBMock, self).__init__()\n                self.sync = Mock()\n\n            def __call__(self, *args, **kwargs):\n                return self\n\n        db = DBMock()\n        monkeypatch.setattr('thefuck.history.shelve.open', db)\n        return db\n\n    def test_set(self, db):\n        history = History()\n        history.update(last_script='ls',\n                       last_fixed_script=None)\n        assert db == {'1-last_script': 'ls',\n                      '1-last_fixed_script': None}\n\n    def test_get(self, db):\n        history = History()\n        db['1-last_script'] = 'cd ..'\n        assert history.last_script == 'cd ..'\n\n    def test_get_without_value(self):\n        history = History()\n        assert history.last_script is None\n"", ""import pytest\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import Mock\nfrom thefuck import main, conf, types\nfrom tests.utils import Rule, Command\n\n\ndef test_load_rule(monkeypatch):\n    match = object()\n    get_new_command = object()\n    load_source = Mock()\n    load_source.return_value = Mock(match=match,\n                                    get_new_command=get_new_command,\n                                    enabled_by_default=True)\n    monkeypatch.setattr('thefuck.main.load_source', load_source)\n    assert main.load_rule(Path('/rules/bash.py')) \\\n           == Rule('bash', match, get_new_command)\n    load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\n@pytest.mark.parametrize('conf_rules, rules', [\n    (conf.DEFAULT_RULES, [Rule('bash', 'bash', 'bash'),\n                          Rule('lisp', 'lisp', 'lisp'),\n                          Rule('bash', 'bash', 'bash'),\n                          Rule('lisp', 'lisp', 'lisp')]),\n    (types.RulesNamesList(['bash']), [Rule('bash', 'bash', 'bash'),\n                                      Rule('bash', 'bash', 'bash')])])\ndef test_get_rules(monkeypatch, conf_rules, rules):\n    monkeypatch.setattr(\n        'thefuck.main.Path.glob',\n        lambda *_: [PosixPath('bash.py'), PosixPath('lisp.py')])\n    monkeypatch.setattr('thefuck.main.load_source',\n                        lambda x, _: Mock(match=x, get_new_command=x,\n                                          enabled_by_default=True))\n    assert list(main.get_rules(Path('~'), Mock(rules=conf_rules))) == rules\n\n\nclass TestGetCommand(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, monkeypatch):\n        Popen = Mock()\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        monkeypatch.setattr('thefuck.main.Popen', Popen)\n        return Popen\n\n    @pytest.fixture(autouse=True)\n    def prepare(self, monkeypatch):\n        monkeypatch.setattr('thefuck.main.os.environ', {})\n        monkeypatch.setattr('thefuck.main.wait_output', lambda *_: True)\n\n    def test_get_command_calls(self, Popen):\n        assert main.get_command(Mock(), Mock(),\n            ['thefuck', 'apt-get', 'search', 'vim']) \\\n               == Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n    @pytest.mark.parametrize('history, args, result', [\n        (Mock(), [''], None),\n        (Mock(last_script='ls', last_fixed_script='ls -la'),\n         ['thefuck', 'fuck'], 'ls -la'),\n        (Mock(last_script='ls', last_fixed_script='ls -la'),\n         ['thefuck', 'ls'], 'ls -la'),\n        (Mock(last_script='ls', last_fixed_script=''),\n         ['thefuck', 'ls'], 'ls'),\n        (Mock(last_script='ls', last_fixed_script=''),\n         ['thefuck', 'fuck'], 'ls')])\n    def test_get_command_script(self, history, args, result):\n        if result:\n            assert main.get_command(Mock(), history, args).script == result\n        else:\n            assert main.get_command(Mock(), history, args) is None\n\n\nclass TestGetMatchedRule(object):\n    @pytest.fixture\n    def rules(self):\n        return [Rule('', lambda x, _: x.script == 'cd ..'),\n                Rule('', lambda *_: False),\n                Rule('rule', Mock(side_effect=OSError('Denied')))]\n\n    def test_no_match(self):\n        assert main.get_matched_rule(\n            Command('ls'), [Rule('', lambda *_: False)],\n            Mock(no_colors=True)) is None\n\n    def test_match(self):\n        rule = Rule('', lambda x, _: x.script == 'cd ..')\n        assert main.get_matched_rule(\n            Command('cd ..'), [rule], Mock(no_colors=True)) == rule\n\n    def test_when_rule_failed(self, capsys):\n        main.get_matched_rule(\n            Command('ls'), [Rule('test', Mock(side_effect=OSError('Denied')))],\n            Mock(no_colors=True))\n        assert capsys.readouterr()[1].split('\\n')[0] == '[WARN] Rule test:'\n\n\nclass TestRunRule(object):\n    @pytest.fixture(autouse=True)\n    def confirm(self, monkeypatch):\n        mock = Mock(return_value=True)\n        monkeypatch.setattr('thefuck.main.confirm', mock)\n        return mock\n\n    def test_run_rule(self, capsys):\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), Mock(), None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n\n    def test_run_rule_with_side_effect(self, capsys):\n        side_effect = Mock()\n        settings = Mock()\n        command = Command()\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command',\n                           side_effect=side_effect),\n                      command, Mock(), settings)\n        assert capsys.readouterr() == ('new-command\\n', '')\n        side_effect.assert_called_once_with(command, settings)\n\n    def test_hisotry_updated(self):\n        history = Mock()\n        main.run_rule(Rule(get_new_command=lambda *_: 'ls -lah'),\n                      Command('ls'), history, None)\n        history.update.assert_called_once_with(last_script='ls',\n                                               last_fixed_script='ls -lah')\n\n    def test_when_not_comfirmed(self, capsys, confirm):\n        confirm.return_value = False\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), Mock(), None)\n        assert capsys.readouterr() == ('', '')\n\n\nclass TestConfirm(object):\n    @pytest.fixture\n    def stdin(self, monkeypatch):\n        mock = Mock(return_value='\\n')\n        monkeypatch.setattr('sys.stdin.read', mock)\n        return mock\n\n    def test_when_not_required(self, capsys):\n        assert main.confirm('command', None, Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command\\n')\n\n    def test_with_side_effect_and_without_confirmation(self, capsys):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command*\\n')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed(self, capsys, stdin):\n        assert main.confirm('command', None, Mock(require_confirmation=True,\n                                                  no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed_with_side_effect(self, capsys, stdin):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=True,\n                                                    no_colors=True))\n        assert capsys.readouterr() == ('', 'command* [enter/ctrl+c]')\n\n    def test_when_confirmation_required_and_aborted(self, capsys, stdin):\n        stdin.side_effect = KeyboardInterrupt\n        assert not main.confirm('command', None, Mock(require_confirmation=True,\n                                                      no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", 'from imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom .history import History\nfrom . import logs, conf, types\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    conf.initialize_settings_file(user_dir)\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return types.Rule(rule.name[:-3], rule_module.match,\n                      rule_module.get_new_command,\n                      getattr(rule_module, \'enabled_by_default\', True),\n                      getattr(rule_module, \'side_effect\', None))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent \\\n        .joinpath(\'rules\') \\\n        .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, history, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if script == \'fuck\' or script == history.last_script:\n        script = history.last_fixed_script or history.last_script\n\n    if not script:\n        return\n\n    history.update(last_script=script,\n                   last_fixed_script=None)\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return types.Command(script, result.stdout.read().decode(\'utf-8\'),\n                             result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, side_effect, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, side_effect, settings)\n        return True\n\n    logs.confirm_command(new_command, side_effect, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, history, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, rule.side_effect, settings):\n        if rule.side_effect:\n            rule.side_effect(command, settings)\n        history.update(last_script=command.script,\n                       last_fixed_script=new_command)\n        print(new_command)\n\n\ndef alias():\n    print(""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n"")\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n    history = History()\n\n    command = get_command(settings, history, sys.argv)\n    if command:\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, history, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n']","[""import pytest\nfrom mock import Mock\nfrom thefuck.history import History\n\n\nclass TestHistory(object):\n    @pytest.fixture(autouse=True)\n    def process(self, monkeypatch):\n        Process = Mock()\n        Process.return_value.parent.return_value.pid = 1\n        monkeypatch.setattr('thefuck.history.Process', Process)\n        return Process\n\n    @pytest.fixture(autouse=True)\n    def db(self, monkeypatch):\n        class DBMock(dict):\n            def __init__(self):\n                super(DBMock, self).__init__()\n                self.sync = Mock()\n\n            def __call__(self, *args, **kwargs):\n                return self\n\n        db = DBMock()\n        monkeypatch.setattr('thefuck.history.shelve.open', db)\n        return db\n\n    def test_set(self, db):\n        history = History()\n        history.update(last_command='ls',\n                       last_fixed_command=None)\n        assert db == {'1-last_command': 'ls',\n                      '1-last_fixed_command': None}\n\n    def test_get(self, db):\n        history = History()\n        db['1-last_command'] = 'cd ..'\n        assert history.last_command == 'cd ..'\n\n    def test_get_without_value(self):\n        history = History()\n        assert history.last_command is None\n"", ""import pytest\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import Mock\nfrom thefuck import main, conf, types\nfrom tests.utils import Rule, Command\n\n\ndef test_load_rule(monkeypatch):\n    match = object()\n    get_new_command = object()\n    load_source = Mock()\n    load_source.return_value = Mock(match=match,\n                                    get_new_command=get_new_command,\n                                    enabled_by_default=True)\n    monkeypatch.setattr('thefuck.main.load_source', load_source)\n    assert main.load_rule(Path('/rules/bash.py')) \\\n           == Rule('bash', match, get_new_command)\n    load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\n@pytest.mark.parametrize('conf_rules, rules', [\n    (conf.DEFAULT_RULES, [Rule('bash', 'bash', 'bash'),\n                          Rule('lisp', 'lisp', 'lisp'),\n                          Rule('bash', 'bash', 'bash'),\n                          Rule('lisp', 'lisp', 'lisp')]),\n    (types.RulesNamesList(['bash']), [Rule('bash', 'bash', 'bash'),\n                                      Rule('bash', 'bash', 'bash')])])\ndef test_get_rules(monkeypatch, conf_rules, rules):\n    monkeypatch.setattr(\n        'thefuck.main.Path.glob',\n        lambda *_: [PosixPath('bash.py'), PosixPath('lisp.py')])\n    monkeypatch.setattr('thefuck.main.load_source',\n                        lambda x, _: Mock(match=x, get_new_command=x,\n                                          enabled_by_default=True))\n    assert list(main.get_rules(Path('~'), Mock(rules=conf_rules))) == rules\n\n\nclass TestGetCommand(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, monkeypatch):\n        Popen = Mock()\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        monkeypatch.setattr('thefuck.main.Popen', Popen)\n        return Popen\n\n    @pytest.fixture(autouse=True)\n    def prepare(self, monkeypatch):\n        monkeypatch.setattr('thefuck.main.os.environ', {})\n        monkeypatch.setattr('thefuck.main.wait_output', lambda *_: True)\n\n    def test_get_command_calls(self, Popen):\n        assert main.get_command(Mock(), Mock(),\n            ['thefuck', 'apt-get', 'search', 'vim']) \\\n               == Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n    @pytest.mark.parametrize('history, args, result', [\n        (Mock(), [''], None),\n        (Mock(last_command='ls', last_fixed_command='ls -la'),\n         ['thefuck', 'fuck'], 'ls -la'),\n        (Mock(last_command='ls', last_fixed_command='ls -la'),\n         ['thefuck', 'ls'], 'ls -la'),\n        (Mock(last_command='ls', last_fixed_command=''),\n         ['thefuck', 'ls'], 'ls'),\n        (Mock(last_command='ls', last_fixed_command=''),\n         ['thefuck', 'fuck'], 'ls')])\n    def test_get_command_script(self, history, args, result):\n        if result:\n            assert main.get_command(Mock(), history, args).script == result\n        else:\n            assert main.get_command(Mock(), history, args) is None\n\n\nclass TestGetMatchedRule(object):\n    @pytest.fixture\n    def rules(self):\n        return [Rule('', lambda x, _: x.script == 'cd ..'),\n                Rule('', lambda *_: False),\n                Rule('rule', Mock(side_effect=OSError('Denied')))]\n\n    def test_no_match(self):\n        assert main.get_matched_rule(\n            Command('ls'), [Rule('', lambda *_: False)],\n            Mock(no_colors=True)) is None\n\n    def test_match(self):\n        rule = Rule('', lambda x, _: x.script == 'cd ..')\n        assert main.get_matched_rule(\n            Command('cd ..'), [rule], Mock(no_colors=True)) == rule\n\n    def test_when_rule_failed(self, capsys):\n        main.get_matched_rule(\n            Command('ls'), [Rule('test', Mock(side_effect=OSError('Denied')))],\n            Mock(no_colors=True))\n        assert capsys.readouterr()[1].split('\\n')[0] == '[WARN] Rule test:'\n\n\nclass TestRunRule(object):\n    @pytest.fixture(autouse=True)\n    def confirm(self, monkeypatch):\n        mock = Mock(return_value=True)\n        monkeypatch.setattr('thefuck.main.confirm', mock)\n        return mock\n\n    def test_run_rule(self, capsys):\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), Mock(), None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n\n    def test_run_rule_with_side_effect(self, capsys):\n        side_effect = Mock()\n        settings = Mock()\n        command = Command()\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command',\n                           side_effect=side_effect),\n                      command, Mock(), settings)\n        assert capsys.readouterr() == ('new-command\\n', '')\n        side_effect.assert_called_once_with(command, settings)\n\n    def test_hisotry_updated(self):\n        history = Mock()\n        main.run_rule(Rule(get_new_command=lambda *_: 'ls -lah'),\n                      Command('ls'), history, None)\n        history.update.assert_called_once_with(last_command='ls',\n                                               last_fixed_command='ls -lah')\n\n    def test_when_not_comfirmed(self, capsys, confirm):\n        confirm.return_value = False\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), Mock(), None)\n        assert capsys.readouterr() == ('', '')\n\n\nclass TestConfirm(object):\n    @pytest.fixture\n    def stdin(self, monkeypatch):\n        mock = Mock(return_value='\\n')\n        monkeypatch.setattr('sys.stdin.read', mock)\n        return mock\n\n    def test_when_not_required(self, capsys):\n        assert main.confirm('command', None, Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command\\n')\n\n    def test_with_side_effect_and_without_confirmation(self, capsys):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command*\\n')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed(self, capsys, stdin):\n        assert main.confirm('command', None, Mock(require_confirmation=True,\n                                                  no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed_with_side_effect(self, capsys, stdin):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=True,\n                                                    no_colors=True))\n        assert capsys.readouterr() == ('', 'command* [enter/ctrl+c]')\n\n    def test_when_confirmation_required_and_aborted(self, capsys, stdin):\n        stdin.side_effect = KeyboardInterrupt\n        assert not main.confirm('command', None, Mock(require_confirmation=True,\n                                                      no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", 'from imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom .history import History\nfrom . import logs, conf, types\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    conf.initialize_settings_file(user_dir)\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return types.Rule(rule.name[:-3], rule_module.match,\n                      rule_module.get_new_command,\n                      getattr(rule_module, \'enabled_by_default\', True),\n                      getattr(rule_module, \'side_effect\', None))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent \\\n        .joinpath(\'rules\') \\\n        .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, history, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if script == \'fuck\' or script == history.last_command:\n        script = history.last_fixed_command or history.last_command\n\n    if not script:\n        return\n\n    history.update(last_command=script,\n                   last_fixed_command=None)\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return types.Command(script, result.stdout.read().decode(\'utf-8\'),\n                             result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, side_effect, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, side_effect, settings)\n        return True\n\n    logs.confirm_command(new_command, side_effect, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, history, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, rule.side_effect, settings):\n        if rule.side_effect:\n            rule.side_effect(command, settings)\n        history.update(last_command=command.script,\n                       last_fixed_command=new_command)\n        print(new_command)\n\n\ndef alias():\n    print(""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n"")\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n    history = History()\n\n    command = get_command(settings, history, sys.argv)\n    if command:\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, history, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n']","[[<pydriller.domain.commit.Method object at 0x7f1983f0e670>, <pydriller.domain.commit.Method object at 0x7f1983f0e3a0>, <pydriller.domain.commit.Method object at 0x7f1983f0ef70>, <pydriller.domain.commit.Method object at 0x7f1983f0e520>, <pydriller.domain.commit.Method object at 0x7f1983f0e4f0>, <pydriller.domain.commit.Method object at 0x7f1983f0afa0>, <pydriller.domain.commit.Method object at 0x7f1983f0ae20>], [<pydriller.domain.commit.Method object at 0x7f1983f6b790>, <pydriller.domain.commit.Method object at 0x7f1983f6b8e0>, <pydriller.domain.commit.Method object at 0x7f1983f6b7c0>, <pydriller.domain.commit.Method object at 0x7f1983f6b640>, <pydriller.domain.commit.Method object at 0x7f1983f64790>, <pydriller.domain.commit.Method object at 0x7f1983f647c0>, <pydriller.domain.commit.Method object at 0x7f1983f64640>, <pydriller.domain.commit.Method object at 0x7f1983f64670>, <pydriller.domain.commit.Method object at 0x7f1983f644f0>, <pydriller.domain.commit.Method object at 0x7f1983f64520>, <pydriller.domain.commit.Method object at 0x7f1983f643a0>, <pydriller.domain.commit.Method object at 0x7f1983f643d0>, <pydriller.domain.commit.Method object at 0x7f1983f64250>, <pydriller.domain.commit.Method object at 0x7f1983f64280>, <pydriller.domain.commit.Method object at 0x7f1983f64100>, <pydriller.domain.commit.Method object at 0x7f1983f64130>, <pydriller.domain.commit.Method object at 0x7f1983f60f70>, <pydriller.domain.commit.Method object at 0x7f1983f60fa0>, <pydriller.domain.commit.Method object at 0x7f1983f60e20>, <pydriller.domain.commit.Method object at 0x7f1983f60e50>, <pydriller.domain.commit.Method object at 0x7f1983f60cd0>], [<pydriller.domain.commit.Method object at 0x7f1983f5a100>, <pydriller.domain.commit.Method object at 0x7f1983f55f70>, <pydriller.domain.commit.Method object at 0x7f1983f55fa0>, <pydriller.domain.commit.Method object at 0x7f1983f55e20>, <pydriller.domain.commit.Method object at 0x7f1983f557c0>, <pydriller.domain.commit.Method object at 0x7f1983f55640>, <pydriller.domain.commit.Method object at 0x7f1983f55670>, <pydriller.domain.commit.Method object at 0x7f1983f554f0>, <pydriller.domain.commit.Method object at 0x7f1983f55520>, <pydriller.domain.commit.Method object at 0x7f1983f553a0>]]","[[<pydriller.domain.commit.Method object at 0x7f1983f32910>, <pydriller.domain.commit.Method object at 0x7f1983d7a040>, <pydriller.domain.commit.Method object at 0x7f1983f32a30>], [<pydriller.domain.commit.Method object at 0x7f1983f713a0>], [<pydriller.domain.commit.Method object at 0x7f1983f5a910>, <pydriller.domain.commit.Method object at 0x7f1983f5aa30>]]"
thefuck,938f1df0355a0364d82c8a2d9e2ccb929be999b7,Remove not used fixture,2015-05-02 04:56:23+02:00,nvbn,0,6,6,1,['test_main.py'],"[""import pytest\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import Mock\nfrom thefuck import main, conf, types\nfrom tests.utils import Rule, Command\n\n\ndef test_load_rule(monkeypatch):\n    match = object()\n    get_new_command = object()\n    load_source = Mock()\n    load_source.return_value = Mock(match=match,\n                                    get_new_command=get_new_command,\n                                    enabled_by_default=True)\n    monkeypatch.setattr('thefuck.main.load_source', load_source)\n    assert main.load_rule(Path('/rules/bash.py')) \\\n           == Rule('bash', match, get_new_command)\n    load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\n@pytest.mark.parametrize('conf_rules, rules', [\n    (conf.DEFAULT_RULES, [Rule('bash', 'bash', 'bash'),\n                          Rule('lisp', 'lisp', 'lisp'),\n                          Rule('bash', 'bash', 'bash'),\n                          Rule('lisp', 'lisp', 'lisp')]),\n    (types.RulesNamesList(['bash']), [Rule('bash', 'bash', 'bash'),\n                                      Rule('bash', 'bash', 'bash')])])\ndef test_get_rules(monkeypatch, conf_rules, rules):\n    monkeypatch.setattr(\n        'thefuck.main.Path.glob',\n        lambda *_: [PosixPath('bash.py'), PosixPath('lisp.py')])\n    monkeypatch.setattr('thefuck.main.load_source',\n                        lambda x, _: Mock(match=x, get_new_command=x,\n                                          enabled_by_default=True))\n    assert list(main.get_rules(Path('~'), Mock(rules=conf_rules))) == rules\n\n\nclass TestGetCommand(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, monkeypatch):\n        Popen = Mock()\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        monkeypatch.setattr('thefuck.main.Popen', Popen)\n        return Popen\n\n    @pytest.fixture(autouse=True)\n    def prepare(self, monkeypatch):\n        monkeypatch.setattr('thefuck.main.os.environ', {})\n        monkeypatch.setattr('thefuck.main.wait_output', lambda *_: True)\n\n    def test_get_command_calls(self, Popen):\n        assert main.get_command(Mock(), Mock(),\n            ['thefuck', 'apt-get', 'search', 'vim']) \\\n               == Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n    @pytest.mark.parametrize('history, args, result', [\n        (Mock(), [''], None),\n        (Mock(last_command='ls', last_fixed_command='ls -la'),\n         ['thefuck', 'fuck'], 'ls -la'),\n        (Mock(last_command='ls', last_fixed_command='ls -la'),\n         ['thefuck', 'ls'], 'ls -la'),\n        (Mock(last_command='ls', last_fixed_command=''),\n         ['thefuck', 'ls'], 'ls'),\n        (Mock(last_command='ls', last_fixed_command=''),\n         ['thefuck', 'fuck'], 'ls')])\n    def test_get_command_script(self, history, args, result):\n        if result:\n            assert main.get_command(Mock(), history, args).script == result\n        else:\n            assert main.get_command(Mock(), history, args) is None\n\n\nclass TestGetMatchedRule(object):\n    @pytest.fixture\n    def rules(self):\n        return [Rule('', lambda x, _: x.script == 'cd ..'),\n                Rule('', lambda *_: False),\n                Rule('rule', Mock(side_effect=OSError('Denied')))]\n\n    def test_no_match(self):\n        assert main.get_matched_rule(\n            Command('ls'), [Rule('', lambda *_: False)],\n            Mock(no_colors=True)) is None\n\n    def test_match(self):\n        rule = Rule('', lambda x, _: x.script == 'cd ..')\n        assert main.get_matched_rule(\n            Command('cd ..'), [rule], Mock(no_colors=True)) == rule\n\n    def test_when_rule_failed(self, capsys):\n        main.get_matched_rule(\n            Command('ls'), [Rule('test', Mock(side_effect=OSError('Denied')))],\n            Mock(no_colors=True))\n        assert capsys.readouterr()[1].split('\\n')[0] == '[WARN] Rule test:'\n\n\nclass TestRunRule(object):\n    @pytest.fixture(autouse=True)\n    def confirm(self, monkeypatch):\n        mock = Mock(return_value=True)\n        monkeypatch.setattr('thefuck.main.confirm', mock)\n        return mock\n\n    def test_run_rule(self, capsys):\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), Mock(), None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n\n    def test_run_rule_with_side_effect(self, capsys):\n        side_effect = Mock()\n        settings = Mock()\n        command = Command()\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command',\n                           side_effect=side_effect),\n                      command, Mock(), settings)\n        assert capsys.readouterr() == ('new-command\\n', '')\n        side_effect.assert_called_once_with(command, settings)\n\n    def test_hisotry_updated(self):\n        history = Mock()\n        main.run_rule(Rule(get_new_command=lambda *_: 'ls -lah'),\n                      Command('ls'), history, None)\n        history.update.assert_called_once_with(last_command='ls',\n                                               last_fixed_command='ls -lah')\n\n    def test_when_not_comfirmed(self, capsys, confirm):\n        confirm.return_value = False\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), Mock(), None)\n        assert capsys.readouterr() == ('', '')\n\n\nclass TestConfirm(object):\n    @pytest.fixture\n    def stdin(self, monkeypatch):\n        mock = Mock(return_value='\\n')\n        monkeypatch.setattr('sys.stdin.read', mock)\n        return mock\n\n    def test_when_not_required(self, capsys):\n        assert main.confirm('command', None, Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command\\n')\n\n    def test_with_side_effect_and_without_confirmation(self, capsys):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command*\\n')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed(self, capsys, stdin):\n        assert main.confirm('command', None, Mock(require_confirmation=True,\n                                                  no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed_with_side_effect(self, capsys, stdin):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=True,\n                                                    no_colors=True))\n        assert capsys.readouterr() == ('', 'command* [enter/ctrl+c]')\n\n    def test_when_confirmation_required_and_aborted(self, capsys, stdin):\n        stdin.side_effect = KeyboardInterrupt\n        assert not main.confirm('command', None, Mock(require_confirmation=True,\n                                                      no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n""]","[""import pytest\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import Mock\nfrom thefuck import main, conf, types\nfrom tests.utils import Rule, Command\n\n\ndef test_load_rule(monkeypatch):\n    match = object()\n    get_new_command = object()\n    load_source = Mock()\n    load_source.return_value = Mock(match=match,\n                                    get_new_command=get_new_command,\n                                    enabled_by_default=True)\n    monkeypatch.setattr('thefuck.main.load_source', load_source)\n    assert main.load_rule(Path('/rules/bash.py')) \\\n           == Rule('bash', match, get_new_command)\n    load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\n@pytest.mark.parametrize('conf_rules, rules', [\n    (conf.DEFAULT_RULES, [Rule('bash', 'bash', 'bash'),\n                          Rule('lisp', 'lisp', 'lisp'),\n                          Rule('bash', 'bash', 'bash'),\n                          Rule('lisp', 'lisp', 'lisp')]),\n    (types.RulesNamesList(['bash']), [Rule('bash', 'bash', 'bash'),\n                                      Rule('bash', 'bash', 'bash')])])\ndef test_get_rules(monkeypatch, conf_rules, rules):\n    monkeypatch.setattr(\n        'thefuck.main.Path.glob',\n        lambda *_: [PosixPath('bash.py'), PosixPath('lisp.py')])\n    monkeypatch.setattr('thefuck.main.load_source',\n                        lambda x, _: Mock(match=x, get_new_command=x,\n                                          enabled_by_default=True))\n    assert list(main.get_rules(Path('~'), Mock(rules=conf_rules))) == rules\n\n\nclass TestGetCommand(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, monkeypatch):\n        Popen = Mock()\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        monkeypatch.setattr('thefuck.main.Popen', Popen)\n        return Popen\n\n    @pytest.fixture(autouse=True)\n    def prepare(self, monkeypatch):\n        monkeypatch.setattr('thefuck.main.os.environ', {})\n        monkeypatch.setattr('thefuck.main.wait_output', lambda *_: True)\n\n    def test_get_command_calls(self, Popen):\n        assert main.get_command(Mock(), Mock(),\n            ['thefuck', 'apt-get', 'search', 'vim']) \\\n               == Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n    @pytest.mark.parametrize('history, args, result', [\n        (Mock(), [''], None),\n        (Mock(last_command='ls', last_fixed_command='ls -la'),\n         ['thefuck', 'fuck'], 'ls -la'),\n        (Mock(last_command='ls', last_fixed_command='ls -la'),\n         ['thefuck', 'ls'], 'ls -la'),\n        (Mock(last_command='ls', last_fixed_command=''),\n         ['thefuck', 'ls'], 'ls'),\n        (Mock(last_command='ls', last_fixed_command=''),\n         ['thefuck', 'fuck'], 'ls')])\n    def test_get_command_script(self, history, args, result):\n        if result:\n            assert main.get_command(Mock(), history, args).script == result\n        else:\n            assert main.get_command(Mock(), history, args) is None\n\n\nclass TestGetMatchedRule(object):\n    def test_no_match(self):\n        assert main.get_matched_rule(\n            Command('ls'), [Rule('', lambda *_: False)],\n            Mock(no_colors=True)) is None\n\n    def test_match(self):\n        rule = Rule('', lambda x, _: x.script == 'cd ..')\n        assert main.get_matched_rule(\n            Command('cd ..'), [rule], Mock(no_colors=True)) == rule\n\n    def test_when_rule_failed(self, capsys):\n        main.get_matched_rule(\n            Command('ls'), [Rule('test', Mock(side_effect=OSError('Denied')))],\n            Mock(no_colors=True))\n        assert capsys.readouterr()[1].split('\\n')[0] == '[WARN] Rule test:'\n\n\nclass TestRunRule(object):\n    @pytest.fixture(autouse=True)\n    def confirm(self, monkeypatch):\n        mock = Mock(return_value=True)\n        monkeypatch.setattr('thefuck.main.confirm', mock)\n        return mock\n\n    def test_run_rule(self, capsys):\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), Mock(), None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n\n    def test_run_rule_with_side_effect(self, capsys):\n        side_effect = Mock()\n        settings = Mock()\n        command = Command()\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command',\n                           side_effect=side_effect),\n                      command, Mock(), settings)\n        assert capsys.readouterr() == ('new-command\\n', '')\n        side_effect.assert_called_once_with(command, settings)\n\n    def test_hisotry_updated(self):\n        history = Mock()\n        main.run_rule(Rule(get_new_command=lambda *_: 'ls -lah'),\n                      Command('ls'), history, None)\n        history.update.assert_called_once_with(last_command='ls',\n                                               last_fixed_command='ls -lah')\n\n    def test_when_not_comfirmed(self, capsys, confirm):\n        confirm.return_value = False\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), Mock(), None)\n        assert capsys.readouterr() == ('', '')\n\n\nclass TestConfirm(object):\n    @pytest.fixture\n    def stdin(self, monkeypatch):\n        mock = Mock(return_value='\\n')\n        monkeypatch.setattr('sys.stdin.read', mock)\n        return mock\n\n    def test_when_not_required(self, capsys):\n        assert main.confirm('command', None, Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command\\n')\n\n    def test_with_side_effect_and_without_confirmation(self, capsys):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command*\\n')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed(self, capsys, stdin):\n        assert main.confirm('command', None, Mock(require_confirmation=True,\n                                                  no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed_with_side_effect(self, capsys, stdin):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=True,\n                                                    no_colors=True))\n        assert capsys.readouterr() == ('', 'command* [enter/ctrl+c]')\n\n    def test_when_confirmation_required_and_aborted(self, capsys, stdin):\n        stdin.side_effect = KeyboardInterrupt\n        assert not main.confirm('command', None, Mock(require_confirmation=True,\n                                                      no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983f64e50>, <pydriller.domain.commit.Method object at 0x7f1983f64fa0>, <pydriller.domain.commit.Method object at 0x7f1983f64cd0>, <pydriller.domain.commit.Method object at 0x7f1983f64d00>, <pydriller.domain.commit.Method object at 0x7f1983e578e0>, <pydriller.domain.commit.Method object at 0x7f1983e577c0>, <pydriller.domain.commit.Method object at 0x7f1983e57d00>, <pydriller.domain.commit.Method object at 0x7f1983d4a580>, <pydriller.domain.commit.Method object at 0x7f1983d4a400>, <pydriller.domain.commit.Method object at 0x7f1983cd7160>, <pydriller.domain.commit.Method object at 0x7f1983cd7c10>, <pydriller.domain.commit.Method object at 0x7f1983cd77f0>, <pydriller.domain.commit.Method object at 0x7f1983cd7550>, <pydriller.domain.commit.Method object at 0x7f1983e81f70>, <pydriller.domain.commit.Method object at 0x7f1983e5c3a0>, <pydriller.domain.commit.Method object at 0x7f1983e5c7c0>, <pydriller.domain.commit.Method object at 0x7f1983e5ce20>, <pydriller.domain.commit.Method object at 0x7f1983e17a60>, <pydriller.domain.commit.Method object at 0x7f1983d287f0>, <pydriller.domain.commit.Method object at 0x7f1983f0e640>, <pydriller.domain.commit.Method object at 0x7f1983f0e250>]]",[[<pydriller.domain.commit.Method object at 0x7f1983e57d00>]]
thefuck,fcc2a1a40a6e07a76cc653352c052e810df0546f,"#128 #69 add support of shell specific actions, add alias expansion for bash and zsh",2015-05-03 12:46:01+02:00,nvbn,141,2,143,4,"['test_main.py', 'test_shells.py', 'main.py', 'shells.py']","[""import pytest\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import Mock\nfrom thefuck import main, conf, types\nfrom tests.utils import Rule, Command\n\n\ndef test_load_rule(monkeypatch):\n    match = object()\n    get_new_command = object()\n    load_source = Mock()\n    load_source.return_value = Mock(match=match,\n                                    get_new_command=get_new_command,\n                                    enabled_by_default=True)\n    monkeypatch.setattr('thefuck.main.load_source', load_source)\n    assert main.load_rule(Path('/rules/bash.py')) \\\n           == Rule('bash', match, get_new_command)\n    load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\n@pytest.mark.parametrize('conf_rules, rules', [\n    (conf.DEFAULT_RULES, [Rule('bash', 'bash', 'bash'),\n                          Rule('lisp', 'lisp', 'lisp'),\n                          Rule('bash', 'bash', 'bash'),\n                          Rule('lisp', 'lisp', 'lisp')]),\n    (types.RulesNamesList(['bash']), [Rule('bash', 'bash', 'bash'),\n                                      Rule('bash', 'bash', 'bash')])])\ndef test_get_rules(monkeypatch, conf_rules, rules):\n    monkeypatch.setattr(\n        'thefuck.main.Path.glob',\n        lambda *_: [PosixPath('bash.py'), PosixPath('lisp.py')])\n    monkeypatch.setattr('thefuck.main.load_source',\n                        lambda x, _: Mock(match=x, get_new_command=x,\n                                          enabled_by_default=True))\n    assert list(main.get_rules(Path('~'), Mock(rules=conf_rules))) == rules\n\n\nclass TestGetCommand(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, monkeypatch):\n        Popen = Mock()\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        monkeypatch.setattr('thefuck.main.Popen', Popen)\n        return Popen\n\n    @pytest.fixture(autouse=True)\n    def prepare(self, monkeypatch):\n        monkeypatch.setattr('thefuck.main.os.environ', {})\n        monkeypatch.setattr('thefuck.main.wait_output', lambda *_: True)\n\n    def test_get_command_calls(self, Popen):\n        assert main.get_command(Mock(), Mock(),\n            ['thefuck', 'apt-get', 'search', 'vim']) \\\n               == Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n    @pytest.mark.parametrize('history, args, result', [\n        (Mock(), [''], None),\n        (Mock(last_command='ls', last_fixed_command='ls -la'),\n         ['thefuck', 'fuck'], 'ls -la'),\n        (Mock(last_command='ls', last_fixed_command='ls -la'),\n         ['thefuck', 'ls'], 'ls -la'),\n        (Mock(last_command='ls', last_fixed_command=''),\n         ['thefuck', 'ls'], 'ls'),\n        (Mock(last_command='ls', last_fixed_command=''),\n         ['thefuck', 'fuck'], 'ls')])\n    def test_get_command_script(self, history, args, result):\n        if result:\n            assert main.get_command(Mock(), history, args).script == result\n        else:\n            assert main.get_command(Mock(), history, args) is None\n\n\nclass TestGetMatchedRule(object):\n    def test_no_match(self):\n        assert main.get_matched_rule(\n            Command('ls'), [Rule('', lambda *_: False)],\n            Mock(no_colors=True)) is None\n\n    def test_match(self):\n        rule = Rule('', lambda x, _: x.script == 'cd ..')\n        assert main.get_matched_rule(\n            Command('cd ..'), [rule], Mock(no_colors=True)) == rule\n\n    def test_when_rule_failed(self, capsys):\n        main.get_matched_rule(\n            Command('ls'), [Rule('test', Mock(side_effect=OSError('Denied')))],\n            Mock(no_colors=True))\n        assert capsys.readouterr()[1].split('\\n')[0] == '[WARN] Rule test:'\n\n\nclass TestRunRule(object):\n    @pytest.fixture(autouse=True)\n    def confirm(self, monkeypatch):\n        mock = Mock(return_value=True)\n        monkeypatch.setattr('thefuck.main.confirm', mock)\n        return mock\n\n    def test_run_rule(self, capsys):\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), Mock(), None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n\n    def test_run_rule_with_side_effect(self, capsys):\n        side_effect = Mock()\n        settings = Mock()\n        command = Command()\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command',\n                           side_effect=side_effect),\n                      command, Mock(), settings)\n        assert capsys.readouterr() == ('new-command\\n', '')\n        side_effect.assert_called_once_with(command, settings)\n\n    def test_hisotry_updated(self):\n        history = Mock()\n        main.run_rule(Rule(get_new_command=lambda *_: 'ls -lah'),\n                      Command('ls'), history, None)\n        history.update.assert_called_once_with(last_command='ls',\n                                               last_fixed_command='ls -lah')\n\n    def test_when_not_comfirmed(self, capsys, confirm):\n        confirm.return_value = False\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), Mock(), None)\n        assert capsys.readouterr() == ('', '')\n\n\nclass TestConfirm(object):\n    @pytest.fixture\n    def stdin(self, monkeypatch):\n        mock = Mock(return_value='\\n')\n        monkeypatch.setattr('sys.stdin.read', mock)\n        return mock\n\n    def test_when_not_required(self, capsys):\n        assert main.confirm('command', None, Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command\\n')\n\n    def test_with_side_effect_and_without_confirmation(self, capsys):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command*\\n')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed(self, capsys, stdin):\n        assert main.confirm('command', None, Mock(require_confirmation=True,\n                                                  no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed_with_side_effect(self, capsys, stdin):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=True,\n                                                    no_colors=True))\n        assert capsys.readouterr() == ('', 'command* [enter/ctrl+c]')\n\n    def test_when_confirmation_required_and_aborted(self, capsys, stdin):\n        stdin.side_effect = KeyboardInterrupt\n        assert not main.confirm('command', None, Mock(require_confirmation=True,\n                                                      no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", None, 'from imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom .history import History\nfrom . import logs, conf, types\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    conf.initialize_settings_file(user_dir)\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return types.Rule(rule.name[:-3], rule_module.match,\n                      rule_module.get_new_command,\n                      getattr(rule_module, \'enabled_by_default\', True),\n                      getattr(rule_module, \'side_effect\', None))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent \\\n        .joinpath(\'rules\') \\\n        .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, history, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if script == \'fuck\' or script == history.last_command:\n        script = history.last_fixed_command or history.last_command\n\n    if not script:\n        return\n\n    history.update(last_command=script,\n                   last_fixed_command=None)\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return types.Command(script, result.stdout.read().decode(\'utf-8\'),\n                             result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, side_effect, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, side_effect, settings)\n        return True\n\n    logs.confirm_command(new_command, side_effect, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, history, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = rule.get_new_command(command, settings)\n    if confirm(new_command, rule.side_effect, settings):\n        if rule.side_effect:\n            rule.side_effect(command, settings)\n        history.update(last_command=command.script,\n                       last_fixed_command=new_command)\n        print(new_command)\n\n\ndef alias():\n    print(""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n"")\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n    history = History()\n\n    command = get_command(settings, history, sys.argv)\n    if command:\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, history, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', None]","[""import pytest\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import Mock\nfrom thefuck import main, conf, types\nfrom tests.utils import Rule, Command\n\n\ndef test_load_rule(monkeypatch):\n    match = object()\n    get_new_command = object()\n    load_source = Mock()\n    load_source.return_value = Mock(match=match,\n                                    get_new_command=get_new_command,\n                                    enabled_by_default=True)\n    monkeypatch.setattr('thefuck.main.load_source', load_source)\n    assert main.load_rule(Path('/rules/bash.py')) \\\n           == Rule('bash', match, get_new_command)\n    load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\n@pytest.mark.parametrize('conf_rules, rules', [\n    (conf.DEFAULT_RULES, [Rule('bash', 'bash', 'bash'),\n                          Rule('lisp', 'lisp', 'lisp'),\n                          Rule('bash', 'bash', 'bash'),\n                          Rule('lisp', 'lisp', 'lisp')]),\n    (types.RulesNamesList(['bash']), [Rule('bash', 'bash', 'bash'),\n                                      Rule('bash', 'bash', 'bash')])])\ndef test_get_rules(monkeypatch, conf_rules, rules):\n    monkeypatch.setattr(\n        'thefuck.main.Path.glob',\n        lambda *_: [PosixPath('bash.py'), PosixPath('lisp.py')])\n    monkeypatch.setattr('thefuck.main.load_source',\n                        lambda x, _: Mock(match=x, get_new_command=x,\n                                          enabled_by_default=True))\n    assert list(main.get_rules(Path('~'), Mock(rules=conf_rules))) == rules\n\n\nclass TestGetCommand(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, monkeypatch):\n        Popen = Mock()\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        monkeypatch.setattr('thefuck.main.Popen', Popen)\n        return Popen\n\n    @pytest.fixture(autouse=True)\n    def prepare(self, monkeypatch):\n        monkeypatch.setattr('thefuck.main.os.environ', {})\n        monkeypatch.setattr('thefuck.main.wait_output', lambda *_: True)\n\n    @pytest.fixture(autouse=True)\n    def generic_shell(self, monkeypatch):\n        monkeypatch.setattr('thefuck.shells.from_shell', lambda x: x)\n        monkeypatch.setattr('thefuck.shells.to_shell', lambda x: x)\n\n    def test_get_command_calls(self, Popen):\n        assert main.get_command(Mock(), Mock(),\n            ['thefuck', 'apt-get', 'search', 'vim']) \\\n               == Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n    @pytest.mark.parametrize('history, args, result', [\n        (Mock(), [''], None),\n        (Mock(last_command='ls', last_fixed_command='ls -la'),\n         ['thefuck', 'fuck'], 'ls -la'),\n        (Mock(last_command='ls', last_fixed_command='ls -la'),\n         ['thefuck', 'ls'], 'ls -la'),\n        (Mock(last_command='ls', last_fixed_command=''),\n         ['thefuck', 'ls'], 'ls'),\n        (Mock(last_command='ls', last_fixed_command=''),\n         ['thefuck', 'fuck'], 'ls')])\n    def test_get_command_script(self, history, args, result):\n        if result:\n            assert main.get_command(Mock(), history, args).script == result\n        else:\n            assert main.get_command(Mock(), history, args) is None\n\n\nclass TestGetMatchedRule(object):\n    def test_no_match(self):\n        assert main.get_matched_rule(\n            Command('ls'), [Rule('', lambda *_: False)],\n            Mock(no_colors=True)) is None\n\n    def test_match(self):\n        rule = Rule('', lambda x, _: x.script == 'cd ..')\n        assert main.get_matched_rule(\n            Command('cd ..'), [rule], Mock(no_colors=True)) == rule\n\n    def test_when_rule_failed(self, capsys):\n        main.get_matched_rule(\n            Command('ls'), [Rule('test', Mock(side_effect=OSError('Denied')))],\n            Mock(no_colors=True))\n        assert capsys.readouterr()[1].split('\\n')[0] == '[WARN] Rule test:'\n\n\nclass TestRunRule(object):\n    @pytest.fixture(autouse=True)\n    def confirm(self, monkeypatch):\n        mock = Mock(return_value=True)\n        monkeypatch.setattr('thefuck.main.confirm', mock)\n        return mock\n\n    def test_run_rule(self, capsys):\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), Mock(), None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n\n    def test_run_rule_with_side_effect(self, capsys):\n        side_effect = Mock()\n        settings = Mock()\n        command = Command()\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command',\n                           side_effect=side_effect),\n                      command, Mock(), settings)\n        assert capsys.readouterr() == ('new-command\\n', '')\n        side_effect.assert_called_once_with(command, settings)\n\n    def test_hisotry_updated(self):\n        history = Mock()\n        main.run_rule(Rule(get_new_command=lambda *_: 'ls -lah'),\n                      Command('ls'), history, None)\n        history.update.assert_called_once_with(last_command='ls',\n                                               last_fixed_command='ls -lah')\n\n    def test_when_not_comfirmed(self, capsys, confirm):\n        confirm.return_value = False\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), Mock(), None)\n        assert capsys.readouterr() == ('', '')\n\n\nclass TestConfirm(object):\n    @pytest.fixture\n    def stdin(self, monkeypatch):\n        mock = Mock(return_value='\\n')\n        monkeypatch.setattr('sys.stdin.read', mock)\n        return mock\n\n    def test_when_not_required(self, capsys):\n        assert main.confirm('command', None, Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command\\n')\n\n    def test_with_side_effect_and_without_confirmation(self, capsys):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command*\\n')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed(self, capsys, stdin):\n        assert main.confirm('command', None, Mock(require_confirmation=True,\n                                                  no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed_with_side_effect(self, capsys, stdin):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=True,\n                                                    no_colors=True))\n        assert capsys.readouterr() == ('', 'command* [enter/ctrl+c]')\n\n    def test_when_confirmation_required_and_aborted(self, capsys, stdin):\n        stdin.side_effect = KeyboardInterrupt\n        assert not main.confirm('command', None, Mock(require_confirmation=True,\n                                                      no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", ""import pytest\nfrom mock import Mock\nfrom thefuck import shells\n\n\nclass TestGeneric(object):\n    def test_from_shell(self):\n        assert shells.Generic().from_shell('pwd') == 'pwd'\n\n    def test_to_shell(self):\n        assert shells.Bash().to_shell('pwd') == 'pwd'\n\n\nclass TestBash(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, monkeypatch):\n        mock = Mock()\n        monkeypatch.setattr('thefuck.shells.Popen', mock)\n        mock.return_value.stdout.read.return_value = (\n            b'alias l=\\'ls -CF\\'\\n'\n            b'alias la=\\'ls -A\\'\\n'\n            b'alias ll=\\'ls -alF\\'')\n        return mock\n\n    @pytest.mark.parametrize('before, after', [\n        ('pwd', 'pwd'),\n        ('ll', 'ls -alF')])\n    def test_from_shell(self, before, after):\n        assert shells.Bash().from_shell(before) == after\n\n    def test_to_shell(self):\n        assert shells.Bash().to_shell('pwd') == 'pwd'\n\n\nclass TestZsh(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, monkeypatch):\n        mock = Mock()\n        monkeypatch.setattr('thefuck.shells.Popen', mock)\n        mock.return_value.stdout.read.return_value = (\n            b'l=\\'ls -CF\\'\\n'\n            b'la=\\'ls -A\\'\\n'\n            b'll=\\'ls -alF\\'')\n        return mock\n\n    @pytest.mark.parametrize('before, after', [\n        ('pwd', 'pwd'),\n        ('ll', 'ls -alF')])\n    def test_from_shell(self, before, after):\n        assert shells.Zsh().from_shell(before) == after\n\n    def test_to_shell(self):\n        assert shells.Zsh().to_shell('pwd') == 'pwd'"", 'from imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom .history import History\nfrom . import logs, conf, types, shells\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    conf.initialize_settings_file(user_dir)\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return types.Rule(rule.name[:-3], rule_module.match,\n                      rule_module.get_new_command,\n                      getattr(rule_module, \'enabled_by_default\', True),\n                      getattr(rule_module, \'side_effect\', None))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent \\\n        .joinpath(\'rules\') \\\n        .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, history, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if script == \'fuck\' or script == history.last_command:\n        script = history.last_fixed_command or history.last_command\n\n    if not script:\n        return\n\n    script = shells.from_shell(script)\n    history.update(last_command=script,\n                   last_fixed_command=None)\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return types.Command(script, result.stdout.read().decode(\'utf-8\'),\n                             result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, side_effect, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, side_effect, settings)\n        return True\n\n    logs.confirm_command(new_command, side_effect, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, history, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = shells.to_shell(rule.get_new_command(command, settings))\n    if confirm(new_command, rule.side_effect, settings):\n        if rule.side_effect:\n            rule.side_effect(command, settings)\n        history.update(last_command=command.script,\n                       last_fixed_command=new_command)\n        print(new_command)\n\n\ndef alias():\n    print(""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n"")\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n    history = History()\n\n    command = get_command(settings, history, sys.argv)\n    if command:\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, history, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', '""""""Module with shell specific actions, each shell class should\nimplement `from_shell` and `to_shell` methods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nimport os\nfrom psutil import Process\n\n\nFNULL = open(os.devnull, \'w\')\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n\nclass Bash(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=FNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias)\n\n\nclass Zsh(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=FNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'zsh\': Zsh()})\n\n\ndef _get_shell():\n    shell = Process(os.getpid()).parent().cmdline()[0]\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n']","[[<pydriller.domain.commit.Method object at 0x7f1983f76250>, <pydriller.domain.commit.Method object at 0x7f1983f76100>, <pydriller.domain.commit.Method object at 0x7f1983f76a30>, <pydriller.domain.commit.Method object at 0x7f1983f76280>, <pydriller.domain.commit.Method object at 0x7f1983f55cd0>, <pydriller.domain.commit.Method object at 0x7f1983f55d00>, <pydriller.domain.commit.Method object at 0x7f1983f55b80>, <pydriller.domain.commit.Method object at 0x7f1983f55bb0>, <pydriller.domain.commit.Method object at 0x7f1983f55a30>, <pydriller.domain.commit.Method object at 0x7f1983f55a60>, <pydriller.domain.commit.Method object at 0x7f1983f558e0>, <pydriller.domain.commit.Method object at 0x7f1983f55910>, <pydriller.domain.commit.Method object at 0x7f1983f55790>, <pydriller.domain.commit.Method object at 0x7f1983f55280>, <pydriller.domain.commit.Method object at 0x7f1983f55100>, <pydriller.domain.commit.Method object at 0x7f1983f55130>, <pydriller.domain.commit.Method object at 0x7f1983f4ef70>, <pydriller.domain.commit.Method object at 0x7f1983f4efa0>, <pydriller.domain.commit.Method object at 0x7f1983f4ee20>, <pydriller.domain.commit.Method object at 0x7f1983f4ee50>], [], [<pydriller.domain.commit.Method object at 0x7f1983f4e910>, <pydriller.domain.commit.Method object at 0x7f1983f4e250>, <pydriller.domain.commit.Method object at 0x7f1983f4e280>, <pydriller.domain.commit.Method object at 0x7f1983f4e100>, <pydriller.domain.commit.Method object at 0x7f1983f4e130>, <pydriller.domain.commit.Method object at 0x7f1983fc9130>, <pydriller.domain.commit.Method object at 0x7f1983fc9040>, <pydriller.domain.commit.Method object at 0x7f1983fc9340>, <pydriller.domain.commit.Method object at 0x7f1983fc9370>, <pydriller.domain.commit.Method object at 0x7f1983fc9190>], []]","[[<pydriller.domain.commit.Method object at 0x7f1983f368e0>], [<pydriller.domain.commit.Method object at 0x7f1983f4e790>, <pydriller.domain.commit.Method object at 0x7f1983f4e670>, <pydriller.domain.commit.Method object at 0x7f1983f4e4f0>, <pydriller.domain.commit.Method object at 0x7f1983f4e640>], [<pydriller.domain.commit.Method object at 0x7f1983fc9790>, <pydriller.domain.commit.Method object at 0x7f1983fc9a60>], [<pydriller.domain.commit.Method object at 0x7f1983ec0e20>, <pydriller.domain.commit.Method object at 0x7f1983fc9cd0>, <pydriller.domain.commit.Method object at 0x7f1983ec0e50>, <pydriller.domain.commit.Method object at 0x7f1983e96a60>, <pydriller.domain.commit.Method object at 0x7f1983fc9b80>, <pydriller.domain.commit.Method object at 0x7f1983fc9bb0>, <pydriller.domain.commit.Method object at 0x7f1983f55e50>, <pydriller.domain.commit.Method object at 0x7f1983fc9310>]]"
thefuck,bcd3154121bfe334a0713af9b12ad9aede3ae642,Bump to 1.33,2015-05-03 12:59:37+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nVERSION = \'1.32\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\', \'thefuck-alias = thefuck.main:alias\']})\n']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.33\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\', \'thefuck-alias = thefuck.main:alias\']})\n']",[[]],[[]]
thefuck,3ce8c1187c09ebe7cc7ebd82a37f89b28c71c29a,Make `thefuck-alias` depends on current shell,2015-05-03 13:04:33+02:00,nvbn,8,1,9,2,"['main.py', 'shells.py']","['from imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom .history import History\nfrom . import logs, conf, types, shells\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    conf.initialize_settings_file(user_dir)\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return types.Rule(rule.name[:-3], rule_module.match,\n                      rule_module.get_new_command,\n                      getattr(rule_module, \'enabled_by_default\', True),\n                      getattr(rule_module, \'side_effect\', None))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent \\\n        .joinpath(\'rules\') \\\n        .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, history, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if script == \'fuck\' or script == history.last_command:\n        script = history.last_fixed_command or history.last_command\n\n    if not script:\n        return\n\n    script = shells.from_shell(script)\n    history.update(last_command=script,\n                   last_fixed_command=None)\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return types.Command(script, result.stdout.read().decode(\'utf-8\'),\n                             result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, side_effect, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, side_effect, settings)\n        return True\n\n    logs.confirm_command(new_command, side_effect, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, history, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = shells.to_shell(rule.get_new_command(command, settings))\n    if confirm(new_command, rule.side_effect, settings):\n        if rule.side_effect:\n            rule.side_effect(command, settings)\n        history.update(last_command=command.script,\n                       last_fixed_command=new_command)\n        print(new_command)\n\n\ndef alias():\n    print(""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n"")\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n    history = History()\n\n    command = get_command(settings, history, sys.argv)\n    if command:\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, history, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', '""""""Module with shell specific actions, each shell class should\nimplement `from_shell` and `to_shell` methods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nimport os\nfrom psutil import Process\n\n\nFNULL = open(os.devnull, \'w\')\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n\nclass Bash(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=FNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias)\n\n\nclass Zsh(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=FNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'zsh\': Zsh()})\n\n\ndef _get_shell():\n    shell = Process(os.getpid()).parent().cmdline()[0]\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n']","['from imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom .history import History\nfrom . import logs, conf, types, shells\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    conf.initialize_settings_file(user_dir)\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return types.Rule(rule.name[:-3], rule_module.match,\n                      rule_module.get_new_command,\n                      getattr(rule_module, \'enabled_by_default\', True),\n                      getattr(rule_module, \'side_effect\', None))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent \\\n        .joinpath(\'rules\') \\\n        .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, history, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if script == \'fuck\' or script == history.last_command:\n        script = history.last_fixed_command or history.last_command\n\n    if not script:\n        return\n\n    script = shells.from_shell(script)\n    history.update(last_command=script,\n                   last_fixed_command=None)\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return types.Command(script, result.stdout.read().decode(\'utf-8\'),\n                             result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, side_effect, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, side_effect, settings)\n        return True\n\n    logs.confirm_command(new_command, side_effect, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, history, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = shells.to_shell(rule.get_new_command(command, settings))\n    if confirm(new_command, rule.side_effect, settings):\n        if rule.side_effect:\n            rule.side_effect(command, settings)\n        history.update(last_command=command.script,\n                       last_fixed_command=new_command)\n        print(new_command)\n\n\ndef alias():\n    print(shells.app_alias())\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n    history = History()\n\n    command = get_command(settings, history, sys.argv)\n    if command:\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, history, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', '""""""Module with shell specific actions, each shell class should\nimplement `from_shell` and `to_shell` methods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nimport os\nfrom psutil import Process\n\n\nFNULL = open(os.devnull, \'w\')\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n\nclass Bash(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=FNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias)\n\n\nclass Zsh(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=FNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'zsh\': Zsh()})\n\n\ndef _get_shell():\n    shell = Process(os.getpid()).parent().cmdline()[0]\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    return _get_shell().app_alias()\n']","[[<pydriller.domain.commit.Method object at 0x7f1983f15a60>, <pydriller.domain.commit.Method object at 0x7f1983f15a30>, <pydriller.domain.commit.Method object at 0x7f1983f153d0>, <pydriller.domain.commit.Method object at 0x7f1983ea84f0>, <pydriller.domain.commit.Method object at 0x7f1983f5aa60>, <pydriller.domain.commit.Method object at 0x7f1983f5a8e0>, <pydriller.domain.commit.Method object at 0x7f1983f5a790>, <pydriller.domain.commit.Method object at 0x7f1983f5a7c0>, <pydriller.domain.commit.Method object at 0x7f1983f5a4f0>, <pydriller.domain.commit.Method object at 0x7f1983f5af70>], [<pydriller.domain.commit.Method object at 0x7f198507f820>, <pydriller.domain.commit.Method object at 0x7f198507f2b0>, <pydriller.domain.commit.Method object at 0x7f198507fdf0>, <pydriller.domain.commit.Method object at 0x7f198507fe20>, <pydriller.domain.commit.Method object at 0x7f198507fd30>, <pydriller.domain.commit.Method object at 0x7f198507feb0>, <pydriller.domain.commit.Method object at 0x7f198507fee0>, <pydriller.domain.commit.Method object at 0x7f198507ff10>, <pydriller.domain.commit.Method object at 0x7f198507fbb0>, <pydriller.domain.commit.Method object at 0x7f198507fbe0>, <pydriller.domain.commit.Method object at 0x7f198507fd60>]]","[[<pydriller.domain.commit.Method object at 0x7f1983f64e20>], [<pydriller.domain.commit.Method object at 0x7f1983f603a0>, <pydriller.domain.commit.Method object at 0x7f1983f60b80>]]"
thefuck,93c90d575868caff09f37cc11c22b2a06732b2e5,#157 Don't fail if can't get brew commands,2015-05-03 13:24:33+02:00,nvbn,18,15,33,1,['brew_unknown_command.py'],"[""import difflib\nimport os\nimport re\nimport subprocess\nimport thefuck.logs\n\nBREW_CMD_PATH = '/Library/Homebrew/cmd'\nTAP_PATH = '/Library/Taps'\nTAP_CMD_PATH = '/%s/%s/cmd'\n\n\ndef _get_brew_path_prefix():\n    '''To get brew path'''\n    try:\n        return subprocess.check_output(['brew', '--prefix']).strip()\n    except:\n        return None\n\n\ndef _get_brew_commands(brew_path_prefix):\n    '''To get brew default commands on local environment'''\n    brew_cmd_path = brew_path_prefix + BREW_CMD_PATH\n\n    commands = (name.replace('.rb', '') for name in os.listdir(brew_cmd_path)\n                if name.endswith('.rb'))\n\n    return commands\n\n\ndef _get_brew_tap_specific_commands(brew_path_prefix):\n    '''To get tap's specific commands\n    https://github.com/Homebrew/homebrew/blob/master/Library/brew.rb#L115'''\n    commands = []\n    brew_taps_path = brew_path_prefix + TAP_PATH\n\n    for user in _get_directory_names_only(brew_taps_path):\n        taps = _get_directory_names_only(brew_taps_path + '/%s' % user)\n\n        # Brew Taps's naming rule\n        # https://github.com/Homebrew/homebrew/blob/master/share/doc/homebrew/brew-tap.md#naming-conventions-and-limitations\n        taps = (tap for tap in taps if tap.startswith('homebrew-'))\n        for tap in taps:\n            tap_cmd_path = brew_taps_path + TAP_CMD_PATH % (user, tap)\n\n            if os.path.isdir(tap_cmd_path):\n                commands += (name.replace('brew-', '').replace('.rb', '')\n                             for name in os.listdir(tap_cmd_path)\n                             if _is_brew_tap_cmd_naming(name))\n\n    return commands\n\n\ndef _is_brew_tap_cmd_naming(name):\n    if name.startswith('brew-') and name.endswith('.rb'):\n        return True\n\n    return False\n\n\ndef _get_directory_names_only(path):\n    return [d for d in os.listdir(path)\n            if os.path.isdir(os.path.join(path, d))]\n\nbrew_commands = []\nbrew_path_prefix = _get_brew_path_prefix()\n\nif brew_path_prefix:\n    brew_commands += _get_brew_commands(brew_path_prefix)\n    brew_commands += _get_brew_tap_specific_commands(brew_path_prefix)\nelse:\n    # Failback commands for testing (Based on Homebrew 0.9.5)\n    brew_commands = ['info', 'home', 'options', 'install', 'uninstall',\n                     'search', 'list', 'update', 'upgrade', 'pin', 'unpin',\n                     'doctor', 'create', 'edit']\n\n\ndef _get_similar_commands(command):\n    return difflib.get_close_matches(command, brew_commands)\n\n\ndef match(command, settings):\n    is_proper_command = ('brew' in command.script and\n                         'Unknown command' in command.stderr)\n\n    has_possible_commands = False\n    if is_proper_command:\n        broken_cmd = re.findall(r'Error: Unknown command: ([a-z]+)',\n                                command.stderr)[0]\n        has_possible_commands = len(_get_similar_commands(broken_cmd)) > 0\n\n    return has_possible_commands\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r'Error: Unknown command: ([a-z]+)',\n                            command.stderr)[0]\n    new_cmd = _get_similar_commands(broken_cmd)[0]\n\n    return command.script.replace(broken_cmd, new_cmd, 1)\n""]","['import difflib\nimport os\nimport re\nimport subprocess\n\n\nBREW_CMD_PATH = \'/Library/Homebrew/cmd\'\nTAP_PATH = \'/Library/Taps\'\nTAP_CMD_PATH = \'/%s/%s/cmd\'\n\n\ndef _get_brew_path_prefix():\n    """"""To get brew path""""""\n    try:\n        return subprocess.check_output([\'brew\', \'--prefix\']).strip()\n    except:\n        return None\n\n\ndef _get_brew_commands(brew_path_prefix):\n    """"""To get brew default commands on local environment""""""\n    brew_cmd_path = brew_path_prefix + BREW_CMD_PATH\n\n    commands = [name.replace(\'.rb\', \'\') for name in os.listdir(brew_cmd_path)\n                if name.endswith(\'.rb\')]\n\n    return commands\n\n\ndef _get_brew_tap_specific_commands(brew_path_prefix):\n    """"""To get tap\'s specific commands\n    https://github.com/Homebrew/homebrew/blob/master/Library/brew.rb#L115""""""\n    commands = []\n    brew_taps_path = brew_path_prefix + TAP_PATH\n\n    for user in _get_directory_names_only(brew_taps_path):\n        taps = _get_directory_names_only(brew_taps_path + \'/%s\' % user)\n\n        # Brew Taps\'s naming rule\n        # https://github.com/Homebrew/homebrew/blob/master/share/doc/homebrew/brew-tap.md#naming-conventions-and-limitations\n        taps = (tap for tap in taps if tap.startswith(\'homebrew-\'))\n        for tap in taps:\n            tap_cmd_path = brew_taps_path + TAP_CMD_PATH % (user, tap)\n\n            if os.path.isdir(tap_cmd_path):\n                commands += (name.replace(\'brew-\', \'\').replace(\'.rb\', \'\')\n                             for name in os.listdir(tap_cmd_path)\n                             if _is_brew_tap_cmd_naming(name))\n\n    return commands\n\n\ndef _is_brew_tap_cmd_naming(name):\n    if name.startswith(\'brew-\') and name.endswith(\'.rb\'):\n        return True\n\n    return False\n\n\ndef _get_directory_names_only(path):\n    return [d for d in os.listdir(path)\n            if os.path.isdir(os.path.join(path, d))]\n\n\nbrew_path_prefix = _get_brew_path_prefix()\n\n# Failback commands for testing (Based on Homebrew 0.9.5)\nbrew_commands = [\'info\', \'home\', \'options\', \'install\', \'uninstall\',\n                 \'search\', \'list\', \'update\', \'upgrade\', \'pin\', \'unpin\',\n                 \'doctor\', \'create\', \'edit\']\n\nif brew_path_prefix:\n    try:\n        brew_commands = _get_brew_commands(brew_path_prefix) \\\n                        + _get_brew_tap_specific_commands(brew_path_prefix)\n    except OSError:\n        pass\n\n\ndef _get_similar_commands(command):\n    return difflib.get_close_matches(command, brew_commands)\n\n\ndef match(command, settings):\n    is_proper_command = (\'brew\' in command.script and\n                         \'Unknown command\' in command.stderr)\n\n    has_possible_commands = False\n    if is_proper_command:\n        broken_cmd = re.findall(r\'Error: Unknown command: ([a-z]+)\',\n                                command.stderr)[0]\n        has_possible_commands = len(_get_similar_commands(broken_cmd)) > 0\n\n    return has_possible_commands\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r\'Error: Unknown command: ([a-z]+)\',\n                            command.stderr)[0]\n    new_cmd = _get_similar_commands(broken_cmd)[0]\n\n    return command.script.replace(broken_cmd, new_cmd, 1)\n']","[[<pydriller.domain.commit.Method object at 0x7f198507f160>, <pydriller.domain.commit.Method object at 0x7f198507fc70>, <pydriller.domain.commit.Method object at 0x7f198507f1f0>, <pydriller.domain.commit.Method object at 0x7f198507f100>, <pydriller.domain.commit.Method object at 0x7f198507ff40>, <pydriller.domain.commit.Method object at 0x7f198507f5b0>, <pydriller.domain.commit.Method object at 0x7f198507fdc0>, <pydriller.domain.commit.Method object at 0x7f198507f280>]]","[[<pydriller.domain.commit.Method object at 0x7f1983f60670>, <pydriller.domain.commit.Method object at 0x7f1983fc99a0>, <pydriller.domain.commit.Method object at 0x7f1983f60520>]]"
thefuck,72ac9650f944746fca2b5a48c031579c205b730f,Bump to 1.34,2015-05-03 13:25:01+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nVERSION = \'1.33\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\', \'thefuck-alias = thefuck.main:alias\']})\n']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.34\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\', \'thefuck-alias = thefuck.main:alias\']})\n']",[[]],[[]]
thefuck,3f2fe0d275e38d9825721b5d1c70bb5369462b89,#89 #152 Use shell history,2015-05-04 04:44:16+02:00,nvbn,94,114,208,7,"['README.md', 'test_history.py', 'test_main.py', 'test_shells.py', 'history.py', 'main.py', 'shells.py']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n'rpl' is not a task. See 'lein help'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there's `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to `.bashrc` or `.zshrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck='eval $(thefuck $(fc -ln -1))'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK='fuck'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cd_mkdir` &ndash; creates directories before cd'ing into them;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `composer_not_command` &ndash; fixes composer command name.\n\nBundled, but not enabled by default:\n\n* `ls_lah` &ndash; adds -lah to ls;\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n    \n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call('chmod 777 .', shell=True)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\nExample of `settings.py`:\n\n```python\nrules = ['sudo', 'no_command']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES='sudo:no_command'\nexport THEFUCK_REQUIRE_CONFIRMATION='true'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS='false'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n"", ""import pytest\nfrom mock import Mock\nfrom thefuck.history import History\n\n\nclass TestHistory(object):\n    @pytest.fixture(autouse=True)\n    def process(self, monkeypatch):\n        Process = Mock()\n        Process.return_value.parent.return_value.pid = 1\n        monkeypatch.setattr('thefuck.history.Process', Process)\n        return Process\n\n    @pytest.fixture(autouse=True)\n    def db(self, monkeypatch):\n        class DBMock(dict):\n            def __init__(self):\n                super(DBMock, self).__init__()\n                self.sync = Mock()\n\n            def __call__(self, *args, **kwargs):\n                return self\n\n        db = DBMock()\n        monkeypatch.setattr('thefuck.history.shelve.open', db)\n        return db\n\n    def test_set(self, db):\n        history = History()\n        history.update(last_command='ls',\n                       last_fixed_command=None)\n        assert db == {'1-last_command': 'ls',\n                      '1-last_fixed_command': None}\n\n    def test_get(self, db):\n        history = History()\n        db['1-last_command'] = 'cd ..'\n        assert history.last_command == 'cd ..'\n\n    def test_get_without_value(self):\n        history = History()\n        assert history.last_command is None\n"", ""import pytest\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import Mock\nfrom thefuck import main, conf, types\nfrom tests.utils import Rule, Command\n\n\ndef test_load_rule(monkeypatch):\n    match = object()\n    get_new_command = object()\n    load_source = Mock()\n    load_source.return_value = Mock(match=match,\n                                    get_new_command=get_new_command,\n                                    enabled_by_default=True)\n    monkeypatch.setattr('thefuck.main.load_source', load_source)\n    assert main.load_rule(Path('/rules/bash.py')) \\\n           == Rule('bash', match, get_new_command)\n    load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\n@pytest.mark.parametrize('conf_rules, rules', [\n    (conf.DEFAULT_RULES, [Rule('bash', 'bash', 'bash'),\n                          Rule('lisp', 'lisp', 'lisp'),\n                          Rule('bash', 'bash', 'bash'),\n                          Rule('lisp', 'lisp', 'lisp')]),\n    (types.RulesNamesList(['bash']), [Rule('bash', 'bash', 'bash'),\n                                      Rule('bash', 'bash', 'bash')])])\ndef test_get_rules(monkeypatch, conf_rules, rules):\n    monkeypatch.setattr(\n        'thefuck.main.Path.glob',\n        lambda *_: [PosixPath('bash.py'), PosixPath('lisp.py')])\n    monkeypatch.setattr('thefuck.main.load_source',\n                        lambda x, _: Mock(match=x, get_new_command=x,\n                                          enabled_by_default=True))\n    assert list(main.get_rules(Path('~'), Mock(rules=conf_rules))) == rules\n\n\nclass TestGetCommand(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, monkeypatch):\n        Popen = Mock()\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        monkeypatch.setattr('thefuck.main.Popen', Popen)\n        return Popen\n\n    @pytest.fixture(autouse=True)\n    def prepare(self, monkeypatch):\n        monkeypatch.setattr('thefuck.main.os.environ', {})\n        monkeypatch.setattr('thefuck.main.wait_output', lambda *_: True)\n\n    @pytest.fixture(autouse=True)\n    def generic_shell(self, monkeypatch):\n        monkeypatch.setattr('thefuck.shells.from_shell', lambda x: x)\n        monkeypatch.setattr('thefuck.shells.to_shell', lambda x: x)\n\n    def test_get_command_calls(self, Popen):\n        assert main.get_command(Mock(), Mock(),\n            ['thefuck', 'apt-get', 'search', 'vim']) \\\n               == Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n    @pytest.mark.parametrize('history, args, result', [\n        (Mock(), [''], None),\n        (Mock(last_command='ls', last_fixed_command='ls -la'),\n         ['thefuck', 'fuck'], 'ls -la'),\n        (Mock(last_command='ls', last_fixed_command='ls -la'),\n         ['thefuck', 'ls'], 'ls -la'),\n        (Mock(last_command='ls', last_fixed_command=''),\n         ['thefuck', 'ls'], 'ls'),\n        (Mock(last_command='ls', last_fixed_command=''),\n         ['thefuck', 'fuck'], 'ls')])\n    def test_get_command_script(self, history, args, result):\n        if result:\n            assert main.get_command(Mock(), history, args).script == result\n        else:\n            assert main.get_command(Mock(), history, args) is None\n\n\nclass TestGetMatchedRule(object):\n    def test_no_match(self):\n        assert main.get_matched_rule(\n            Command('ls'), [Rule('', lambda *_: False)],\n            Mock(no_colors=True)) is None\n\n    def test_match(self):\n        rule = Rule('', lambda x, _: x.script == 'cd ..')\n        assert main.get_matched_rule(\n            Command('cd ..'), [rule], Mock(no_colors=True)) == rule\n\n    def test_when_rule_failed(self, capsys):\n        main.get_matched_rule(\n            Command('ls'), [Rule('test', Mock(side_effect=OSError('Denied')))],\n            Mock(no_colors=True))\n        assert capsys.readouterr()[1].split('\\n')[0] == '[WARN] Rule test:'\n\n\nclass TestRunRule(object):\n    @pytest.fixture(autouse=True)\n    def confirm(self, monkeypatch):\n        mock = Mock(return_value=True)\n        monkeypatch.setattr('thefuck.main.confirm', mock)\n        return mock\n\n    def test_run_rule(self, capsys):\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), Mock(), None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n\n    def test_run_rule_with_side_effect(self, capsys):\n        side_effect = Mock()\n        settings = Mock()\n        command = Command()\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command',\n                           side_effect=side_effect),\n                      command, Mock(), settings)\n        assert capsys.readouterr() == ('new-command\\n', '')\n        side_effect.assert_called_once_with(command, settings)\n\n    def test_hisotry_updated(self):\n        history = Mock()\n        main.run_rule(Rule(get_new_command=lambda *_: 'ls -lah'),\n                      Command('ls'), history, None)\n        history.update.assert_called_once_with(last_command='ls',\n                                               last_fixed_command='ls -lah')\n\n    def test_when_not_comfirmed(self, capsys, confirm):\n        confirm.return_value = False\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), Mock(), None)\n        assert capsys.readouterr() == ('', '')\n\n\nclass TestConfirm(object):\n    @pytest.fixture\n    def stdin(self, monkeypatch):\n        mock = Mock(return_value='\\n')\n        monkeypatch.setattr('sys.stdin.read', mock)\n        return mock\n\n    def test_when_not_required(self, capsys):\n        assert main.confirm('command', None, Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command\\n')\n\n    def test_with_side_effect_and_without_confirmation(self, capsys):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command*\\n')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed(self, capsys, stdin):\n        assert main.confirm('command', None, Mock(require_confirmation=True,\n                                                  no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed_with_side_effect(self, capsys, stdin):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=True,\n                                                    no_colors=True))\n        assert capsys.readouterr() == ('', 'command* [enter/ctrl+c]')\n\n    def test_when_confirmation_required_and_aborted(self, capsys, stdin):\n        stdin.side_effect = KeyboardInterrupt\n        assert not main.confirm('command', None, Mock(require_confirmation=True,\n                                                      no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", ""import pytest\nfrom mock import Mock\nfrom thefuck import shells\n\n\nclass TestGeneric(object):\n    def test_from_shell(self):\n        assert shells.Generic().from_shell('pwd') == 'pwd'\n\n    def test_to_shell(self):\n        assert shells.Bash().to_shell('pwd') == 'pwd'\n\n\nclass TestBash(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, monkeypatch):\n        mock = Mock()\n        monkeypatch.setattr('thefuck.shells.Popen', mock)\n        mock.return_value.stdout.read.return_value = (\n            b'alias l=\\'ls -CF\\'\\n'\n            b'alias la=\\'ls -A\\'\\n'\n            b'alias ll=\\'ls -alF\\'')\n        return mock\n\n    @pytest.mark.parametrize('before, after', [\n        ('pwd', 'pwd'),\n        ('ll', 'ls -alF')])\n    def test_from_shell(self, before, after):\n        assert shells.Bash().from_shell(before) == after\n\n    def test_to_shell(self):\n        assert shells.Bash().to_shell('pwd') == 'pwd'\n\n\nclass TestZsh(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, monkeypatch):\n        mock = Mock()\n        monkeypatch.setattr('thefuck.shells.Popen', mock)\n        mock.return_value.stdout.read.return_value = (\n            b'l=\\'ls -CF\\'\\n'\n            b'la=\\'ls -A\\'\\n'\n            b'll=\\'ls -alF\\'')\n        return mock\n\n    @pytest.mark.parametrize('before, after', [\n        ('pwd', 'pwd'),\n        ('ll', 'ls -alF')])\n    def test_from_shell(self, before, after):\n        assert shells.Zsh().from_shell(before) == after\n\n    def test_to_shell(self):\n        assert shells.Zsh().to_shell('pwd') == 'pwd'"", 'import os\nimport shelve\nfrom tempfile import gettempdir\nfrom psutil import Process\n\n\nclass History(object):\n    """"""Temporary history of commands/fixed-commands dependent on\n    current shell instance.\n\n    """"""\n\n    def __init__(self):\n        self._path = os.path.join(gettempdir(), \'.thefuck_history\')\n        self._pid = Process(os.getpid()).parent().pid\n        self._db = shelve.open(self._path)\n\n    def _prepare_key(self, key):\n        return \'{}-{}\'.format(self._pid, key)\n\n    def update(self, **kwargs):\n        self._db.update({self._prepare_key(k): v for k,v in kwargs.items()})\n        self._db.sync()\n        return self\n\n    def __getattr__(self, item):\n        return self._db.get(self._prepare_key(item))\n', 'from imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nfrom .history import History\nfrom . import logs, conf, types, shells\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    conf.initialize_settings_file(user_dir)\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return types.Rule(rule.name[:-3], rule_module.match,\n                      rule_module.get_new_command,\n                      getattr(rule_module, \'enabled_by_default\', True),\n                      getattr(rule_module, \'side_effect\', None))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent \\\n        .joinpath(\'rules\') \\\n        .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, history, args):\n    """"""Creates command from `args` and executes it.""""""\n    if sys.version_info[0] < 3:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if script == \'fuck\' or script == history.last_command:\n        script = history.last_fixed_command or history.last_command\n\n    if not script:\n        return\n\n    script = shells.from_shell(script)\n    history.update(last_command=script,\n                   last_fixed_command=None)\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return types.Command(script, result.stdout.read().decode(\'utf-8\'),\n                             result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, side_effect, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, side_effect, settings)\n        return True\n\n    logs.confirm_command(new_command, side_effect, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, history, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = shells.to_shell(rule.get_new_command(command, settings))\n    if confirm(new_command, rule.side_effect, settings):\n        if rule.side_effect:\n            rule.side_effect(command, settings)\n        history.update(last_command=command.script,\n                       last_fixed_command=new_command)\n        print(new_command)\n\n\ndef alias():\n    print(shells.app_alias())\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n    history = History()\n\n    command = get_command(settings, history, sys.argv)\n    if command:\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, history, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', '""""""Module with shell specific actions, each shell class should\nimplement `from_shell` and `to_shell` methods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nimport os\nfrom psutil import Process\n\n\nFNULL = open(os.devnull, \'w\')\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n\nclass Bash(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=FNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias)\n\n\nclass Zsh(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=FNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'zsh\': Zsh()})\n\n\ndef _get_shell():\n    shell = Process(os.getpid()).parent().cmdline()[0]\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    return _get_shell().app_alias()\n']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n'rpl' is not a task. See 'lein help'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there's `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck='eval $(thefuck $(fc -ln -1)); history -r'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK='fuck'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck='eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cd_mkdir` &ndash; creates directories before cd'ing into them;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `composer_not_command` &ndash; fixes composer command name.\n\nBundled, but not enabled by default:\n\n* `ls_lah` &ndash; adds -lah to ls;\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n    \n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call('chmod 777 .', shell=True)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\nExample of `settings.py`:\n\n```python\nrules = ['sudo', 'no_command']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES='sudo:no_command'\nexport THEFUCK_REQUIRE_CONFIRMATION='true'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS='false'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n"", None, ""import pytest\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import Mock\nfrom thefuck import main, conf, types\nfrom tests.utils import Rule, Command\n\n\ndef test_load_rule(monkeypatch):\n    match = object()\n    get_new_command = object()\n    load_source = Mock()\n    load_source.return_value = Mock(match=match,\n                                    get_new_command=get_new_command,\n                                    enabled_by_default=True)\n    monkeypatch.setattr('thefuck.main.load_source', load_source)\n    assert main.load_rule(Path('/rules/bash.py')) \\\n           == Rule('bash', match, get_new_command)\n    load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\n@pytest.mark.parametrize('conf_rules, rules', [\n    (conf.DEFAULT_RULES, [Rule('bash', 'bash', 'bash'),\n                          Rule('lisp', 'lisp', 'lisp'),\n                          Rule('bash', 'bash', 'bash'),\n                          Rule('lisp', 'lisp', 'lisp')]),\n    (types.RulesNamesList(['bash']), [Rule('bash', 'bash', 'bash'),\n                                      Rule('bash', 'bash', 'bash')])])\ndef test_get_rules(monkeypatch, conf_rules, rules):\n    monkeypatch.setattr(\n        'thefuck.main.Path.glob',\n        lambda *_: [PosixPath('bash.py'), PosixPath('lisp.py')])\n    monkeypatch.setattr('thefuck.main.load_source',\n                        lambda x, _: Mock(match=x, get_new_command=x,\n                                          enabled_by_default=True))\n    assert list(main.get_rules(Path('~'), Mock(rules=conf_rules))) == rules\n\n\nclass TestGetCommand(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, monkeypatch):\n        Popen = Mock()\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        monkeypatch.setattr('thefuck.main.Popen', Popen)\n        return Popen\n\n    @pytest.fixture(autouse=True)\n    def prepare(self, monkeypatch):\n        monkeypatch.setattr('thefuck.main.os.environ', {})\n        monkeypatch.setattr('thefuck.main.wait_output', lambda *_: True)\n\n    @pytest.fixture(autouse=True)\n    def generic_shell(self, monkeypatch):\n        monkeypatch.setattr('thefuck.shells.from_shell', lambda x: x)\n        monkeypatch.setattr('thefuck.shells.to_shell', lambda x: x)\n\n    def test_get_command_calls(self, Popen):\n        assert main.get_command(Mock(),\n            ['thefuck', 'apt-get', 'search', 'vim']) \\\n               == Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n    @pytest.mark.parametrize('args, result', [\n        (['thefuck', 'ls', '-la'], 'ls -la'),\n        (['thefuck', 'ls'], 'ls')])\n    def test_get_command_script(self, args, result):\n        if result:\n            assert main.get_command(Mock(), args).script == result\n        else:\n            assert main.get_command(Mock(), args) is None\n\n\nclass TestGetMatchedRule(object):\n    def test_no_match(self):\n        assert main.get_matched_rule(\n            Command('ls'), [Rule('', lambda *_: False)],\n            Mock(no_colors=True)) is None\n\n    def test_match(self):\n        rule = Rule('', lambda x, _: x.script == 'cd ..')\n        assert main.get_matched_rule(\n            Command('cd ..'), [rule], Mock(no_colors=True)) == rule\n\n    def test_when_rule_failed(self, capsys):\n        main.get_matched_rule(\n            Command('ls'), [Rule('test', Mock(side_effect=OSError('Denied')))],\n            Mock(no_colors=True))\n        assert capsys.readouterr()[1].split('\\n')[0] == '[WARN] Rule test:'\n\n\nclass TestRunRule(object):\n    @pytest.fixture(autouse=True)\n    def confirm(self, monkeypatch):\n        mock = Mock(return_value=True)\n        monkeypatch.setattr('thefuck.main.confirm', mock)\n        return mock\n\n    def test_run_rule(self, capsys):\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n\n    def test_run_rule_with_side_effect(self, capsys):\n        side_effect = Mock()\n        settings = Mock()\n        command = Command()\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command',\n                           side_effect=side_effect),\n                      command, settings)\n        assert capsys.readouterr() == ('new-command\\n', '')\n        side_effect.assert_called_once_with(command, settings)\n\n    def test_when_not_comfirmed(self, capsys, confirm):\n        confirm.return_value = False\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), None)\n        assert capsys.readouterr() == ('', '')\n\n\nclass TestConfirm(object):\n    @pytest.fixture\n    def stdin(self, monkeypatch):\n        mock = Mock(return_value='\\n')\n        monkeypatch.setattr('sys.stdin.read', mock)\n        return mock\n\n    def test_when_not_required(self, capsys):\n        assert main.confirm('command', None, Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command\\n')\n\n    def test_with_side_effect_and_without_confirmation(self, capsys):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command*\\n')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed(self, capsys, stdin):\n        assert main.confirm('command', None, Mock(require_confirmation=True,\n                                                  no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed_with_side_effect(self, capsys, stdin):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=True,\n                                                    no_colors=True))\n        assert capsys.readouterr() == ('', 'command* [enter/ctrl+c]')\n\n    def test_when_confirmation_required_and_aborted(self, capsys, stdin):\n        stdin.side_effect = KeyboardInterrupt\n        assert not main.confirm('command', None, Mock(require_confirmation=True,\n                                                      no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", ""import pytest\nfrom mock import Mock, MagicMock\nfrom thefuck import shells\n\n\n@pytest.fixture\ndef builtins_open(monkeypatch):\n    mock = MagicMock()\n    monkeypatch.setattr('six.moves.builtins.open', mock)\n    return mock\n\n\n@pytest.fixture\ndef isfile(monkeypatch):\n    mock = Mock(return_value=True)\n    monkeypatch.setattr('os.path.isfile', mock)\n    return mock\n\n\nclass TestGeneric(object):\n    def test_from_shell(self):\n        assert shells.Generic().from_shell('pwd') == 'pwd'\n\n    def test_to_shell(self):\n        assert shells.Generic().to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open):\n        assert shells.Generic().put_to_history('ls') is None\n        assert builtins_open.call_count == 0\n\n\n@pytest.mark.usefixtures('isfile')\nclass TestBash(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, monkeypatch):\n        mock = Mock()\n        monkeypatch.setattr('thefuck.shells.Popen', mock)\n        mock.return_value.stdout.read.return_value = (\n            b'alias l=\\'ls -CF\\'\\n'\n            b'alias la=\\'ls -A\\'\\n'\n            b'alias ll=\\'ls -alF\\'')\n        return mock\n\n    @pytest.mark.parametrize('before, after', [\n        ('pwd', 'pwd'),\n        ('ll', 'ls -alF')])\n    def test_from_shell(self, before, after):\n        assert shells.Bash().from_shell(before) == after\n\n    def test_to_shell(self):\n        assert shells.Bash().to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open):\n        shells.Bash().put_to_history('ls')\n        builtins_open.return_value.__enter__.return_value.\\\n            write.assert_called_once_with('ls\\n')\n\n\n@pytest.mark.usefixtures('isfile')\nclass TestZsh(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, monkeypatch):\n        mock = Mock()\n        monkeypatch.setattr('thefuck.shells.Popen', mock)\n        mock.return_value.stdout.read.return_value = (\n            b'l=\\'ls -CF\\'\\n'\n            b'la=\\'ls -A\\'\\n'\n            b'll=\\'ls -alF\\'')\n        return mock\n\n    @pytest.mark.parametrize('before, after', [\n        ('pwd', 'pwd'),\n        ('ll', 'ls -alF')])\n    def test_from_shell(self, before, after):\n        assert shells.Zsh().from_shell(before) == after\n\n    def test_to_shell(self):\n        assert shells.Zsh().to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open, monkeypatch):\n        monkeypatch.setattr('thefuck.shells.time',\n                            lambda: 1430707243.3517463)\n        shells.Zsh().put_to_history('ls')\n        builtins_open.return_value.__enter__.return_value. \\\n            write.assert_called_once_with(': 1430707243:0;ls\\n')"", None, 'from imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nimport six\nfrom . import logs, conf, types, shells\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    conf.initialize_settings_file(user_dir)\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return types.Rule(rule.name[:-3], rule_module.match,\n                      rule_module.get_new_command,\n                      getattr(rule_module, \'enabled_by_default\', True),\n                      getattr(rule_module, \'side_effect\', None))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent \\\n        .joinpath(\'rules\') \\\n        .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if six.PY2:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    script = shells.from_shell(script)\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return types.Command(script, result.stdout.read().decode(\'utf-8\'),\n                             result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, side_effect, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, side_effect, settings)\n        return True\n\n    logs.confirm_command(new_command, side_effect, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = shells.to_shell(rule.get_new_command(command, settings))\n    if confirm(new_command, rule.side_effect, settings):\n        if rule.side_effect:\n            rule.side_effect(command, settings)\n        shells.put_to_history(new_command)\n        print(new_command)\n\n\ndef alias():\n    print(shells.app_alias())\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', '""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias` and `put_to_history`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\n\n\nFNULL = open(os.devnull, \'w\')\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n\nclass Bash(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=FNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Zsh(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=FNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'zsh\': Zsh()})\n\n\ndef _get_shell():\n    shell = Process(os.getpid()).parent().cmdline()[0]\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    return _get_shell().app_alias()\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n']","[[], [<pydriller.domain.commit.Method object at 0x7f198507fd00>, <pydriller.domain.commit.Method object at 0x7f198507ffa0>, <pydriller.domain.commit.Method object at 0x7f1983f713d0>, <pydriller.domain.commit.Method object at 0x7f1983f71640>, <pydriller.domain.commit.Method object at 0x7f1983f71910>, <pydriller.domain.commit.Method object at 0x7f1983f60790>, <pydriller.domain.commit.Method object at 0x7f1983f603d0>], [<pydriller.domain.commit.Method object at 0x7f1983f6be50>, <pydriller.domain.commit.Method object at 0x7f1983f6b3a0>, <pydriller.domain.commit.Method object at 0x7f1983f6bfa0>, <pydriller.domain.commit.Method object at 0x7f198504fc10>, <pydriller.domain.commit.Method object at 0x7f1983ed0670>, <pydriller.domain.commit.Method object at 0x7f1983f328e0>, <pydriller.domain.commit.Method object at 0x7f1983f327c0>, <pydriller.domain.commit.Method object at 0x7f1983f32bb0>, <pydriller.domain.commit.Method object at 0x7f1983f324f0>, <pydriller.domain.commit.Method object at 0x7f1983f32a60>, <pydriller.domain.commit.Method object at 0x7f1983f32790>, <pydriller.domain.commit.Method object at 0x7f1983f32f70>, <pydriller.domain.commit.Method object at 0x7f1983f32640>, <pydriller.domain.commit.Method object at 0x7f1983f32cd0>, <pydriller.domain.commit.Method object at 0x7f1983f4e7c0>, <pydriller.domain.commit.Method object at 0x7f1983fc9a90>, <pydriller.domain.commit.Method object at 0x7f1983fc9be0>, <pydriller.domain.commit.Method object at 0x7f1983fc9c10>, <pydriller.domain.commit.Method object at 0x7f1983fc9ca0>, <pydriller.domain.commit.Method object at 0x7f1983fc9c70>, <pydriller.domain.commit.Method object at 0x7f1983fc9d90>], [<pydriller.domain.commit.Method object at 0x7f1983cf6be0>, <pydriller.domain.commit.Method object at 0x7f1983cf6820>, <pydriller.domain.commit.Method object at 0x7f1983cf6c10>, <pydriller.domain.commit.Method object at 0x7f1983cf6f10>, <pydriller.domain.commit.Method object at 0x7f1983cf6cd0>, <pydriller.domain.commit.Method object at 0x7f1983cf6580>, <pydriller.domain.commit.Method object at 0x7f1983cf6e50>, <pydriller.domain.commit.Method object at 0x7f1983cf6430>], [<pydriller.domain.commit.Method object at 0x7f1983fc98e0>, <pydriller.domain.commit.Method object at 0x7f1983fc9730>, <pydriller.domain.commit.Method object at 0x7f1983fc9ac0>, <pydriller.domain.commit.Method object at 0x7f1983fc9880>], [<pydriller.domain.commit.Method object at 0x7f1983ea88e0>, <pydriller.domain.commit.Method object at 0x7f1983ea8790>, <pydriller.domain.commit.Method object at 0x7f1983d74550>, <pydriller.domain.commit.Method object at 0x7f1983f5afa0>, <pydriller.domain.commit.Method object at 0x7f1983f717c0>, <pydriller.domain.commit.Method object at 0x7f1983f71250>, <pydriller.domain.commit.Method object at 0x7f1983f71520>, <pydriller.domain.commit.Method object at 0x7f1983f71130>, <pydriller.domain.commit.Method object at 0x7f1983f714f0>, <pydriller.domain.commit.Method object at 0x7f1983f71280>], [<pydriller.domain.commit.Method object at 0x7f198504fd00>, <pydriller.domain.commit.Method object at 0x7f198504f220>, <pydriller.domain.commit.Method object at 0x7f198504f5e0>, <pydriller.domain.commit.Method object at 0x7f198504f880>, <pydriller.domain.commit.Method object at 0x7f1983cf6d00>, <pydriller.domain.commit.Method object at 0x7f1983cf6e80>, <pydriller.domain.commit.Method object at 0x7f1983cf6f70>, <pydriller.domain.commit.Method object at 0x7f1983cf6fa0>, <pydriller.domain.commit.Method object at 0x7f1983cf6fd0>, <pydriller.domain.commit.Method object at 0x7f1983cf6970>, <pydriller.domain.commit.Method object at 0x7f1983cf6e20>, <pydriller.domain.commit.Method object at 0x7f1983cf6ee0>, <pydriller.domain.commit.Method object at 0x7f1983cf6550>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983f60790>, <pydriller.domain.commit.Method object at 0x7f198507ffa0>, <pydriller.domain.commit.Method object at 0x7f1983f71640>, <pydriller.domain.commit.Method object at 0x7f1983f713d0>, <pydriller.domain.commit.Method object at 0x7f1983f71910>, <pydriller.domain.commit.Method object at 0x7f198507fd00>, <pydriller.domain.commit.Method object at 0x7f1983f603d0>], [<pydriller.domain.commit.Method object at 0x7f1983f20130>, <pydriller.domain.commit.Method object at 0x7f1983f5a520>, <pydriller.domain.commit.Method object at 0x7f1983f32cd0>, <pydriller.domain.commit.Method object at 0x7f1983f327c0>, <pydriller.domain.commit.Method object at 0x7f1983f20100>, <pydriller.domain.commit.Method object at 0x7f1983f203d0>, <pydriller.domain.commit.Method object at 0x7f1983f5ab80>], [<pydriller.domain.commit.Method object at 0x7f1983fc97c0>, <pydriller.domain.commit.Method object at 0x7f1983fc9640>, <pydriller.domain.commit.Method object at 0x7f1983fc9430>, <pydriller.domain.commit.Method object at 0x7f1983fc96d0>, <pydriller.domain.commit.Method object at 0x7f1983d7aa90>], [<pydriller.domain.commit.Method object at 0x7f1983fc98e0>, <pydriller.domain.commit.Method object at 0x7f1983fc9ac0>, <pydriller.domain.commit.Method object at 0x7f1983fc9880>, <pydriller.domain.commit.Method object at 0x7f1983fc9730>], [<pydriller.domain.commit.Method object at 0x7f1983f71130>, <pydriller.domain.commit.Method object at 0x7f1983f15bb0>, <pydriller.domain.commit.Method object at 0x7f1983f60250>, <pydriller.domain.commit.Method object at 0x7f1983f717c0>, <pydriller.domain.commit.Method object at 0x7f1983f60280>], [<pydriller.domain.commit.Method object at 0x7f198507f670>, <pydriller.domain.commit.Method object at 0x7f198507f640>, <pydriller.domain.commit.Method object at 0x7f198507fd90>, <pydriller.domain.commit.Method object at 0x7f198504fdf0>]]"
thefuck,a8ff2375c0b4fd99ed1bcb79edd33377461ce79e,Bump to 1.35,2015-05-04 05:01:56+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nVERSION = \'1.34\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\', \'thefuck-alias = thefuck.main:alias\']})\n']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.35\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\', \'thefuck-alias = thefuck.main:alias\']})\n']",[[]],[[]]
thefuck,6624ecb3b85e82e9f1a08823f6e41ee805d35a9e,Add a rule for pacman,2015-05-05 11:13:29+02:00,mcarton,43,0,43,2,"['README.md', 'pacman.py']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n'rpl' is not a task. See 'lein help'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there's `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck='eval $(thefuck $(fc -ln -1)); history -r'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK='fuck'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck='eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cd_mkdir` &ndash; creates directories before cd'ing into them;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `composer_not_command` &ndash; fixes composer command name.\n\nBundled, but not enabled by default:\n\n* `ls_lah` &ndash; adds -lah to ls;\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n    \n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call('chmod 777 .', shell=True)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\nExample of `settings.py`:\n\n```python\nrules = ['sudo', 'no_command']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES='sudo:no_command'\nexport THEFUCK_REQUIRE_CONFIRMATION='true'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS='false'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n"", None]","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n'rpl' is not a task. See 'lein help'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there's `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck='eval $(thefuck $(fc -ln -1)); history -r'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK='fuck'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck='eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cd_mkdir` &ndash; creates directories before cd'ing into them;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `composer_not_command` &ndash; fixes composer command name.\n\nBundled, but not enabled by default:\n\n* `ls_lah` &ndash; adds -lah to ls;\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n    \n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call('chmod 777 .', shell=True)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\nExample of `settings.py`:\n\n```python\nrules = ['sudo', 'no_command']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES='sudo:no_command'\nexport THEFUCK_REQUIRE_CONFIRMATION='true'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS='false'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n"", 'import subprocess\n\n\ndef __command_available(command):\n    try:\n        subprocess.check_output([command], stderr=subprocess.DEVNULL)\n        return True\n    except subprocess.CalledProcessError:\n        # command exists but is not happy to be called without any argument\n        return True\n    except FileNotFoundError:\n        return False\n\n\ndef __get_pkgfile(command):\n    try:\n        return subprocess.check_output(\n            [\'pkgfile\', \'-b\', \'-v\', command.script.split("" "")[0]],\n            universal_newlines=True, stderr=subprocess.DEVNULL\n        ).split()\n    except subprocess.CalledProcessError:\n        return None\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and __get_pkgfile(command)\n\n\ndef get_new_command(command, settings):\n    package = __get_pkgfile(command)[0]\n\n    return \'{} -S {} && {}\'.format(pacman, package, command.script)\n\n\nif not __command_available(\'pkgfile\'):\n    enabled_by_default = False\nelif __command_available(\'yaourt\'):\n    pacman = \'yaourt\'\nelif __command_available(\'pacman\'):\n    pacman = \'sudo pacman\'\nelse:\n    enabled_by_default = False\n']","[[], []]","[[], [<pydriller.domain.commit.Method object at 0x7f198504f850>, <pydriller.domain.commit.Method object at 0x7f198504f910>, <pydriller.domain.commit.Method object at 0x7f198504f820>, <pydriller.domain.commit.Method object at 0x7f198504f8b0>]]"
thefuck,9380eb1f56fda20547c88afd7a5b82f82fa120d9,Add a git_add rule,2015-05-06 11:31:31+02:00,mcarton,16,0,16,2,"['README.md', 'git_add.py']","[""# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command 'puthon' found, did you mean:\n Command 'python' from package 'python-minimal' (main)\n Command 'python' from package 'python3' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: 'brnch' is not a git command. See 'git --help'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n'rpl' is not a task. See 'lein help'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there's `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck='eval $(thefuck $(fc -ln -1)); history -r'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK='fuck'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck='eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cd_mkdir` &ndash; creates directories before cd'ing into them;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `composer_not_command` &ndash; fixes composer command name.\n\nBundled, but not enabled by default:\n\n* `ls_lah` &ndash; adds -lah to ls;\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return ('permission denied' in command.stderr.lower()\n            or 'EACCES' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'sudo {}'.format(command.script)\n    \n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call('chmod 777 .', shell=True)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\nExample of `settings.py`:\n\n```python\nrules = ['sudo', 'no_command']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES='sudo:no_command'\nexport THEFUCK_REQUIRE_CONFIRMATION='true'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS='false'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n"", None]","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_add` &ndash; fix *""Did you forget to \'git add\'?""*;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `composer_not_command` &ndash; fixes composer command name.\n\nBundled, but not enabled by default:\n\n* `ls_lah` &ndash; adds -lah to ls;\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n    \n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call(\'chmod 777 .\', shell=True)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\nExample of `settings.py`:\n\n```python\nrules = [\'sudo\', \'no_command\']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES=\'sudo:no_command\'\nexport THEFUCK_REQUIRE_CONFIRMATION=\'true\'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS=\'false\'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', 'import re\n\n\ndef match(command, settings):\n    return (\'git\' in command.script\n            and \'did not match any file(s) known to git.\' in command.stderr\n            and ""Did you forget to \'git add\'?"" in command.stderr)\n\n\ndef get_new_command(command, settings):\n    missing_file = re.findall(\n            r""error: pathspec \'([^\']*)\' ""\n            ""did not match any file\\(s\\) known to git."", command.stderr)[0]\n\n    return \'git add -- {} && {}\'.format(missing_file, command.script)\n']","[[], []]","[[], [<pydriller.domain.commit.Method object at 0x7f1982905910>, <pydriller.domain.commit.Method object at 0x7f19829054f0>]]"
thefuck,5864faadeff34bad0b2b15d904802707dd68fbfd,#165 fix python 2 support,2015-05-06 13:17:14+02:00,nvbn,9,7,16,3,"['pacman.py', 'shells.py', 'utils.py']","['import subprocess\n\n\ndef __command_available(command):\n    try:\n        subprocess.check_output([command], stderr=subprocess.DEVNULL)\n        return True\n    except subprocess.CalledProcessError:\n        # command exists but is not happy to be called without any argument\n        return True\n    except FileNotFoundError:\n        return False\n\n\ndef __get_pkgfile(command):\n    try:\n        return subprocess.check_output(\n            [\'pkgfile\', \'-b\', \'-v\', command.script.split("" "")[0]],\n            universal_newlines=True, stderr=subprocess.DEVNULL\n        ).split()\n    except subprocess.CalledProcessError:\n        return None\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and __get_pkgfile(command)\n\n\ndef get_new_command(command, settings):\n    package = __get_pkgfile(command)[0]\n\n    return \'{} -S {} && {}\'.format(pacman, package, command.script)\n\n\nif not __command_available(\'pkgfile\'):\n    enabled_by_default = False\nelif __command_available(\'yaourt\'):\n    pacman = \'yaourt\'\nelif __command_available(\'pacman\'):\n    pacman = \'sudo pacman\'\nelse:\n    enabled_by_default = False\n', '""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias` and `put_to_history`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\n\n\nFNULL = open(os.devnull, \'w\')\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n\nclass Bash(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=FNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Zsh(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=FNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'zsh\': Zsh()})\n\n\ndef _get_shell():\n    shell = Process(os.getpid()).parent().cmdline()[0]\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    return _get_shell().app_alias()\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n', 'from functools import wraps\nimport os\nimport six\nfrom .types import Command\n\n\ndef which(program):\n    """"""Returns `program` path or `None`.""""""\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef wrap_settings(params):\n    """"""Adds default values to settings if it not presented.\n\n    Usage:\n\n        @wrap_settings({\'apt\': \'/usr/bin/apt\'})\n        def match(command, settings):\n            print(settings.apt)\n\n    """"""\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(command, settings):\n            return fn(command, settings.update(**params))\n        return wrapper\n    return decorator\n\n\ndef sudo_support(fn):\n    """"""Removes sudo before calling fn and adds it after.""""""\n    @wraps(fn)\n    def wrapper(command, settings):\n        if not command.script.startswith(\'sudo \'):\n            return fn(command, settings)\n\n        result = fn(Command(command.script[5:],\n                            command.stdout,\n                            command.stderr),\n                    settings)\n\n        if result and isinstance(result, six.string_types):\n            return u\'sudo {}\'.format(result)\n        else:\n            return result\n    return wrapper\n']","['import subprocess\nfrom thefuck.utils import DEVNULL\n\n\ndef __command_available(command):\n    try:\n        subprocess.check_output([command], stderr=DEVNULL)\n        return True\n    except subprocess.CalledProcessError:\n        # command exists but is not happy to be called without any argument\n        return True\n    except OSError:\n        return False\n\n\ndef __get_pkgfile(command):\n    try:\n        return subprocess.check_output(\n            [\'pkgfile\', \'-b\', \'-v\', command.script.split("" "")[0]],\n            universal_newlines=True, stderr=subprocess.DEVNULL\n        ).split()\n    except subprocess.CalledProcessError:\n        return None\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and __get_pkgfile(command)\n\n\ndef get_new_command(command, settings):\n    package = __get_pkgfile(command)[0]\n\n    return \'{} -S {} && {}\'.format(pacman, package, command.script)\n\n\nif not __command_available(\'pkgfile\'):\n    enabled_by_default = False\nelif __command_available(\'yaourt\'):\n    pacman = \'yaourt\'\nelif __command_available(\'pacman\'):\n    pacman = \'sudo pacman\'\nelse:\n    enabled_by_default = False\n', '""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias` and `put_to_history`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\nfrom .utils import DEVNULL\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n\nclass Bash(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Zsh(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'zsh\': Zsh()})\n\n\ndef _get_shell():\n    shell = Process(os.getpid()).parent().cmdline()[0]\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    return _get_shell().app_alias()\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n', 'from functools import wraps\nimport os\nimport six\nfrom .types import Command\n\n\nDEVNULL = open(os.devnull, \'w\')\n\n\ndef which(program):\n    """"""Returns `program` path or `None`.""""""\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[""PATH""].split(os.pathsep):\n            path = path.strip(\'""\')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef wrap_settings(params):\n    """"""Adds default values to settings if it not presented.\n\n    Usage:\n\n        @wrap_settings({\'apt\': \'/usr/bin/apt\'})\n        def match(command, settings):\n            print(settings.apt)\n\n    """"""\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(command, settings):\n            return fn(command, settings.update(**params))\n        return wrapper\n    return decorator\n\n\ndef sudo_support(fn):\n    """"""Removes sudo before calling fn and adds it after.""""""\n    @wraps(fn)\n    def wrapper(command, settings):\n        if not command.script.startswith(\'sudo \'):\n            return fn(command, settings)\n\n        result = fn(Command(command.script[5:],\n                            command.stdout,\n                            command.stderr),\n                    settings)\n\n        if result and isinstance(result, six.string_types):\n            return u\'sudo {}\'.format(result)\n        else:\n            return result\n    return wrapper\n']","[[<pydriller.domain.commit.Method object at 0x7f1982907100>, <pydriller.domain.commit.Method object at 0x7f19829070a0>, <pydriller.domain.commit.Method object at 0x7f1982907130>, <pydriller.domain.commit.Method object at 0x7f1982907160>], [<pydriller.domain.commit.Method object at 0x7f1983f203a0>, <pydriller.domain.commit.Method object at 0x7f1983f4e460>, <pydriller.domain.commit.Method object at 0x7f1983f4e430>, <pydriller.domain.commit.Method object at 0x7f1983f4e2b0>, <pydriller.domain.commit.Method object at 0x7f198504fb80>, <pydriller.domain.commit.Method object at 0x7f198504f7f0>, <pydriller.domain.commit.Method object at 0x7f198504f9d0>, <pydriller.domain.commit.Method object at 0x7f198504fe50>, <pydriller.domain.commit.Method object at 0x7f198504f7c0>, <pydriller.domain.commit.Method object at 0x7f198504fa60>, <pydriller.domain.commit.Method object at 0x7f198504f550>, <pydriller.domain.commit.Method object at 0x7f198504f760>, <pydriller.domain.commit.Method object at 0x7f198504f6d0>, <pydriller.domain.commit.Method object at 0x7f198504fe20>, <pydriller.domain.commit.Method object at 0x7f198504fe80>, <pydriller.domain.commit.Method object at 0x7f198504faf0>, <pydriller.domain.commit.Method object at 0x7f198504fd30>, <pydriller.domain.commit.Method object at 0x7f198504fc40>, <pydriller.domain.commit.Method object at 0x7f198504f8e0>, <pydriller.domain.commit.Method object at 0x7f198504f730>, <pydriller.domain.commit.Method object at 0x7f198504fa00>], [<pydriller.domain.commit.Method object at 0x7f198507fcd0>, <pydriller.domain.commit.Method object at 0x7f198507ffd0>, <pydriller.domain.commit.Method object at 0x7f198507f850>, <pydriller.domain.commit.Method object at 0x7f198507fca0>, <pydriller.domain.commit.Method object at 0x7f198507fa00>, <pydriller.domain.commit.Method object at 0x7f198507f9d0>, <pydriller.domain.commit.Method object at 0x7f198507f910>]]","[[<pydriller.domain.commit.Method object at 0x7f1982905880>], [<pydriller.domain.commit.Method object at 0x7f1982905760>], []]"
thefuck,fc3fcf028ac480bab2ab6a9f58f4accce5faf084,#154 Add priority to rules,2015-05-06 13:57:09+02:00,nvbn,56,26,82,6,"['README.md', 'test_main.py', 'utils.py', 'conf.py', 'main.py', 'types.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_add` &ndash; fix *""Did you forget to \'git add\'?""*;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `composer_not_command` &ndash; fixes composer command name.\n\nBundled, but not enabled by default:\n\n* `ls_lah` &ndash; adds -lah to ls;\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n    \n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call(\'chmod 777 .\', shell=True)\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\nExample of `settings.py`:\n\n```python\nrules = [\'sudo\', \'no_command\']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES=\'sudo:no_command\'\nexport THEFUCK_REQUIRE_CONFIRMATION=\'true\'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS=\'false\'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""import pytest\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import Mock\nfrom thefuck import main, conf, types\nfrom tests.utils import Rule, Command\n\n\ndef test_load_rule(monkeypatch):\n    match = object()\n    get_new_command = object()\n    load_source = Mock()\n    load_source.return_value = Mock(match=match,\n                                    get_new_command=get_new_command,\n                                    enabled_by_default=True)\n    monkeypatch.setattr('thefuck.main.load_source', load_source)\n    assert main.load_rule(Path('/rules/bash.py')) \\\n           == Rule('bash', match, get_new_command)\n    load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\n@pytest.mark.parametrize('conf_rules, rules', [\n    (conf.DEFAULT_RULES, [Rule('bash', 'bash', 'bash'),\n                          Rule('lisp', 'lisp', 'lisp'),\n                          Rule('bash', 'bash', 'bash'),\n                          Rule('lisp', 'lisp', 'lisp')]),\n    (types.RulesNamesList(['bash']), [Rule('bash', 'bash', 'bash'),\n                                      Rule('bash', 'bash', 'bash')])])\ndef test_get_rules(monkeypatch, conf_rules, rules):\n    monkeypatch.setattr(\n        'thefuck.main.Path.glob',\n        lambda *_: [PosixPath('bash.py'), PosixPath('lisp.py')])\n    monkeypatch.setattr('thefuck.main.load_source',\n                        lambda x, _: Mock(match=x, get_new_command=x,\n                                          enabled_by_default=True))\n    assert list(main.get_rules(Path('~'), Mock(rules=conf_rules))) == rules\n\n\nclass TestGetCommand(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, monkeypatch):\n        Popen = Mock()\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        monkeypatch.setattr('thefuck.main.Popen', Popen)\n        return Popen\n\n    @pytest.fixture(autouse=True)\n    def prepare(self, monkeypatch):\n        monkeypatch.setattr('thefuck.main.os.environ', {})\n        monkeypatch.setattr('thefuck.main.wait_output', lambda *_: True)\n\n    @pytest.fixture(autouse=True)\n    def generic_shell(self, monkeypatch):\n        monkeypatch.setattr('thefuck.shells.from_shell', lambda x: x)\n        monkeypatch.setattr('thefuck.shells.to_shell', lambda x: x)\n\n    def test_get_command_calls(self, Popen):\n        assert main.get_command(Mock(),\n            ['thefuck', 'apt-get', 'search', 'vim']) \\\n               == Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n    @pytest.mark.parametrize('args, result', [\n        (['thefuck', 'ls', '-la'], 'ls -la'),\n        (['thefuck', 'ls'], 'ls')])\n    def test_get_command_script(self, args, result):\n        if result:\n            assert main.get_command(Mock(), args).script == result\n        else:\n            assert main.get_command(Mock(), args) is None\n\n\nclass TestGetMatchedRule(object):\n    def test_no_match(self):\n        assert main.get_matched_rule(\n            Command('ls'), [Rule('', lambda *_: False)],\n            Mock(no_colors=True)) is None\n\n    def test_match(self):\n        rule = Rule('', lambda x, _: x.script == 'cd ..')\n        assert main.get_matched_rule(\n            Command('cd ..'), [rule], Mock(no_colors=True)) == rule\n\n    def test_when_rule_failed(self, capsys):\n        main.get_matched_rule(\n            Command('ls'), [Rule('test', Mock(side_effect=OSError('Denied')))],\n            Mock(no_colors=True))\n        assert capsys.readouterr()[1].split('\\n')[0] == '[WARN] Rule test:'\n\n\nclass TestRunRule(object):\n    @pytest.fixture(autouse=True)\n    def confirm(self, monkeypatch):\n        mock = Mock(return_value=True)\n        monkeypatch.setattr('thefuck.main.confirm', mock)\n        return mock\n\n    def test_run_rule(self, capsys):\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n\n    def test_run_rule_with_side_effect(self, capsys):\n        side_effect = Mock()\n        settings = Mock()\n        command = Command()\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command',\n                           side_effect=side_effect),\n                      command, settings)\n        assert capsys.readouterr() == ('new-command\\n', '')\n        side_effect.assert_called_once_with(command, settings)\n\n    def test_when_not_comfirmed(self, capsys, confirm):\n        confirm.return_value = False\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), None)\n        assert capsys.readouterr() == ('', '')\n\n\nclass TestConfirm(object):\n    @pytest.fixture\n    def stdin(self, monkeypatch):\n        mock = Mock(return_value='\\n')\n        monkeypatch.setattr('sys.stdin.read', mock)\n        return mock\n\n    def test_when_not_required(self, capsys):\n        assert main.confirm('command', None, Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command\\n')\n\n    def test_with_side_effect_and_without_confirmation(self, capsys):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command*\\n')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed(self, capsys, stdin):\n        assert main.confirm('command', None, Mock(require_confirmation=True,\n                                                  no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed_with_side_effect(self, capsys, stdin):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=True,\n                                                    no_colors=True))\n        assert capsys.readouterr() == ('', 'command* [enter/ctrl+c]')\n\n    def test_when_confirmation_required_and_aborted(self, capsys, stdin):\n        stdin.side_effect = KeyboardInterrupt\n        assert not main.confirm('command', None, Mock(require_confirmation=True,\n                                                      no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", ""from thefuck import types\n\n\ndef Command(script='', stdout='', stderr=''):\n    return types.Command(script, stdout, stderr)\n\n\ndef Rule(name='', match=lambda *_: True,\n         get_new_command=lambda *_: '',\n         enabled_by_default=True,\n         side_effect=None):\n    return types.Rule(name, match, get_new_command,\n                      enabled_by_default, side_effect)\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs, types\n\n\nclass _DefaultRulesNames(types.RulesNamesList):\n    def __add__(self, items):\n        return _DefaultRulesNames(list(self) + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRulesNames, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRulesNames):\n            return super(_DefaultRulesNames, self).__eq__(other)\n        else:\n            return False\n\n\nDEFAULT_RULES = _DefaultRulesNames([])\n\n\nDEFAULT_SETTINGS = {\'rules\': DEFAULT_RULES,\n                    \'wait_command\': 3,\n                    \'require_confirmation\': False,\n                    \'no_colors\': False}\n\nENV_TO_ATTR = {\'THEFUCK_RULES\': \'rules\',\n               \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n               \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n               \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n\nSETTINGS_HEADER = u""""""# ~/.thefuck/settings.py: The Fuck settings file\n#\n# The rules are defined as in the example bellow:\n#\n# rules = [\'cd_parent\', \'git_push\', \'python_command\', \'sudo\']\n#\n# The default values are as follows. Uncomment and change to fit your needs.\n# See https://github.com/nvbn/thefuck#settings for more information.\n#\n\n""""""\n\n\ndef _settings_from_file(user_dir):\n    """"""Loads settings from file.""""""\n    settings = load_source(\'settings\',\n                           text_type(user_dir.joinpath(\'settings.py\')))\n    return {key: getattr(settings, key)\n            for key in DEFAULT_SETTINGS.keys()\n            if hasattr(settings, key)}\n\n\ndef _rules_from_env(val):\n    """"""Transforms rules list from env-string to python.""""""\n    val = val.split(\':\')\n    if \'DEFAULT_RULES\' in val:\n        val = DEFAULT_RULES + [rule for rule in val if rule != \'DEFAULT_RULES\']\n    return val\n\n\ndef _val_from_env(env, attr):\n    """"""Transforms env-strings to python.""""""\n    val = os.environ[env]\n    if attr == \'rules\':\n        val = _rules_from_env(val)\n    elif attr == \'wait_command\':\n        val = int(val)\n    elif attr in (\'require_confirmation\', \'no_colors\'):\n        val = val.lower() == \'true\'\n    return val\n\n\ndef _settings_from_env():\n    """"""Loads settings from env.""""""\n    return {attr: _val_from_env(env, attr)\n            for env, attr in ENV_TO_ATTR.items()\n            if env in os.environ}\n\n\ndef get_settings(user_dir):\n    """"""Returns settings filled with values from `settings.py` and env.""""""\n    conf = copy(DEFAULT_SETTINGS)\n    try:\n        conf.update(_settings_from_file(user_dir))\n    except Exception:\n        logs.exception(""Can\'t load settings from file"",\n                       sys.exc_info(),\n                       types.Settings(conf))\n\n    try:\n        conf.update(_settings_from_env())\n    except Exception:\n        logs.exception(""Can\'t load settings from env"",\n                       sys.exc_info(),\n                       types.Settings(conf))\n\n    if not isinstance(conf[\'rules\'], types.RulesNamesList):\n        conf[\'rules\'] = types.RulesNamesList(conf[\'rules\'])\n\n    return types.Settings(conf)\n\n\ndef initialize_settings_file(user_dir):\n    settings_path = user_dir.joinpath(\'settings.py\')\n    if not settings_path.is_file():\n        with settings_path.open(mode=\'w\') as settings_file:\n            settings_file.write(SETTINGS_HEADER)\n            for setting in DEFAULT_SETTINGS.items():\n                settings_file.write(u\'# {} = {}\\n\'.format(*setting))\n', 'from imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nimport six\nfrom . import logs, conf, types, shells\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    conf.initialize_settings_file(user_dir)\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return types.Rule(rule.name[:-3], rule_module.match,\n                      rule_module.get_new_command,\n                      getattr(rule_module, \'enabled_by_default\', True),\n                      getattr(rule_module, \'side_effect\', None))\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent \\\n        .joinpath(\'rules\') \\\n        .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    for rule in sorted(list(bundled)) + list(user):\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if six.PY2:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    script = shells.from_shell(script)\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return types.Command(script, result.stdout.read().decode(\'utf-8\'),\n                             result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, side_effect, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, side_effect, settings)\n        return True\n\n    logs.confirm_command(new_command, side_effect, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = shells.to_shell(rule.get_new_command(command, settings))\n    if confirm(new_command, rule.side_effect, settings):\n        if rule.side_effect:\n            rule.side_effect(command, settings)\n        shells.put_to_history(new_command)\n        print(new_command)\n\n\ndef alias():\n    print(shells.app_alias())\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', 'from collections import namedtuple\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\n\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\', \'side_effect\'))\n\n\nclass RulesNamesList(list):\n    """"""Wrapper a top of list for storing rules names.""""""\n\n    def __contains__(self, item):\n        return super(RulesNamesList, self).__contains__(item.name)\n\n\nclass Settings(dict):\n\n    def __getattr__(self, item):\n        return self.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = dict(self)\n        conf.update(kwargs)\n        return Settings(conf)\n']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_add` &ndash; fix *""Did you forget to \'git add\'?""*;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `composer_not_command` &ndash; fixes composer command name.\n\nBundled, but not enabled by default:\n\n* `ls_lah` &ndash; adds -lah to ls;\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n    \n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call(\'chmod 777 .\', shell=True)\n    \npriority = 1000  # Lower first\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\nExample of `settings.py`:\n\n```python\nrules = [\'sudo\', \'no_command\']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES=\'sudo:no_command\'\nexport THEFUCK_REQUIRE_CONFIRMATION=\'true\'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS=\'false\'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""import pytest\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import Mock\nfrom thefuck import main, conf, types\nfrom tests.utils import Rule, Command\n\n\ndef test_load_rule(monkeypatch):\n    match = object()\n    get_new_command = object()\n    load_source = Mock()\n    load_source.return_value = Mock(match=match,\n                                    get_new_command=get_new_command,\n                                    enabled_by_default=True,\n                                    priority=900)\n    monkeypatch.setattr('thefuck.main.load_source', load_source)\n    assert main.load_rule(Path('/rules/bash.py')) \\\n           == Rule('bash', match, get_new_command, priority=900)\n    load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\nclass TestGetRules(object):\n    @pytest.fixture(autouse=True)\n    def glob(self, monkeypatch):\n        mock = Mock(return_value=[])\n        monkeypatch.setattr('thefuck.main.Path.glob', mock)\n        return mock\n\n    def _compare_names(self, rules, names):\n        return [r.name for r in rules] == names\n\n    @pytest.mark.parametrize('conf_rules, rules', [\n        (conf.DEFAULT_RULES, ['bash', 'lisp', 'bash', 'lisp']),\n        (types.RulesNamesList(['bash']), ['bash', 'bash'])])\n    def test_get(self, monkeypatch, glob, conf_rules, rules):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        monkeypatch.setattr('thefuck.main.load_source',\n                            lambda x, _: Rule(x))\n        assert self._compare_names(\n            main.get_rules(Path('~'), Mock(rules=conf_rules)), rules)\n\n    @pytest.mark.parametrize('unordered, ordered', [\n        ([Rule('bash', priority=100), Rule('python', priority=5)],\n         ['python', 'bash']),\n        ([Rule('lisp', priority=9999), Rule('c', priority=conf.DEFAULT_PRIORITY)],\n         ['c', 'lisp'])])\n    def test_ordered_by_priority(self, monkeypatch, unordered, ordered):\n        monkeypatch.setattr('thefuck.main._get_loaded_rules',\n                            lambda *_: unordered)\n        assert self._compare_names(main.get_rules(Path('~'), Mock()), ordered)\n\n\nclass TestGetCommand(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, monkeypatch):\n        Popen = Mock()\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        monkeypatch.setattr('thefuck.main.Popen', Popen)\n        return Popen\n\n    @pytest.fixture(autouse=True)\n    def prepare(self, monkeypatch):\n        monkeypatch.setattr('thefuck.main.os.environ', {})\n        monkeypatch.setattr('thefuck.main.wait_output', lambda *_: True)\n\n    @pytest.fixture(autouse=True)\n    def generic_shell(self, monkeypatch):\n        monkeypatch.setattr('thefuck.shells.from_shell', lambda x: x)\n        monkeypatch.setattr('thefuck.shells.to_shell', lambda x: x)\n\n    def test_get_command_calls(self, Popen):\n        assert main.get_command(Mock(),\n            ['thefuck', 'apt-get', 'search', 'vim']) \\\n               == Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n    @pytest.mark.parametrize('args, result', [\n        (['thefuck', 'ls', '-la'], 'ls -la'),\n        (['thefuck', 'ls'], 'ls')])\n    def test_get_command_script(self, args, result):\n        if result:\n            assert main.get_command(Mock(), args).script == result\n        else:\n            assert main.get_command(Mock(), args) is None\n\n\nclass TestGetMatchedRule(object):\n    def test_no_match(self):\n        assert main.get_matched_rule(\n            Command('ls'), [Rule('', lambda *_: False)],\n            Mock(no_colors=True)) is None\n\n    def test_match(self):\n        rule = Rule('', lambda x, _: x.script == 'cd ..')\n        assert main.get_matched_rule(\n            Command('cd ..'), [rule], Mock(no_colors=True)) == rule\n\n    def test_when_rule_failed(self, capsys):\n        main.get_matched_rule(\n            Command('ls'), [Rule('test', Mock(side_effect=OSError('Denied')))],\n            Mock(no_colors=True))\n        assert capsys.readouterr()[1].split('\\n')[0] == '[WARN] Rule test:'\n\n\nclass TestRunRule(object):\n    @pytest.fixture(autouse=True)\n    def confirm(self, monkeypatch):\n        mock = Mock(return_value=True)\n        monkeypatch.setattr('thefuck.main.confirm', mock)\n        return mock\n\n    def test_run_rule(self, capsys):\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n\n    def test_run_rule_with_side_effect(self, capsys):\n        side_effect = Mock()\n        settings = Mock()\n        command = Command()\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command',\n                           side_effect=side_effect),\n                      command, settings)\n        assert capsys.readouterr() == ('new-command\\n', '')\n        side_effect.assert_called_once_with(command, settings)\n\n    def test_when_not_comfirmed(self, capsys, confirm):\n        confirm.return_value = False\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), None)\n        assert capsys.readouterr() == ('', '')\n\n\nclass TestConfirm(object):\n    @pytest.fixture\n    def stdin(self, monkeypatch):\n        mock = Mock(return_value='\\n')\n        monkeypatch.setattr('sys.stdin.read', mock)\n        return mock\n\n    def test_when_not_required(self, capsys):\n        assert main.confirm('command', None, Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command\\n')\n\n    def test_with_side_effect_and_without_confirmation(self, capsys):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command*\\n')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed(self, capsys, stdin):\n        assert main.confirm('command', None, Mock(require_confirmation=True,\n                                                  no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed_with_side_effect(self, capsys, stdin):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=True,\n                                                    no_colors=True))\n        assert capsys.readouterr() == ('', 'command* [enter/ctrl+c]')\n\n    def test_when_confirmation_required_and_aborted(self, capsys, stdin):\n        stdin.side_effect = KeyboardInterrupt\n        assert not main.confirm('command', None, Mock(require_confirmation=True,\n                                                      no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", ""from thefuck import types\nfrom thefuck.conf import DEFAULT_PRIORITY\n\n\ndef Command(script='', stdout='', stderr=''):\n    return types.Command(script, stdout, stderr)\n\n\ndef Rule(name='', match=lambda *_: True,\n         get_new_command=lambda *_: '',\n         enabled_by_default=True,\n         side_effect=None,\n         priority=DEFAULT_PRIORITY):\n    return types.Rule(name, match, get_new_command,\n                      enabled_by_default, side_effect,\n                      priority)\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs, types\n\n\nclass _DefaultRulesNames(types.RulesNamesList):\n    def __add__(self, items):\n        return _DefaultRulesNames(list(self) + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRulesNames, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRulesNames):\n            return super(_DefaultRulesNames, self).__eq__(other)\n        else:\n            return False\n\n\nDEFAULT_RULES = _DefaultRulesNames([])\nDEFAULT_PRIORITY = 1000\n\n\nDEFAULT_SETTINGS = {\'rules\': DEFAULT_RULES,\n                    \'wait_command\': 3,\n                    \'require_confirmation\': False,\n                    \'no_colors\': False}\n\nENV_TO_ATTR = {\'THEFUCK_RULES\': \'rules\',\n               \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n               \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n               \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n\nSETTINGS_HEADER = u""""""# ~/.thefuck/settings.py: The Fuck settings file\n#\n# The rules are defined as in the example bellow:\n#\n# rules = [\'cd_parent\', \'git_push\', \'python_command\', \'sudo\']\n#\n# The default values are as follows. Uncomment and change to fit your needs.\n# See https://github.com/nvbn/thefuck#settings for more information.\n#\n\n""""""\n\n\ndef _settings_from_file(user_dir):\n    """"""Loads settings from file.""""""\n    settings = load_source(\'settings\',\n                           text_type(user_dir.joinpath(\'settings.py\')))\n    return {key: getattr(settings, key)\n            for key in DEFAULT_SETTINGS.keys()\n            if hasattr(settings, key)}\n\n\ndef _rules_from_env(val):\n    """"""Transforms rules list from env-string to python.""""""\n    val = val.split(\':\')\n    if \'DEFAULT_RULES\' in val:\n        val = DEFAULT_RULES + [rule for rule in val if rule != \'DEFAULT_RULES\']\n    return val\n\n\ndef _val_from_env(env, attr):\n    """"""Transforms env-strings to python.""""""\n    val = os.environ[env]\n    if attr == \'rules\':\n        val = _rules_from_env(val)\n    elif attr == \'wait_command\':\n        val = int(val)\n    elif attr in (\'require_confirmation\', \'no_colors\'):\n        val = val.lower() == \'true\'\n    return val\n\n\ndef _settings_from_env():\n    """"""Loads settings from env.""""""\n    return {attr: _val_from_env(env, attr)\n            for env, attr in ENV_TO_ATTR.items()\n            if env in os.environ}\n\n\ndef get_settings(user_dir):\n    """"""Returns settings filled with values from `settings.py` and env.""""""\n    conf = copy(DEFAULT_SETTINGS)\n    try:\n        conf.update(_settings_from_file(user_dir))\n    except Exception:\n        logs.exception(""Can\'t load settings from file"",\n                       sys.exc_info(),\n                       types.Settings(conf))\n\n    try:\n        conf.update(_settings_from_env())\n    except Exception:\n        logs.exception(""Can\'t load settings from env"",\n                       sys.exc_info(),\n                       types.Settings(conf))\n\n    if not isinstance(conf[\'rules\'], types.RulesNamesList):\n        conf[\'rules\'] = types.RulesNamesList(conf[\'rules\'])\n\n    return types.Settings(conf)\n\n\ndef initialize_settings_file(user_dir):\n    settings_path = user_dir.joinpath(\'settings.py\')\n    if not settings_path.is_file():\n        with settings_path.open(mode=\'w\') as settings_file:\n            settings_file.write(SETTINGS_HEADER)\n            for setting in DEFAULT_SETTINGS.items():\n                settings_file.write(u\'# {} = {}\\n\'.format(*setting))\n', 'from imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nimport six\nfrom . import logs, conf, types, shells\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    conf.initialize_settings_file(user_dir)\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return types.Rule(rule.name[:-3], rule_module.match,\n                      rule_module.get_new_command,\n                      getattr(rule_module, \'enabled_by_default\', True),\n                      getattr(rule_module, \'side_effect\', None),\n                      getattr(rule_module, \'priority\', conf.DEFAULT_PRIORITY))\n\n\ndef _get_loaded_rules(rules, settings):\n    """"""Yields all available rules.""""""\n    for rule in rules:\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent \\\n        .joinpath(\'rules\') \\\n        .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    rules = _get_loaded_rules(sorted(bundled) + sorted(user), settings)\n    return sorted(rules, key=lambda rule: rule.priority)\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if six.PY2:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    script = shells.from_shell(script)\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return types.Command(script, result.stdout.read().decode(\'utf-8\'),\n                             result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, side_effect, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, side_effect, settings)\n        return True\n\n    logs.confirm_command(new_command, side_effect, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = shells.to_shell(rule.get_new_command(command, settings))\n    if confirm(new_command, rule.side_effect, settings):\n        if rule.side_effect:\n            rule.side_effect(command, settings)\n        shells.put_to_history(new_command)\n        print(new_command)\n\n\ndef alias():\n    print(shells.app_alias())\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n', 'from collections import namedtuple\n\n\nCommand = namedtuple(\'Command\', (\'script\', \'stdout\', \'stderr\'))\n\nRule = namedtuple(\'Rule\', (\'name\', \'match\', \'get_new_command\',\n                           \'enabled_by_default\', \'side_effect\',\n                           \'priority\'))\n\n\nclass RulesNamesList(list):\n    """"""Wrapper a top of list for storing rules names.""""""\n\n    def __contains__(self, item):\n        return super(RulesNamesList, self).__contains__(item.name)\n\n\nclass Settings(dict):\n\n    def __getattr__(self, item):\n        return self.get(item)\n\n    def update(self, **kwargs):\n        """"""Returns new settings with new values from `kwargs`.""""""\n        conf = dict(self)\n        conf.update(kwargs)\n        return Settings(conf)\n']","[[], [<pydriller.domain.commit.Method object at 0x7f1982907580>, <pydriller.domain.commit.Method object at 0x7f1982907520>, <pydriller.domain.commit.Method object at 0x7f19829075b0>, <pydriller.domain.commit.Method object at 0x7f19829075e0>, <pydriller.domain.commit.Method object at 0x7f19829079d0>, <pydriller.domain.commit.Method object at 0x7f1982907a00>, <pydriller.domain.commit.Method object at 0x7f1982907a30>, <pydriller.domain.commit.Method object at 0x7f1983f71100>, <pydriller.domain.commit.Method object at 0x7f1983fc9a30>, <pydriller.domain.commit.Method object at 0x7f1983fc9dc0>, <pydriller.domain.commit.Method object at 0x7f1983fc9d60>, <pydriller.domain.commit.Method object at 0x7f1983fc9400>, <pydriller.domain.commit.Method object at 0x7f1983fc9eb0>, <pydriller.domain.commit.Method object at 0x7f1983fc9d30>, <pydriller.domain.commit.Method object at 0x7f1983ea83d0>, <pydriller.domain.commit.Method object at 0x7f1983ea8910>, <pydriller.domain.commit.Method object at 0x7f1983ea8f70>, <pydriller.domain.commit.Method object at 0x7f1983ea8250>, <pydriller.domain.commit.Method object at 0x7f1983f5a280>, <pydriller.domain.commit.Method object at 0x7f1983f5ae50>], [<pydriller.domain.commit.Method object at 0x7f1983f6bb80>, <pydriller.domain.commit.Method object at 0x7f1983f6bbb0>], [<pydriller.domain.commit.Method object at 0x7f198507f9a0>, <pydriller.domain.commit.Method object at 0x7f198507f940>, <pydriller.domain.commit.Method object at 0x7f198507f220>, <pydriller.domain.commit.Method object at 0x7f198507f7f0>, <pydriller.domain.commit.Method object at 0x7f1982905ee0>, <pydriller.domain.commit.Method object at 0x7f1982905d90>, <pydriller.domain.commit.Method object at 0x7f1982905eb0>, <pydriller.domain.commit.Method object at 0x7f1982905a30>, <pydriller.domain.commit.Method object at 0x7f1982905e50>], [<pydriller.domain.commit.Method object at 0x7f1983d626a0>, <pydriller.domain.commit.Method object at 0x7f1983d90970>, <pydriller.domain.commit.Method object at 0x7f1983f60130>, <pydriller.domain.commit.Method object at 0x7f1982907040>, <pydriller.domain.commit.Method object at 0x7f19829077c0>, <pydriller.domain.commit.Method object at 0x7f19829077f0>, <pydriller.domain.commit.Method object at 0x7f1982907820>, <pydriller.domain.commit.Method object at 0x7f1982907850>, <pydriller.domain.commit.Method object at 0x7f1982907880>, <pydriller.domain.commit.Method object at 0x7f19829078b0>], [<pydriller.domain.commit.Method object at 0x7f1982907d60>, <pydriller.domain.commit.Method object at 0x7f1982907d00>, <pydriller.domain.commit.Method object at 0x7f1982907d90>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983f6be20>, <pydriller.domain.commit.Method object at 0x7f1983f6b130>, <pydriller.domain.commit.Method object at 0x7f1983fc9f40>, <pydriller.domain.commit.Method object at 0x7f1983f4e6a0>, <pydriller.domain.commit.Method object at 0x7f1983f4e610>, <pydriller.domain.commit.Method object at 0x7f1982907520>], [<pydriller.domain.commit.Method object at 0x7f1983f6bbb0>, <pydriller.domain.commit.Method object at 0x7f1983f64a60>], [], [<pydriller.domain.commit.Method object at 0x7f1982905be0>, <pydriller.domain.commit.Method object at 0x7f19829054c0>, <pydriller.domain.commit.Method object at 0x7f1982905a60>], []]"
thefuck,5bf14246138d03c7c044e7a5720964223597cad3,#164 Decrease priority of `no_command`,2015-05-07 12:57:43+02:00,nvbn,3,0,3,1,['no_command.py'],"[""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\nfrom thefuck.utils import sudo_support\n\n\ndef _safe(fn, fallback):\n    try:\n        return fn()\n    except OSError:\n        return fallback\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ.get('PATH', '').split(':')\n            for exe in _safe(lambda: list(Path(path).iterdir()), [])\n            if not _safe(exe.is_dir, True)]\n\n\n@sudo_support\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n""]","[""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\nfrom thefuck.utils import sudo_support\n\n\ndef _safe(fn, fallback):\n    try:\n        return fn()\n    except OSError:\n        return fallback\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ.get('PATH', '').split(':')\n            for exe in _safe(lambda: list(Path(path).iterdir()), [])\n            if not _safe(exe.is_dir, True)]\n\n\n@sudo_support\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n\n\npriority = 3000\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983fc9e50>, <pydriller.domain.commit.Method object at 0x7f1983fc9b50>, <pydriller.domain.commit.Method object at 0x7f1983fc9910>, <pydriller.domain.commit.Method object at 0x7f1983fc9c40>]]",[[]]
thefuck,05f594b918d2bf6b718754218af652286da35ebb,#154 Add ability to override priority in settings,2015-05-07 13:11:45+02:00,nvbn,51,18,69,5,"['README.md', 'test_conf.py', 'test_main.py', 'conf.py', 'main.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_add` &ndash; fix *""Did you forget to \'git add\'?""*;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `composer_not_command` &ndash; fixes composer command name.\n\nBundled, but not enabled by default:\n\n* `ls_lah` &ndash; adds -lah to ls;\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n    \n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call(\'chmod 777 .\', shell=True)\n    \npriority = 1000  # Lower first\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output.\n\nExample of `settings.py`:\n\n```python\nrules = [\'sudo\', \'no_command\']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES=\'sudo:no_command\'\nexport THEFUCK_REQUIRE_CONFIRMATION=\'true\'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS=\'false\'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""import pytest\nimport six\nfrom mock import Mock\nfrom thefuck import conf\nfrom tests.utils import Rule\n\n\n@pytest.mark.parametrize('enabled, rules, result', [\n    (True, conf.DEFAULT_RULES, True),\n    (False, conf.DEFAULT_RULES, False),\n    (False, conf.DEFAULT_RULES + ['test'], True)])\ndef test_default(enabled, rules, result):\n    assert (Rule('test', enabled_by_default=enabled) in rules) == result\n\n\n@pytest.fixture\ndef load_source(monkeypatch):\n    mock = Mock()\n    monkeypatch.setattr('thefuck.conf.load_source', mock)\n    return mock\n\n\n@pytest.fixture\ndef environ(monkeypatch):\n    data = {}\n    monkeypatch.setattr('thefuck.conf.os.environ', data)\n    return data\n\n\n@pytest.mark.usefixture('environ')\ndef test_settings_defaults(load_source):\n    load_source.return_value = object()\n    for key, val in conf.DEFAULT_SETTINGS.items():\n        assert getattr(conf.get_settings(Mock()), key) == val\n\n\n@pytest.mark.usefixture('environ')\nclass TestSettingsFromFile(object):\n    def test_from_file(self, load_source):\n        load_source.return_value = Mock(rules=['test'],\n                                        wait_command=10,\n                                        require_confirmation=True,\n                                        no_colors=True)\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n\n    def test_from_file_with_DEFAULT(self, load_source):\n        load_source.return_value = Mock(rules=conf.DEFAULT_RULES + ['test'],\n                                        wait_command=10,\n                                        require_confirmation=True,\n                                        no_colors=True)\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['test']\n\n\n@pytest.mark.usefixture('load_source')\nclass TestSettingsFromEnv(object):\n    def test_from_env(self, environ):\n        environ.update({'THEFUCK_RULES': 'bash:lisp',\n                        'THEFUCK_WAIT_COMMAND': '55',\n                        'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                        'THEFUCK_NO_COLORS': 'false'})\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n\n    def test_from_env_with_DEFAULT(self, environ):\n        environ.update({'THEFUCK_RULES': 'DEFAULT_RULES:bash:lisp'})\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['bash', 'lisp']\n\n\nclass TestInitializeSettingsFile(object):\n    def test_ignore_if_exists(self):\n        settings_path_mock = Mock(is_file=Mock(return_value=True), open=Mock())\n        user_dir_mock = Mock(joinpath=Mock(return_value=settings_path_mock))\n        conf.initialize_settings_file(user_dir_mock)\n        assert settings_path_mock.is_file.call_count == 1\n        assert not settings_path_mock.open.called\n\n    def test_create_if_doesnt_exists(self):\n        settings_file = six.StringIO()\n        settings_path_mock = Mock(\n            is_file=Mock(return_value=False),\n            open=Mock(return_value=Mock(\n                __exit__=lambda *args: None, __enter__=lambda *args: settings_file)))\n        user_dir_mock = Mock(joinpath=Mock(return_value=settings_path_mock))\n        conf.initialize_settings_file(user_dir_mock)\n        settings_file_contents = settings_file.getvalue()\n        assert settings_path_mock.is_file.call_count == 1\n        assert settings_path_mock.open.call_count == 1\n        assert conf.SETTINGS_HEADER in settings_file_contents\n        for setting in conf.DEFAULT_SETTINGS.items():\n            assert '# {} = {}\\n'.format(*setting) in settings_file_contents\n        settings_file.close()\n"", ""import pytest\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import Mock\nfrom thefuck import main, conf, types\nfrom tests.utils import Rule, Command\n\n\ndef test_load_rule(monkeypatch):\n    match = object()\n    get_new_command = object()\n    load_source = Mock()\n    load_source.return_value = Mock(match=match,\n                                    get_new_command=get_new_command,\n                                    enabled_by_default=True,\n                                    priority=900)\n    monkeypatch.setattr('thefuck.main.load_source', load_source)\n    assert main.load_rule(Path('/rules/bash.py')) \\\n           == Rule('bash', match, get_new_command, priority=900)\n    load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\nclass TestGetRules(object):\n    @pytest.fixture(autouse=True)\n    def glob(self, monkeypatch):\n        mock = Mock(return_value=[])\n        monkeypatch.setattr('thefuck.main.Path.glob', mock)\n        return mock\n\n    def _compare_names(self, rules, names):\n        return [r.name for r in rules] == names\n\n    @pytest.mark.parametrize('conf_rules, rules', [\n        (conf.DEFAULT_RULES, ['bash', 'lisp', 'bash', 'lisp']),\n        (types.RulesNamesList(['bash']), ['bash', 'bash'])])\n    def test_get(self, monkeypatch, glob, conf_rules, rules):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        monkeypatch.setattr('thefuck.main.load_source',\n                            lambda x, _: Rule(x))\n        assert self._compare_names(\n            main.get_rules(Path('~'), Mock(rules=conf_rules)), rules)\n\n    @pytest.mark.parametrize('unordered, ordered', [\n        ([Rule('bash', priority=100), Rule('python', priority=5)],\n         ['python', 'bash']),\n        ([Rule('lisp', priority=9999), Rule('c', priority=conf.DEFAULT_PRIORITY)],\n         ['c', 'lisp'])])\n    def test_ordered_by_priority(self, monkeypatch, unordered, ordered):\n        monkeypatch.setattr('thefuck.main._get_loaded_rules',\n                            lambda *_: unordered)\n        assert self._compare_names(main.get_rules(Path('~'), Mock()), ordered)\n\n\nclass TestGetCommand(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, monkeypatch):\n        Popen = Mock()\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        monkeypatch.setattr('thefuck.main.Popen', Popen)\n        return Popen\n\n    @pytest.fixture(autouse=True)\n    def prepare(self, monkeypatch):\n        monkeypatch.setattr('thefuck.main.os.environ', {})\n        monkeypatch.setattr('thefuck.main.wait_output', lambda *_: True)\n\n    @pytest.fixture(autouse=True)\n    def generic_shell(self, monkeypatch):\n        monkeypatch.setattr('thefuck.shells.from_shell', lambda x: x)\n        monkeypatch.setattr('thefuck.shells.to_shell', lambda x: x)\n\n    def test_get_command_calls(self, Popen):\n        assert main.get_command(Mock(),\n            ['thefuck', 'apt-get', 'search', 'vim']) \\\n               == Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n    @pytest.mark.parametrize('args, result', [\n        (['thefuck', 'ls', '-la'], 'ls -la'),\n        (['thefuck', 'ls'], 'ls')])\n    def test_get_command_script(self, args, result):\n        if result:\n            assert main.get_command(Mock(), args).script == result\n        else:\n            assert main.get_command(Mock(), args) is None\n\n\nclass TestGetMatchedRule(object):\n    def test_no_match(self):\n        assert main.get_matched_rule(\n            Command('ls'), [Rule('', lambda *_: False)],\n            Mock(no_colors=True)) is None\n\n    def test_match(self):\n        rule = Rule('', lambda x, _: x.script == 'cd ..')\n        assert main.get_matched_rule(\n            Command('cd ..'), [rule], Mock(no_colors=True)) == rule\n\n    def test_when_rule_failed(self, capsys):\n        main.get_matched_rule(\n            Command('ls'), [Rule('test', Mock(side_effect=OSError('Denied')))],\n            Mock(no_colors=True))\n        assert capsys.readouterr()[1].split('\\n')[0] == '[WARN] Rule test:'\n\n\nclass TestRunRule(object):\n    @pytest.fixture(autouse=True)\n    def confirm(self, monkeypatch):\n        mock = Mock(return_value=True)\n        monkeypatch.setattr('thefuck.main.confirm', mock)\n        return mock\n\n    def test_run_rule(self, capsys):\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n\n    def test_run_rule_with_side_effect(self, capsys):\n        side_effect = Mock()\n        settings = Mock()\n        command = Command()\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command',\n                           side_effect=side_effect),\n                      command, settings)\n        assert capsys.readouterr() == ('new-command\\n', '')\n        side_effect.assert_called_once_with(command, settings)\n\n    def test_when_not_comfirmed(self, capsys, confirm):\n        confirm.return_value = False\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), None)\n        assert capsys.readouterr() == ('', '')\n\n\nclass TestConfirm(object):\n    @pytest.fixture\n    def stdin(self, monkeypatch):\n        mock = Mock(return_value='\\n')\n        monkeypatch.setattr('sys.stdin.read', mock)\n        return mock\n\n    def test_when_not_required(self, capsys):\n        assert main.confirm('command', None, Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command\\n')\n\n    def test_with_side_effect_and_without_confirmation(self, capsys):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command*\\n')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed(self, capsys, stdin):\n        assert main.confirm('command', None, Mock(require_confirmation=True,\n                                                  no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed_with_side_effect(self, capsys, stdin):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=True,\n                                                    no_colors=True))\n        assert capsys.readouterr() == ('', 'command* [enter/ctrl+c]')\n\n    def test_when_confirmation_required_and_aborted(self, capsys, stdin):\n        stdin.side_effect = KeyboardInterrupt\n        assert not main.confirm('command', None, Mock(require_confirmation=True,\n                                                      no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs, types\n\n\nclass _DefaultRulesNames(types.RulesNamesList):\n    def __add__(self, items):\n        return _DefaultRulesNames(list(self) + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRulesNames, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRulesNames):\n            return super(_DefaultRulesNames, self).__eq__(other)\n        else:\n            return False\n\n\nDEFAULT_RULES = _DefaultRulesNames([])\nDEFAULT_PRIORITY = 1000\n\n\nDEFAULT_SETTINGS = {\'rules\': DEFAULT_RULES,\n                    \'wait_command\': 3,\n                    \'require_confirmation\': False,\n                    \'no_colors\': False}\n\nENV_TO_ATTR = {\'THEFUCK_RULES\': \'rules\',\n               \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n               \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n               \'THEFUCK_NO_COLORS\': \'no_colors\'}\n\n\nSETTINGS_HEADER = u""""""# ~/.thefuck/settings.py: The Fuck settings file\n#\n# The rules are defined as in the example bellow:\n#\n# rules = [\'cd_parent\', \'git_push\', \'python_command\', \'sudo\']\n#\n# The default values are as follows. Uncomment and change to fit your needs.\n# See https://github.com/nvbn/thefuck#settings for more information.\n#\n\n""""""\n\n\ndef _settings_from_file(user_dir):\n    """"""Loads settings from file.""""""\n    settings = load_source(\'settings\',\n                           text_type(user_dir.joinpath(\'settings.py\')))\n    return {key: getattr(settings, key)\n            for key in DEFAULT_SETTINGS.keys()\n            if hasattr(settings, key)}\n\n\ndef _rules_from_env(val):\n    """"""Transforms rules list from env-string to python.""""""\n    val = val.split(\':\')\n    if \'DEFAULT_RULES\' in val:\n        val = DEFAULT_RULES + [rule for rule in val if rule != \'DEFAULT_RULES\']\n    return val\n\n\ndef _val_from_env(env, attr):\n    """"""Transforms env-strings to python.""""""\n    val = os.environ[env]\n    if attr == \'rules\':\n        val = _rules_from_env(val)\n    elif attr == \'wait_command\':\n        val = int(val)\n    elif attr in (\'require_confirmation\', \'no_colors\'):\n        val = val.lower() == \'true\'\n    return val\n\n\ndef _settings_from_env():\n    """"""Loads settings from env.""""""\n    return {attr: _val_from_env(env, attr)\n            for env, attr in ENV_TO_ATTR.items()\n            if env in os.environ}\n\n\ndef get_settings(user_dir):\n    """"""Returns settings filled with values from `settings.py` and env.""""""\n    conf = copy(DEFAULT_SETTINGS)\n    try:\n        conf.update(_settings_from_file(user_dir))\n    except Exception:\n        logs.exception(""Can\'t load settings from file"",\n                       sys.exc_info(),\n                       types.Settings(conf))\n\n    try:\n        conf.update(_settings_from_env())\n    except Exception:\n        logs.exception(""Can\'t load settings from env"",\n                       sys.exc_info(),\n                       types.Settings(conf))\n\n    if not isinstance(conf[\'rules\'], types.RulesNamesList):\n        conf[\'rules\'] = types.RulesNamesList(conf[\'rules\'])\n\n    return types.Settings(conf)\n\n\ndef initialize_settings_file(user_dir):\n    settings_path = user_dir.joinpath(\'settings.py\')\n    if not settings_path.is_file():\n        with settings_path.open(mode=\'w\') as settings_file:\n            settings_file.write(SETTINGS_HEADER)\n            for setting in DEFAULT_SETTINGS.items():\n                settings_file.write(u\'# {} = {}\\n\'.format(*setting))\n', 'from imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nimport six\nfrom . import logs, conf, types, shells\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    conf.initialize_settings_file(user_dir)\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return types.Rule(rule.name[:-3], rule_module.match,\n                      rule_module.get_new_command,\n                      getattr(rule_module, \'enabled_by_default\', True),\n                      getattr(rule_module, \'side_effect\', None),\n                      getattr(rule_module, \'priority\', conf.DEFAULT_PRIORITY))\n\n\ndef _get_loaded_rules(rules, settings):\n    """"""Yields all available rules.""""""\n    for rule in rules:\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent \\\n        .joinpath(\'rules\') \\\n        .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    rules = _get_loaded_rules(sorted(bundled) + sorted(user), settings)\n    return sorted(rules, key=lambda rule: rule.priority)\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if six.PY2:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    script = shells.from_shell(script)\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return types.Command(script, result.stdout.read().decode(\'utf-8\'),\n                             result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, side_effect, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, side_effect, settings)\n        return True\n\n    logs.confirm_command(new_command, side_effect, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = shells.to_shell(rule.get_new_command(command, settings))\n    if confirm(new_command, rule.side_effect, settings):\n        if rule.side_effect:\n            rule.side_effect(command, settings)\n        shells.put_to_history(new_command)\n        print(new_command)\n\n\ndef alias():\n    print(shells.app_alias())\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_add` &ndash; fix *""Did you forget to \'git add\'?""*;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `composer_not_command` &ndash; fixes composer command name.\n\nBundled, but not enabled by default:\n\n* `ls_lah` &ndash; adds -lah to ls;\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n    \n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call(\'chmod 777 .\', shell=True)\n    \npriority = 1000  # Lower first\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output;\n* `priority` &ndash; dict with rules priorities, rule with lower `priority` will be matched first.\n\nExample of `settings.py`:\n\n```python\nrules = [\'sudo\', \'no_command\']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\npriority = {\'sudo\': 100, \'no_command\': 9999}\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`;\n* `THEFUCK_PRIORITY` &ndash; priority of the rules, like `no_command=9999:apt_get=100`,\nrule with lower `priority` will be matched first.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES=\'sudo:no_command\'\nexport THEFUCK_REQUIRE_CONFIRMATION=\'true\'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS=\'false\'\nexport THEFUCK_PRIORITY=\'no_command=9999:apt_get=100\'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""import pytest\nimport six\nfrom mock import Mock\nfrom thefuck import conf\nfrom tests.utils import Rule\n\n\n@pytest.mark.parametrize('enabled, rules, result', [\n    (True, conf.DEFAULT_RULES, True),\n    (False, conf.DEFAULT_RULES, False),\n    (False, conf.DEFAULT_RULES + ['test'], True)])\ndef test_default(enabled, rules, result):\n    assert (Rule('test', enabled_by_default=enabled) in rules) == result\n\n\n@pytest.fixture\ndef load_source(monkeypatch):\n    mock = Mock()\n    monkeypatch.setattr('thefuck.conf.load_source', mock)\n    return mock\n\n\n@pytest.fixture\ndef environ(monkeypatch):\n    data = {}\n    monkeypatch.setattr('thefuck.conf.os.environ', data)\n    return data\n\n\n@pytest.mark.usefixture('environ')\ndef test_settings_defaults(load_source):\n    load_source.return_value = object()\n    for key, val in conf.DEFAULT_SETTINGS.items():\n        assert getattr(conf.get_settings(Mock()), key) == val\n\n\n@pytest.mark.usefixture('environ')\nclass TestSettingsFromFile(object):\n    def test_from_file(self, load_source):\n        load_source.return_value = Mock(rules=['test'],\n                                        wait_command=10,\n                                        require_confirmation=True,\n                                        no_colors=True,\n                                        priority={'vim': 100})\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n        assert settings.priority == {'vim': 100}\n\n    def test_from_file_with_DEFAULT(self, load_source):\n        load_source.return_value = Mock(rules=conf.DEFAULT_RULES + ['test'],\n                                        wait_command=10,\n                                        require_confirmation=True,\n                                        no_colors=True)\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['test']\n\n\n@pytest.mark.usefixture('load_source')\nclass TestSettingsFromEnv(object):\n    def test_from_env(self, environ):\n        environ.update({'THEFUCK_RULES': 'bash:lisp',\n                        'THEFUCK_WAIT_COMMAND': '55',\n                        'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                        'THEFUCK_NO_COLORS': 'false',\n                        'THEFUCK_PRIORITY': 'bash=10:lisp=wrong:vim=15'})\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n        assert settings.priority == {'bash': 10, 'vim': 15}\n\n    def test_from_env_with_DEFAULT(self, environ):\n        environ.update({'THEFUCK_RULES': 'DEFAULT_RULES:bash:lisp'})\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['bash', 'lisp']\n\n\nclass TestInitializeSettingsFile(object):\n    def test_ignore_if_exists(self):\n        settings_path_mock = Mock(is_file=Mock(return_value=True), open=Mock())\n        user_dir_mock = Mock(joinpath=Mock(return_value=settings_path_mock))\n        conf.initialize_settings_file(user_dir_mock)\n        assert settings_path_mock.is_file.call_count == 1\n        assert not settings_path_mock.open.called\n\n    def test_create_if_doesnt_exists(self):\n        settings_file = six.StringIO()\n        settings_path_mock = Mock(\n            is_file=Mock(return_value=False),\n            open=Mock(return_value=Mock(\n                __exit__=lambda *args: None, __enter__=lambda *args: settings_file)))\n        user_dir_mock = Mock(joinpath=Mock(return_value=settings_path_mock))\n        conf.initialize_settings_file(user_dir_mock)\n        settings_file_contents = settings_file.getvalue()\n        assert settings_path_mock.is_file.call_count == 1\n        assert settings_path_mock.open.call_count == 1\n        assert conf.SETTINGS_HEADER in settings_file_contents\n        for setting in conf.DEFAULT_SETTINGS.items():\n            assert '# {} = {}\\n'.format(*setting) in settings_file_contents\n        settings_file.close()\n"", ""import pytest\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import Mock\nfrom thefuck import main, conf, types\nfrom tests.utils import Rule, Command\n\n\ndef test_load_rule(monkeypatch):\n    match = object()\n    get_new_command = object()\n    load_source = Mock()\n    load_source.return_value = Mock(match=match,\n                                    get_new_command=get_new_command,\n                                    enabled_by_default=True,\n                                    priority=900)\n    monkeypatch.setattr('thefuck.main.load_source', load_source)\n    assert main.load_rule(Path('/rules/bash.py')) \\\n           == Rule('bash', match, get_new_command, priority=900)\n    load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\nclass TestGetRules(object):\n    @pytest.fixture(autouse=True)\n    def glob(self, monkeypatch):\n        mock = Mock(return_value=[])\n        monkeypatch.setattr('thefuck.main.Path.glob', mock)\n        return mock\n\n    def _compare_names(self, rules, names):\n        return [r.name for r in rules] == names\n\n    @pytest.mark.parametrize('conf_rules, rules', [\n        (conf.DEFAULT_RULES, ['bash', 'lisp', 'bash', 'lisp']),\n        (types.RulesNamesList(['bash']), ['bash', 'bash'])])\n    def test_get(self, monkeypatch, glob, conf_rules, rules):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        monkeypatch.setattr('thefuck.main.load_source',\n                            lambda x, _: Rule(x))\n        assert self._compare_names(\n            main.get_rules(Path('~'), Mock(rules=conf_rules, priority={})),\n            rules)\n\n    @pytest.mark.parametrize('priority, unordered, ordered', [\n        ({},\n         [Rule('bash', priority=100), Rule('python', priority=5)],\n         ['python', 'bash']),\n        ({},\n         [Rule('lisp', priority=9999), Rule('c', priority=conf.DEFAULT_PRIORITY)],\n         ['c', 'lisp']),\n        ({'python': 9999},\n         [Rule('bash', priority=100), Rule('python', priority=5)],\n         ['bash', 'python'])])\n    def test_ordered_by_priority(self, monkeypatch, priority, unordered, ordered):\n        monkeypatch.setattr('thefuck.main._get_loaded_rules',\n                            lambda *_: unordered)\n        assert self._compare_names(\n            main.get_rules(Path('~'), Mock(priority=priority)),\n            ordered)\n\n\nclass TestGetCommand(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, monkeypatch):\n        Popen = Mock()\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        monkeypatch.setattr('thefuck.main.Popen', Popen)\n        return Popen\n\n    @pytest.fixture(autouse=True)\n    def prepare(self, monkeypatch):\n        monkeypatch.setattr('thefuck.main.os.environ', {})\n        monkeypatch.setattr('thefuck.main.wait_output', lambda *_: True)\n\n    @pytest.fixture(autouse=True)\n    def generic_shell(self, monkeypatch):\n        monkeypatch.setattr('thefuck.shells.from_shell', lambda x: x)\n        monkeypatch.setattr('thefuck.shells.to_shell', lambda x: x)\n\n    def test_get_command_calls(self, Popen):\n        assert main.get_command(Mock(),\n            ['thefuck', 'apt-get', 'search', 'vim']) \\\n               == Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n    @pytest.mark.parametrize('args, result', [\n        (['thefuck', 'ls', '-la'], 'ls -la'),\n        (['thefuck', 'ls'], 'ls')])\n    def test_get_command_script(self, args, result):\n        if result:\n            assert main.get_command(Mock(), args).script == result\n        else:\n            assert main.get_command(Mock(), args) is None\n\n\nclass TestGetMatchedRule(object):\n    def test_no_match(self):\n        assert main.get_matched_rule(\n            Command('ls'), [Rule('', lambda *_: False)],\n            Mock(no_colors=True)) is None\n\n    def test_match(self):\n        rule = Rule('', lambda x, _: x.script == 'cd ..')\n        assert main.get_matched_rule(\n            Command('cd ..'), [rule], Mock(no_colors=True)) == rule\n\n    def test_when_rule_failed(self, capsys):\n        main.get_matched_rule(\n            Command('ls'), [Rule('test', Mock(side_effect=OSError('Denied')))],\n            Mock(no_colors=True))\n        assert capsys.readouterr()[1].split('\\n')[0] == '[WARN] Rule test:'\n\n\nclass TestRunRule(object):\n    @pytest.fixture(autouse=True)\n    def confirm(self, monkeypatch):\n        mock = Mock(return_value=True)\n        monkeypatch.setattr('thefuck.main.confirm', mock)\n        return mock\n\n    def test_run_rule(self, capsys):\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n\n    def test_run_rule_with_side_effect(self, capsys):\n        side_effect = Mock()\n        settings = Mock()\n        command = Command()\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command',\n                           side_effect=side_effect),\n                      command, settings)\n        assert capsys.readouterr() == ('new-command\\n', '')\n        side_effect.assert_called_once_with(command, settings)\n\n    def test_when_not_comfirmed(self, capsys, confirm):\n        confirm.return_value = False\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), None)\n        assert capsys.readouterr() == ('', '')\n\n\nclass TestConfirm(object):\n    @pytest.fixture\n    def stdin(self, monkeypatch):\n        mock = Mock(return_value='\\n')\n        monkeypatch.setattr('sys.stdin.read', mock)\n        return mock\n\n    def test_when_not_required(self, capsys):\n        assert main.confirm('command', None, Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command\\n')\n\n    def test_with_side_effect_and_without_confirmation(self, capsys):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command*\\n')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed(self, capsys, stdin):\n        assert main.confirm('command', None, Mock(require_confirmation=True,\n                                                  no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed_with_side_effect(self, capsys, stdin):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=True,\n                                                    no_colors=True))\n        assert capsys.readouterr() == ('', 'command* [enter/ctrl+c]')\n\n    def test_when_confirmation_required_and_aborted(self, capsys, stdin):\n        stdin.side_effect = KeyboardInterrupt\n        assert not main.confirm('command', None, Mock(require_confirmation=True,\n                                                      no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", 'from copy import copy\nfrom imp import load_source\nimport os\nimport sys\nfrom six import text_type\nfrom . import logs, types\n\n\nclass _DefaultRulesNames(types.RulesNamesList):\n    def __add__(self, items):\n        return _DefaultRulesNames(list(self) + items)\n\n    def __contains__(self, item):\n        return item.enabled_by_default or \\\n               super(_DefaultRulesNames, self).__contains__(item)\n\n    def __eq__(self, other):\n        if isinstance(other, _DefaultRulesNames):\n            return super(_DefaultRulesNames, self).__eq__(other)\n        else:\n            return False\n\n\nDEFAULT_RULES = _DefaultRulesNames([])\nDEFAULT_PRIORITY = 1000\n\n\nDEFAULT_SETTINGS = {\'rules\': DEFAULT_RULES,\n                    \'wait_command\': 3,\n                    \'require_confirmation\': False,\n                    \'no_colors\': False,\n                    \'priority\': {}}\n\nENV_TO_ATTR = {\'THEFUCK_RULES\': \'rules\',\n               \'THEFUCK_WAIT_COMMAND\': \'wait_command\',\n               \'THEFUCK_REQUIRE_CONFIRMATION\': \'require_confirmation\',\n               \'THEFUCK_NO_COLORS\': \'no_colors\',\n               \'THEFUCK_PRIORITY\': \'priority\'}\n\n\nSETTINGS_HEADER = u""""""# ~/.thefuck/settings.py: The Fuck settings file\n#\n# The rules are defined as in the example bellow:\n#\n# rules = [\'cd_parent\', \'git_push\', \'python_command\', \'sudo\']\n#\n# The default values are as follows. Uncomment and change to fit your needs.\n# See https://github.com/nvbn/thefuck#settings for more information.\n#\n\n""""""\n\n\ndef _settings_from_file(user_dir):\n    """"""Loads settings from file.""""""\n    settings = load_source(\'settings\',\n                           text_type(user_dir.joinpath(\'settings.py\')))\n    return {key: getattr(settings, key)\n            for key in DEFAULT_SETTINGS.keys()\n            if hasattr(settings, key)}\n\n\ndef _rules_from_env(val):\n    """"""Transforms rules list from env-string to python.""""""\n    val = val.split(\':\')\n    if \'DEFAULT_RULES\' in val:\n        val = DEFAULT_RULES + [rule for rule in val if rule != \'DEFAULT_RULES\']\n    return val\n\n\ndef _priority_from_env(val):\n    """"""Gets priority pairs from env.""""""\n    for part in val.split(\':\'):\n        try:\n            rule, priority = part.split(\'=\')\n            yield rule, int(priority)\n        except ValueError:\n            continue\n\n\ndef _val_from_env(env, attr):\n    """"""Transforms env-strings to python.""""""\n    val = os.environ[env]\n    if attr == \'rules\':\n        return _rules_from_env(val)\n    elif attr == \'priority\':\n        return dict(_priority_from_env(val))\n    elif attr == \'wait_command\':\n        return int(val)\n    elif attr in (\'require_confirmation\', \'no_colors\'):\n        return val.lower() == \'true\'\n    else:\n        return val\n\n\ndef _settings_from_env():\n    """"""Loads settings from env.""""""\n    return {attr: _val_from_env(env, attr)\n            for env, attr in ENV_TO_ATTR.items()\n            if env in os.environ}\n\n\ndef get_settings(user_dir):\n    """"""Returns settings filled with values from `settings.py` and env.""""""\n    conf = copy(DEFAULT_SETTINGS)\n    try:\n        conf.update(_settings_from_file(user_dir))\n    except Exception:\n        logs.exception(""Can\'t load settings from file"",\n                       sys.exc_info(),\n                       types.Settings(conf))\n\n    try:\n        conf.update(_settings_from_env())\n    except Exception:\n        logs.exception(""Can\'t load settings from env"",\n                       sys.exc_info(),\n                       types.Settings(conf))\n\n    if not isinstance(conf[\'rules\'], types.RulesNamesList):\n        conf[\'rules\'] = types.RulesNamesList(conf[\'rules\'])\n\n    return types.Settings(conf)\n\n\ndef initialize_settings_file(user_dir):\n    settings_path = user_dir.joinpath(\'settings.py\')\n    if not settings_path.is_file():\n        with settings_path.open(mode=\'w\') as settings_file:\n            settings_file.write(SETTINGS_HEADER)\n            for setting in DEFAULT_SETTINGS.items():\n                settings_file.write(u\'# {} = {}\\n\'.format(*setting))\n', 'from imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nimport six\nfrom . import logs, conf, types, shells\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    conf.initialize_settings_file(user_dir)\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return types.Rule(rule.name[:-3], rule_module.match,\n                      rule_module.get_new_command,\n                      getattr(rule_module, \'enabled_by_default\', True),\n                      getattr(rule_module, \'side_effect\', None),\n                      getattr(rule_module, \'priority\', conf.DEFAULT_PRIORITY))\n\n\ndef _get_loaded_rules(rules, settings):\n    """"""Yields all available rules.""""""\n    for rule in rules:\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent \\\n        .joinpath(\'rules\') \\\n        .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    rules = _get_loaded_rules(sorted(bundled) + sorted(user), settings)\n    return sorted(rules, key=lambda rule: settings.priority.get(\n        rule.name, rule.priority))\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if six.PY2:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    script = shells.from_shell(script)\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return types.Command(script, result.stdout.read().decode(\'utf-8\'),\n                             result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, side_effect, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, side_effect, settings)\n        return True\n\n    logs.confirm_command(new_command, side_effect, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = shells.to_shell(rule.get_new_command(command, settings))\n    if confirm(new_command, rule.side_effect, settings):\n        if rule.side_effect:\n            rule.side_effect(command, settings)\n        shells.put_to_history(new_command)\n        print(new_command)\n\n\ndef alias():\n    print(shells.app_alias())\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n']","[[], [<pydriller.domain.commit.Method object at 0x7f1982907fd0>, <pydriller.domain.commit.Method object at 0x7f1982907ee0>, <pydriller.domain.commit.Method object at 0x7f1982907dc0>, <pydriller.domain.commit.Method object at 0x7f1982907a90>, <pydriller.domain.commit.Method object at 0x7f1982907d30>, <pydriller.domain.commit.Method object at 0x7f1982907eb0>, <pydriller.domain.commit.Method object at 0x7f1982907f40>, <pydriller.domain.commit.Method object at 0x7f1982907e80>, <pydriller.domain.commit.Method object at 0x7f1982907f70>, <pydriller.domain.commit.Method object at 0x7f1982907220>], [<pydriller.domain.commit.Method object at 0x7f1983f4e550>, <pydriller.domain.commit.Method object at 0x7f1983f4e5b0>, <pydriller.domain.commit.Method object at 0x7f1983f4e4c0>, <pydriller.domain.commit.Method object at 0x7f1983f4e070>, <pydriller.domain.commit.Method object at 0x7f198507f250>, <pydriller.domain.commit.Method object at 0x7f198507fb80>, <pydriller.domain.commit.Method object at 0x7f198507f6a0>, <pydriller.domain.commit.Method object at 0x7f198507f5e0>, <pydriller.domain.commit.Method object at 0x7f198507f400>, <pydriller.domain.commit.Method object at 0x7f198507fe80>, <pydriller.domain.commit.Method object at 0x7f198507f970>, <pydriller.domain.commit.Method object at 0x7f198507fb50>, <pydriller.domain.commit.Method object at 0x7f198507f610>, <pydriller.domain.commit.Method object at 0x7f198507fe50>, <pydriller.domain.commit.Method object at 0x7f198507fac0>, <pydriller.domain.commit.Method object at 0x7f198507f580>, <pydriller.domain.commit.Method object at 0x7f198507fb20>, <pydriller.domain.commit.Method object at 0x7f198507f8b0>, <pydriller.domain.commit.Method object at 0x7f198507fa30>, <pydriller.domain.commit.Method object at 0x7f198507f6d0>, <pydriller.domain.commit.Method object at 0x7f198507f8e0>, <pydriller.domain.commit.Method object at 0x7f198507f550>, <pydriller.domain.commit.Method object at 0x7f198507f2e0>], [<pydriller.domain.commit.Method object at 0x7f1983fc9df0>, <pydriller.domain.commit.Method object at 0x7f1983fc96a0>, <pydriller.domain.commit.Method object at 0x7f1983fc9e80>, <pydriller.domain.commit.Method object at 0x7f1983fc9f10>, <pydriller.domain.commit.Method object at 0x7f198290c880>, <pydriller.domain.commit.Method object at 0x7f198290c640>, <pydriller.domain.commit.Method object at 0x7f198290c670>, <pydriller.domain.commit.Method object at 0x7f198290c6a0>, <pydriller.domain.commit.Method object at 0x7f198290c6d0>], [<pydriller.domain.commit.Method object at 0x7f198290cfa0>, <pydriller.domain.commit.Method object at 0x7f1982926040>, <pydriller.domain.commit.Method object at 0x7f1982926070>, <pydriller.domain.commit.Method object at 0x7f19829260a0>, <pydriller.domain.commit.Method object at 0x7f19829262e0>, <pydriller.domain.commit.Method object at 0x7f1982926310>, <pydriller.domain.commit.Method object at 0x7f1982926340>, <pydriller.domain.commit.Method object at 0x7f1982926370>, <pydriller.domain.commit.Method object at 0x7f19829263a0>, <pydriller.domain.commit.Method object at 0x7f19829263d0>, <pydriller.domain.commit.Method object at 0x7f1982926400>]]","[[], [<pydriller.domain.commit.Method object at 0x7f198290c8b0>, <pydriller.domain.commit.Method object at 0x7f198290c910>], [<pydriller.domain.commit.Method object at 0x7f19829071f0>, <pydriller.domain.commit.Method object at 0x7f198507f250>, <pydriller.domain.commit.Method object at 0x7f1982905b20>], [<pydriller.domain.commit.Method object at 0x7f1983f5a670>, <pydriller.domain.commit.Method object at 0x7f1983f5a640>], [<pydriller.domain.commit.Method object at 0x7f198290c130>]]"
thefuck,f3d377114e8110d445a0bcbbbf38f2606008ddb9,Bump to 1.36,2015-05-07 13:12:25+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nVERSION = \'1.35\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\', \'thefuck-alias = thefuck.main:alias\']})\n']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.36\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\', \'thefuck-alias = thefuck.main:alias\']})\n']",[[]],[[]]
thefuck,91c1fe414a9ecfe26768211da62c2999611145fe,Update `thefuck-alias` entry point,2015-05-07 13:32:23+02:00,nvbn,2,5,7,2,"['setup.py', 'main.py']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.36\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\', \'thefuck-alias = thefuck.main:alias\']})\n', 'from imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nimport six\nfrom . import logs, conf, types, shells\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    conf.initialize_settings_file(user_dir)\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return types.Rule(rule.name[:-3], rule_module.match,\n                      rule_module.get_new_command,\n                      getattr(rule_module, \'enabled_by_default\', True),\n                      getattr(rule_module, \'side_effect\', None),\n                      getattr(rule_module, \'priority\', conf.DEFAULT_PRIORITY))\n\n\ndef _get_loaded_rules(rules, settings):\n    """"""Yields all available rules.""""""\n    for rule in rules:\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent \\\n        .joinpath(\'rules\') \\\n        .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    rules = _get_loaded_rules(sorted(bundled) + sorted(user), settings)\n    return sorted(rules, key=lambda rule: settings.priority.get(\n        rule.name, rule.priority))\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if six.PY2:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    script = shells.from_shell(script)\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return types.Command(script, result.stdout.read().decode(\'utf-8\'),\n                             result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, side_effect, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, side_effect, settings)\n        return True\n\n    logs.confirm_command(new_command, side_effect, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = shells.to_shell(rule.get_new_command(command, settings))\n    if confirm(new_command, rule.side_effect, settings):\n        if rule.side_effect:\n            rule.side_effect(command, settings)\n        shells.put_to_history(new_command)\n        print(new_command)\n\n\ndef alias():\n    print(shells.app_alias())\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.36\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\',\n          \'thefuck-alias = thefuck.shells:app_alias\']})\n', 'from imp import load_source\nfrom pathlib import Path\nfrom os.path import expanduser\nfrom subprocess import Popen, PIPE\nimport os\nimport sys\nfrom psutil import Process, TimeoutExpired\nimport colorama\nimport six\nfrom . import logs, conf, types, shells\n\n\ndef setup_user_dir():\n    """"""Returns user config dir, create it when it doesn\'t exist.""""""\n    user_dir = Path(expanduser(\'~/.thefuck\'))\n    rules_dir = user_dir.joinpath(\'rules\')\n    if not rules_dir.is_dir():\n        rules_dir.mkdir(parents=True)\n    conf.initialize_settings_file(user_dir)\n    return user_dir\n\n\ndef load_rule(rule):\n    """"""Imports rule module and returns it.""""""\n    rule_module = load_source(rule.name[:-3], str(rule))\n    return types.Rule(rule.name[:-3], rule_module.match,\n                      rule_module.get_new_command,\n                      getattr(rule_module, \'enabled_by_default\', True),\n                      getattr(rule_module, \'side_effect\', None),\n                      getattr(rule_module, \'priority\', conf.DEFAULT_PRIORITY))\n\n\ndef _get_loaded_rules(rules, settings):\n    """"""Yields all available rules.""""""\n    for rule in rules:\n        if rule.name != \'__init__.py\':\n            loaded_rule = load_rule(rule)\n            if loaded_rule in settings.rules:\n                yield loaded_rule\n\n\ndef get_rules(user_dir, settings):\n    """"""Returns all enabled rules.""""""\n    bundled = Path(__file__).parent \\\n        .joinpath(\'rules\') \\\n        .glob(\'*.py\')\n    user = user_dir.joinpath(\'rules\').glob(\'*.py\')\n    rules = _get_loaded_rules(sorted(bundled) + sorted(user), settings)\n    return sorted(rules, key=lambda rule: settings.priority.get(\n        rule.name, rule.priority))\n\n\ndef wait_output(settings, popen):\n    """"""Returns `True` if we can get output of the command in the\n    `wait_command` time.\n\n    Command will be killed if it wasn\'t finished in the time.\n\n    """"""\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.get_children(recursive=True):\n            child.kill()\n        proc.kill()\n        return False\n\n\ndef get_command(settings, args):\n    """"""Creates command from `args` and executes it.""""""\n    if six.PY2:\n        script = \' \'.join(arg.decode(\'utf-8\') for arg in args[1:])\n    else:\n        script = \' \'.join(args[1:])\n\n    if not script:\n        return\n\n    script = shells.from_shell(script)\n    result = Popen(script, shell=True, stdout=PIPE, stderr=PIPE,\n                   env=dict(os.environ, LANG=\'C\'))\n    if wait_output(settings, result):\n        return types.Command(script, result.stdout.read().decode(\'utf-8\'),\n                             result.stderr.read().decode(\'utf-8\'))\n\n\ndef get_matched_rule(command, rules, settings):\n    """"""Returns first matched rule for command.""""""\n    for rule in rules:\n        try:\n            if rule.match(command, settings):\n                return rule\n        except Exception:\n            logs.rule_failed(rule, sys.exc_info(), settings)\n\n\ndef confirm(new_command, side_effect, settings):\n    """"""Returns `True` when running of new command confirmed.""""""\n    if not settings.require_confirmation:\n        logs.show_command(new_command, side_effect, settings)\n        return True\n\n    logs.confirm_command(new_command, side_effect, settings)\n    try:\n        sys.stdin.read(1)\n        return True\n    except KeyboardInterrupt:\n        logs.failed(\'Aborted\', settings)\n        return False\n\n\ndef run_rule(rule, command, settings):\n    """"""Runs command from rule for passed command.""""""\n    new_command = shells.to_shell(rule.get_new_command(command, settings))\n    if confirm(new_command, rule.side_effect, settings):\n        if rule.side_effect:\n            rule.side_effect(command, settings)\n        shells.put_to_history(new_command)\n        print(new_command)\n\n\ndef main():\n    colorama.init()\n    user_dir = setup_user_dir()\n    settings = conf.get_settings(user_dir)\n\n    command = get_command(settings, sys.argv)\n    if command:\n        rules = get_rules(user_dir, settings)\n        matched_rule = get_matched_rule(command, rules, settings)\n        if matched_rule:\n            run_rule(matched_rule, command, settings)\n            return\n\n    logs.failed(\'No fuck given\', settings)\n']","[[], [<pydriller.domain.commit.Method object at 0x7f198290c5e0>, <pydriller.domain.commit.Method object at 0x7f198290c1f0>, <pydriller.domain.commit.Method object at 0x7f198290c8e0>, <pydriller.domain.commit.Method object at 0x7f198290c610>, <pydriller.domain.commit.Method object at 0x7f198290ce50>, <pydriller.domain.commit.Method object at 0x7f198290caf0>, <pydriller.domain.commit.Method object at 0x7f198290c190>, <pydriller.domain.commit.Method object at 0x7f198290cb50>, <pydriller.domain.commit.Method object at 0x7f198290c100>, <pydriller.domain.commit.Method object at 0x7f198290c460>, <pydriller.domain.commit.Method object at 0x7f198290c760>]]","[[], [<pydriller.domain.commit.Method object at 0x7f198290c460>]]"
thefuck,2b12b4bfced02d4f646e8dcdc046bf18e854e434,Improve tests with `mocker`,2015-05-07 13:42:52+02:00,nvbn,28,42,70,4,"['requirements.txt', 'test_conf.py', 'test_main.py', 'test_shells.py']","['pytest\nmock\n', ""import pytest\nimport six\nfrom mock import Mock\nfrom thefuck import conf\nfrom tests.utils import Rule\n\n\n@pytest.mark.parametrize('enabled, rules, result', [\n    (True, conf.DEFAULT_RULES, True),\n    (False, conf.DEFAULT_RULES, False),\n    (False, conf.DEFAULT_RULES + ['test'], True)])\ndef test_default(enabled, rules, result):\n    assert (Rule('test', enabled_by_default=enabled) in rules) == result\n\n\n@pytest.fixture\ndef load_source(monkeypatch):\n    mock = Mock()\n    monkeypatch.setattr('thefuck.conf.load_source', mock)\n    return mock\n\n\n@pytest.fixture\ndef environ(monkeypatch):\n    data = {}\n    monkeypatch.setattr('thefuck.conf.os.environ', data)\n    return data\n\n\n@pytest.mark.usefixture('environ')\ndef test_settings_defaults(load_source):\n    load_source.return_value = object()\n    for key, val in conf.DEFAULT_SETTINGS.items():\n        assert getattr(conf.get_settings(Mock()), key) == val\n\n\n@pytest.mark.usefixture('environ')\nclass TestSettingsFromFile(object):\n    def test_from_file(self, load_source):\n        load_source.return_value = Mock(rules=['test'],\n                                        wait_command=10,\n                                        require_confirmation=True,\n                                        no_colors=True,\n                                        priority={'vim': 100})\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n        assert settings.priority == {'vim': 100}\n\n    def test_from_file_with_DEFAULT(self, load_source):\n        load_source.return_value = Mock(rules=conf.DEFAULT_RULES + ['test'],\n                                        wait_command=10,\n                                        require_confirmation=True,\n                                        no_colors=True)\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['test']\n\n\n@pytest.mark.usefixture('load_source')\nclass TestSettingsFromEnv(object):\n    def test_from_env(self, environ):\n        environ.update({'THEFUCK_RULES': 'bash:lisp',\n                        'THEFUCK_WAIT_COMMAND': '55',\n                        'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                        'THEFUCK_NO_COLORS': 'false',\n                        'THEFUCK_PRIORITY': 'bash=10:lisp=wrong:vim=15'})\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n        assert settings.priority == {'bash': 10, 'vim': 15}\n\n    def test_from_env_with_DEFAULT(self, environ):\n        environ.update({'THEFUCK_RULES': 'DEFAULT_RULES:bash:lisp'})\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['bash', 'lisp']\n\n\nclass TestInitializeSettingsFile(object):\n    def test_ignore_if_exists(self):\n        settings_path_mock = Mock(is_file=Mock(return_value=True), open=Mock())\n        user_dir_mock = Mock(joinpath=Mock(return_value=settings_path_mock))\n        conf.initialize_settings_file(user_dir_mock)\n        assert settings_path_mock.is_file.call_count == 1\n        assert not settings_path_mock.open.called\n\n    def test_create_if_doesnt_exists(self):\n        settings_file = six.StringIO()\n        settings_path_mock = Mock(\n            is_file=Mock(return_value=False),\n            open=Mock(return_value=Mock(\n                __exit__=lambda *args: None, __enter__=lambda *args: settings_file)))\n        user_dir_mock = Mock(joinpath=Mock(return_value=settings_path_mock))\n        conf.initialize_settings_file(user_dir_mock)\n        settings_file_contents = settings_file.getvalue()\n        assert settings_path_mock.is_file.call_count == 1\n        assert settings_path_mock.open.call_count == 1\n        assert conf.SETTINGS_HEADER in settings_file_contents\n        for setting in conf.DEFAULT_SETTINGS.items():\n            assert '# {} = {}\\n'.format(*setting) in settings_file_contents\n        settings_file.close()\n"", ""import pytest\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import Mock\nfrom thefuck import main, conf, types\nfrom tests.utils import Rule, Command\n\n\ndef test_load_rule(monkeypatch):\n    match = object()\n    get_new_command = object()\n    load_source = Mock()\n    load_source.return_value = Mock(match=match,\n                                    get_new_command=get_new_command,\n                                    enabled_by_default=True,\n                                    priority=900)\n    monkeypatch.setattr('thefuck.main.load_source', load_source)\n    assert main.load_rule(Path('/rules/bash.py')) \\\n           == Rule('bash', match, get_new_command, priority=900)\n    load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\nclass TestGetRules(object):\n    @pytest.fixture(autouse=True)\n    def glob(self, monkeypatch):\n        mock = Mock(return_value=[])\n        monkeypatch.setattr('thefuck.main.Path.glob', mock)\n        return mock\n\n    def _compare_names(self, rules, names):\n        return [r.name for r in rules] == names\n\n    @pytest.mark.parametrize('conf_rules, rules', [\n        (conf.DEFAULT_RULES, ['bash', 'lisp', 'bash', 'lisp']),\n        (types.RulesNamesList(['bash']), ['bash', 'bash'])])\n    def test_get(self, monkeypatch, glob, conf_rules, rules):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        monkeypatch.setattr('thefuck.main.load_source',\n                            lambda x, _: Rule(x))\n        assert self._compare_names(\n            main.get_rules(Path('~'), Mock(rules=conf_rules, priority={})),\n            rules)\n\n    @pytest.mark.parametrize('priority, unordered, ordered', [\n        ({},\n         [Rule('bash', priority=100), Rule('python', priority=5)],\n         ['python', 'bash']),\n        ({},\n         [Rule('lisp', priority=9999), Rule('c', priority=conf.DEFAULT_PRIORITY)],\n         ['c', 'lisp']),\n        ({'python': 9999},\n         [Rule('bash', priority=100), Rule('python', priority=5)],\n         ['bash', 'python'])])\n    def test_ordered_by_priority(self, monkeypatch, priority, unordered, ordered):\n        monkeypatch.setattr('thefuck.main._get_loaded_rules',\n                            lambda *_: unordered)\n        assert self._compare_names(\n            main.get_rules(Path('~'), Mock(priority=priority)),\n            ordered)\n\n\nclass TestGetCommand(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, monkeypatch):\n        Popen = Mock()\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        monkeypatch.setattr('thefuck.main.Popen', Popen)\n        return Popen\n\n    @pytest.fixture(autouse=True)\n    def prepare(self, monkeypatch):\n        monkeypatch.setattr('thefuck.main.os.environ', {})\n        monkeypatch.setattr('thefuck.main.wait_output', lambda *_: True)\n\n    @pytest.fixture(autouse=True)\n    def generic_shell(self, monkeypatch):\n        monkeypatch.setattr('thefuck.shells.from_shell', lambda x: x)\n        monkeypatch.setattr('thefuck.shells.to_shell', lambda x: x)\n\n    def test_get_command_calls(self, Popen):\n        assert main.get_command(Mock(),\n            ['thefuck', 'apt-get', 'search', 'vim']) \\\n               == Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n    @pytest.mark.parametrize('args, result', [\n        (['thefuck', 'ls', '-la'], 'ls -la'),\n        (['thefuck', 'ls'], 'ls')])\n    def test_get_command_script(self, args, result):\n        if result:\n            assert main.get_command(Mock(), args).script == result\n        else:\n            assert main.get_command(Mock(), args) is None\n\n\nclass TestGetMatchedRule(object):\n    def test_no_match(self):\n        assert main.get_matched_rule(\n            Command('ls'), [Rule('', lambda *_: False)],\n            Mock(no_colors=True)) is None\n\n    def test_match(self):\n        rule = Rule('', lambda x, _: x.script == 'cd ..')\n        assert main.get_matched_rule(\n            Command('cd ..'), [rule], Mock(no_colors=True)) == rule\n\n    def test_when_rule_failed(self, capsys):\n        main.get_matched_rule(\n            Command('ls'), [Rule('test', Mock(side_effect=OSError('Denied')))],\n            Mock(no_colors=True))\n        assert capsys.readouterr()[1].split('\\n')[0] == '[WARN] Rule test:'\n\n\nclass TestRunRule(object):\n    @pytest.fixture(autouse=True)\n    def confirm(self, monkeypatch):\n        mock = Mock(return_value=True)\n        monkeypatch.setattr('thefuck.main.confirm', mock)\n        return mock\n\n    def test_run_rule(self, capsys):\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n\n    def test_run_rule_with_side_effect(self, capsys):\n        side_effect = Mock()\n        settings = Mock()\n        command = Command()\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command',\n                           side_effect=side_effect),\n                      command, settings)\n        assert capsys.readouterr() == ('new-command\\n', '')\n        side_effect.assert_called_once_with(command, settings)\n\n    def test_when_not_comfirmed(self, capsys, confirm):\n        confirm.return_value = False\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), None)\n        assert capsys.readouterr() == ('', '')\n\n\nclass TestConfirm(object):\n    @pytest.fixture\n    def stdin(self, monkeypatch):\n        mock = Mock(return_value='\\n')\n        monkeypatch.setattr('sys.stdin.read', mock)\n        return mock\n\n    def test_when_not_required(self, capsys):\n        assert main.confirm('command', None, Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command\\n')\n\n    def test_with_side_effect_and_without_confirmation(self, capsys):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command*\\n')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed(self, capsys, stdin):\n        assert main.confirm('command', None, Mock(require_confirmation=True,\n                                                  no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed_with_side_effect(self, capsys, stdin):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=True,\n                                                    no_colors=True))\n        assert capsys.readouterr() == ('', 'command* [enter/ctrl+c]')\n\n    def test_when_confirmation_required_and_aborted(self, capsys, stdin):\n        stdin.side_effect = KeyboardInterrupt\n        assert not main.confirm('command', None, Mock(require_confirmation=True,\n                                                      no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", ""import pytest\nfrom mock import Mock, MagicMock\nfrom thefuck import shells\n\n\n@pytest.fixture\ndef builtins_open(monkeypatch):\n    mock = MagicMock()\n    monkeypatch.setattr('six.moves.builtins.open', mock)\n    return mock\n\n\n@pytest.fixture\ndef isfile(monkeypatch):\n    mock = Mock(return_value=True)\n    monkeypatch.setattr('os.path.isfile', mock)\n    return mock\n\n\nclass TestGeneric(object):\n    def test_from_shell(self):\n        assert shells.Generic().from_shell('pwd') == 'pwd'\n\n    def test_to_shell(self):\n        assert shells.Generic().to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open):\n        assert shells.Generic().put_to_history('ls') is None\n        assert builtins_open.call_count == 0\n\n\n@pytest.mark.usefixtures('isfile')\nclass TestBash(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, monkeypatch):\n        mock = Mock()\n        monkeypatch.setattr('thefuck.shells.Popen', mock)\n        mock.return_value.stdout.read.return_value = (\n            b'alias l=\\'ls -CF\\'\\n'\n            b'alias la=\\'ls -A\\'\\n'\n            b'alias ll=\\'ls -alF\\'')\n        return mock\n\n    @pytest.mark.parametrize('before, after', [\n        ('pwd', 'pwd'),\n        ('ll', 'ls -alF')])\n    def test_from_shell(self, before, after):\n        assert shells.Bash().from_shell(before) == after\n\n    def test_to_shell(self):\n        assert shells.Bash().to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open):\n        shells.Bash().put_to_history('ls')\n        builtins_open.return_value.__enter__.return_value.\\\n            write.assert_called_once_with('ls\\n')\n\n\n@pytest.mark.usefixtures('isfile')\nclass TestZsh(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, monkeypatch):\n        mock = Mock()\n        monkeypatch.setattr('thefuck.shells.Popen', mock)\n        mock.return_value.stdout.read.return_value = (\n            b'l=\\'ls -CF\\'\\n'\n            b'la=\\'ls -A\\'\\n'\n            b'll=\\'ls -alF\\'')\n        return mock\n\n    @pytest.mark.parametrize('before, after', [\n        ('pwd', 'pwd'),\n        ('ll', 'ls -alF')])\n    def test_from_shell(self, before, after):\n        assert shells.Zsh().from_shell(before) == after\n\n    def test_to_shell(self):\n        assert shells.Zsh().to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open, monkeypatch):\n        monkeypatch.setattr('thefuck.shells.time',\n                            lambda: 1430707243.3517463)\n        shells.Zsh().put_to_history('ls')\n        builtins_open.return_value.__enter__.return_value. \\\n            write.assert_called_once_with(': 1430707243:0;ls\\n')""]","['pytest\nmock\npytest-mock\n', ""import pytest\nimport six\nfrom mock import Mock\nfrom thefuck import conf\nfrom tests.utils import Rule\n\n\n@pytest.mark.parametrize('enabled, rules, result', [\n    (True, conf.DEFAULT_RULES, True),\n    (False, conf.DEFAULT_RULES, False),\n    (False, conf.DEFAULT_RULES + ['test'], True)])\ndef test_default(enabled, rules, result):\n    assert (Rule('test', enabled_by_default=enabled) in rules) == result\n\n\n@pytest.fixture\ndef load_source(mocker):\n    return mocker.patch('thefuck.conf.load_source')\n\n\n@pytest.fixture\ndef environ(monkeypatch):\n    data = {}\n    monkeypatch.setattr('thefuck.conf.os.environ', data)\n    return data\n\n\n@pytest.mark.usefixture('environ')\ndef test_settings_defaults(load_source):\n    load_source.return_value = object()\n    for key, val in conf.DEFAULT_SETTINGS.items():\n        assert getattr(conf.get_settings(Mock()), key) == val\n\n\n@pytest.mark.usefixture('environ')\nclass TestSettingsFromFile(object):\n    def test_from_file(self, load_source):\n        load_source.return_value = Mock(rules=['test'],\n                                        wait_command=10,\n                                        require_confirmation=True,\n                                        no_colors=True,\n                                        priority={'vim': 100})\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n        assert settings.priority == {'vim': 100}\n\n    def test_from_file_with_DEFAULT(self, load_source):\n        load_source.return_value = Mock(rules=conf.DEFAULT_RULES + ['test'],\n                                        wait_command=10,\n                                        require_confirmation=True,\n                                        no_colors=True)\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['test']\n\n\n@pytest.mark.usefixture('load_source')\nclass TestSettingsFromEnv(object):\n    def test_from_env(self, environ):\n        environ.update({'THEFUCK_RULES': 'bash:lisp',\n                        'THEFUCK_WAIT_COMMAND': '55',\n                        'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                        'THEFUCK_NO_COLORS': 'false',\n                        'THEFUCK_PRIORITY': 'bash=10:lisp=wrong:vim=15'})\n        settings = conf.get_settings(Mock())\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n        assert settings.priority == {'bash': 10, 'vim': 15}\n\n    def test_from_env_with_DEFAULT(self, environ):\n        environ.update({'THEFUCK_RULES': 'DEFAULT_RULES:bash:lisp'})\n        settings = conf.get_settings(Mock())\n        assert settings.rules == conf.DEFAULT_RULES + ['bash', 'lisp']\n\n\nclass TestInitializeSettingsFile(object):\n    def test_ignore_if_exists(self):\n        settings_path_mock = Mock(is_file=Mock(return_value=True), open=Mock())\n        user_dir_mock = Mock(joinpath=Mock(return_value=settings_path_mock))\n        conf.initialize_settings_file(user_dir_mock)\n        assert settings_path_mock.is_file.call_count == 1\n        assert not settings_path_mock.open.called\n\n    def test_create_if_doesnt_exists(self):\n        settings_file = six.StringIO()\n        settings_path_mock = Mock(\n            is_file=Mock(return_value=False),\n            open=Mock(return_value=Mock(\n                __exit__=lambda *args: None, __enter__=lambda *args: settings_file)))\n        user_dir_mock = Mock(joinpath=Mock(return_value=settings_path_mock))\n        conf.initialize_settings_file(user_dir_mock)\n        settings_file_contents = settings_file.getvalue()\n        assert settings_path_mock.is_file.call_count == 1\n        assert settings_path_mock.open.call_count == 1\n        assert conf.SETTINGS_HEADER in settings_file_contents\n        for setting in conf.DEFAULT_SETTINGS.items():\n            assert '# {} = {}\\n'.format(*setting) in settings_file_contents\n        settings_file.close()\n"", ""import pytest\nfrom subprocess import PIPE\nfrom pathlib import PosixPath, Path\nfrom mock import Mock\nfrom thefuck import main, conf, types\nfrom tests.utils import Rule, Command\n\n\ndef test_load_rule(mocker):\n    match = object()\n    get_new_command = object()\n    load_source = mocker.patch(\n        'thefuck.main.load_source',\n        return_value=Mock(match=match,\n                          get_new_command=get_new_command,\n                          enabled_by_default=True,\n                          priority=900))\n    assert main.load_rule(Path('/rules/bash.py')) \\\n           == Rule('bash', match, get_new_command, priority=900)\n    load_source.assert_called_once_with('bash', '/rules/bash.py')\n\n\nclass TestGetRules(object):\n    @pytest.fixture(autouse=True)\n    def glob(self, mocker):\n        return mocker.patch('thefuck.main.Path.glob', return_value=[])\n\n    def _compare_names(self, rules, names):\n        return [r.name for r in rules] == names\n\n    @pytest.mark.parametrize('conf_rules, rules', [\n        (conf.DEFAULT_RULES, ['bash', 'lisp', 'bash', 'lisp']),\n        (types.RulesNamesList(['bash']), ['bash', 'bash'])])\n    def test_get(self, monkeypatch, glob, conf_rules, rules):\n        glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]\n        monkeypatch.setattr('thefuck.main.load_source',\n                            lambda x, _: Rule(x))\n        assert self._compare_names(\n            main.get_rules(Path('~'), Mock(rules=conf_rules, priority={})),\n            rules)\n\n    @pytest.mark.parametrize('priority, unordered, ordered', [\n        ({},\n         [Rule('bash', priority=100), Rule('python', priority=5)],\n         ['python', 'bash']),\n        ({},\n         [Rule('lisp', priority=9999), Rule('c', priority=conf.DEFAULT_PRIORITY)],\n         ['c', 'lisp']),\n        ({'python': 9999},\n         [Rule('bash', priority=100), Rule('python', priority=5)],\n         ['bash', 'python'])])\n    def test_ordered_by_priority(self, monkeypatch, priority, unordered, ordered):\n        monkeypatch.setattr('thefuck.main._get_loaded_rules',\n                            lambda *_: unordered)\n        assert self._compare_names(\n            main.get_rules(Path('~'), Mock(priority=priority)),\n            ordered)\n\n\nclass TestGetCommand(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, monkeypatch):\n        Popen = Mock()\n        Popen.return_value.stdout.read.return_value = b'stdout'\n        Popen.return_value.stderr.read.return_value = b'stderr'\n        monkeypatch.setattr('thefuck.main.Popen', Popen)\n        return Popen\n\n    @pytest.fixture(autouse=True)\n    def prepare(self, monkeypatch):\n        monkeypatch.setattr('thefuck.main.os.environ', {})\n        monkeypatch.setattr('thefuck.main.wait_output', lambda *_: True)\n\n    @pytest.fixture(autouse=True)\n    def generic_shell(self, monkeypatch):\n        monkeypatch.setattr('thefuck.shells.from_shell', lambda x: x)\n        monkeypatch.setattr('thefuck.shells.to_shell', lambda x: x)\n\n    def test_get_command_calls(self, Popen):\n        assert main.get_command(Mock(),\n            ['thefuck', 'apt-get', 'search', 'vim']) \\\n               == Command('apt-get search vim', 'stdout', 'stderr')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdout=PIPE,\n                                      stderr=PIPE,\n                                      env={'LANG': 'C'})\n\n    @pytest.mark.parametrize('args, result', [\n        (['thefuck', 'ls', '-la'], 'ls -la'),\n        (['thefuck', 'ls'], 'ls')])\n    def test_get_command_script(self, args, result):\n        if result:\n            assert main.get_command(Mock(), args).script == result\n        else:\n            assert main.get_command(Mock(), args) is None\n\n\nclass TestGetMatchedRule(object):\n    def test_no_match(self):\n        assert main.get_matched_rule(\n            Command('ls'), [Rule('', lambda *_: False)],\n            Mock(no_colors=True)) is None\n\n    def test_match(self):\n        rule = Rule('', lambda x, _: x.script == 'cd ..')\n        assert main.get_matched_rule(\n            Command('cd ..'), [rule], Mock(no_colors=True)) == rule\n\n    def test_when_rule_failed(self, capsys):\n        main.get_matched_rule(\n            Command('ls'), [Rule('test', Mock(side_effect=OSError('Denied')))],\n            Mock(no_colors=True))\n        assert capsys.readouterr()[1].split('\\n')[0] == '[WARN] Rule test:'\n\n\nclass TestRunRule(object):\n    @pytest.fixture(autouse=True)\n    def confirm(self, mocker):\n        return mocker.patch('thefuck.main.confirm', return_value=True)\n\n    def test_run_rule(self, capsys):\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), None)\n        assert capsys.readouterr() == ('new-command\\n', '')\n\n    def test_run_rule_with_side_effect(self, capsys):\n        side_effect = Mock()\n        settings = Mock()\n        command = Command()\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command',\n                           side_effect=side_effect),\n                      command, settings)\n        assert capsys.readouterr() == ('new-command\\n', '')\n        side_effect.assert_called_once_with(command, settings)\n\n    def test_when_not_comfirmed(self, capsys, confirm):\n        confirm.return_value = False\n        main.run_rule(Rule(get_new_command=lambda *_: 'new-command'),\n                      Command(), None)\n        assert capsys.readouterr() == ('', '')\n\n\nclass TestConfirm(object):\n    @pytest.fixture\n    def stdin(self, mocker):\n        return mocker.patch('sys.stdin.read', return_value='\\n')\n\n    def test_when_not_required(self, capsys):\n        assert main.confirm('command', None, Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command\\n')\n\n    def test_with_side_effect_and_without_confirmation(self, capsys):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=False))\n        assert capsys.readouterr() == ('', 'command*\\n')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed(self, capsys, stdin):\n        assert main.confirm('command', None, Mock(require_confirmation=True,\n                                                  no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]')\n\n    # `stdin` fixture should be applied after `capsys`\n    def test_when_confirmation_required_and_confirmed_with_side_effect(self, capsys, stdin):\n        assert main.confirm('command', Mock(), Mock(require_confirmation=True,\n                                                    no_colors=True))\n        assert capsys.readouterr() == ('', 'command* [enter/ctrl+c]')\n\n    def test_when_confirmation_required_and_aborted(self, capsys, stdin):\n        stdin.side_effect = KeyboardInterrupt\n        assert not main.confirm('command', None, Mock(require_confirmation=True,\n                                                      no_colors=True))\n        assert capsys.readouterr() == ('', 'command [enter/ctrl+c]Aborted\\n')\n"", ""import pytest\nfrom thefuck import shells\n\n\n@pytest.fixture\ndef builtins_open(mocker):\n    return mocker.patch('six.moves.builtins.open')\n\n\n@pytest.fixture\ndef isfile(mocker):\n    return mocker.patch('os.path.isfile', return_value=True)\n\n\nclass TestGeneric(object):\n    def test_from_shell(self):\n        assert shells.Generic().from_shell('pwd') == 'pwd'\n\n    def test_to_shell(self):\n        assert shells.Generic().to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open):\n        assert shells.Generic().put_to_history('ls') is None\n        assert builtins_open.call_count == 0\n\n\n@pytest.mark.usefixtures('isfile')\nclass TestBash(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, mocker):\n        mock = mocker.patch('thefuck.shells.Popen')\n        mock.return_value.stdout.read.return_value = (\n            b'alias l=\\'ls -CF\\'\\n'\n            b'alias la=\\'ls -A\\'\\n'\n            b'alias ll=\\'ls -alF\\'')\n        return mock\n\n    @pytest.mark.parametrize('before, after', [\n        ('pwd', 'pwd'),\n        ('ll', 'ls -alF')])\n    def test_from_shell(self, before, after):\n        assert shells.Bash().from_shell(before) == after\n\n    def test_to_shell(self):\n        assert shells.Bash().to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open):\n        shells.Bash().put_to_history('ls')\n        builtins_open.return_value.__enter__.return_value. \\\n            write.assert_called_once_with('ls\\n')\n\n\n@pytest.mark.usefixtures('isfile')\nclass TestZsh(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, mocker):\n        mock = mocker.patch('thefuck.shells.Popen')\n        mock.return_value.stdout.read.return_value = (\n            b'l=\\'ls -CF\\'\\n'\n            b'la=\\'ls -A\\'\\n'\n            b'll=\\'ls -alF\\'')\n        return mock\n\n    @pytest.mark.parametrize('before, after', [\n        ('pwd', 'pwd'),\n        ('ll', 'ls -alF')])\n    def test_from_shell(self, before, after):\n        assert shells.Zsh().from_shell(before) == after\n\n    def test_to_shell(self):\n        assert shells.Zsh().to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open, mocker):\n        mocker.patch('thefuck.shells.time',\n                     return_value=1430707243.3517463)\n        shells.Zsh().put_to_history('ls')\n        builtins_open.return_value.__enter__.return_value. \\\n            write.assert_called_once_with(': 1430707243:0;ls\\n')""]","[[], [<pydriller.domain.commit.Method object at 0x7f1983f4e340>, <pydriller.domain.commit.Method object at 0x7f1983f4ea00>, <pydriller.domain.commit.Method object at 0x7f1983f4eb50>, <pydriller.domain.commit.Method object at 0x7f1983f4e9d0>, <pydriller.domain.commit.Method object at 0x7f1983f4e0a0>, <pydriller.domain.commit.Method object at 0x7f1983f4e370>, <pydriller.domain.commit.Method object at 0x7f1983f4e190>, <pydriller.domain.commit.Method object at 0x7f1983f4e220>, <pydriller.domain.commit.Method object at 0x7f1983f4e6d0>, <pydriller.domain.commit.Method object at 0x7f1983f4e760>], [<pydriller.domain.commit.Method object at 0x7f1982926d30>, <pydriller.domain.commit.Method object at 0x7f1982926af0>, <pydriller.domain.commit.Method object at 0x7f1982926d60>, <pydriller.domain.commit.Method object at 0x7f1982926d90>, <pydriller.domain.commit.Method object at 0x7f19829268b0>, <pydriller.domain.commit.Method object at 0x7f1982926850>, <pydriller.domain.commit.Method object at 0x7f1982926430>, <pydriller.domain.commit.Method object at 0x7f1982926880>, <pydriller.domain.commit.Method object at 0x7f19829265e0>, <pydriller.domain.commit.Method object at 0x7f1982926730>, <pydriller.domain.commit.Method object at 0x7f1982926610>, <pydriller.domain.commit.Method object at 0x7f1982926670>, <pydriller.domain.commit.Method object at 0x7f1982926580>, <pydriller.domain.commit.Method object at 0x7f1982926490>, <pydriller.domain.commit.Method object at 0x7f19829266d0>, <pydriller.domain.commit.Method object at 0x7f19829265b0>, <pydriller.domain.commit.Method object at 0x7f19829264c0>, <pydriller.domain.commit.Method object at 0x7f19829267c0>, <pydriller.domain.commit.Method object at 0x7f1982926820>, <pydriller.domain.commit.Method object at 0x7f1982926700>, <pydriller.domain.commit.Method object at 0x7f1982926790>, <pydriller.domain.commit.Method object at 0x7f19829267f0>, <pydriller.domain.commit.Method object at 0x7f1982926460>], [<pydriller.domain.commit.Method object at 0x7f1982926ac0>, <pydriller.domain.commit.Method object at 0x7f1982926a90>, <pydriller.domain.commit.Method object at 0x7f1982926a30>, <pydriller.domain.commit.Method object at 0x7f1982926dc0>, <pydriller.domain.commit.Method object at 0x7f1982926df0>, <pydriller.domain.commit.Method object at 0x7f1982926cd0>, <pydriller.domain.commit.Method object at 0x7f19829266a0>, <pydriller.domain.commit.Method object at 0x7f1982926910>, <pydriller.domain.commit.Method object at 0x7f1982926b20>, <pydriller.domain.commit.Method object at 0x7f1982926b50>, <pydriller.domain.commit.Method object at 0x7f1982926b80>, <pydriller.domain.commit.Method object at 0x7f1982926bb0>, <pydriller.domain.commit.Method object at 0x7f1982926be0>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983fc90a0>, <pydriller.domain.commit.Method object at 0x7f1983f4ea00>], [<pydriller.domain.commit.Method object at 0x7f1982926d30>, <pydriller.domain.commit.Method object at 0x7f1983f2b8e0>, <pydriller.domain.commit.Method object at 0x7f1982907e20>, <pydriller.domain.commit.Method object at 0x7f19829267c0>, <pydriller.domain.commit.Method object at 0x7f19829058e0>, <pydriller.domain.commit.Method object at 0x7f19829057c0>, <pydriller.domain.commit.Method object at 0x7f1982926af0>, <pydriller.domain.commit.Method object at 0x7f1982926490>], [<pydriller.domain.commit.Method object at 0x7f19828b0430>, <pydriller.domain.commit.Method object at 0x7f19828b0040>, <pydriller.domain.commit.Method object at 0x7f1982926ac0>, <pydriller.domain.commit.Method object at 0x7f19828b04f0>, <pydriller.domain.commit.Method object at 0x7f19828b03a0>, <pydriller.domain.commit.Method object at 0x7f1982926a90>, <pydriller.domain.commit.Method object at 0x7f19828b0070>, <pydriller.domain.commit.Method object at 0x7f1982926cd0>, <pydriller.domain.commit.Method object at 0x7f1982926be0>]]"
thefuck,36d80859a4d3e02c161db7d1600734ea9d1eacc1,Add tox config,2015-05-07 13:51:27+02:00,nvbn,7,1,8,2,"['test_shells.py', 'tox.ini']","[""import pytest\nfrom thefuck import shells\n\n\n@pytest.fixture\ndef builtins_open(mocker):\n    return mocker.patch('six.moves.builtins.open')\n\n\n@pytest.fixture\ndef isfile(mocker):\n    return mocker.patch('os.path.isfile', return_value=True)\n\n\nclass TestGeneric(object):\n    def test_from_shell(self):\n        assert shells.Generic().from_shell('pwd') == 'pwd'\n\n    def test_to_shell(self):\n        assert shells.Generic().to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open):\n        assert shells.Generic().put_to_history('ls') is None\n        assert builtins_open.call_count == 0\n\n\n@pytest.mark.usefixtures('isfile')\nclass TestBash(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, mocker):\n        mock = mocker.patch('thefuck.shells.Popen')\n        mock.return_value.stdout.read.return_value = (\n            b'alias l=\\'ls -CF\\'\\n'\n            b'alias la=\\'ls -A\\'\\n'\n            b'alias ll=\\'ls -alF\\'')\n        return mock\n\n    @pytest.mark.parametrize('before, after', [\n        ('pwd', 'pwd'),\n        ('ll', 'ls -alF')])\n    def test_from_shell(self, before, after):\n        assert shells.Bash().from_shell(before) == after\n\n    def test_to_shell(self):\n        assert shells.Bash().to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open):\n        shells.Bash().put_to_history('ls')\n        builtins_open.return_value.__enter__.return_value. \\\n            write.assert_called_once_with('ls\\n')\n\n\n@pytest.mark.usefixtures('isfile')\nclass TestZsh(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, mocker):\n        mock = mocker.patch('thefuck.shells.Popen')\n        mock.return_value.stdout.read.return_value = (\n            b'l=\\'ls -CF\\'\\n'\n            b'la=\\'ls -A\\'\\n'\n            b'll=\\'ls -alF\\'')\n        return mock\n\n    @pytest.mark.parametrize('before, after', [\n        ('pwd', 'pwd'),\n        ('ll', 'ls -alF')])\n    def test_from_shell(self, before, after):\n        assert shells.Zsh().from_shell(before) == after\n\n    def test_to_shell(self):\n        assert shells.Zsh().to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open, mocker):\n        mocker.patch('thefuck.shells.time',\n                     return_value=1430707243.3517463)\n        shells.Zsh().put_to_history('ls')\n        builtins_open.return_value.__enter__.return_value. \\\n            write.assert_called_once_with(': 1430707243:0;ls\\n')"", None]","[""import pytest\nfrom thefuck import shells\n\n\n@pytest.fixture\ndef builtins_open(mocker):\n    return mocker.patch('six.moves.builtins.open')\n\n\n@pytest.fixture\ndef isfile(mocker):\n    return mocker.patch('os.path.isfile', return_value=True)\n\n\nclass TestGeneric(object):\n    def test_from_shell(self):\n        assert shells.Generic().from_shell('pwd') == 'pwd'\n\n    def test_to_shell(self):\n        assert shells.Generic().to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open):\n        assert shells.Generic().put_to_history('ls') is None\n        assert builtins_open.call_count == 0\n\n\n@pytest.mark.usefixtures('isfile')\nclass TestBash(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, mocker):\n        mock = mocker.patch('thefuck.shells.Popen')\n        mock.return_value.stdout.read.return_value = (\n            b'alias l=\\'ls -CF\\'\\n'\n            b'alias la=\\'ls -A\\'\\n'\n            b'alias ll=\\'ls -alF\\'')\n        return mock\n\n    @pytest.mark.parametrize('before, after', [\n        ('pwd', 'pwd'),\n        ('ll', 'ls -alF')])\n    def test_from_shell(self, before, after):\n        assert shells.Bash().from_shell(before) == after\n\n    def test_to_shell(self):\n        assert shells.Bash().to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open):\n        shells.Bash().put_to_history('ls')\n        builtins_open.return_value.__enter__.return_value. \\\n            write.assert_called_once_with('ls\\n')\n\n\n@pytest.mark.usefixtures('isfile')\nclass TestZsh(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, mocker):\n        mock = mocker.patch('thefuck.shells.Popen')\n        mock.return_value.stdout.read.return_value = (\n            b'l=\\'ls -CF\\'\\n'\n            b'la=\\'ls -A\\'\\n'\n            b'll=\\'ls -alF\\'')\n        return mock\n\n    @pytest.mark.parametrize('before, after', [\n        ('pwd', 'pwd'),\n        ('ll', 'ls -alF')])\n    def test_from_shell(self, before, after):\n        assert shells.Zsh().from_shell(before) == after\n\n    def test_to_shell(self):\n        assert shells.Zsh().to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open, mocker):\n        mocker.patch('thefuck.shells.time',\n                     return_value=1430707243.3517463)\n        shells.Zsh().put_to_history('ls')\n        builtins_open.return_value.__enter__.return_value. \\\n            write.assert_called_once_with(': 1430707243:0;ls\\n')\n"", '[tox]\nenvlist = py27,py33,py34\n\n[testenv]\ndeps = -rrequirements.txt\ncommands = py.test\n']","[[<pydriller.domain.commit.Method object at 0x7f1983f4edc0>, <pydriller.domain.commit.Method object at 0x7f1983f4ee80>, <pydriller.domain.commit.Method object at 0x7f1983f4eee0>, <pydriller.domain.commit.Method object at 0x7f1983f4ef10>, <pydriller.domain.commit.Method object at 0x7f1983f4eaf0>, <pydriller.domain.commit.Method object at 0x7f1983f4eb20>, <pydriller.domain.commit.Method object at 0x7f1983f4e1f0>, <pydriller.domain.commit.Method object at 0x7f1983f4e8b0>, <pydriller.domain.commit.Method object at 0x7f1983f4e9a0>, <pydriller.domain.commit.Method object at 0x7f1983f4e310>, <pydriller.domain.commit.Method object at 0x7f1983f4e820>, <pydriller.domain.commit.Method object at 0x7f1983f4e880>, <pydriller.domain.commit.Method object at 0x7f1983f4e160>], []]","[[<pydriller.domain.commit.Method object at 0x7f1982907670>], []]"
thefuck,0cdd23edcffe4b49f72ce7bdd8df695c946ea99c,Use wheel,2015-05-07 14:16:07+02:00,nvbn,4,1,5,3,"['release.py', 'requirements.txt', 'setup.cfg']","['#!/usr/bin/env python\nfrom subprocess import call\nimport re\n\n\nversion = None\n\n\ndef get_new_setup_py_lines():\n    global version\n    with open(\'setup.py\', \'r\') as sf:\n        current_setup = sf.readlines()\n    for line in current_setup:\n        if line.startswith(\'VERSION = \'):\n            major, minor = re.findall(r""VERSION = \'(\\d+)\\.(\\d+)\'"", line)[0]\n            version = ""{}.{}"".format(major, int(minor) + 1)\n            yield ""VERSION = \'{}\'\\n"".format(version)\n        else:\n            yield line\n\n\nlines = list(get_new_setup_py_lines())\nwith open(\'setup.py\', \'w\') as sf:\n    sf.writelines(lines)\n\ncall(\'git pull\', shell=True)\ncall(\'git commit -am ""Bump to {}""\'.format(version), shell=True)\ncall(\'git tag {}\'.format(version), shell=True)\ncall(\'git push\', shell=True)\ncall(\'git push --tags\', shell=True)\ncall(\'python setup.py sdist upload\', shell=True)\n', 'pytest\nmock\npytest-mock\n', None]","['#!/usr/bin/env python\nfrom subprocess import call\nimport re\n\n\nversion = None\n\n\ndef get_new_setup_py_lines():\n    global version\n    with open(\'setup.py\', \'r\') as sf:\n        current_setup = sf.readlines()\n    for line in current_setup:\n        if line.startswith(\'VERSION = \'):\n            major, minor = re.findall(r""VERSION = \'(\\d+)\\.(\\d+)\'"", line)[0]\n            version = ""{}.{}"".format(major, int(minor) + 1)\n            yield ""VERSION = \'{}\'\\n"".format(version)\n        else:\n            yield line\n\n\nlines = list(get_new_setup_py_lines())\nwith open(\'setup.py\', \'w\') as sf:\n    sf.writelines(lines)\n\ncall(\'git pull\', shell=True)\ncall(\'git commit -am ""Bump to {}""\'.format(version), shell=True)\ncall(\'git tag {}\'.format(version), shell=True)\ncall(\'git push\', shell=True)\ncall(\'git push --tags\', shell=True)\ncall(\'python setup.py sdist bdist_wheel upload\', shell=True)\n', 'pytest\nmock\npytest-mock\nwheel\n', '[bdist_wheel]\nuniversal = 1\n']","[[<pydriller.domain.commit.Method object at 0x7f1983f4edf0>], [], []]","[[], [], []]"
thefuck,29e70e14a0e08907e79ebee1a90bf0fcbfb6b1ec,Bump to 1.37,2015-05-07 14:16:17+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nVERSION = \'1.36\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\',\n          \'thefuck-alias = thefuck.shells:app_alias\']})\n']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.37\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\',\n          \'thefuck-alias = thefuck.shells:app_alias\']})\n']",[[]],[[]]
thefuck,a395ac568c7d5ccc0627e5cb7b43306359a9a612,"Add the git_checkout rule

It creates a branch before checking-out to it if the branch does not
exist.",2015-05-07 20:32:04+02:00,mcarton,16,0,16,2,"['README.md', 'git_checkout.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_add` &ndash; fix *""Did you forget to \'git add\'?""*;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `composer_not_command` &ndash; fixes composer command name.\n\nBundled, but not enabled by default:\n\n* `ls_lah` &ndash; adds -lah to ls;\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n    \n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call(\'chmod 777 .\', shell=True)\n    \npriority = 1000  # Lower first\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output;\n* `priority` &ndash; dict with rules priorities, rule with lower `priority` will be matched first.\n\nExample of `settings.py`:\n\n```python\nrules = [\'sudo\', \'no_command\']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\npriority = {\'sudo\': 100, \'no_command\': 9999}\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`;\n* `THEFUCK_PRIORITY` &ndash; priority of the rules, like `no_command=9999:apt_get=100`,\nrule with lower `priority` will be matched first.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES=\'sudo:no_command\'\nexport THEFUCK_REQUIRE_CONFIRMATION=\'true\'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS=\'false\'\nexport THEFUCK_PRIORITY=\'no_command=9999:apt_get=100\'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', None]","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_add` &ndash; fix *""Did you forget to \'git add\'?""*;\n* `git_checkout` &ndash; creates the branch before checking-out;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `composer_not_command` &ndash; fixes composer command name.\n\nBundled, but not enabled by default:\n\n* `ls_lah` &ndash; adds -lah to ls;\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n    \n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call(\'chmod 777 .\', shell=True)\n    \npriority = 1000  # Lower first\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output;\n* `priority` &ndash; dict with rules priorities, rule with lower `priority` will be matched first.\n\nExample of `settings.py`:\n\n```python\nrules = [\'sudo\', \'no_command\']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\npriority = {\'sudo\': 100, \'no_command\': 9999}\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`;\n* `THEFUCK_PRIORITY` &ndash; priority of the rules, like `no_command=9999:apt_get=100`,\nrule with lower `priority` will be matched first.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES=\'sudo:no_command\'\nexport THEFUCK_REQUIRE_CONFIRMATION=\'true\'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS=\'false\'\nexport THEFUCK_PRIORITY=\'no_command=9999:apt_get=100\'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', 'import re\n\n\ndef match(command, settings):\n    return (\'git\' in command.script\n            and \'did not match any file(s) known to git.\' in command.stderr\n            and ""Did you forget to \'git add\'?"" not in command.stderr)\n\n\ndef get_new_command(command, settings):\n    missing_file = re.findall(\n            r""error: pathspec \'([^\']*)\' ""\n            ""did not match any file\\(s\\) known to git."", command.stderr)[0]\n\n    return \'git branch {} && {}\'.format(missing_file, command.script)\n']","[[], []]","[[], [<pydriller.domain.commit.Method object at 0x7f198290c3a0>, <pydriller.domain.commit.Method object at 0x7f198290c5b0>]]"
thefuck,793e8830739f719351bb6da808916eac86014afe,add man_no_space command,2015-05-08 00:15:32+05:30,SanketDG,9,0,9,1,['man_no_space.py'],[None],"[""def match(command, settings):\n    return (command.script.startswith(u'man')\n            and u'command not found' in command.stderr.lower())\n\n\ndef get_new_command(command, settings):\n    return u'man {}'.format(command.script[3:])\n\npriority = 2000\n""]",[[]],"[[<pydriller.domain.commit.Method object at 0x7f19828b07f0>, <pydriller.domain.commit.Method object at 0x7f19828b03d0>]]"
thefuck,65aeea857ef3e4934e25f5eb2675abe4520a7d77,add tests for man_no_space,2015-05-08 00:15:57+05:30,SanketDG,12,0,12,1,['test_man_no_space.py'],[None],"[""from thefuck.rules.man_no_space import match, get_new_command\nfrom tests.utils import Command\n\n\ndef test_match():\n    assert match(Command('mandiff', stderr='mandiff: command not found'), None)\n    assert not match(Command(), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(\n        Command('mandiff'), None) == 'man diff'\n""]",[[]],"[[<pydriller.domain.commit.Method object at 0x7f19828b0910>, <pydriller.domain.commit.Method object at 0x7f19828b0160>]]"
thefuck,932a7c5db5e63735ba5e3dcc77d24a95284810bd,Add a don't repeat yourself rule,2015-05-08 01:49:47+02:00,mcarton,13,0,13,2,"['README.md', 'dry.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_add` &ndash; fix *""Did you forget to \'git add\'?""*;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `composer_not_command` &ndash; fixes composer command name.\n\nBundled, but not enabled by default:\n\n* `ls_lah` &ndash; adds -lah to ls;\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n    \n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call(\'chmod 777 .\', shell=True)\n    \npriority = 1000  # Lower first\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output;\n* `priority` &ndash; dict with rules priorities, rule with lower `priority` will be matched first.\n\nExample of `settings.py`:\n\n```python\nrules = [\'sudo\', \'no_command\']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\npriority = {\'sudo\': 100, \'no_command\': 9999}\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`;\n* `THEFUCK_PRIORITY` &ndash; priority of the rules, like `no_command=9999:apt_get=100`,\nrule with lower `priority` will be matched first.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES=\'sudo:no_command\'\nexport THEFUCK_REQUIRE_CONFIRMATION=\'true\'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS=\'false\'\nexport THEFUCK_PRIORITY=\'no_command=9999:apt_get=100\'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', None]","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `dry` &ndash; fix repetitions like ""git git push"";\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_add` &ndash; fix *""Did you forget to \'git add\'?""*;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `composer_not_command` &ndash; fixes composer command name.\n\nBundled, but not enabled by default:\n\n* `ls_lah` &ndash; adds -lah to ls;\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n    \n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call(\'chmod 777 .\', shell=True)\n    \npriority = 1000  # Lower first\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output;\n* `priority` &ndash; dict with rules priorities, rule with lower `priority` will be matched first.\n\nExample of `settings.py`:\n\n```python\nrules = [\'sudo\', \'no_command\']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\npriority = {\'sudo\': 100, \'no_command\': 9999}\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`;\n* `THEFUCK_PRIORITY` &ndash; priority of the rules, like `no_command=9999:apt_get=100`,\nrule with lower `priority` will be matched first.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES=\'sudo:no_command\'\nexport THEFUCK_REQUIRE_CONFIRMATION=\'true\'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS=\'false\'\nexport THEFUCK_PRIORITY=\'no_command=9999:apt_get=100\'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', 'def match(command, settings):\n    split_command = command.script.split()\n\n    return len(split_command) >= 2 and split_command[0] == split_command[1]\n\n\ndef get_new_command(command, settings):\n    return command.script[command.script.find(\' \'):]\n\n# it should be rare enough to actually have to type twice the same word, so\n# this rule can have a higher priority to come before things like ""cd cd foo""\npriority = 900\n']","[[], []]","[[], [<pydriller.domain.commit.Method object at 0x7f19828b0e20>, <pydriller.domain.commit.Method object at 0x7f19828b0c40>]]"
thefuck,56f636f3d8efbabb0942dd751f567484c67f3fbe,Remove unnecessary space in the DRY rule,2015-05-08 11:41:26+02:00,mcarton,1,1,2,1,['dry.py'],"['def match(command, settings):\n    split_command = command.script.split()\n\n    return len(split_command) >= 2 and split_command[0] == split_command[1]\n\n\ndef get_new_command(command, settings):\n    return command.script[command.script.find(\' \'):]\n\n# it should be rare enough to actually have to type twice the same word, so\n# this rule can have a higher priority to come before things like ""cd cd foo""\npriority = 900\n']","['def match(command, settings):\n    split_command = command.script.split()\n\n    return len(split_command) >= 2 and split_command[0] == split_command[1]\n\n\ndef get_new_command(command, settings):\n    return command.script[command.script.find(\' \')+1:]\n\n# it should be rare enough to actually have to type twice the same word, so\n# this rule can have a higher priority to come before things like ""cd cd foo""\npriority = 900\n']","[[<pydriller.domain.commit.Method object at 0x7f19828b01c0>, <pydriller.domain.commit.Method object at 0x7f19828b0250>]]",[[<pydriller.domain.commit.Method object at 0x7f19828b08e0>]]
thefuck,95007220fbe4c5554a92b2b688fb9724ec949ebd,Add a test for the DRY rule,2015-05-08 11:42:00+02:00,mcarton,17,0,17,1,['test_dry.py'],[None],"[""import pytest\nfrom thefuck.rules.dry import match, get_new_command\nfrom tests.utils import Command\n\n\n@pytest.mark.parametrize('command', [\n    Command(script='cd cd foo'),\n    Command(script='git git push origin/master')])\ndef test_match(command):\n    assert match(command, None)\n\n\n@pytest.mark.parametrize('command, new_command', [\n    (Command('cd cd foo'), 'cd foo'),\n    (Command('git git push origin/master'), 'git push origin/master')])\ndef test_get_new_command(command, new_command):\n    assert get_new_command(command, None) == new_command\n""]",[[]],"[[<pydriller.domain.commit.Method object at 0x7f19828b9250>, <pydriller.domain.commit.Method object at 0x7f19828b9400>]]"
thefuck,f082ba829fadd26e5528338a0ada15cd3ce14404,Bump to 1.38,2015-05-08 15:27:33+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nVERSION = \'1.37\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\',\n          \'thefuck-alias = thefuck.shells:app_alias\']})\n']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.38\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\',\n          \'thefuck-alias = thefuck.shells:app_alias\']})\n']",[[]],[[]]
thefuck,690729d5a15ebb105ca9fadb383549e3c8d0356f,#176 Fix fails with wrong aliases,2015-05-09 18:53:36+02:00,nvbn,2,2,4,1,['shells.py'],"['""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias` and `put_to_history`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\nfrom .utils import DEVNULL\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n\nclass Bash(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Zsh(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'zsh\': Zsh()})\n\n\ndef _get_shell():\n    shell = Process(os.getpid()).parent().cmdline()[0]\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    return _get_shell().app_alias()\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n']","['""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias` and `put_to_history`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\nfrom .utils import DEVNULL\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n\nclass Bash(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Zsh(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'zsh\': Zsh()})\n\n\ndef _get_shell():\n    shell = Process(os.getpid()).parent().cmdline()[0]\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    return _get_shell().app_alias()\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n']","[[<pydriller.domain.commit.Method object at 0x7f1983f55880>, <pydriller.domain.commit.Method object at 0x7f1983f55d90>, <pydriller.domain.commit.Method object at 0x7f1983f55730>, <pydriller.domain.commit.Method object at 0x7f1983f55ac0>, <pydriller.domain.commit.Method object at 0x7f1983f55490>, <pydriller.domain.commit.Method object at 0x7f1983f55370>, <pydriller.domain.commit.Method object at 0x7f1983f552e0>, <pydriller.domain.commit.Method object at 0x7f1983f553d0>, <pydriller.domain.commit.Method object at 0x7f1983f55310>, <pydriller.domain.commit.Method object at 0x7f1983f55160>, <pydriller.domain.commit.Method object at 0x7f1983f55190>, <pydriller.domain.commit.Method object at 0x7f1983f55250>, <pydriller.domain.commit.Method object at 0x7f1983f55220>, <pydriller.domain.commit.Method object at 0x7f1983f551f0>, <pydriller.domain.commit.Method object at 0x7f1983f55040>, <pydriller.domain.commit.Method object at 0x7f1983f55070>, <pydriller.domain.commit.Method object at 0x7f1983f551c0>, <pydriller.domain.commit.Method object at 0x7f1983f550a0>, <pydriller.domain.commit.Method object at 0x7f1983f5a160>, <pydriller.domain.commit.Method object at 0x7f1983f5a190>, <pydriller.domain.commit.Method object at 0x7f1983f5a1f0>]]",[[<pydriller.domain.commit.Method object at 0x7f1983fc9220>]]
thefuck,f477cd69c250a4d4a9f5fb714c719f0170aacac8,Bump to 1.39,2015-05-09 18:53:49+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nVERSION = \'1.38\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\',\n          \'thefuck-alias = thefuck.shells:app_alias\']})\n']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.39\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\',\n          \'thefuck-alias = thefuck.shells:app_alias\']})\n']",[[]],[[]]
thefuck,c749615ad6184976e2bbdf537209a446e01c7eab,Add a `C++11` rule,2015-05-09 20:37:13+02:00,mcarton,11,0,11,1,['c++11.py'],[None],"[""def match(command, settings):\n    return (('g++' in command.script or 'clang++' in command.script) and\n            ('This file requires compiler and library support for the '\n             'ISO C++ 2011 standard.' in command.stderr or\n             '-Wc++11-extensions' in command.stderr\n            )\n           )\n\n\ndef get_new_command(command, settings):\n    return command.script + ' -std=c++11'\n""]",[[]],"[[<pydriller.domain.commit.Method object at 0x7f1983f5a730>, <pydriller.domain.commit.Method object at 0x7f1983f5a5b0>]]"
thefuck,6cdc2c27fb98b2989ae34c9c508ca30a5e3459ef,#179 /c++1/cpp11/s,2015-05-10 09:35:02+02:00,nvbn,2,4,6,2,"['README.md', 'cpp11.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `c++11` &ndash; add missing `-std=c++11` to `g++` or `clang++`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `dry` &ndash; fix repetitions like ""git git push"";\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_add` &ndash; fix *""Did you forget to \'git add\'?""*;\n* `git_checkout` &ndash; creates the branch before checking-out;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `man_no_space` &ndash; fixes man commands without spaces, for example `mandiff`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `composer_not_command` &ndash; fixes composer command name.\n\nBundled, but not enabled by default:\n\n* `ls_lah` &ndash; adds -lah to ls;\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n\n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call(\'chmod 777 .\', shell=True)\n\npriority = 1000  # Lower first\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output;\n* `priority` &ndash; dict with rules priorities, rule with lower `priority` will be matched first.\n\nExample of `settings.py`:\n\n```python\nrules = [\'sudo\', \'no_command\']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\npriority = {\'sudo\': 100, \'no_command\': 9999}\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`;\n* `THEFUCK_PRIORITY` &ndash; priority of the rules, like `no_command=9999:apt_get=100`,\nrule with lower `priority` will be matched first.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES=\'sudo:no_command\'\nexport THEFUCK_REQUIRE_CONFIRMATION=\'true\'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS=\'false\'\nexport THEFUCK_PRIORITY=\'no_command=9999:apt_get=100\'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""def match(command, settings):\n    return (('g++' in command.script or 'clang++' in command.script) and\n            ('This file requires compiler and library support for the '\n             'ISO C++ 2011 standard.' in command.stderr or\n             '-Wc++11-extensions' in command.stderr\n            )\n           )\n\n\ndef get_new_command(command, settings):\n    return command.script + ' -std=c++11'\n""]","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run changed command, there\'s `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match rule for the previous command, create new command\nusing matched rule and run it. Rules enabled by default:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cpp11` &ndash; add missing `-std=c++11` to `g++` or `clang++`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `dry` &ndash; fix repetitions like ""git git push"";\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_add` &ndash; fix *""Did you forget to \'git add\'?""*;\n* `git_checkout` &ndash; creates the branch before checking-out;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `man_no_space` &ndash; fixes man commands without spaces, for example `mandiff`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `composer_not_command` &ndash; fixes composer command name.\n\nBundled, but not enabled by default:\n\n* `ls_lah` &ndash; adds -lah to ls;\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n\n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call(\'chmod 777 .\', shell=True)\n\npriority = 1000  # Lower first\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters, they can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; require confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output;\n* `priority` &ndash; dict with rules priorities, rule with lower `priority` will be matched first.\n\nExample of `settings.py`:\n\n```python\nrules = [\'sudo\', \'no_command\']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\npriority = {\'sudo\': 100, \'no_command\': 9999}\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`;\n* `THEFUCK_PRIORITY` &ndash; priority of the rules, like `no_command=9999:apt_get=100`,\nrule with lower `priority` will be matched first.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES=\'sudo:no_command\'\nexport THEFUCK_REQUIRE_CONFIRMATION=\'true\'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS=\'false\'\nexport THEFUCK_PRIORITY=\'no_command=9999:apt_get=100\'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""def match(command, settings):\n    return (('g++' in command.script or 'clang++' in command.script) and\n            ('This file requires compiler and library support for the '\n             'ISO C++ 2011 standard.' in command.stderr or\n             '-Wc++11-extensions' in command.stderr))\n\n\ndef get_new_command(command, settings):\n    return command.script + ' -std=c++11'\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f1982907a60>, <pydriller.domain.commit.Method object at 0x7f1982907700>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983f4ec10>]]"
thefuck,64318c09b728e1bf45fd9c431139812d41bab917,#161 support different psutils versions,2015-05-11 14:16:23+02:00,nvbn,4,1,5,1,['shells.py'],"['""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias` and `put_to_history`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\nfrom .utils import DEVNULL\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n\nclass Bash(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Zsh(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'zsh\': Zsh()})\n\n\ndef _get_shell():\n    shell = Process(os.getpid()).parent().cmdline()[0]\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    return _get_shell().app_alias()\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n']","['""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias` and `put_to_history`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\nfrom .utils import DEVNULL\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n\nclass Bash(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Zsh(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'zsh\': Zsh()})\n\n\ndef _get_shell():\n    try:\n        shell = Process(os.getpid()).parent().cmdline()[0]\n    except TypeError:\n        shell = Process(os.getpid()).parent.cmdline[0]\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    return _get_shell().app_alias()\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n']","[[<pydriller.domain.commit.Method object at 0x7f1982907640>, <pydriller.domain.commit.Method object at 0x7f1982907df0>, <pydriller.domain.commit.Method object at 0x7f1982907cd0>, <pydriller.domain.commit.Method object at 0x7f1983f4ef40>, <pydriller.domain.commit.Method object at 0x7f1983f4e970>, <pydriller.domain.commit.Method object at 0x7f1983f4e940>, <pydriller.domain.commit.Method object at 0x7f1983f4eac0>, <pydriller.domain.commit.Method object at 0x7f1983f4ec40>, <pydriller.domain.commit.Method object at 0x7f1983f4e040>, <pydriller.domain.commit.Method object at 0x7f1983f4ea90>, <pydriller.domain.commit.Method object at 0x7f1983f4eca0>, <pydriller.domain.commit.Method object at 0x7f1983f4ed30>, <pydriller.domain.commit.Method object at 0x7f1983f4e730>, <pydriller.domain.commit.Method object at 0x7f1983f4e1c0>, <pydriller.domain.commit.Method object at 0x7f1983f4e7f0>, <pydriller.domain.commit.Method object at 0x7f1983f4ec70>, <pydriller.domain.commit.Method object at 0x7f1983f4ed90>, <pydriller.domain.commit.Method object at 0x7f1983f4e850>, <pydriller.domain.commit.Method object at 0x7f1983f4efd0>, <pydriller.domain.commit.Method object at 0x7f1983f4e490>, <pydriller.domain.commit.Method object at 0x7f1983f4ed60>]]",[[<pydriller.domain.commit.Method object at 0x7f19828b93d0>]]
thefuck,0fc7c00e8dd5b90054b5b0d41c1c25239c18c878,Bump to 1.40,2015-05-11 14:16:59+02:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nVERSION = \'1.39\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\',\n          \'thefuck-alias = thefuck.shells:app_alias\']})\n']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.40\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\',\n          \'thefuck-alias = thefuck.shells:app_alias\']})\n']",[[]],[[]]
thefuck,484a53e314356985f0ba9c3215077bcf45a0ff23,"fix(brew_unknown_command): make subprocess.check_output return str

Fix `TypeError: can't concat bytes to str` error on Python 3.4.

Signed-off-by: Pablo Santiago Blum de Aguiar <scorphus@gmail.com>",2015-05-11 23:58:53-03:00,Pablo Santiago Blum de Aguiar,2,1,3,1,['brew_unknown_command.py'],"['import difflib\nimport os\nimport re\nimport subprocess\n\n\nBREW_CMD_PATH = \'/Library/Homebrew/cmd\'\nTAP_PATH = \'/Library/Taps\'\nTAP_CMD_PATH = \'/%s/%s/cmd\'\n\n\ndef _get_brew_path_prefix():\n    """"""To get brew path""""""\n    try:\n        return subprocess.check_output([\'brew\', \'--prefix\']).strip()\n    except:\n        return None\n\n\ndef _get_brew_commands(brew_path_prefix):\n    """"""To get brew default commands on local environment""""""\n    brew_cmd_path = brew_path_prefix + BREW_CMD_PATH\n\n    commands = [name.replace(\'.rb\', \'\') for name in os.listdir(brew_cmd_path)\n                if name.endswith(\'.rb\')]\n\n    return commands\n\n\ndef _get_brew_tap_specific_commands(brew_path_prefix):\n    """"""To get tap\'s specific commands\n    https://github.com/Homebrew/homebrew/blob/master/Library/brew.rb#L115""""""\n    commands = []\n    brew_taps_path = brew_path_prefix + TAP_PATH\n\n    for user in _get_directory_names_only(brew_taps_path):\n        taps = _get_directory_names_only(brew_taps_path + \'/%s\' % user)\n\n        # Brew Taps\'s naming rule\n        # https://github.com/Homebrew/homebrew/blob/master/share/doc/homebrew/brew-tap.md#naming-conventions-and-limitations\n        taps = (tap for tap in taps if tap.startswith(\'homebrew-\'))\n        for tap in taps:\n            tap_cmd_path = brew_taps_path + TAP_CMD_PATH % (user, tap)\n\n            if os.path.isdir(tap_cmd_path):\n                commands += (name.replace(\'brew-\', \'\').replace(\'.rb\', \'\')\n                             for name in os.listdir(tap_cmd_path)\n                             if _is_brew_tap_cmd_naming(name))\n\n    return commands\n\n\ndef _is_brew_tap_cmd_naming(name):\n    if name.startswith(\'brew-\') and name.endswith(\'.rb\'):\n        return True\n\n    return False\n\n\ndef _get_directory_names_only(path):\n    return [d for d in os.listdir(path)\n            if os.path.isdir(os.path.join(path, d))]\n\n\nbrew_path_prefix = _get_brew_path_prefix()\n\n# Failback commands for testing (Based on Homebrew 0.9.5)\nbrew_commands = [\'info\', \'home\', \'options\', \'install\', \'uninstall\',\n                 \'search\', \'list\', \'update\', \'upgrade\', \'pin\', \'unpin\',\n                 \'doctor\', \'create\', \'edit\']\n\nif brew_path_prefix:\n    try:\n        brew_commands = _get_brew_commands(brew_path_prefix) \\\n                        + _get_brew_tap_specific_commands(brew_path_prefix)\n    except OSError:\n        pass\n\n\ndef _get_similar_commands(command):\n    return difflib.get_close_matches(command, brew_commands)\n\n\ndef match(command, settings):\n    is_proper_command = (\'brew\' in command.script and\n                         \'Unknown command\' in command.stderr)\n\n    has_possible_commands = False\n    if is_proper_command:\n        broken_cmd = re.findall(r\'Error: Unknown command: ([a-z]+)\',\n                                command.stderr)[0]\n        has_possible_commands = len(_get_similar_commands(broken_cmd)) > 0\n\n    return has_possible_commands\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r\'Error: Unknown command: ([a-z]+)\',\n                            command.stderr)[0]\n    new_cmd = _get_similar_commands(broken_cmd)[0]\n\n    return command.script.replace(broken_cmd, new_cmd, 1)\n']","['import difflib\nimport os\nimport re\nimport subprocess\n\n\nBREW_CMD_PATH = \'/Library/Homebrew/cmd\'\nTAP_PATH = \'/Library/Taps\'\nTAP_CMD_PATH = \'/%s/%s/cmd\'\n\n\ndef _get_brew_path_prefix():\n    """"""To get brew path""""""\n    try:\n        return subprocess.check_output([\'brew\', \'--prefix\'],\n                                       universal_newlines=True).strip()\n    except:\n        return None\n\n\ndef _get_brew_commands(brew_path_prefix):\n    """"""To get brew default commands on local environment""""""\n    brew_cmd_path = brew_path_prefix + BREW_CMD_PATH\n\n    commands = [name.replace(\'.rb\', \'\') for name in os.listdir(brew_cmd_path)\n                if name.endswith(\'.rb\')]\n\n    return commands\n\n\ndef _get_brew_tap_specific_commands(brew_path_prefix):\n    """"""To get tap\'s specific commands\n    https://github.com/Homebrew/homebrew/blob/master/Library/brew.rb#L115""""""\n    commands = []\n    brew_taps_path = brew_path_prefix + TAP_PATH\n\n    for user in _get_directory_names_only(brew_taps_path):\n        taps = _get_directory_names_only(brew_taps_path + \'/%s\' % user)\n\n        # Brew Taps\'s naming rule\n        # https://github.com/Homebrew/homebrew/blob/master/share/doc/homebrew/brew-tap.md#naming-conventions-and-limitations\n        taps = (tap for tap in taps if tap.startswith(\'homebrew-\'))\n        for tap in taps:\n            tap_cmd_path = brew_taps_path + TAP_CMD_PATH % (user, tap)\n\n            if os.path.isdir(tap_cmd_path):\n                commands += (name.replace(\'brew-\', \'\').replace(\'.rb\', \'\')\n                             for name in os.listdir(tap_cmd_path)\n                             if _is_brew_tap_cmd_naming(name))\n\n    return commands\n\n\ndef _is_brew_tap_cmd_naming(name):\n    if name.startswith(\'brew-\') and name.endswith(\'.rb\'):\n        return True\n\n    return False\n\n\ndef _get_directory_names_only(path):\n    return [d for d in os.listdir(path)\n            if os.path.isdir(os.path.join(path, d))]\n\n\nbrew_path_prefix = _get_brew_path_prefix()\n\n# Failback commands for testing (Based on Homebrew 0.9.5)\nbrew_commands = [\'info\', \'home\', \'options\', \'install\', \'uninstall\',\n                 \'search\', \'list\', \'update\', \'upgrade\', \'pin\', \'unpin\',\n                 \'doctor\', \'create\', \'edit\']\n\nif brew_path_prefix:\n    try:\n        brew_commands = _get_brew_commands(brew_path_prefix) \\\n                        + _get_brew_tap_specific_commands(brew_path_prefix)\n    except OSError:\n        pass\n\n\ndef _get_similar_commands(command):\n    return difflib.get_close_matches(command, brew_commands)\n\n\ndef match(command, settings):\n    is_proper_command = (\'brew\' in command.script and\n                         \'Unknown command\' in command.stderr)\n\n    has_possible_commands = False\n    if is_proper_command:\n        broken_cmd = re.findall(r\'Error: Unknown command: ([a-z]+)\',\n                                command.stderr)[0]\n        has_possible_commands = len(_get_similar_commands(broken_cmd)) > 0\n\n    return has_possible_commands\n\n\ndef get_new_command(command, settings):\n    broken_cmd = re.findall(r\'Error: Unknown command: ([a-z]+)\',\n                            command.stderr)[0]\n    new_cmd = _get_similar_commands(broken_cmd)[0]\n\n    return command.script.replace(broken_cmd, new_cmd, 1)\n']","[[<pydriller.domain.commit.Method object at 0x7f1983f5a3d0>, <pydriller.domain.commit.Method object at 0x7f1983f5a1c0>, <pydriller.domain.commit.Method object at 0x7f1983f5a760>, <pydriller.domain.commit.Method object at 0x7f1983f5a8b0>, <pydriller.domain.commit.Method object at 0x7f1983cf66a0>, <pydriller.domain.commit.Method object at 0x7f1983cf6190>, <pydriller.domain.commit.Method object at 0x7f1983cf6df0>, <pydriller.domain.commit.Method object at 0x7f1983cf6c70>]]",[[<pydriller.domain.commit.Method object at 0x7f1983f5a5e0>]]
thefuck,7489040f8fc1332e5609b48a2707a212f9532b0e,fix thefuck-alias,2015-05-12 14:29:00+05:30,SanketDG,1,1,2,1,['shells.py'],"['""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias` and `put_to_history`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\nfrom .utils import DEVNULL\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n\nclass Bash(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Zsh(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'zsh\': Zsh()})\n\n\ndef _get_shell():\n    try:\n        shell = Process(os.getpid()).parent().cmdline()[0]\n    except TypeError:\n        shell = Process(os.getpid()).parent.cmdline[0]\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    return _get_shell().app_alias()\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n']","['""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias` and `put_to_history`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\nfrom .utils import DEVNULL\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        print ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n\nclass Bash(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Zsh(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'zsh\': Zsh()})\n\n\ndef _get_shell():\n    try:\n        shell = Process(os.getpid()).parent().cmdline()[0]\n    except TypeError:\n        shell = Process(os.getpid()).parent.cmdline[0]\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    return _get_shell().app_alias()\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n']","[[<pydriller.domain.commit.Method object at 0x7f198290ce80>, <pydriller.domain.commit.Method object at 0x7f198290c430>, <pydriller.domain.commit.Method object at 0x7f198290c2e0>, <pydriller.domain.commit.Method object at 0x7f198290cb20>, <pydriller.domain.commit.Method object at 0x7f19828b0b20>, <pydriller.domain.commit.Method object at 0x7f19828b08b0>, <pydriller.domain.commit.Method object at 0x7f19828b0940>, <pydriller.domain.commit.Method object at 0x7f19828b0460>, <pydriller.domain.commit.Method object at 0x7f19828b0eb0>, <pydriller.domain.commit.Method object at 0x7f19828b0df0>, <pydriller.domain.commit.Method object at 0x7f19828b0be0>, <pydriller.domain.commit.Method object at 0x7f19828b0d30>, <pydriller.domain.commit.Method object at 0x7f19828b0820>, <pydriller.domain.commit.Method object at 0x7f19828b09d0>, <pydriller.domain.commit.Method object at 0x7f19828b0850>, <pydriller.domain.commit.Method object at 0x7f19828b0c70>, <pydriller.domain.commit.Method object at 0x7f19828b0a90>, <pydriller.domain.commit.Method object at 0x7f19828b0ca0>, <pydriller.domain.commit.Method object at 0x7f19828b09a0>, <pydriller.domain.commit.Method object at 0x7f19828b0730>, <pydriller.domain.commit.Method object at 0x7f19828b0bb0>]]",[[<pydriller.domain.commit.Method object at 0x7f1983fc9820>]]
thefuck,e8de4ee7e88173954e2e397e253ac484b8751397,#185 Fix python 3,2015-05-12 14:22:20+02:00,nvbn,2,2,4,1,['shells.py'],"['""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias` and `put_to_history`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\nfrom .utils import DEVNULL\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        print ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n\nclass Bash(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Zsh(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'zsh\': Zsh()})\n\n\ndef _get_shell():\n    try:\n        shell = Process(os.getpid()).parent().cmdline()[0]\n    except TypeError:\n        shell = Process(os.getpid()).parent.cmdline[0]\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    return _get_shell().app_alias()\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n']","['""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias` and `put_to_history`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\nfrom .utils import DEVNULL\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n\nclass Bash(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Zsh(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'zsh\': Zsh()})\n\n\ndef _get_shell():\n    try:\n        shell = Process(os.getpid()).parent().cmdline()[0]\n    except TypeError:\n        shell = Process(os.getpid()).parent.cmdline[0]\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    print(_get_shell().app_alias())\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n']","[[<pydriller.domain.commit.Method object at 0x7f19828b9bb0>, <pydriller.domain.commit.Method object at 0x7f19828b9a90>, <pydriller.domain.commit.Method object at 0x7f19828b9be0>, <pydriller.domain.commit.Method object at 0x7f19828b9c10>, <pydriller.domain.commit.Method object at 0x7f19828cb070>, <pydriller.domain.commit.Method object at 0x7f19828cb0a0>, <pydriller.domain.commit.Method object at 0x7f19828cb0d0>, <pydriller.domain.commit.Method object at 0x7f19828cb100>, <pydriller.domain.commit.Method object at 0x7f19828cb130>, <pydriller.domain.commit.Method object at 0x7f19828cb160>, <pydriller.domain.commit.Method object at 0x7f19828cb190>, <pydriller.domain.commit.Method object at 0x7f19828cb1c0>, <pydriller.domain.commit.Method object at 0x7f19828cb1f0>, <pydriller.domain.commit.Method object at 0x7f19828cb220>, <pydriller.domain.commit.Method object at 0x7f19828cb250>, <pydriller.domain.commit.Method object at 0x7f19828cb280>, <pydriller.domain.commit.Method object at 0x7f19828cb2b0>, <pydriller.domain.commit.Method object at 0x7f19828cb2e0>, <pydriller.domain.commit.Method object at 0x7f19828cb310>, <pydriller.domain.commit.Method object at 0x7f19828cb340>, <pydriller.domain.commit.Method object at 0x7f19828cb370>]]","[[<pydriller.domain.commit.Method object at 0x7f19828b9af0>, <pydriller.domain.commit.Method object at 0x7f19828b90d0>]]"
thefuck,8ac4dafe6d89f0d405ca4acad140d75482a00dc4,Add a git_stash rule,2015-05-12 19:44:52+02:00,mcarton,8,0,8,2,"['README.md', 'git_stash.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run the changed command, there is a `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to the `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match a rule for the previous command, creates a new command\nusing the matched rule and runs it. Rules enabled by default are as follows:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cpp11` &ndash; add missing `-std=c++11` to `g++` or `clang++`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `dry` &ndash; fix repetitions like ""git git push"";\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_add` &ndash; fix *""Did you forget to \'git add\'?""*;\n* `git_checkout` &ndash; creates the branch before checking-out;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `man_no_space` &ndash; fixes man commands without spaces, for example `mandiff`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `composer_not_command` &ndash; fixes composer command name.\n\nBundled, but not enabled by default:\n\n* `ls_lah` &ndash; adds -lah to ls;\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n\n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call(\'chmod 777 .\', shell=True)\n\npriority = 1000  # Lower first\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters which can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; requires confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output;\n* `priority` &ndash; dict with rules priorities, rule with lower `priority` will be matched first.\n\nExample of `settings.py`:\n\n```python\nrules = [\'sudo\', \'no_command\']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\npriority = {\'sudo\': 100, \'no_command\': 9999}\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`;\n* `THEFUCK_PRIORITY` &ndash; priority of the rules, like `no_command=9999:apt_get=100`,\nrule with lower `priority` will be matched first.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES=\'sudo:no_command\'\nexport THEFUCK_REQUIRE_CONFIRMATION=\'true\'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS=\'false\'\nexport THEFUCK_PRIORITY=\'no_command=9999:apt_get=100\'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', None]","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run the changed command, there is a `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to the `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match a rule for the previous command, creates a new command\nusing the matched rule and runs it. Rules enabled by default are as follows:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cpp11` &ndash; add missing `-std=c++11` to `g++` or `clang++`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `dry` &ndash; fix repetitions like ""git git push"";\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_add` &ndash; fix *""Did you forget to \'git add\'?""*;\n* `git_checkout` &ndash; creates the branch before checking-out;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `git_stash` &ndash; stashes you local modifications before rebase;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `man_no_space` &ndash; fixes man commands without spaces, for example `mandiff`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `composer_not_command` &ndash; fixes composer command name.\n\nBundled, but not enabled by default:\n\n* `ls_lah` &ndash; adds -lah to ls;\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n\n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call(\'chmod 777 .\', shell=True)\n\npriority = 1000  # Lower first\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters which can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; requires confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output;\n* `priority` &ndash; dict with rules priorities, rule with lower `priority` will be matched first.\n\nExample of `settings.py`:\n\n```python\nrules = [\'sudo\', \'no_command\']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\npriority = {\'sudo\': 100, \'no_command\': 9999}\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`;\n* `THEFUCK_PRIORITY` &ndash; priority of the rules, like `no_command=9999:apt_get=100`,\nrule with lower `priority` will be matched first.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES=\'sudo:no_command\'\nexport THEFUCK_REQUIRE_CONFIRMATION=\'true\'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS=\'false\'\nexport THEFUCK_PRIORITY=\'no_command=9999:apt_get=100\'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""def match(command, settings):\n    return ('git' in command.script\n            and 'Please commit or stash them.' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'git stash && ' + command.script\n""]","[[], []]","[[], [<pydriller.domain.commit.Method object at 0x7f1983f55fd0>, <pydriller.domain.commit.Method object at 0x7f1983f55460>]]"
thefuck,65c624ad52ff577cd0b78b34b64130c91c39589f,Improve the git_stash rule,2015-05-13 09:47:31+02:00,mcarton,3,2,5,1,['git_stash.py'],"[""def match(command, settings):\n    return ('git' in command.script\n            and 'Please commit or stash them.' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return 'git stash && ' + command.script\n""]","['def match(command, settings):\n    # catches ""Please commit or stash them"" and ""Please, commit your changes or\n    # stash them before you can switch branches.""\n    return \'git\' in command.script and \'or stash them\' in command.stderr\n\n\ndef get_new_command(command, settings):\n    return \'git stash && \' + command.script\n']","[[<pydriller.domain.commit.Method object at 0x7f1983f5abb0>, <pydriller.domain.commit.Method object at 0x7f1983f5ac10>]]",[[<pydriller.domain.commit.Method object at 0x7f1983f5aee0>]]
thefuck,7b29b54ac7ceffcbff966eb5685dec1f81cf399a,Add initial tcsh support. Still require better history support,2015-05-13 15:55:33+01:00,Hugh Macdonald,31,1,32,2,"['README.md', 'shells.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run the changed command, there is a `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to the `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match a rule for the previous command, creates a new command\nusing the matched rule and runs it. Rules enabled by default are as follows:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cpp11` &ndash; add missing `-std=c++11` to `g++` or `clang++`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `dry` &ndash; fix repetitions like ""git git push"";\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_add` &ndash; fix *""Did you forget to \'git add\'?""*;\n* `git_checkout` &ndash; creates the branch before checking-out;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `git_stash` &ndash; stashes you local modifications before rebasing or switching branch;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `man_no_space` &ndash; fixes man commands without spaces, for example `mandiff`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `composer_not_command` &ndash; fixes composer command name.\n\nBundled, but not enabled by default:\n\n* `ls_lah` &ndash; adds -lah to ls;\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n\n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call(\'chmod 777 .\', shell=True)\n\npriority = 1000  # Lower first\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters which can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; requires confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output;\n* `priority` &ndash; dict with rules priorities, rule with lower `priority` will be matched first.\n\nExample of `settings.py`:\n\n```python\nrules = [\'sudo\', \'no_command\']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\npriority = {\'sudo\': 100, \'no_command\': 9999}\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`;\n* `THEFUCK_PRIORITY` &ndash; priority of the rules, like `no_command=9999:apt_get=100`,\nrule with lower `priority` will be matched first.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES=\'sudo:no_command\'\nexport THEFUCK_REQUIRE_CONFIRMATION=\'true\'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS=\'false\'\nexport THEFUCK_PRIORITY=\'no_command=9999:apt_get=100\'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', '""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias` and `put_to_history`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\nfrom .utils import DEVNULL\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n\nclass Bash(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Zsh(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'zsh\': Zsh()})\n\n\ndef _get_shell():\n    try:\n        shell = Process(os.getpid()).parent().cmdline()[0]\n    except TypeError:\n        shell = Process(os.getpid()).parent.cmdline[0]\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    print(_get_shell().app_alias())\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run the changed command, there is a `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to the `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\n```\n\nIf you are using `tcsh`:\n```tcsh\nalias fuck \'set fuckedCmd=`history -h 2 | head -n 1` && eval `thefuck ${fuckedCmd}`\'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match a rule for the previous command, creates a new command\nusing the matched rule and runs it. Rules enabled by default are as follows:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cpp11` &ndash; add missing `-std=c++11` to `g++` or `clang++`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `dry` &ndash; fix repetitions like ""git git push"";\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_add` &ndash; fix *""Did you forget to \'git add\'?""*;\n* `git_checkout` &ndash; creates the branch before checking-out;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `git_stash` &ndash; stashes you local modifications before rebasing or switching branch;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `man_no_space` &ndash; fixes man commands without spaces, for example `mandiff`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `composer_not_command` &ndash; fixes composer command name.\n\nBundled, but not enabled by default:\n\n* `ls_lah` &ndash; adds -lah to ls;\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n\n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call(\'chmod 777 .\', shell=True)\n\npriority = 1000  # Lower first\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters which can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; requires confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output;\n* `priority` &ndash; dict with rules priorities, rule with lower `priority` will be matched first.\n\nExample of `settings.py`:\n\n```python\nrules = [\'sudo\', \'no_command\']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\npriority = {\'sudo\': 100, \'no_command\': 9999}\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`;\n* `THEFUCK_PRIORITY` &ndash; priority of the rules, like `no_command=9999:apt_get=100`,\nrule with lower `priority` will be matched first.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES=\'sudo:no_command\'\nexport THEFUCK_REQUIRE_CONFIRMATION=\'true\'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS=\'false\'\nexport THEFUCK_PRIORITY=\'no_command=9999:apt_get=100\'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', '""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias` and `put_to_history`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\nfrom .utils import DEVNULL\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n\nclass Bash(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Zsh(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nclass Tcsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(""\\t"", 1)\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'tcsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'\\t\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'#+{}\\n{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'zsh\': Zsh(),\n    \'-csh\': Tcsh(),\n    \'tcsh\': Tcsh()})\n\n\ndef _get_shell():\n    try:\n        shell = Process(os.getpid()).parent().cmdline()[0]\n    except TypeError:\n        shell = Process(os.getpid()).parent.cmdline[0]\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    print(_get_shell().app_alias())\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n']","[[], [<pydriller.domain.commit.Method object at 0x7f19828b91f0>, <pydriller.domain.commit.Method object at 0x7f19828b9a00>, <pydriller.domain.commit.Method object at 0x7f19828b94f0>, <pydriller.domain.commit.Method object at 0x7f19828b9ac0>, <pydriller.domain.commit.Method object at 0x7f19828b9eb0>, <pydriller.domain.commit.Method object at 0x7f19828b9ee0>, <pydriller.domain.commit.Method object at 0x7f19828b9f10>, <pydriller.domain.commit.Method object at 0x7f19828b9f40>, <pydriller.domain.commit.Method object at 0x7f19828b9f70>, <pydriller.domain.commit.Method object at 0x7f19828b9fa0>, <pydriller.domain.commit.Method object at 0x7f19828b9fd0>, <pydriller.domain.commit.Method object at 0x7f19828b9b20>, <pydriller.domain.commit.Method object at 0x7f19828b9460>, <pydriller.domain.commit.Method object at 0x7f19828b9820>, <pydriller.domain.commit.Method object at 0x7f19828b92e0>, <pydriller.domain.commit.Method object at 0x7f19828b9880>, <pydriller.domain.commit.Method object at 0x7f19828b9700>, <pydriller.domain.commit.Method object at 0x7f19828b9370>, <pydriller.domain.commit.Method object at 0x7f19828b93a0>, <pydriller.domain.commit.Method object at 0x7f19828b9340>, <pydriller.domain.commit.Method object at 0x7f19828b96a0>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983f600a0>, <pydriller.domain.commit.Method object at 0x7f1983f601f0>, <pydriller.domain.commit.Method object at 0x7f1983f60160>, <pydriller.domain.commit.Method object at 0x7f1983f600d0>, <pydriller.domain.commit.Method object at 0x7f1983f60190>]]"
thefuck,d2e511fa2c591738ba83cb3ba199536cff709785,"refact(brew_install): remove an unused import

Signed-off-by: Pablo Santiago Blum de Aguiar <scorphus@gmail.com>",2015-05-13 15:53:30-03:00,Pablo Santiago Blum de Aguiar,0,2,2,1,['brew_install.py'],"[""import difflib\nimport os\nimport re\nfrom subprocess import check_output\n\nimport thefuck.logs\n\n# Formulars are base on each local system's status\nbrew_formulas = []\ntry:\n    brew_path_prefix = check_output(['brew', '--prefix']).strip()\n    brew_formula_path = brew_path_prefix + '/Library/Formula'\n\n    for file_name in os.listdir(brew_formula_path):\n        if file_name.endswith('.rb'):\n            brew_formulas.append(file_name.replace('.rb', ''))\nexcept:\n    pass\n\n\ndef _get_similar_formulars(formula_name):\n    return difflib.get_close_matches(formula_name, brew_formulas, 1, 0.85)\n\n\ndef match(command, settings):\n    is_proper_command = ('brew install' in command.script and\n                         'No available formula' in command.stderr)\n\n    has_possible_formulas = False\n    if is_proper_command:\n        formula = re.findall(r'Error: No available formula for ([a-z]+)',\n                             command.stderr)[0]\n        has_possible_formulas = len(_get_similar_formulars(formula)) > 0\n\n    return has_possible_formulas\n\n\ndef get_new_command(command, settings):\n    not_exist_formula = re.findall(r'Error: No available formula for ([a-z]+)',\n                                   command.stderr)[0]\n    exist_formula = _get_similar_formulars(not_exist_formula)[0]\n\n    return command.script.replace(not_exist_formula, exist_formula, 1)\n""]","[""import difflib\nimport os\nimport re\nfrom subprocess import check_output\n\n# Formulars are base on each local system's status\nbrew_formulas = []\ntry:\n    brew_path_prefix = check_output(['brew', '--prefix']).strip()\n    brew_formula_path = brew_path_prefix + '/Library/Formula'\n\n    for file_name in os.listdir(brew_formula_path):\n        if file_name.endswith('.rb'):\n            brew_formulas.append(file_name.replace('.rb', ''))\nexcept:\n    pass\n\n\ndef _get_similar_formulars(formula_name):\n    return difflib.get_close_matches(formula_name, brew_formulas, 1, 0.85)\n\n\ndef match(command, settings):\n    is_proper_command = ('brew install' in command.script and\n                         'No available formula' in command.stderr)\n\n    has_possible_formulas = False\n    if is_proper_command:\n        formula = re.findall(r'Error: No available formula for ([a-z]+)',\n                             command.stderr)[0]\n        has_possible_formulas = len(_get_similar_formulars(formula)) > 0\n\n    return has_possible_formulas\n\n\ndef get_new_command(command, settings):\n    not_exist_formula = re.findall(r'Error: No available formula for ([a-z]+)',\n                                   command.stderr)[0]\n    exist_formula = _get_similar_formulars(not_exist_formula)[0]\n\n    return command.script.replace(not_exist_formula, exist_formula, 1)\n""]","[[<pydriller.domain.commit.Method object at 0x7f1983f644c0>, <pydriller.domain.commit.Method object at 0x7f19828b9550>, <pydriller.domain.commit.Method object at 0x7f19828b94c0>]]",[[]]
thefuck,9cf41f8e439d89d4f8614069e70fa86b3d91be39,"fix(brew_install): make subprocess.check_output return str

This fix makes the `brew_install` rule work on Python 3.

Signed-off-by: Pablo Santiago Blum de Aguiar <scorphus@gmail.com>",2015-05-13 15:53:30-03:00,Pablo Santiago Blum de Aguiar,2,1,3,1,['brew_install.py'],"[""import difflib\nimport os\nimport re\nfrom subprocess import check_output\n\n# Formulars are base on each local system's status\nbrew_formulas = []\ntry:\n    brew_path_prefix = check_output(['brew', '--prefix']).strip()\n    brew_formula_path = brew_path_prefix + '/Library/Formula'\n\n    for file_name in os.listdir(brew_formula_path):\n        if file_name.endswith('.rb'):\n            brew_formulas.append(file_name.replace('.rb', ''))\nexcept:\n    pass\n\n\ndef _get_similar_formulars(formula_name):\n    return difflib.get_close_matches(formula_name, brew_formulas, 1, 0.85)\n\n\ndef match(command, settings):\n    is_proper_command = ('brew install' in command.script and\n                         'No available formula' in command.stderr)\n\n    has_possible_formulas = False\n    if is_proper_command:\n        formula = re.findall(r'Error: No available formula for ([a-z]+)',\n                             command.stderr)[0]\n        has_possible_formulas = len(_get_similar_formulars(formula)) > 0\n\n    return has_possible_formulas\n\n\ndef get_new_command(command, settings):\n    not_exist_formula = re.findall(r'Error: No available formula for ([a-z]+)',\n                                   command.stderr)[0]\n    exist_formula = _get_similar_formulars(not_exist_formula)[0]\n\n    return command.script.replace(not_exist_formula, exist_formula, 1)\n""]","[""import difflib\nimport os\nimport re\nfrom subprocess import check_output\n\n# Formulars are base on each local system's status\nbrew_formulas = []\ntry:\n    brew_path_prefix = check_output(['brew', '--prefix'],\n                                    universal_newlines=True).strip()\n    brew_formula_path = brew_path_prefix + '/Library/Formula'\n\n    for file_name in os.listdir(brew_formula_path):\n        if file_name.endswith('.rb'):\n            brew_formulas.append(file_name.replace('.rb', ''))\nexcept:\n    pass\n\n\ndef _get_similar_formulars(formula_name):\n    return difflib.get_close_matches(formula_name, brew_formulas, 1, 0.85)\n\n\ndef match(command, settings):\n    is_proper_command = ('brew install' in command.script and\n                         'No available formula' in command.stderr)\n\n    has_possible_formulas = False\n    if is_proper_command:\n        formula = re.findall(r'Error: No available formula for ([a-z]+)',\n                             command.stderr)[0]\n        has_possible_formulas = len(_get_similar_formulars(formula)) > 0\n\n    return has_possible_formulas\n\n\ndef get_new_command(command, settings):\n    not_exist_formula = re.findall(r'Error: No available formula for ([a-z]+)',\n                                   command.stderr)[0]\n    exist_formula = _get_similar_formulars(not_exist_formula)[0]\n\n    return command.script.replace(not_exist_formula, exist_formula, 1)\n""]","[[<pydriller.domain.commit.Method object at 0x7f19828b05b0>, <pydriller.domain.commit.Method object at 0x7f1982926ee0>, <pydriller.domain.commit.Method object at 0x7f1982926640>]]",[[]]
thefuck,3c4f9d50a945a13c813884c795c78e8634940cf7,Add a `no_such_file` rule,2015-05-15 18:03:17+02:00,mcarton,27,0,27,2,"['README.md', 'no_such_file.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run the changed command, there is a `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to the `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\n```\n\nIf you are using `tcsh`:\n```tcsh\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match a rule for the previous command, creates a new command\nusing the matched rule and runs it. Rules enabled by default are as follows:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cpp11` &ndash; add missing `-std=c++11` to `g++` or `clang++`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `dry` &ndash; fix repetitions like ""git git push"";\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_add` &ndash; fix *""Did you forget to \'git add\'?""*;\n* `git_checkout` &ndash; creates the branch before checking-out;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `git_stash` &ndash; stashes you local modifications before rebasing or switching branch;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `man_no_space` &ndash; fixes man commands without spaces, for example `mandiff`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `composer_not_command` &ndash; fixes composer command name.\n\nBundled, but not enabled by default:\n\n* `ls_lah` &ndash; adds -lah to ls;\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n\n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call(\'chmod 777 .\', shell=True)\n\npriority = 1000  # Lower first\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters which can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; requires confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output;\n* `priority` &ndash; dict with rules priorities, rule with lower `priority` will be matched first.\n\nExample of `settings.py`:\n\n```python\nrules = [\'sudo\', \'no_command\']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\npriority = {\'sudo\': 100, \'no_command\': 9999}\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`;\n* `THEFUCK_PRIORITY` &ndash; priority of the rules, like `no_command=9999:apt_get=100`,\nrule with lower `priority` will be matched first.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES=\'sudo:no_command\'\nexport THEFUCK_REQUIRE_CONFIRMATION=\'true\'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS=\'false\'\nexport THEFUCK_PRIORITY=\'no_command=9999:apt_get=100\'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', None]","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run the changed command, there is a `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to the `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\n```\n\nIf you are using `tcsh`:\n```tcsh\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match a rule for the previous command, creates a new command\nusing the matched rule and runs it. Rules enabled by default are as follows:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cpp11` &ndash; add missing `-std=c++11` to `g++` or `clang++`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `dry` &ndash; fix repetitions like ""git git push"";\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_add` &ndash; fix *""Did you forget to \'git add\'?""*;\n* `git_checkout` &ndash; creates the branch before checking-out;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `git_stash` &ndash; stashes you local modifications before rebasing or switching branch;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `no_such_file` &ndash; creates missing directories with `mv` and `cp` commands;\n* `man_no_space` &ndash; fixes man commands without spaces, for example `mandiff`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `composer_not_command` &ndash; fixes composer command name.\n\nBundled, but not enabled by default:\n\n* `ls_lah` &ndash; adds -lah to ls;\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n\n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call(\'chmod 777 .\', shell=True)\n\npriority = 1000  # Lower first\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters which can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; requires confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output;\n* `priority` &ndash; dict with rules priorities, rule with lower `priority` will be matched first.\n\nExample of `settings.py`:\n\n```python\nrules = [\'sudo\', \'no_command\']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\npriority = {\'sudo\': 100, \'no_command\': 9999}\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`;\n* `THEFUCK_PRIORITY` &ndash; priority of the rules, like `no_command=9999:apt_get=100`,\nrule with lower `priority` will be matched first.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES=\'sudo:no_command\'\nexport THEFUCK_REQUIRE_CONFIRMATION=\'true\'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS=\'false\'\nexport THEFUCK_PRIORITY=\'no_command=9999:apt_get=100\'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', 'import re\n\n\npatterns = (\n    r""mv: cannot move \'[^\']*\' to \'([^\']*)\': No such file or directory"",\n    r""cp: cannot create regular file \'([^\']*)\': No such file or directory"",\n)\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if re.search(pattern, command.stderr):\n            return True\n\n    return False\n\n\ndef get_new_command(command, settings):\n    for pattern in patterns:\n        file = re.findall(pattern, command.stderr)\n\n        if file:\n            file = file[0]\n            dir = file[0:file.rfind(\'/\')]\n\n            return \'mkdir -p {} && {}\'.format(dir, command.script)\n']","[[], []]","[[], [<pydriller.domain.commit.Method object at 0x7f198290ca60>, <pydriller.domain.commit.Method object at 0x7f198290ceb0>]]"
thefuck,5504aa44a1b47d6533c65c0f5884f11eda06359b,Add tests for the `no_such_file` rule,2015-05-15 18:03:33+02:00,mcarton,19,0,19,1,['test_no_such_file.py'],[None],"['import pytest\nfrom thefuck.rules.no_such_file import match, get_new_command\nfrom tests.utils import Command\n\n\n@pytest.mark.parametrize(\'command\', [\n    Command(script=\'mv foo bar/foo\', stderr=""mv: cannot move \'foo\' to \'bar/foo\': No such file or directory""),\n    Command(script=\'mv foo bar/\', stderr=""mv: cannot move \'foo\' to \'bar/\': No such file or directory""),\n    ])\ndef test_match(command):\n    assert match(command, None)\n\n\n@pytest.mark.parametrize(\'command, new_command\', [\n    (Command(script=\'mv foo bar/foo\', stderr=""mv: cannot move \'foo\' to \'bar/foo\': No such file or directory""), \'mkdir -p bar && mv foo bar/foo\'),\n    (Command(script=\'mv foo bar/\', stderr=""mv: cannot move \'foo\' to \'bar/\': No such file or directory""), \'mkdir -p bar && mv foo bar/\'),\n    ])\ndef test_get_new_command(command, new_command):\n    assert get_new_command(command, None) == new_command\n']",[[]],"[[<pydriller.domain.commit.Method object at 0x7f198290ccd0>, <pydriller.domain.commit.Method object at 0x7f198290cdc0>]]"
thefuck,08a2065119b00f57a12549affd242d7f2e18f9a3,Add missing cases for the `no_such_file` rule,2015-05-15 18:08:43+02:00,mcarton,2,0,2,1,['no_such_file.py'],"['import re\n\n\npatterns = (\n    r""mv: cannot move \'[^\']*\' to \'([^\']*)\': No such file or directory"",\n    r""cp: cannot create regular file \'([^\']*)\': No such file or directory"",\n)\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if re.search(pattern, command.stderr):\n            return True\n\n    return False\n\n\ndef get_new_command(command, settings):\n    for pattern in patterns:\n        file = re.findall(pattern, command.stderr)\n\n        if file:\n            file = file[0]\n            dir = file[0:file.rfind(\'/\')]\n\n            return \'mkdir -p {} && {}\'.format(dir, command.script)\n']","['import re\n\n\npatterns = (\n    r""mv: cannot move \'[^\']*\' to \'([^\']*)\': No such file or directory"",\n    r""mv: cannot move \'[^\']*\' to \'([^\']*)\': Not a directory"",\n    r""cp: cannot create regular file \'([^\']*)\': No such file or directory"",\n    r""cp: cannot create regular file \'([^\']*)\': Not a directory"",\n)\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if re.search(pattern, command.stderr):\n            return True\n\n    return False\n\n\ndef get_new_command(command, settings):\n    for pattern in patterns:\n        file = re.findall(pattern, command.stderr)\n\n        if file:\n            file = file[0]\n            dir = file[0:file.rfind(\'/\')]\n\n            return \'mkdir -p {} && {}\'.format(dir, command.script)\n']","[[<pydriller.domain.commit.Method object at 0x7f19828b0f40>, <pydriller.domain.commit.Method object at 0x7f19828b0ee0>]]",[[]]
thefuck,744f17d9055d55b87e55eab1c5aa4a0cc910b313,Add a `whois` rule,2015-05-15 18:41:55+02:00,mcarton,30,0,30,1,['whois.py'],[None],"['from urllib.parse import urlparse\n\n\ndef match(command, settings):\n    """"""\n    What the `whois` command returns depends on the \'Whois server\' it contacted\n    and is not consistent through different servers. But there can be only two\n    types of errors I can think of with `whois`:\n        - `whois https://en.wikipedia.org/` → `whois en.wikipedia.org`;\n        - `whois en.wikipedia.org` → `whois wikipedia.org`.\n    So we match any `whois` command and then:\n        - if there is a slash: keep only the FQDN;\n        - if there is no slash but there is a point: removes the left-most\n          subdomain.\n\n    We cannot either remove all subdomains because we cannot know which part is\n    the subdomains and which is the domain, consider:\n        - www.google.fr → subdomain: www, domain: \'google.fr\';\n        - google.co.uk → subdomain: None, domain; \'google.co.uk\'.\n    """"""\n    return \'whois\' in command.script\n\n\ndef get_new_command(command, settings):\n    url = command.script.split()[1]\n\n    if \'/\' in command.script:\n        return \'whois \' + urlparse(url).netloc\n    elif \'.\' in command.script:\n        return \'whois \' + \'.\'.join(urlparse(url).path.split(\'.\')[1:])\n']",[[]],"[[<pydriller.domain.commit.Method object at 0x7f19828b0340>, <pydriller.domain.commit.Method object at 0x7f19828b0790>]]"
thefuck,fc8f1b11361c2aff3e42cc2d2e39b07c505aa3d9,"fix(pacman): make the entire rule py2-compatible

One reference to subprocess.DEVNULL remained.

Signed-off-by: Pablo Santiago Blum de Aguiar <scorphus@gmail.com>",2015-05-15 15:53:37-03:00,Pablo Santiago Blum de Aguiar,1,1,2,1,['pacman.py'],"['import subprocess\nfrom thefuck.utils import DEVNULL\n\n\ndef __command_available(command):\n    try:\n        subprocess.check_output([command], stderr=DEVNULL)\n        return True\n    except subprocess.CalledProcessError:\n        # command exists but is not happy to be called without any argument\n        return True\n    except OSError:\n        return False\n\n\ndef __get_pkgfile(command):\n    try:\n        return subprocess.check_output(\n            [\'pkgfile\', \'-b\', \'-v\', command.script.split("" "")[0]],\n            universal_newlines=True, stderr=subprocess.DEVNULL\n        ).split()\n    except subprocess.CalledProcessError:\n        return None\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and __get_pkgfile(command)\n\n\ndef get_new_command(command, settings):\n    package = __get_pkgfile(command)[0]\n\n    return \'{} -S {} && {}\'.format(pacman, package, command.script)\n\n\nif not __command_available(\'pkgfile\'):\n    enabled_by_default = False\nelif __command_available(\'yaourt\'):\n    pacman = \'yaourt\'\nelif __command_available(\'pacman\'):\n    pacman = \'sudo pacman\'\nelse:\n    enabled_by_default = False\n']","['import subprocess\nfrom thefuck.utils import DEVNULL\n\n\ndef __command_available(command):\n    try:\n        subprocess.check_output([command], stderr=DEVNULL)\n        return True\n    except subprocess.CalledProcessError:\n        # command exists but is not happy to be called without any argument\n        return True\n    except OSError:\n        return False\n\n\ndef __get_pkgfile(command):\n    try:\n        return subprocess.check_output(\n            [\'pkgfile\', \'-b\', \'-v\', command.script.split("" "")[0]],\n            universal_newlines=True, stderr=DEVNULL\n        ).split()\n    except subprocess.CalledProcessError:\n        return None\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and __get_pkgfile(command)\n\n\ndef get_new_command(command, settings):\n    package = __get_pkgfile(command)[0]\n\n    return \'{} -S {} && {}\'.format(pacman, package, command.script)\n\n\nif not __command_available(\'pkgfile\'):\n    enabled_by_default = False\nelif __command_available(\'yaourt\'):\n    pacman = \'yaourt\'\nelif __command_available(\'pacman\'):\n    pacman = \'sudo pacman\'\nelse:\n    enabled_by_default = False\n']","[[<pydriller.domain.commit.Method object at 0x7f19828b9e20>, <pydriller.domain.commit.Method object at 0x7f19828b9d90>, <pydriller.domain.commit.Method object at 0x7f19828b9e80>, <pydriller.domain.commit.Method object at 0x7f1983f605e0>]]",[[<pydriller.domain.commit.Method object at 0x7f19828b99a0>]]
thefuck,d5bd57fb4978d4a204f51d65e1e526197f41e955,Adding rule for forgotten '-r' when grepping folders,2015-05-15 19:09:14-03:00,Igor Santos,19,0,19,2,"['test_grep_recursive.py', 'grep_recursive.py']","[None, None]","[""from thefuck.rules.grep_recursive import match, get_new_command\nfrom tests.utils import Command\n\n\ndef test_match():\n    assert match(Command('grep blah .', stderr='grep: .: Is a directory'), None)\n    assert not match(Command(), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(\n        Command('grep blah .'), None) == 'grep -r blah .'\n"", ""def match(command, settings):\n\treturn (command.script.startswith('grep')\n            and 'is a directory' in command.stderr.lower())\n\n\ndef get_new_command(command, settings):\n    return 'grep -r {}'.format(command.script[5:])\n""]","[[], []]","[[<pydriller.domain.commit.Method object at 0x7f1983f60460>, <pydriller.domain.commit.Method object at 0x7f1983f60b50>], [<pydriller.domain.commit.Method object at 0x7f1983f60220>, <pydriller.domain.commit.Method object at 0x7f1983f60d30>]]"
thefuck,5f2b2433b15ca3941a75bc57c45637a5e7f5edce,Cleanup `pacman` rule,2015-05-16 15:25:32+02:00,mcarton,4,15,19,1,['pacman.py'],"['import subprocess\nfrom thefuck.utils import DEVNULL\n\n\ndef __command_available(command):\n    try:\n        subprocess.check_output([command], stderr=DEVNULL)\n        return True\n    except subprocess.CalledProcessError:\n        # command exists but is not happy to be called without any argument\n        return True\n    except OSError:\n        return False\n\n\ndef __get_pkgfile(command):\n    try:\n        return subprocess.check_output(\n            [\'pkgfile\', \'-b\', \'-v\', command.script.split("" "")[0]],\n            universal_newlines=True, stderr=DEVNULL\n        ).split()\n    except subprocess.CalledProcessError:\n        return None\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and __get_pkgfile(command)\n\n\ndef get_new_command(command, settings):\n    package = __get_pkgfile(command)[0]\n\n    return \'{} -S {} && {}\'.format(pacman, package, command.script)\n\n\nif not __command_available(\'pkgfile\'):\n    enabled_by_default = False\nelif __command_available(\'yaourt\'):\n    pacman = \'yaourt\'\nelif __command_available(\'pacman\'):\n    pacman = \'sudo pacman\'\nelse:\n    enabled_by_default = False\n']","['import subprocess\nfrom thefuck.utils import DEVNULL, which\n\n\ndef __get_pkgfile(command):\n    try:\n        return subprocess.check_output(\n            [\'pkgfile\', \'-b\', \'-v\', command.script.split("" "")[0]],\n            universal_newlines=True, stderr=DEVNULL\n        ).split()\n    except subprocess.CalledProcessError:\n        return None\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and __get_pkgfile(command)\n\n\ndef get_new_command(command, settings):\n    package = __get_pkgfile(command)[0]\n\n    return \'{} -S {} && {}\'.format(pacman, package, command.script)\n\n\nif not which(\'pkgfile\'):\n    enabled_by_default = False\nelif which(\'yaourt\'):\n    pacman = \'yaourt\'\nelif which(\'pacman\'):\n    pacman = \'sudo pacman\'\nelse:\n    enabled_by_default = False\n']","[[<pydriller.domain.commit.Method object at 0x7f1983f6b5e0>, <pydriller.domain.commit.Method object at 0x7f1983f6b5b0>, <pydriller.domain.commit.Method object at 0x7f1983f6b700>, <pydriller.domain.commit.Method object at 0x7f1983f6b310>]]",[[<pydriller.domain.commit.Method object at 0x7f1983f6b5e0>]]
thefuck,6539c853b4838c7c6ea049604ddb5bcd024ad6ba,Add tests for the `whois` rule,2015-05-16 15:36:27+02:00,mcarton,19,0,19,1,['test_whois.py'],[None],"[""import pytest\nfrom thefuck.rules.whois import match, get_new_command\nfrom tests.utils import Command\n\n\n@pytest.mark.parametrize('command', [\n    Command(script='whois https://en.wikipedia.org/wiki/Main_Page'),\n    Command(script='whois https://en.wikipedia.org/'),\n    Command(script='whois en.wikipedia.org')])\ndef test_match(command):\n    assert match(command, None)\n\n\n@pytest.mark.parametrize('command, new_command', [\n    (Command('whois https://en.wikipedia.org/wiki/Main_Page'), 'whois en.wikipedia.org'),\n    (Command('whois https://en.wikipedia.org/'), 'whois en.wikipedia.org'),\n    (Command('whois en.wikipedia.org'), 'whois wikipedia.org')])\ndef test_get_new_command(command, new_command):\n    assert get_new_command(command, None) == new_command\n""]",[[]],"[[<pydriller.domain.commit.Method object at 0x7f1983f64c10>, <pydriller.domain.commit.Method object at 0x7f1983f64b20>]]"
thefuck,d854320acc27f95984857673af20a6931a118e60,"refact(shells): add specific `app_alias` methods for Bash and Zsh

Signed-off-by: Pablo Santiago Blum de Aguiar <scorphus@gmail.com>",2015-05-16 11:40:32-03:00,Pablo Santiago Blum de Aguiar,6,0,6,1,['shells.py'],"['""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias` and `put_to_history`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\nfrom .utils import DEVNULL\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n\nclass Bash(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Zsh(Generic):\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nclass Tcsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(""\\t"", 1)\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'tcsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'\\t\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'#+{}\\n{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'zsh\': Zsh(),\n    \'-csh\': Tcsh(),\n    \'tcsh\': Tcsh()})\n\n\ndef _get_shell():\n    try:\n        shell = Process(os.getpid()).parent().cmdline()[0]\n    except TypeError:\n        shell = Process(os.getpid()).parent.cmdline[0]\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    print(_get_shell().app_alias())\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n']","['""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias` and `put_to_history`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\nfrom .utils import DEVNULL\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n\nclass Bash(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Zsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nclass Tcsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(""\\t"", 1)\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'tcsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'\\t\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'#+{}\\n{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'zsh\': Zsh(),\n    \'-csh\': Tcsh(),\n    \'tcsh\': Tcsh()})\n\n\ndef _get_shell():\n    try:\n        shell = Process(os.getpid()).parent().cmdline()[0]\n    except TypeError:\n        shell = Process(os.getpid()).parent.cmdline[0]\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    print(_get_shell().app_alias())\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n']","[[<pydriller.domain.commit.Method object at 0x7f1983f5acd0>, <pydriller.domain.commit.Method object at 0x7f1983f55c40>, <pydriller.domain.commit.Method object at 0x7f1983f55700>, <pydriller.domain.commit.Method object at 0x7f1983f55c70>, <pydriller.domain.commit.Method object at 0x7f1982907ac0>, <pydriller.domain.commit.Method object at 0x7f19829074c0>, <pydriller.domain.commit.Method object at 0x7f1982907c40>, <pydriller.domain.commit.Method object at 0x7f19829076a0>, <pydriller.domain.commit.Method object at 0x7f1982907910>, <pydriller.domain.commit.Method object at 0x7f19829074f0>, <pydriller.domain.commit.Method object at 0x7f1982907c10>, <pydriller.domain.commit.Method object at 0x7f1982907b50>, <pydriller.domain.commit.Method object at 0x7f1982907be0>, <pydriller.domain.commit.Method object at 0x7f1982907730>, <pydriller.domain.commit.Method object at 0x7f1982907940>, <pydriller.domain.commit.Method object at 0x7f1982907190>, <pydriller.domain.commit.Method object at 0x7f1982907460>, <pydriller.domain.commit.Method object at 0x7f1982907400>, <pydriller.domain.commit.Method object at 0x7f1982907250>, <pydriller.domain.commit.Method object at 0x7f1982907430>, <pydriller.domain.commit.Method object at 0x7f19829073a0>, <pydriller.domain.commit.Method object at 0x7f1983f5ad30>, <pydriller.domain.commit.Method object at 0x7f1983f5aa00>, <pydriller.domain.commit.Method object at 0x7f1983f5a940>, <pydriller.domain.commit.Method object at 0x7f1983f5ac40>, <pydriller.domain.commit.Method object at 0x7f1983f5aaf0>]]",[[<pydriller.domain.commit.Method object at 0x7f1983f5ae80>]]
thefuck,3d0d4be4a9ce51b67e1278b47ca5c593834b3d59,"refact(shells): add `and_` method to assemble expressions involving AND

Signed-off-by: Pablo Santiago Blum de Aguiar <scorphus@gmail.com>",2015-05-16 11:52:50-03:00,Pablo Santiago Blum de Aguiar,37,7,44,10,"['__init__.py', 'conftest.py', 'apt_get.py', 'cd_mkdir.py', 'git_add.py', 'git_checkout.py', 'git_stash.py', 'no_such_file.py', 'pacman.py', 'shells.py']","[None, None, 'try:\n    import CommandNotFound\nexcept ImportError:\n    enabled_by_default = False\n\n\ndef match(command, settings):\n    if \'not found\' in command.stderr:\n        try:\n            c = CommandNotFound.CommandNotFound()\n            pkgs = c.getPackages(command.script.split("" "")[0])\n            name, _ = pkgs[0]\n            return True\n        except IndexError:\n            # IndexError is thrown when no matching package is found\n            return False\n\n\ndef get_new_command(command, settings):\n    c = CommandNotFound.CommandNotFound()\n    pkgs = c.getPackages(command.script.split("" "")[0])\n    name, _ = pkgs[0]\n    return ""sudo apt-get install {} && {}"".format(name, command.script)\n', ""import re\nfrom thefuck.utils import sudo_support\n\n\n@sudo_support\ndef match(command, settings):\n    return (command.script.startswith('cd ')\n        and ('no such file or directory' in command.stderr.lower()\n            or 'cd: can\\'t cd to' in command.stderr.lower()))\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    return re.sub(r'^cd (.*)', 'mkdir -p \\\\1 && cd \\\\1', command.script)\n"", 'import re\n\n\ndef match(command, settings):\n    return (\'git\' in command.script\n            and \'did not match any file(s) known to git.\' in command.stderr\n            and ""Did you forget to \'git add\'?"" in command.stderr)\n\n\ndef get_new_command(command, settings):\n    missing_file = re.findall(\n            r""error: pathspec \'([^\']*)\' ""\n            ""did not match any file\\(s\\) known to git."", command.stderr)[0]\n\n    return \'git add -- {} && {}\'.format(missing_file, command.script)\n', 'import re\n\n\ndef match(command, settings):\n    return (\'git\' in command.script\n            and \'did not match any file(s) known to git.\' in command.stderr\n            and ""Did you forget to \'git add\'?"" not in command.stderr)\n\n\ndef get_new_command(command, settings):\n    missing_file = re.findall(\n            r""error: pathspec \'([^\']*)\' ""\n            ""did not match any file\\(s\\) known to git."", command.stderr)[0]\n\n    return \'git branch {} && {}\'.format(missing_file, command.script)\n', 'def match(command, settings):\n    # catches ""Please commit or stash them"" and ""Please, commit your changes or\n    # stash them before you can switch branches.""\n    return \'git\' in command.script and \'or stash them\' in command.stderr\n\n\ndef get_new_command(command, settings):\n    return \'git stash && \' + command.script\n', 'import re\n\n\npatterns = (\n    r""mv: cannot move \'[^\']*\' to \'([^\']*)\': No such file or directory"",\n    r""mv: cannot move \'[^\']*\' to \'([^\']*)\': Not a directory"",\n    r""cp: cannot create regular file \'([^\']*)\': No such file or directory"",\n    r""cp: cannot create regular file \'([^\']*)\': Not a directory"",\n)\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if re.search(pattern, command.stderr):\n            return True\n\n    return False\n\n\ndef get_new_command(command, settings):\n    for pattern in patterns:\n        file = re.findall(pattern, command.stderr)\n\n        if file:\n            file = file[0]\n            dir = file[0:file.rfind(\'/\')]\n\n            return \'mkdir -p {} && {}\'.format(dir, command.script)\n', 'import subprocess\nfrom thefuck.utils import DEVNULL\n\n\ndef __command_available(command):\n    try:\n        subprocess.check_output([command], stderr=DEVNULL)\n        return True\n    except subprocess.CalledProcessError:\n        # command exists but is not happy to be called without any argument\n        return True\n    except OSError:\n        return False\n\n\ndef __get_pkgfile(command):\n    try:\n        return subprocess.check_output(\n            [\'pkgfile\', \'-b\', \'-v\', command.script.split("" "")[0]],\n            universal_newlines=True, stderr=DEVNULL\n        ).split()\n    except subprocess.CalledProcessError:\n        return None\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and __get_pkgfile(command)\n\n\ndef get_new_command(command, settings):\n    package = __get_pkgfile(command)[0]\n\n    return \'{} -S {} && {}\'.format(pacman, package, command.script)\n\n\nif not __command_available(\'pkgfile\'):\n    enabled_by_default = False\nelif __command_available(\'yaourt\'):\n    pacman = \'yaourt\'\nelif __command_available(\'pacman\'):\n    pacman = \'sudo pacman\'\nelse:\n    enabled_by_default = False\n', '""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias` and `put_to_history`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\nfrom .utils import DEVNULL\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n\nclass Bash(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Zsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nclass Tcsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(""\\t"", 1)\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'tcsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'\\t\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'#+{}\\n{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'zsh\': Zsh(),\n    \'-csh\': Tcsh(),\n    \'tcsh\': Tcsh()})\n\n\ndef _get_shell():\n    try:\n        shell = Process(os.getpid()).parent().cmdline()[0]\n    except TypeError:\n        shell = Process(os.getpid()).parent.cmdline[0]\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    print(_get_shell().app_alias())\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n']","[None, ""import pytest\n\n\n@pytest.fixture(autouse=True)\ndef generic_shell(monkeypatch):\n    monkeypatch.setattr('thefuck.shells.and_', lambda *x: ' && '.join(x))\n"", 'from thefuck import shells\n\ntry:\n    import CommandNotFound\nexcept ImportError:\n    enabled_by_default = False\n\n\ndef match(command, settings):\n    if \'not found\' in command.stderr:\n        try:\n            c = CommandNotFound.CommandNotFound()\n            pkgs = c.getPackages(command.script.split("" "")[0])\n            name, _ = pkgs[0]\n            return True\n        except IndexError:\n            # IndexError is thrown when no matching package is found\n            return False\n\n\ndef get_new_command(command, settings):\n    c = CommandNotFound.CommandNotFound()\n    pkgs = c.getPackages(command.script.split("" "")[0])\n    name, _ = pkgs[0]\n    formatme = shells.and_(\'sudo apt-get install {}\', \'{}\')\n    return formatme.format(name, command.script)\n', ""import re\nfrom thefuck import shells\nfrom thefuck.utils import sudo_support\n\n\n@sudo_support\ndef match(command, settings):\n    return (command.script.startswith('cd ')\n        and ('no such file or directory' in command.stderr.lower()\n            or 'cd: can\\'t cd to' in command.stderr.lower()))\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    repl = shells.and_('mkdir -p \\\\1', 'cd \\\\1')\n    return re.sub(r'^cd (.*)', repl, command.script)\n"", 'import re\nfrom thefuck import shells\n\n\ndef match(command, settings):\n    return (\'git\' in command.script\n            and \'did not match any file(s) known to git.\' in command.stderr\n            and ""Did you forget to \'git add\'?"" in command.stderr)\n\n\ndef get_new_command(command, settings):\n    missing_file = re.findall(\n            r""error: pathspec \'([^\']*)\' ""\n            ""did not match any file\\(s\\) known to git."", command.stderr)[0]\n\n    formatme = shells.and_(\'git add -- {}\', \'{}\')\n    return formatme.format(missing_file, command.script)\n', 'import re\nfrom thefuck import shells\n\n\ndef match(command, settings):\n    return (\'git\' in command.script\n            and \'did not match any file(s) known to git.\' in command.stderr\n            and ""Did you forget to \'git add\'?"" not in command.stderr)\n\n\ndef get_new_command(command, settings):\n    missing_file = re.findall(\n            r""error: pathspec \'([^\']*)\' ""\n            ""did not match any file\\(s\\) known to git."", command.stderr)[0]\n\n    formatme = shells.and_(\'git branch {}\', \'{}\')\n    return formatme.format(missing_file, command.script)\n', 'from thefuck import shells\n\n\ndef match(command, settings):\n    # catches ""Please commit or stash them"" and ""Please, commit your changes or\n    # stash them before you can switch branches.""\n    return \'git\' in command.script and \'or stash them\' in command.stderr\n\n\ndef get_new_command(command, settings):\n    formatme = shells.and_(\'git stash\', \'{}\')\n    return formatme.format(command.script)\n', 'import re\nfrom thefuck import shells\n\n\npatterns = (\n    r""mv: cannot move \'[^\']*\' to \'([^\']*)\': No such file or directory"",\n    r""mv: cannot move \'[^\']*\' to \'([^\']*)\': Not a directory"",\n    r""cp: cannot create regular file \'([^\']*)\': No such file or directory"",\n    r""cp: cannot create regular file \'([^\']*)\': Not a directory"",\n)\n\n\ndef match(command, settings):\n    for pattern in patterns:\n        if re.search(pattern, command.stderr):\n            return True\n\n    return False\n\n\ndef get_new_command(command, settings):\n    for pattern in patterns:\n        file = re.findall(pattern, command.stderr)\n\n        if file:\n            file = file[0]\n            dir = file[0:file.rfind(\'/\')]\n\n            formatme = shells.and_(\'mkdir -p {}\', \'{}\')\n            return formatme.format(dir, command.script)\n', 'import subprocess\nfrom thefuck import shells\nfrom thefuck.utils import DEVNULL\n\n\ndef __command_available(command):\n    try:\n        subprocess.check_output([command], stderr=DEVNULL)\n        return True\n    except subprocess.CalledProcessError:\n        # command exists but is not happy to be called without any argument\n        return True\n    except OSError:\n        return False\n\n\ndef __get_pkgfile(command):\n    try:\n        return subprocess.check_output(\n            [\'pkgfile\', \'-b\', \'-v\', command.script.split("" "")[0]],\n            universal_newlines=True, stderr=DEVNULL\n        ).split()\n    except subprocess.CalledProcessError:\n        return None\n\n\ndef match(command, settings):\n    return \'not found\' in command.stderr and __get_pkgfile(command)\n\n\ndef get_new_command(command, settings):\n    package = __get_pkgfile(command)[0]\n\n    formatme = shells.and_(\'{} -S {}\', \'{}\')\n    return formatme.format(pacman, package, command.script)\n\n\nif not __command_available(\'pkgfile\'):\n    enabled_by_default = False\nelif __command_available(\'yaourt\'):\n    pacman = \'yaourt\'\nelif __command_available(\'pacman\'):\n    pacman = \'sudo pacman\'\nelse:\n    enabled_by_default = False\n', '""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias` and `put_to_history`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\nfrom .utils import DEVNULL\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n    def and_(self, *commands):\n        return \' && \'.join(commands)\n\n\nclass Bash(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Zsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nclass Tcsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(""\\t"", 1)\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'tcsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'\\t\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'#+{}\\n{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'zsh\': Zsh(),\n    \'-csh\': Tcsh(),\n    \'tcsh\': Tcsh()})\n\n\ndef _get_shell():\n    try:\n        shell = Process(os.getpid()).parent().cmdline()[0]\n    except TypeError:\n        shell = Process(os.getpid()).parent.cmdline[0]\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    print(_get_shell().app_alias())\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n\n\ndef and_(*commands):\n    return _get_shell().and_(*commands)\n']","[[], [], [<pydriller.domain.commit.Method object at 0x7f1983f6b8b0>, <pydriller.domain.commit.Method object at 0x7f1983f6b820>], [<pydriller.domain.commit.Method object at 0x7f1983f60a00>, <pydriller.domain.commit.Method object at 0x7f1983f60d90>], [<pydriller.domain.commit.Method object at 0x7f19828b9cd0>, <pydriller.domain.commit.Method object at 0x7f19828b9c40>], [<pydriller.domain.commit.Method object at 0x7f19828b0670>, <pydriller.domain.commit.Method object at 0x7f19828b0a60>], [<pydriller.domain.commit.Method object at 0x7f198290cd30>, <pydriller.domain.commit.Method object at 0x7f198290c4c0>], [<pydriller.domain.commit.Method object at 0x7f1982907280>, <pydriller.domain.commit.Method object at 0x7f19829072b0>], [<pydriller.domain.commit.Method object at 0x7f19829071c0>, <pydriller.domain.commit.Method object at 0x7f19829070d0>, <pydriller.domain.commit.Method object at 0x7f1982907ca0>, <pydriller.domain.commit.Method object at 0x7f1982907c70>], [<pydriller.domain.commit.Method object at 0x7f1983f60b20>, <pydriller.domain.commit.Method object at 0x7f1983f60580>, <pydriller.domain.commit.Method object at 0x7f1983f60490>, <pydriller.domain.commit.Method object at 0x7f1983f60eb0>, <pydriller.domain.commit.Method object at 0x7f1983f6bca0>, <pydriller.domain.commit.Method object at 0x7f1983f6b7f0>, <pydriller.domain.commit.Method object at 0x7f1983f6bc70>, <pydriller.domain.commit.Method object at 0x7f1983f6b220>, <pydriller.domain.commit.Method object at 0x7f1983f6b1f0>, <pydriller.domain.commit.Method object at 0x7f1983f6b9a0>, <pydriller.domain.commit.Method object at 0x7f1983f6bc40>, <pydriller.domain.commit.Method object at 0x7f1983f6b2e0>, <pydriller.domain.commit.Method object at 0x7f1983f6bcd0>, <pydriller.domain.commit.Method object at 0x7f1983f6b6d0>, <pydriller.domain.commit.Method object at 0x7f1983f6b0d0>, <pydriller.domain.commit.Method object at 0x7f1983f6b4c0>, <pydriller.domain.commit.Method object at 0x7f1983f6b760>, <pydriller.domain.commit.Method object at 0x7f1983f6b940>, <pydriller.domain.commit.Method object at 0x7f1983f6b610>, <pydriller.domain.commit.Method object at 0x7f1983f6b6a0>, <pydriller.domain.commit.Method object at 0x7f1983f6b850>, <pydriller.domain.commit.Method object at 0x7f1983f6b400>, <pydriller.domain.commit.Method object at 0x7f1983f6b9d0>, <pydriller.domain.commit.Method object at 0x7f198507f880>, <pydriller.domain.commit.Method object at 0x7f1983f641f0>, <pydriller.domain.commit.Method object at 0x7f1983f64430>, <pydriller.domain.commit.Method object at 0x7f1983f64c40>, <pydriller.domain.commit.Method object at 0x7f1983f645e0>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983f5a130>], [<pydriller.domain.commit.Method object at 0x7f1983f5aac0>], [<pydriller.domain.commit.Method object at 0x7f1983f6b040>], [<pydriller.domain.commit.Method object at 0x7f1983f60af0>], [<pydriller.domain.commit.Method object at 0x7f19828b9970>], [<pydriller.domain.commit.Method object at 0x7f1982926f70>], [<pydriller.domain.commit.Method object at 0x7f198290ca90>], [<pydriller.domain.commit.Method object at 0x7f19829057f0>], [<pydriller.domain.commit.Method object at 0x7f19828b9ca0>, <pydriller.domain.commit.Method object at 0x7f1983f609d0>]]"
thefuck,179839c32fab0241b2ba9dc4c70d938eabfcea23,"test(rules): test other rules involving `shells.and_()`

Signed-off-by: Pablo Santiago Blum de Aguiar <scorphus@gmail.com>",2015-05-16 11:53:01-03:00,Pablo Santiago Blum de Aguiar,227,0,227,5,"['test_apt_get.py', 'test_git_add.py', 'test_git_checkout.py', 'test_git_stash.py', 'test_pacman.py']","[None, None, None, None, None]","[""import pytest\nfrom mock import Mock, patch\nfrom thefuck.rules import apt_get\nfrom thefuck.rules.apt_get import match, get_new_command\nfrom tests.utils import Command\n\n\n# python-commandnotfound is available in ubuntu 14.04+\n@pytest.mark.skipif(not getattr(apt_get, 'enabled_by_default', True),\n                    reason='Skip if python-commandnotfound is not available')\n@pytest.mark.parametrize('command', [\n    Command(script='vim', stderr='vim: command not found')])\ndef test_match(command):\n    assert match(command, None)\n\n\n@pytest.mark.parametrize('command, return_value', [\n    (Command(script='vim', stderr='vim: command not found'),\n     [('vim', 'main'), ('vim-tiny', 'main')])])\n@patch('thefuck.rules.apt_get.CommandNotFound', create=True)\n@patch.multiple(apt_get, create=True, apt_get='apt_get')\ndef test_match_mocked(cmdnf_mock, command, return_value):\n    get_packages = Mock(return_value=return_value)\n    cmdnf_mock.CommandNotFound.return_value = Mock(getPackages=get_packages)\n    assert match(command, None)\n    assert cmdnf_mock.CommandNotFound.called\n    assert get_packages.called\n\n\n@pytest.mark.parametrize('command', [\n    Command(script='vim', stderr=''), Command()])\ndef test_not_match(command):\n    assert not match(command, None)\n\n\n# python-commandnotfound is available in ubuntu 14.04+\n@pytest.mark.skipif(not getattr(apt_get, 'enabled_by_default', True),\n                    reason='Skip if python-commandnotfound is not available')\n@pytest.mark.parametrize('command, new_command', [\n    (Command('vim'), 'sudo apt-get install vim && vim'),\n    (Command('convert'), 'sudo apt-get install imagemagick && convert')])\ndef test_get_new_command(command, new_command):\n    assert get_new_command(command, None) == new_command\n\n\n@pytest.mark.parametrize('command, new_command, return_value', [\n    (Command('vim'), 'sudo apt-get install vim && vim',\n     [('vim', 'main'), ('vim-tiny', 'main')]),\n    (Command('convert'), 'sudo apt-get install imagemagick && convert',\n     [('imagemagick', 'main'),\n      ('graphicsmagick-imagemagick-compat', 'universe')])])\n@patch('thefuck.rules.apt_get.CommandNotFound', create=True)\n@patch.multiple(apt_get, create=True, apt_get='apt_get')\ndef test_get_new_command_mocked(cmdnf_mock, command, new_command, return_value):\n    get_packages = Mock(return_value=return_value)\n    cmdnf_mock.CommandNotFound.return_value = Mock(getPackages=get_packages)\n    assert get_new_command(command, None) == new_command\n    assert cmdnf_mock.CommandNotFound.called\n    assert get_packages.called\n"", 'import pytest\nfrom thefuck.rules.git_add import match, get_new_command\nfrom tests.utils import Command\n\n\n@pytest.fixture\ndef did_not_match(target, did_you_forget=True):\n    error = (""error: pathspec \'{}\' did not match any ""\n             ""file(s) known to git."".format(target))\n    if did_you_forget:\n        error = (""{}\\nDid you forget to \'git add\'?\'"".format(error))\n    return error\n\n\n@pytest.mark.parametrize(\'command\', [\n    Command(script=\'git submodule update unknown\',\n            stderr=did_not_match(\'unknown\')),\n    Command(script=\'git commit unknown\',\n            stderr=did_not_match(\'unknown\'))])  # Older versions of Git\ndef test_match(command):\n    assert match(command, None)\n\n\n@pytest.mark.parametrize(\'command\', [\n    Command(script=\'git submodule update known\', stderr=(\'\')),\n    Command(script=\'git commit known\', stderr=(\'\')),\n    Command(script=\'git commit unknown\',  # Newer versions of Git\n            stderr=did_not_match(\'unknown\', False))])\ndef test_not_match(command):\n    assert not match(command, None)\n\n\n@pytest.mark.parametrize(\'command, new_command\', [\n    (Command(\'git submodule update unknown\', stderr=did_not_match(\'unknown\')),\n     \'git add -- unknown && git submodule update unknown\'),\n    (Command(\'git commit unknown\', stderr=did_not_match(\'unknown\')),  # Old Git\n     \'git add -- unknown && git commit unknown\')])\ndef test_get_new_command(command, new_command):\n    assert get_new_command(command, None) == new_command\n', 'import pytest\nfrom thefuck.rules.git_checkout import match, get_new_command\nfrom tests.utils import Command\n\n\n@pytest.fixture\ndef did_not_match(target, did_you_forget=False):\n    error = (""error: pathspec \'{}\' did not match any ""\n             ""file(s) known to git."".format(target))\n    if did_you_forget:\n        error = (""{}\\nDid you forget to \'git add\'?\'"".format(error))\n    return error\n\n\n@pytest.mark.parametrize(\'command\', [\n    Command(script=\'git checkout unknown\', stderr=did_not_match(\'unknown\')),\n    Command(script=\'git commit unknown\', stderr=did_not_match(\'unknown\'))])\ndef test_match(command):\n    assert match(command, None)\n\n\n@pytest.mark.parametrize(\'command\', [\n    Command(script=\'git submodule update unknown\',\n            stderr=did_not_match(\'unknown\', True)),\n    Command(script=\'git checkout known\', stderr=(\'\')),\n    Command(script=\'git commit known\', stderr=(\'\'))])\ndef test_not_match(command):\n    assert not match(command, None)\n\n\n@pytest.mark.parametrize(\'command, new_command\', [\n    (Command(script=\'git checkout unknown\', stderr=did_not_match(\'unknown\')),\n     \'git branch unknown && git checkout unknown\'),\n    (Command(\'git commit unknown\', stderr=did_not_match(\'unknown\')),\n     \'git branch unknown && git commit unknown\')])\ndef test_get_new_command(command, new_command):\n    assert get_new_command(command, None) == new_command\n', ""import pytest\nfrom thefuck.rules.git_stash import match, get_new_command\nfrom tests.utils import Command\n\n\n@pytest.fixture\ndef cherry_pick_error():\n    return ('error: Your local changes would be overwritten by cherry-pick.\\n'\n            'hint: Commit your changes or stash them to proceed.\\n'\n            'fatal: cherry-pick failed')\n\n\n@pytest.fixture\ndef rebase_error():\n    return ('Cannot rebase: Your index contains uncommitted changes.\\n'\n            'Please commit or stash them.')\n\n\n@pytest.mark.parametrize('command', [\n    Command(script='git cherry-pick a1b2c3d', stderr=cherry_pick_error()),\n    Command(script='git rebase -i HEAD~7', stderr=rebase_error())])\ndef test_match(command):\n    assert match(command, None)\n\n\n@pytest.mark.parametrize('command', [\n    Command(script='git cherry-pick a1b2c3d', stderr=('')),\n    Command(script='git rebase -i HEAD~7', stderr=(''))])\ndef test_not_match(command):\n    assert not match(command, None)\n\n\n@pytest.mark.parametrize('command, new_command', [\n    (Command(script='git cherry-pick a1b2c3d', stderr=cherry_pick_error),\n     'git stash && git cherry-pick a1b2c3d'),\n    (Command('git rebase -i HEAD~7', stderr=rebase_error),\n     'git stash && git rebase -i HEAD~7')])\ndef test_get_new_command(command, new_command):\n    assert get_new_command(command, None) == new_command\n"", ""import pytest\nfrom mock import patch\nfrom thefuck.rules import pacman\nfrom thefuck.rules.pacman import match, get_new_command\nfrom tests.utils import Command\n\n\npacman_cmd = getattr(pacman, 'pacman', 'pacman')\n\n\n@pytest.mark.skipif(not getattr(pacman, 'enabled_by_default', True),\n                    reason='Skip if pacman is not available')\n@pytest.mark.parametrize('command', [\n    Command(script='vim', stderr='vim: command not found')])\ndef test_match(command):\n    assert match(command, None)\n\n\n@pytest.mark.parametrize('command, return_value', [\n    (Command(script='vim', stderr='vim: command not found'), 'vim foo bar')])\n@patch('thefuck.rules.pacman.subprocess')\n@patch.multiple(pacman, create=True, pacman=pacman_cmd)\ndef test_match_mocked(subp_mock, command, return_value):\n    subp_mock.check_output.return_value = return_value\n    assert match(command, None)\n    assert subp_mock.check_output.called\n\n\n@pytest.mark.parametrize('command', [\n    Command(script='vim', stderr=''), Command()])\ndef test_not_match(command):\n    assert not match(command, None)\n\n\n@pytest.mark.skipif(not getattr(pacman, 'enabled_by_default', True),\n                    reason='Skip if pacman is not available')\n@pytest.mark.parametrize('command, new_command', [\n    (Command('vim'), '{} -S vim && vim'.format(pacman_cmd)),\n    (Command('convert'), '{} -S imagemagick && convert'.format(pacman_cmd))])\ndef test_get_new_command(command, new_command, mocker):\n    assert get_new_command(command, None) == new_command\n\n\n@pytest.mark.parametrize('command, new_command, return_value', [\n    (Command('vim'), '{} -S vim && vim'.format(pacman_cmd), 'vim foo bar'),\n    (Command('convert'), '{} -S imagemagick && convert'.format(pacman_cmd),\n     'imagemagick foo bar')])\n@patch('thefuck.rules.pacman.subprocess')\n@patch.multiple(pacman, create=True, pacman=pacman_cmd)\ndef test_get_new_command_mocked(subp_mock, command, new_command, return_value):\n    subp_mock.check_output.return_value = return_value\n    assert get_new_command(command, None) == new_command\n    assert subp_mock.check_output.called\n""]","[[], [], [], [], []]","[[<pydriller.domain.commit.Method object at 0x7f19828b9670>, <pydriller.domain.commit.Method object at 0x7f19828b9490>, <pydriller.domain.commit.Method object at 0x7f19828b9dc0>, <pydriller.domain.commit.Method object at 0x7f19828b9d00>, <pydriller.domain.commit.Method object at 0x7f19828b9580>], [<pydriller.domain.commit.Method object at 0x7f1983f64dc0>, <pydriller.domain.commit.Method object at 0x7f1983f64340>, <pydriller.domain.commit.Method object at 0x7f1983f64970>, <pydriller.domain.commit.Method object at 0x7f1983f64160>], [<pydriller.domain.commit.Method object at 0x7f1983f64a30>, <pydriller.domain.commit.Method object at 0x7f1983f64370>, <pydriller.domain.commit.Method object at 0x7f1983f64df0>, <pydriller.domain.commit.Method object at 0x7f1983f64b50>], [<pydriller.domain.commit.Method object at 0x7f1983f55b20>, <pydriller.domain.commit.Method object at 0x7f1983f55a90>, <pydriller.domain.commit.Method object at 0x7f1983f55850>, <pydriller.domain.commit.Method object at 0x7f1983f55df0>, <pydriller.domain.commit.Method object at 0x7f1983f55400>], [<pydriller.domain.commit.Method object at 0x7f1983f5a850>, <pydriller.domain.commit.Method object at 0x7f19829059a0>, <pydriller.domain.commit.Method object at 0x7f1983f5aa90>, <pydriller.domain.commit.Method object at 0x7f1983f5a820>, <pydriller.domain.commit.Method object at 0x7f1983f5a580>]]"
thefuck,f04c4396eb3cb75cf9f3a9e25ece51d2cc9f50c2,Fix Python 2.7 support,2015-05-16 23:17:53+02:00,mcarton,2,1,3,1,['whois.py'],"['from urllib.parse import urlparse\n\n\ndef match(command, settings):\n    """"""\n    What the `whois` command returns depends on the \'Whois server\' it contacted\n    and is not consistent through different servers. But there can be only two\n    types of errors I can think of with `whois`:\n        - `whois https://en.wikipedia.org/` → `whois en.wikipedia.org`;\n        - `whois en.wikipedia.org` → `whois wikipedia.org`.\n    So we match any `whois` command and then:\n        - if there is a slash: keep only the FQDN;\n        - if there is no slash but there is a point: removes the left-most\n          subdomain.\n\n    We cannot either remove all subdomains because we cannot know which part is\n    the subdomains and which is the domain, consider:\n        - www.google.fr → subdomain: www, domain: \'google.fr\';\n        - google.co.uk → subdomain: None, domain; \'google.co.uk\'.\n    """"""\n    return \'whois\' in command.script\n\n\ndef get_new_command(command, settings):\n    url = command.script.split()[1]\n\n    if \'/\' in command.script:\n        return \'whois \' + urlparse(url).netloc\n    elif \'.\' in command.script:\n        return \'whois \' + \'.\'.join(urlparse(url).path.split(\'.\')[1:])\n']","['# -*- encoding: utf-8 -*-\nfrom six.moves.urllib.parse import urlparse\n\n\ndef match(command, settings):\n    """"""\n    What the `whois` command returns depends on the \'Whois server\' it contacted\n    and is not consistent through different servers. But there can be only two\n    types of errors I can think of with `whois`:\n        - `whois https://en.wikipedia.org/` → `whois en.wikipedia.org`;\n        - `whois en.wikipedia.org` → `whois wikipedia.org`.\n    So we match any `whois` command and then:\n        - if there is a slash: keep only the FQDN;\n        - if there is no slash but there is a point: removes the left-most\n          subdomain.\n\n    We cannot either remove all subdomains because we cannot know which part is\n    the subdomains and which is the domain, consider:\n        - www.google.fr → subdomain: www, domain: \'google.fr\';\n        - google.co.uk → subdomain: None, domain; \'google.co.uk\'.\n    """"""\n    return \'whois\' in command.script\n\n\ndef get_new_command(command, settings):\n    url = command.script.split()[1]\n\n    if \'/\' in command.script:\n        return \'whois \' + urlparse(url).netloc\n    elif \'.\' in command.script:\n        return \'whois \' + \'.\'.join(urlparse(url).path.split(\'.\')[1:])\n']","[[<pydriller.domain.commit.Method object at 0x7f1983fc9ee0>, <pydriller.domain.commit.Method object at 0x7f1983fc9100>]]",[[]]
thefuck,9ef346468c58411f1e2334f60cf05047d54b950a,added cd_correction.py,2015-05-16 21:42:21-07:00,mmussomele,85,0,85,1,['cd_correction.py'],[None],"['#!/usr/bin/env python\n__author__ = ""mmussomele""\n\n""""""Attempts to spellcheck and correct failed cd commands""""""\n\nimport os\nimport cd_mkdir\nfrom thefuck.utils import sudo_support\n\nMAX_ALLOWED_STR_DIST = 5\n\ndef _get_sub_dirs(parent):\n    """"""Returns a list of the child directories of the given parent directory""""""\n    return [child for child in os.listdir(parent) if os.path.isdir(os.path.join(parent, child))]\n\ndef _dam_lev_dist():\n    """"""Returns a Damerau-Levenshtein distance calculator.""""""\n    cache = {}\n    def _calculator(first, second):\n        """"""\n        Calculates the Damerau-Levenshtein distance of two strings.\n        See: http://en.wikipedia.org/wiki/Damerau-Levenshtein_distance#Algorithm\n        """"""\n        if (first, second) in cache:\n            return cache[(first, second)]\n        else:\n            l_first = len(first)\n            l_second = len(second)\n            distances = [[0 for _ in range(l_second + 1)] for _ in range(l_first + 1)]\n            for i in range(l_first + 1):\n                distances[i][0] = i\n            for j in range(1, l_second + 1):\n                distances[0][j] = j\n            for i in range(l_first):\n                for j in range(l_second):\n                    if first[i] == second[j]:\n                        cost = 0\n                    else:\n                        cost = 1\n                    distances[i+1][j+1] = min(distances[i][j+1] + 1, \n                                              distances[i+1][j] + 1,\n                                              distances[i][j] + cost)\n                    if i and j and first[i] == second[j-1] and first[i-1] == second[j]:\n                        distances[i][j] = min(distances[i+1][j+1],\n                                              distances[i-1][j-1] + cost)\n            cache[(first, second)] = distances[l_first][l_second]\n            return distances[l_first][l_second]\n    return _calculator\n\n_dam_lev_dist = _dam_lev_dist()\n\n@sudo_support\ndef match(command, settings):\n    """"""Match function copied from cd_mkdir.py""""""\n    return (command.script.startswith(\'cd \')\n        and (\'no such file or directory\' in command.stderr.lower()\n            or \'cd: can\\\'t cd to\' in command.stderr.lower()))\n\n@sudo_support\ndef get_new_command(command, settings):\n    """"""\n    Attempt to rebuild the path string by spellchecking the directories.\n    If it fails (i.e. no directories are a close enough match), then it \n    defaults to the rules of cd_mkdir. \n    Change sensitivity to matching by changing MAX_ALLOWED_STR_DIST. \n    Higher values allow for larger discrepancies in path names. \n    """"""\n    dest = command.script.split()[1].split(os.sep)\n    if dest[-1] == \'\':\n        dest = dest[:-1]\n    cwd = os.getcwd()\n    for directory in dest:\n        if directory == ""."":\n            continue\n        elif directory == "".."":\n            cwd = os.path.split(cwd)[0]\n            continue\n        best_match = min(_get_sub_dirs(cwd), key=lambda x: _dam_lev_dist(directory, x))\n        if _dam_lev_dist(directory, best_match) > MAX_ALLOWED_STR_DIST:\n            return cd_mkdir.get_new_command(command, settings)\n        else:\n            cwd = os.path.join(cwd, best_match)\n    return ""cd {0}"".format(cwd) \n\nenabled_by_default = True']",[[]],"[[<pydriller.domain.commit.Method object at 0x7f1983f4ea60>, <pydriller.domain.commit.Method object at 0x7f1983f4ebb0>, <pydriller.domain.commit.Method object at 0x7f1983f4e3d0>, <pydriller.domain.commit.Method object at 0x7f1983f4e8e0>, <pydriller.domain.commit.Method object at 0x7f1983f4e0d0>]]"
thefuck,a54c97f624548161123e954ad3e9a01cb84b92a6,added newline to end of cd_correction.py,2015-05-16 21:47:15-07:00,mmussomele,1,1,2,1,['cd_correction.py'],"['#!/usr/bin/env python\n__author__ = ""mmussomele""\n\n""""""Attempts to spellcheck and correct failed cd commands""""""\n\nimport os\nimport cd_mkdir\nfrom thefuck.utils import sudo_support\n\nMAX_ALLOWED_STR_DIST = 5\n\ndef _get_sub_dirs(parent):\n    """"""Returns a list of the child directories of the given parent directory""""""\n    return [child for child in os.listdir(parent) if os.path.isdir(os.path.join(parent, child))]\n\ndef _dam_lev_dist():\n    """"""Returns a Damerau-Levenshtein distance calculator.""""""\n    cache = {}\n    def _calculator(first, second):\n        """"""\n        Calculates the Damerau-Levenshtein distance of two strings.\n        See: http://en.wikipedia.org/wiki/Damerau-Levenshtein_distance#Algorithm\n        """"""\n        if (first, second) in cache:\n            return cache[(first, second)]\n        else:\n            l_first = len(first)\n            l_second = len(second)\n            distances = [[0 for _ in range(l_second + 1)] for _ in range(l_first + 1)]\n            for i in range(l_first + 1):\n                distances[i][0] = i\n            for j in range(1, l_second + 1):\n                distances[0][j] = j\n            for i in range(l_first):\n                for j in range(l_second):\n                    if first[i] == second[j]:\n                        cost = 0\n                    else:\n                        cost = 1\n                    distances[i+1][j+1] = min(distances[i][j+1] + 1, \n                                              distances[i+1][j] + 1,\n                                              distances[i][j] + cost)\n                    if i and j and first[i] == second[j-1] and first[i-1] == second[j]:\n                        distances[i][j] = min(distances[i+1][j+1],\n                                              distances[i-1][j-1] + cost)\n            cache[(first, second)] = distances[l_first][l_second]\n            return distances[l_first][l_second]\n    return _calculator\n\n_dam_lev_dist = _dam_lev_dist()\n\n@sudo_support\ndef match(command, settings):\n    """"""Match function copied from cd_mkdir.py""""""\n    return (command.script.startswith(\'cd \')\n        and (\'no such file or directory\' in command.stderr.lower()\n            or \'cd: can\\\'t cd to\' in command.stderr.lower()))\n\n@sudo_support\ndef get_new_command(command, settings):\n    """"""\n    Attempt to rebuild the path string by spellchecking the directories.\n    If it fails (i.e. no directories are a close enough match), then it \n    defaults to the rules of cd_mkdir. \n    Change sensitivity to matching by changing MAX_ALLOWED_STR_DIST. \n    Higher values allow for larger discrepancies in path names. \n    """"""\n    dest = command.script.split()[1].split(os.sep)\n    if dest[-1] == \'\':\n        dest = dest[:-1]\n    cwd = os.getcwd()\n    for directory in dest:\n        if directory == ""."":\n            continue\n        elif directory == "".."":\n            cwd = os.path.split(cwd)[0]\n            continue\n        best_match = min(_get_sub_dirs(cwd), key=lambda x: _dam_lev_dist(directory, x))\n        if _dam_lev_dist(directory, best_match) > MAX_ALLOWED_STR_DIST:\n            return cd_mkdir.get_new_command(command, settings)\n        else:\n            cwd = os.path.join(cwd, best_match)\n    return ""cd {0}"".format(cwd) \n\nenabled_by_default = True']","['#!/usr/bin/env python\n__author__ = ""mmussomele""\n\n""""""Attempts to spellcheck and correct failed cd commands""""""\n\nimport os\nimport cd_mkdir\nfrom thefuck.utils import sudo_support\n\nMAX_ALLOWED_STR_DIST = 5\n\ndef _get_sub_dirs(parent):\n    """"""Returns a list of the child directories of the given parent directory""""""\n    return [child for child in os.listdir(parent) if os.path.isdir(os.path.join(parent, child))]\n\ndef _dam_lev_dist():\n    """"""Returns a Damerau-Levenshtein distance calculator.""""""\n    cache = {}\n    def _calculator(first, second):\n        """"""\n        Calculates the Damerau-Levenshtein distance of two strings.\n        See: http://en.wikipedia.org/wiki/Damerau-Levenshtein_distance#Algorithm\n        """"""\n        if (first, second) in cache:\n            return cache[(first, second)]\n        else:\n            l_first = len(first)\n            l_second = len(second)\n            distances = [[0 for _ in range(l_second + 1)] for _ in range(l_first + 1)]\n            for i in range(l_first + 1):\n                distances[i][0] = i\n            for j in range(1, l_second + 1):\n                distances[0][j] = j\n            for i in range(l_first):\n                for j in range(l_second):\n                    if first[i] == second[j]:\n                        cost = 0\n                    else:\n                        cost = 1\n                    distances[i+1][j+1] = min(distances[i][j+1] + 1, \n                                              distances[i+1][j] + 1,\n                                              distances[i][j] + cost)\n                    if i and j and first[i] == second[j-1] and first[i-1] == second[j]:\n                        distances[i][j] = min(distances[i+1][j+1],\n                                              distances[i-1][j-1] + cost)\n            cache[(first, second)] = distances[l_first][l_second]\n            return distances[l_first][l_second]\n    return _calculator\n\n_dam_lev_dist = _dam_lev_dist()\n\n@sudo_support\ndef match(command, settings):\n    """"""Match function copied from cd_mkdir.py""""""\n    return (command.script.startswith(\'cd \')\n        and (\'no such file or directory\' in command.stderr.lower()\n            or \'cd: can\\\'t cd to\' in command.stderr.lower()))\n\n@sudo_support\ndef get_new_command(command, settings):\n    """"""\n    Attempt to rebuild the path string by spellchecking the directories.\n    If it fails (i.e. no directories are a close enough match), then it \n    defaults to the rules of cd_mkdir. \n    Change sensitivity to matching by changing MAX_ALLOWED_STR_DIST. \n    Higher values allow for larger discrepancies in path names. \n    """"""\n    dest = command.script.split()[1].split(os.sep)\n    if dest[-1] == \'\':\n        dest = dest[:-1]\n    cwd = os.getcwd()\n    for directory in dest:\n        if directory == ""."":\n            continue\n        elif directory == "".."":\n            cwd = os.path.split(cwd)[0]\n            continue\n        best_match = min(_get_sub_dirs(cwd), key=lambda x: _dam_lev_dist(directory, x))\n        if _dam_lev_dist(directory, best_match) > MAX_ALLOWED_STR_DIST:\n            return cd_mkdir.get_new_command(command, settings)\n        else:\n            cwd = os.path.join(cwd, best_match)\n    return ""cd {0}"".format(cwd) \n\nenabled_by_default = True\n']","[[<pydriller.domain.commit.Method object at 0x7f1982905d30>, <pydriller.domain.commit.Method object at 0x7f1982905a90>, <pydriller.domain.commit.Method object at 0x7f1982905df0>, <pydriller.domain.commit.Method object at 0x7f1982905ac0>, <pydriller.domain.commit.Method object at 0x7f1983f5a2e0>]]",[[]]
thefuck,252859e63a1f41d79899d289da763b973df6a395,fixed accidentally correcting to some directories with short name length,2015-05-16 23:53:08-07:00,mmussomele,2,1,3,1,['cd_correction.py'],"['#!/usr/bin/env python\n__author__ = ""mmussomele""\n\n""""""Attempts to spellcheck and correct failed cd commands""""""\n\nimport os\nimport cd_mkdir\nfrom thefuck.utils import sudo_support\n\nMAX_ALLOWED_STR_DIST = 5\n\ndef _get_sub_dirs(parent):\n    """"""Returns a list of the child directories of the given parent directory""""""\n    return [child for child in os.listdir(parent) if os.path.isdir(os.path.join(parent, child))]\n\ndef _dam_lev_dist():\n    """"""Returns a Damerau-Levenshtein distance calculator.""""""\n    cache = {}\n    def _calculator(first, second):\n        """"""\n        Calculates the Damerau-Levenshtein distance of two strings.\n        See: http://en.wikipedia.org/wiki/Damerau-Levenshtein_distance#Algorithm\n        """"""\n        if (first, second) in cache:\n            return cache[(first, second)]\n        else:\n            l_first = len(first)\n            l_second = len(second)\n            distances = [[0 for _ in range(l_second + 1)] for _ in range(l_first + 1)]\n            for i in range(l_first + 1):\n                distances[i][0] = i\n            for j in range(1, l_second + 1):\n                distances[0][j] = j\n            for i in range(l_first):\n                for j in range(l_second):\n                    if first[i] == second[j]:\n                        cost = 0\n                    else:\n                        cost = 1\n                    distances[i+1][j+1] = min(distances[i][j+1] + 1, \n                                              distances[i+1][j] + 1,\n                                              distances[i][j] + cost)\n                    if i and j and first[i] == second[j-1] and first[i-1] == second[j]:\n                        distances[i][j] = min(distances[i+1][j+1],\n                                              distances[i-1][j-1] + cost)\n            cache[(first, second)] = distances[l_first][l_second]\n            return distances[l_first][l_second]\n    return _calculator\n\n_dam_lev_dist = _dam_lev_dist()\n\n@sudo_support\ndef match(command, settings):\n    """"""Match function copied from cd_mkdir.py""""""\n    return (command.script.startswith(\'cd \')\n        and (\'no such file or directory\' in command.stderr.lower()\n            or \'cd: can\\\'t cd to\' in command.stderr.lower()))\n\n@sudo_support\ndef get_new_command(command, settings):\n    """"""\n    Attempt to rebuild the path string by spellchecking the directories.\n    If it fails (i.e. no directories are a close enough match), then it \n    defaults to the rules of cd_mkdir. \n    Change sensitivity to matching by changing MAX_ALLOWED_STR_DIST. \n    Higher values allow for larger discrepancies in path names. \n    """"""\n    dest = command.script.split()[1].split(os.sep)\n    if dest[-1] == \'\':\n        dest = dest[:-1]\n    cwd = os.getcwd()\n    for directory in dest:\n        if directory == ""."":\n            continue\n        elif directory == "".."":\n            cwd = os.path.split(cwd)[0]\n            continue\n        best_match = min(_get_sub_dirs(cwd), key=lambda x: _dam_lev_dist(directory, x))\n        if _dam_lev_dist(directory, best_match) > MAX_ALLOWED_STR_DIST:\n            return cd_mkdir.get_new_command(command, settings)\n        else:\n            cwd = os.path.join(cwd, best_match)\n    return ""cd {0}"".format(cwd) \n\nenabled_by_default = True\n']","['#!/usr/bin/env python\n__author__ = ""mmussomele""\n\n""""""Attempts to spellcheck and correct failed cd commands""""""\n\nimport os\nimport cd_mkdir\nfrom thefuck.utils import sudo_support\n\nMAX_ALLOWED_STR_DIST = 5\n\ndef _get_sub_dirs(parent):\n    """"""Returns a list of the child directories of the given parent directory""""""\n    return [child for child in os.listdir(parent) if os.path.isdir(os.path.join(parent, child))]\n\ndef _dam_lev_dist():\n    """"""Returns a Damerau-Levenshtein distance calculator.""""""\n    cache = {}\n    def _calculator(first, second):\n        """"""\n        Calculates the Damerau-Levenshtein distance of two strings.\n        See: http://en.wikipedia.org/wiki/Damerau-Levenshtein_distance#Algorithm\n        """"""\n        if (first, second) in cache:\n            return cache[(first, second)]\n        else:\n            l_first = len(first)\n            l_second = len(second)\n            distances = [[0 for _ in range(l_second + 1)] for _ in range(l_first + 1)]\n            for i in range(l_first + 1):\n                distances[i][0] = i\n            for j in range(1, l_second + 1):\n                distances[0][j] = j\n            for i in range(l_first):\n                for j in range(l_second):\n                    if first[i] == second[j]:\n                        cost = 0\n                    else:\n                        cost = 1\n                    distances[i+1][j+1] = min(distances[i][j+1] + 1, \n                                              distances[i+1][j] + 1,\n                                              distances[i][j] + cost)\n                    if i and j and first[i] == second[j-1] and first[i-1] == second[j]:\n                        distances[i][j] = min(distances[i+1][j+1],\n                                              distances[i-1][j-1] + cost)\n            cache[(first, second)] = distances[l_first][l_second]\n            return distances[l_first][l_second]\n    return _calculator\n\n_dam_lev_dist = _dam_lev_dist()\n\n@sudo_support\ndef match(command, settings):\n    """"""Match function copied from cd_mkdir.py""""""\n    return (command.script.startswith(\'cd \')\n        and (\'no such file or directory\' in command.stderr.lower()\n            or \'cd: can\\\'t cd to\' in command.stderr.lower()))\n\n@sudo_support\ndef get_new_command(command, settings):\n    """"""\n    Attempt to rebuild the path string by spellchecking the directories.\n    If it fails (i.e. no directories are a close enough match), then it \n    defaults to the rules of cd_mkdir. \n    Change sensitivity to matching by changing MAX_ALLOWED_STR_DIST. \n    Higher values allow for larger discrepancies in path names. \n    """"""\n    dest = command.script.split()[1].split(os.sep)\n    if dest[-1] == \'\':\n        dest = dest[:-1]\n    cwd = os.getcwd()\n    for directory in dest:\n        if directory == ""."":\n            continue\n        elif directory == "".."":\n            cwd = os.path.split(cwd)[0]\n            continue\n        best_match = min(_get_sub_dirs(cwd), key=lambda x: _dam_lev_dist(directory, x))\n        best_dist = _dam_lev_dist(directory, best_match)\n        if best_dist > MAX_ALLOWED_STR_DIST or best_dist >= len(best_match):\n            return cd_mkdir.get_new_command(command, settings)\n        else:\n            cwd = os.path.join(cwd, best_match)\n    return ""cd {0}"".format(cwd) \n\nenabled_by_default = True\n']","[[<pydriller.domain.commit.Method object at 0x7f1983f647f0>, <pydriller.domain.commit.Method object at 0x7f1983f64040>, <pydriller.domain.commit.Method object at 0x7f1983f64070>, <pydriller.domain.commit.Method object at 0x7f1983f64760>, <pydriller.domain.commit.Method object at 0x7f1983f64a00>]]",[[<pydriller.domain.commit.Method object at 0x7f1983f64eb0>]]
thefuck,8d256390a1215540bcba0186796e15265168a62d,"refact(shells): use os.path.basename to get the name of the shell

Signed-off-by: Pablo Santiago Blum de Aguiar <scorphus@gmail.com>",2015-05-17 12:57:45-03:00,Pablo Santiago Blum de Aguiar,1,1,2,1,['shells.py'],"['""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias` and `put_to_history`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\nfrom .utils import DEVNULL\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n    def and_(self, *commands):\n        return \' && \'.join(commands)\n\n\nclass Bash(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Zsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nclass Tcsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(""\\t"", 1)\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'tcsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'\\t\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'#+{}\\n{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'zsh\': Zsh(),\n    \'-csh\': Tcsh(),\n    \'tcsh\': Tcsh()})\n\n\ndef _get_shell():\n    try:\n        shell = Process(os.getpid()).parent().cmdline()[0]\n    except TypeError:\n        shell = Process(os.getpid()).parent.cmdline[0]\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    print(_get_shell().app_alias())\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n\n\ndef and_(*commands):\n    return _get_shell().and_(*commands)\n']","['""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias` and `put_to_history`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\nfrom .utils import DEVNULL\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n    def and_(self, *commands):\n        return \' && \'.join(commands)\n\n\nclass Bash(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Zsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nclass Tcsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(""\\t"", 1)\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'tcsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'\\t\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'#+{}\\n{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'zsh\': Zsh(),\n    \'-csh\': Tcsh(),\n    \'tcsh\': Tcsh()})\n\n\ndef _get_shell():\n    try:\n        shell = Process(os.getpid()).parent().cmdline()[0]\n    except TypeError:\n        shell = Process(os.getpid()).parent.cmdline[0]\n    return shells[os.path.basename(shell)]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    print(_get_shell().app_alias())\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n\n\ndef and_(*commands):\n    return _get_shell().and_(*commands)\n']","[[<pydriller.domain.commit.Method object at 0x7f198290c4f0>, <pydriller.domain.commit.Method object at 0x7f198290c250>, <pydriller.domain.commit.Method object at 0x7f198290ca00>, <pydriller.domain.commit.Method object at 0x7f198290cd00>, <pydriller.domain.commit.Method object at 0x7f19828b9160>, <pydriller.domain.commit.Method object at 0x7f19828b9d30>, <pydriller.domain.commit.Method object at 0x7f19828b9760>, <pydriller.domain.commit.Method object at 0x7f19828b96d0>, <pydriller.domain.commit.Method object at 0x7f19828b9df0>, <pydriller.domain.commit.Method object at 0x7f19828b9a60>, <pydriller.domain.commit.Method object at 0x7f19828b9310>, <pydriller.domain.commit.Method object at 0x7f19828b9070>, <pydriller.domain.commit.Method object at 0x7f19828b9790>, <pydriller.domain.commit.Method object at 0x7f19828cb3a0>, <pydriller.domain.commit.Method object at 0x7f19828cb7f0>, <pydriller.domain.commit.Method object at 0x7f19828cb520>, <pydriller.domain.commit.Method object at 0x7f19828cb760>, <pydriller.domain.commit.Method object at 0x7f19828cb640>, <pydriller.domain.commit.Method object at 0x7f19828cba30>, <pydriller.domain.commit.Method object at 0x7f19828cb790>, <pydriller.domain.commit.Method object at 0x7f19828cbb20>, <pydriller.domain.commit.Method object at 0x7f19828cb8e0>, <pydriller.domain.commit.Method object at 0x7f19828cbb50>, <pydriller.domain.commit.Method object at 0x7f19828cb700>, <pydriller.domain.commit.Method object at 0x7f19828cb5b0>, <pydriller.domain.commit.Method object at 0x7f19828cbac0>, <pydriller.domain.commit.Method object at 0x7f19828cb880>, <pydriller.domain.commit.Method object at 0x7f19828cb580>, <pydriller.domain.commit.Method object at 0x7f19828cb400>, <pydriller.domain.commit.Method object at 0x7f19828cba00>]]",[[<pydriller.domain.commit.Method object at 0x7f1983f6ba00>]]
thefuck,1b5c935f30371d2cf147de83c327b8a7495b2c10,"feat(shells): add specific actions for the Fish shell

Signed-off-by: Pablo Santiago Blum de Aguiar <scorphus@gmail.com>",2015-05-17 12:57:45-03:00,Pablo Santiago Blum de Aguiar,48,0,48,2,"['test_shells.py', 'shells.py']","[""import pytest\nfrom thefuck import shells\n\n\n@pytest.fixture\ndef builtins_open(mocker):\n    return mocker.patch('six.moves.builtins.open')\n\n\n@pytest.fixture\ndef isfile(mocker):\n    return mocker.patch('os.path.isfile', return_value=True)\n\n\nclass TestGeneric(object):\n    def test_from_shell(self):\n        assert shells.Generic().from_shell('pwd') == 'pwd'\n\n    def test_to_shell(self):\n        assert shells.Generic().to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open):\n        assert shells.Generic().put_to_history('ls') is None\n        assert builtins_open.call_count == 0\n\n\n@pytest.mark.usefixtures('isfile')\nclass TestBash(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, mocker):\n        mock = mocker.patch('thefuck.shells.Popen')\n        mock.return_value.stdout.read.return_value = (\n            b'alias l=\\'ls -CF\\'\\n'\n            b'alias la=\\'ls -A\\'\\n'\n            b'alias ll=\\'ls -alF\\'')\n        return mock\n\n    @pytest.mark.parametrize('before, after', [\n        ('pwd', 'pwd'),\n        ('ll', 'ls -alF')])\n    def test_from_shell(self, before, after):\n        assert shells.Bash().from_shell(before) == after\n\n    def test_to_shell(self):\n        assert shells.Bash().to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open):\n        shells.Bash().put_to_history('ls')\n        builtins_open.return_value.__enter__.return_value. \\\n            write.assert_called_once_with('ls\\n')\n\n\n@pytest.mark.usefixtures('isfile')\nclass TestZsh(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, mocker):\n        mock = mocker.patch('thefuck.shells.Popen')\n        mock.return_value.stdout.read.return_value = (\n            b'l=\\'ls -CF\\'\\n'\n            b'la=\\'ls -A\\'\\n'\n            b'll=\\'ls -alF\\'')\n        return mock\n\n    @pytest.mark.parametrize('before, after', [\n        ('pwd', 'pwd'),\n        ('ll', 'ls -alF')])\n    def test_from_shell(self, before, after):\n        assert shells.Zsh().from_shell(before) == after\n\n    def test_to_shell(self):\n        assert shells.Zsh().to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open, mocker):\n        mocker.patch('thefuck.shells.time',\n                     return_value=1430707243.3517463)\n        shells.Zsh().put_to_history('ls')\n        builtins_open.return_value.__enter__.return_value. \\\n            write.assert_called_once_with(': 1430707243:0;ls\\n')\n"", '""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias` and `put_to_history`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\nfrom .utils import DEVNULL\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n    def and_(self, *commands):\n        return \' && \'.join(commands)\n\n\nclass Bash(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Zsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nclass Tcsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(""\\t"", 1)\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'tcsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'\\t\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'#+{}\\n{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'zsh\': Zsh(),\n    \'-csh\': Tcsh(),\n    \'tcsh\': Tcsh()})\n\n\ndef _get_shell():\n    try:\n        shell = Process(os.getpid()).parent().cmdline()[0]\n    except TypeError:\n        shell = Process(os.getpid()).parent.cmdline[0]\n    return shells[os.path.basename(shell)]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    print(_get_shell().app_alias())\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n\n\ndef and_(*commands):\n    return _get_shell().and_(*commands)\n']","[""import pytest\nfrom thefuck import shells\n\n\n@pytest.fixture\ndef builtins_open(mocker):\n    return mocker.patch('six.moves.builtins.open')\n\n\n@pytest.fixture\ndef isfile(mocker):\n    return mocker.patch('os.path.isfile', return_value=True)\n\n\nclass TestGeneric(object):\n    def test_from_shell(self):\n        assert shells.Generic().from_shell('pwd') == 'pwd'\n\n    def test_to_shell(self):\n        assert shells.Generic().to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open):\n        assert shells.Generic().put_to_history('ls') is None\n        assert builtins_open.call_count == 0\n\n\n@pytest.mark.usefixtures('isfile')\nclass TestBash(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, mocker):\n        mock = mocker.patch('thefuck.shells.Popen')\n        mock.return_value.stdout.read.return_value = (\n            b'alias l=\\'ls -CF\\'\\n'\n            b'alias la=\\'ls -A\\'\\n'\n            b'alias ll=\\'ls -alF\\'')\n        return mock\n\n    @pytest.mark.parametrize('before, after', [\n        ('pwd', 'pwd'),\n        ('ll', 'ls -alF')])\n    def test_from_shell(self, before, after):\n        assert shells.Bash().from_shell(before) == after\n\n    def test_to_shell(self):\n        assert shells.Bash().to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open):\n        shells.Bash().put_to_history('ls')\n        builtins_open.return_value.__enter__.return_value. \\\n            write.assert_called_once_with('ls\\n')\n\n\n@pytest.mark.usefixtures('isfile')\nclass TestFish(object):\n    @pytest.mark.parametrize('before, after', [\n        ('pwd', 'pwd'),\n        ('ll', 'll')])  # Fish has no aliases but functions\n    def test_from_shell(self, before, after):\n        assert shells.Fish().from_shell(before) == after\n\n    def test_to_shell(self):\n        assert shells.Fish().to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open, mocker):\n        mocker.patch('thefuck.shells.time',\n                     return_value=1430707243.3517463)\n        shells.Fish().put_to_history('ls')\n        builtins_open.return_value.__enter__.return_value. \\\n            write.assert_called_once_with('- cmd: ls\\n   when: 1430707243\\n')\n\n    def test_and_(self):\n        assert shells.Fish().and_('foo', 'bar') == 'foo; and bar'\n\n\n@pytest.mark.usefixtures('isfile')\nclass TestZsh(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, mocker):\n        mock = mocker.patch('thefuck.shells.Popen')\n        mock.return_value.stdout.read.return_value = (\n            b'l=\\'ls -CF\\'\\n'\n            b'la=\\'ls -A\\'\\n'\n            b'll=\\'ls -alF\\'')\n        return mock\n\n    @pytest.mark.parametrize('before, after', [\n        ('pwd', 'pwd'),\n        ('ll', 'ls -alF')])\n    def test_from_shell(self, before, after):\n        assert shells.Zsh().from_shell(before) == after\n\n    def test_to_shell(self):\n        assert shells.Zsh().to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open, mocker):\n        mocker.patch('thefuck.shells.time',\n                     return_value=1430707243.3517463)\n        shells.Zsh().put_to_history('ls')\n        builtins_open.return_value.__enter__.return_value. \\\n            write.assert_called_once_with(': 1430707243:0;ls\\n')\n"", '""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias` and `put_to_history`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\nfrom .utils import DEVNULL\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n    def and_(self, *commands):\n        return \' && \'.join(commands)\n\n\nclass Bash(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Fish(Generic):\n    def app_alias(self):\n        return (""function fuck -d \'Correct your previous console command\'\\n""\n                ""    set -l exit_code $status\\n""\n                ""    set -l eval_script""\n                "" (mktemp 2>/dev/null ; or mktemp -t \'thefuck\')\\n""\n                ""    set -l fucked_up_commandd $history[1]\\n""\n                ""    thefuck $fucked_up_commandd > $eval_script\\n""\n                ""    . $eval_script\\n""\n                ""    rm $eval_script\\n""\n                ""    if test $exit_code -ne 0\\n""\n                ""        history --delete $fucked_up_commandd\\n""\n                ""    end\\n""\n                ""end"")\n\n    def _get_history_file_name(self):\n        return os.path.expanduser(\'~/.config/fish/fish_history\')\n\n    def _get_history_line(self, command_script):\n        return u\'- cmd: {}\\n   when: {}\\n\'.format(command_script, int(time()))\n\n    def and_(self, *commands):\n        return \'; and \'.join(commands)\n\n\nclass Zsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nclass Tcsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(""\\t"", 1)\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'tcsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'\\t\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'#+{}\\n{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'fish\': Fish(),\n    \'zsh\': Zsh(),\n    \'-csh\': Tcsh(),\n    \'tcsh\': Tcsh()})\n\n\ndef _get_shell():\n    try:\n        shell = Process(os.getpid()).parent().cmdline()[0]\n    except TypeError:\n        shell = Process(os.getpid()).parent.cmdline[0]\n    return shells[os.path.basename(shell)]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    print(_get_shell().app_alias())\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n\n\ndef and_(*commands):\n    return _get_shell().and_(*commands)\n']","[[<pydriller.domain.commit.Method object at 0x7f19828cbc70>, <pydriller.domain.commit.Method object at 0x7f19828cbcd0>, <pydriller.domain.commit.Method object at 0x7f19828e6040>, <pydriller.domain.commit.Method object at 0x7f19828e6070>, <pydriller.domain.commit.Method object at 0x7f19828e6310>, <pydriller.domain.commit.Method object at 0x7f19828e6340>, <pydriller.domain.commit.Method object at 0x7f19828e6370>, <pydriller.domain.commit.Method object at 0x7f19828e63a0>, <pydriller.domain.commit.Method object at 0x7f19828e63d0>, <pydriller.domain.commit.Method object at 0x7f19828e6400>, <pydriller.domain.commit.Method object at 0x7f19828cb940>, <pydriller.domain.commit.Method object at 0x7f19828cb7c0>, <pydriller.domain.commit.Method object at 0x7f19828cb970>], [<pydriller.domain.commit.Method object at 0x7f1983f6b070>, <pydriller.domain.commit.Method object at 0x7f1983f6b970>, <pydriller.domain.commit.Method object at 0x7f1983f6baf0>, <pydriller.domain.commit.Method object at 0x7f1983f6b880>, <pydriller.domain.commit.Method object at 0x7f1983f64c70>, <pydriller.domain.commit.Method object at 0x7f1983f645b0>, <pydriller.domain.commit.Method object at 0x7f1983f646a0>, <pydriller.domain.commit.Method object at 0x7f1983f55610>, <pydriller.domain.commit.Method object at 0x7f1983f557f0>, <pydriller.domain.commit.Method object at 0x7f1983f55ee0>, <pydriller.domain.commit.Method object at 0x7f1983f554c0>, <pydriller.domain.commit.Method object at 0x7f1983f556d0>, <pydriller.domain.commit.Method object at 0x7f1983f55a00>, <pydriller.domain.commit.Method object at 0x7f1983f55760>, <pydriller.domain.commit.Method object at 0x7f1983f559d0>, <pydriller.domain.commit.Method object at 0x7f1982905790>, <pydriller.domain.commit.Method object at 0x7f1982905c70>, <pydriller.domain.commit.Method object at 0x7f19829059d0>, <pydriller.domain.commit.Method object at 0x7f1982905520>, <pydriller.domain.commit.Method object at 0x7f1982905dc0>, <pydriller.domain.commit.Method object at 0x7f1982905ca0>, <pydriller.domain.commit.Method object at 0x7f1982905bb0>, <pydriller.domain.commit.Method object at 0x7f1982905d00>, <pydriller.domain.commit.Method object at 0x7f1982905550>, <pydriller.domain.commit.Method object at 0x7f1982905670>, <pydriller.domain.commit.Method object at 0x7f1982905af0>, <pydriller.domain.commit.Method object at 0x7f1983f5a220>, <pydriller.domain.commit.Method object at 0x7f1983f5a880>, <pydriller.domain.commit.Method object at 0x7f1983f5ad00>, <pydriller.domain.commit.Method object at 0x7f1983f5a2b0>]]","[[<pydriller.domain.commit.Method object at 0x7f19828cbdf0>, <pydriller.domain.commit.Method object at 0x7f19828cbc40>, <pydriller.domain.commit.Method object at 0x7f19828cb4f0>, <pydriller.domain.commit.Method object at 0x7f19828cba60>], [<pydriller.domain.commit.Method object at 0x7f1983f60970>, <pydriller.domain.commit.Method object at 0x7f1983f606d0>, <pydriller.domain.commit.Method object at 0x7f19828b95e0>, <pydriller.domain.commit.Method object at 0x7f1983f60760>]]"
thefuck,8fdcff776a37579c55281c2107a178ea77bf4317,reimplemented using native string matching,2015-05-17 09:03:19-07:00,mmussomele,7,44,51,1,['cd_correction.py'],"['#!/usr/bin/env python\n__author__ = ""mmussomele""\n\n""""""Attempts to spellcheck and correct failed cd commands""""""\n\nimport os\nimport cd_mkdir\nfrom thefuck.utils import sudo_support\n\nMAX_ALLOWED_STR_DIST = 5\n\ndef _get_sub_dirs(parent):\n    """"""Returns a list of the child directories of the given parent directory""""""\n    return [child for child in os.listdir(parent) if os.path.isdir(os.path.join(parent, child))]\n\ndef _dam_lev_dist():\n    """"""Returns a Damerau-Levenshtein distance calculator.""""""\n    cache = {}\n    def _calculator(first, second):\n        """"""\n        Calculates the Damerau-Levenshtein distance of two strings.\n        See: http://en.wikipedia.org/wiki/Damerau-Levenshtein_distance#Algorithm\n        """"""\n        if (first, second) in cache:\n            return cache[(first, second)]\n        else:\n            l_first = len(first)\n            l_second = len(second)\n            distances = [[0 for _ in range(l_second + 1)] for _ in range(l_first + 1)]\n            for i in range(l_first + 1):\n                distances[i][0] = i\n            for j in range(1, l_second + 1):\n                distances[0][j] = j\n            for i in range(l_first):\n                for j in range(l_second):\n                    if first[i] == second[j]:\n                        cost = 0\n                    else:\n                        cost = 1\n                    distances[i+1][j+1] = min(distances[i][j+1] + 1, \n                                              distances[i+1][j] + 1,\n                                              distances[i][j] + cost)\n                    if i and j and first[i] == second[j-1] and first[i-1] == second[j]:\n                        distances[i][j] = min(distances[i+1][j+1],\n                                              distances[i-1][j-1] + cost)\n            cache[(first, second)] = distances[l_first][l_second]\n            return distances[l_first][l_second]\n    return _calculator\n\n_dam_lev_dist = _dam_lev_dist()\n\n@sudo_support\ndef match(command, settings):\n    """"""Match function copied from cd_mkdir.py""""""\n    return (command.script.startswith(\'cd \')\n        and (\'no such file or directory\' in command.stderr.lower()\n            or \'cd: can\\\'t cd to\' in command.stderr.lower()))\n\n@sudo_support\ndef get_new_command(command, settings):\n    """"""\n    Attempt to rebuild the path string by spellchecking the directories.\n    If it fails (i.e. no directories are a close enough match), then it \n    defaults to the rules of cd_mkdir. \n    Change sensitivity to matching by changing MAX_ALLOWED_STR_DIST. \n    Higher values allow for larger discrepancies in path names. \n    """"""\n    dest = command.script.split()[1].split(os.sep)\n    if dest[-1] == \'\':\n        dest = dest[:-1]\n    cwd = os.getcwd()\n    for directory in dest:\n        if directory == ""."":\n            continue\n        elif directory == "".."":\n            cwd = os.path.split(cwd)[0]\n            continue\n        best_match = min(_get_sub_dirs(cwd), key=lambda x: _dam_lev_dist(directory, x))\n        best_dist = _dam_lev_dist(directory, best_match)\n        if best_dist > MAX_ALLOWED_STR_DIST or best_dist >= len(best_match):\n            return cd_mkdir.get_new_command(command, settings)\n        else:\n            cwd = os.path.join(cwd, best_match)\n    return ""cd {0}"".format(cwd) \n\nenabled_by_default = True\n']","['#!/usr/bin/env python\n__author__ = ""mmussomele""\n\n""""""Attempts to spellcheck and correct failed cd commands""""""\n\nimport os\nimport cd_mkdir\nfrom difflib import get_close_matches\nfrom thefuck.utils import sudo_support\n\nMAX_ALLOWED_DIFF = 0.6\n\ndef _get_sub_dirs(parent):\n    """"""Returns a list of the child directories of the given parent directory""""""\n    return [child for child in os.listdir(parent) if os.path.isdir(os.path.join(parent, child))]\n\n@sudo_support\ndef match(command, settings):\n    """"""Match function copied from cd_mkdir.py""""""\n    return (command.script.startswith(\'cd \')\n        and (\'no such file or directory\' in command.stderr.lower()\n            or \'cd: can\\\'t cd to\' in command.stderr.lower()))\n\n@sudo_support\ndef get_new_command(command, settings):\n    """"""\n    Attempt to rebuild the path string by spellchecking the directories.\n    If it fails (i.e. no directories are a close enough match), then it \n    defaults to the rules of cd_mkdir. \n    Change sensitivity by changing MAX_ALLOWED_DIFF. Default value is 0.6\n    """"""\n    dest = command.script.split()[1].split(os.sep)\n    if dest[-1] == \'\':\n        dest = dest[:-1]\n    cwd = os.getcwd()\n    for directory in dest:\n        if directory == ""."":\n            continue\n        elif directory == "".."":\n            cwd = os.path.split(cwd)[0]\n            continue\n        best_matches = get_close_matches(directory, _get_sub_dirs(cwd), cutoff=MAX_ALLOWED_DIFF)\n        if len(best_matches):\n            cwd = os.path.join(cwd, best_matches[0])\n        else:\n            return cd_mkdir.get_new_command(command, settings)\n    return ""cd {0}"".format(cwd) \n\nenabled_by_default = True\n']","[[<pydriller.domain.commit.Method object at 0x7f1983f60ac0>, <pydriller.domain.commit.Method object at 0x7f1983f60dc0>, <pydriller.domain.commit.Method object at 0x7f1983f60820>, <pydriller.domain.commit.Method object at 0x7f1983f60370>, <pydriller.domain.commit.Method object at 0x7f1983f5a6a0>]]","[[<pydriller.domain.commit.Method object at 0x7f19828b9910>, <pydriller.domain.commit.Method object at 0x7f1983f60dc0>, <pydriller.domain.commit.Method object at 0x7f1983f60820>]]"
thefuck,3c673e097238fae27ba5f4786485d58f4c9c5af5,fixed extra check,2015-05-17 09:52:42-07:00,mmussomele,1,1,2,1,['cd_correction.py'],"['#!/usr/bin/env python\n__author__ = ""mmussomele""\n\n""""""Attempts to spellcheck and correct failed cd commands""""""\n\nimport os\nimport cd_mkdir\nfrom difflib import get_close_matches\nfrom thefuck.utils import sudo_support\n\nMAX_ALLOWED_DIFF = 0.6\n\ndef _get_sub_dirs(parent):\n    """"""Returns a list of the child directories of the given parent directory""""""\n    return [child for child in os.listdir(parent) if os.path.isdir(os.path.join(parent, child))]\n\n@sudo_support\ndef match(command, settings):\n    """"""Match function copied from cd_mkdir.py""""""\n    return (command.script.startswith(\'cd \')\n        and (\'no such file or directory\' in command.stderr.lower()\n            or \'cd: can\\\'t cd to\' in command.stderr.lower()))\n\n@sudo_support\ndef get_new_command(command, settings):\n    """"""\n    Attempt to rebuild the path string by spellchecking the directories.\n    If it fails (i.e. no directories are a close enough match), then it \n    defaults to the rules of cd_mkdir. \n    Change sensitivity by changing MAX_ALLOWED_DIFF. Default value is 0.6\n    """"""\n    dest = command.script.split()[1].split(os.sep)\n    if dest[-1] == \'\':\n        dest = dest[:-1]\n    cwd = os.getcwd()\n    for directory in dest:\n        if directory == ""."":\n            continue\n        elif directory == "".."":\n            cwd = os.path.split(cwd)[0]\n            continue\n        best_matches = get_close_matches(directory, _get_sub_dirs(cwd), cutoff=MAX_ALLOWED_DIFF)\n        if len(best_matches):\n            cwd = os.path.join(cwd, best_matches[0])\n        else:\n            return cd_mkdir.get_new_command(command, settings)\n    return ""cd {0}"".format(cwd) \n\nenabled_by_default = True\n']","['#!/usr/bin/env python\n__author__ = ""mmussomele""\n\n""""""Attempts to spellcheck and correct failed cd commands""""""\n\nimport os\nimport cd_mkdir\nfrom difflib import get_close_matches\nfrom thefuck.utils import sudo_support\n\nMAX_ALLOWED_DIFF = 0.6\n\ndef _get_sub_dirs(parent):\n    """"""Returns a list of the child directories of the given parent directory""""""\n    return [child for child in os.listdir(parent) if os.path.isdir(os.path.join(parent, child))]\n\n@sudo_support\ndef match(command, settings):\n    """"""Match function copied from cd_mkdir.py""""""\n    return (command.script.startswith(\'cd \')\n        and (\'no such file or directory\' in command.stderr.lower()\n            or \'cd: can\\\'t cd to\' in command.stderr.lower()))\n\n@sudo_support\ndef get_new_command(command, settings):\n    """"""\n    Attempt to rebuild the path string by spellchecking the directories.\n    If it fails (i.e. no directories are a close enough match), then it \n    defaults to the rules of cd_mkdir. \n    Change sensitivity by changing MAX_ALLOWED_DIFF. Default value is 0.6\n    """"""\n    dest = command.script.split()[1].split(os.sep)\n    if dest[-1] == \'\':\n        dest = dest[:-1]\n    cwd = os.getcwd()\n    for directory in dest:\n        if directory == ""."":\n            continue\n        elif directory == "".."":\n            cwd = os.path.split(cwd)[0]\n            continue\n        best_matches = get_close_matches(directory, _get_sub_dirs(cwd), cutoff=MAX_ALLOWED_DIFF)\n        if best_matches:\n            cwd = os.path.join(cwd, best_matches[0])\n        else:\n            return cd_mkdir.get_new_command(command, settings)\n    return ""cd {0}"".format(cwd) \n\nenabled_by_default = True\n']","[[<pydriller.domain.commit.Method object at 0x7f1983fc93a0>, <pydriller.domain.commit.Method object at 0x7f1983fc97f0>, <pydriller.domain.commit.Method object at 0x7f1983fc93d0>]]",[[<pydriller.domain.commit.Method object at 0x7f1983f71a90>]]
thefuck,afcee5844bee3b13c5d1c70bd9d5c7df1081fcc9,Fix pacman tests on Arch Linux,2015-05-18 09:41:49+02:00,mcarton,19,6,25,1,['test_pacman.py'],"[""import pytest\nfrom mock import patch\nfrom thefuck.rules import pacman\nfrom thefuck.rules.pacman import match, get_new_command\nfrom tests.utils import Command\n\n\npacman_cmd = getattr(pacman, 'pacman', 'pacman')\n\n\n@pytest.mark.skipif(not getattr(pacman, 'enabled_by_default', True),\n                    reason='Skip if pacman is not available')\n@pytest.mark.parametrize('command', [\n    Command(script='vim', stderr='vim: command not found')])\ndef test_match(command):\n    assert match(command, None)\n\n\n@pytest.mark.parametrize('command, return_value', [\n    (Command(script='vim', stderr='vim: command not found'), 'vim foo bar')])\n@patch('thefuck.rules.pacman.subprocess')\n@patch.multiple(pacman, create=True, pacman=pacman_cmd)\ndef test_match_mocked(subp_mock, command, return_value):\n    subp_mock.check_output.return_value = return_value\n    assert match(command, None)\n    assert subp_mock.check_output.called\n\n\n@pytest.mark.parametrize('command', [\n    Command(script='vim', stderr=''), Command()])\ndef test_not_match(command):\n    assert not match(command, None)\n\n\n@pytest.mark.skipif(not getattr(pacman, 'enabled_by_default', True),\n                    reason='Skip if pacman is not available')\n@pytest.mark.parametrize('command, new_command', [\n    (Command('vim'), '{} -S vim && vim'.format(pacman_cmd)),\n    (Command('convert'), '{} -S imagemagick && convert'.format(pacman_cmd))])\ndef test_get_new_command(command, new_command, mocker):\n    assert get_new_command(command, None) == new_command\n\n\n@pytest.mark.parametrize('command, new_command, return_value', [\n    (Command('vim'), '{} -S vim && vim'.format(pacman_cmd), 'vim foo bar'),\n    (Command('convert'), '{} -S imagemagick && convert'.format(pacman_cmd),\n     'imagemagick foo bar')])\n@patch('thefuck.rules.pacman.subprocess')\n@patch.multiple(pacman, create=True, pacman=pacman_cmd)\ndef test_get_new_command_mocked(subp_mock, command, new_command, return_value):\n    subp_mock.check_output.return_value = return_value\n    assert get_new_command(command, None) == new_command\n    assert subp_mock.check_output.called\n""]","[""import pytest\nfrom mock import patch\nfrom thefuck.rules import pacman\nfrom thefuck.rules.pacman import match, get_new_command\nfrom tests.utils import Command\n\n\npacman_cmd = getattr(pacman, 'pacman', 'pacman')\n\nPKGFILE_OUTPUT_CONVERT = '''\nextra/imagemagick 6.9.1.0-1\\t/usr/bin/convert\n'''\n\nPKGFILE_OUTPUT_VIM = '''\nextra/gvim 7.4.712-1        \\t/usr/bin/vim\nextra/gvim-python3 7.4.712-1\\t/usr/bin/vim\nextra/vim 7.4.712-1         \\t/usr/bin/vim\nextra/vim-minimal 7.4.712-1 \\t/usr/bin/vim\nextra/vim-python3 7.4.712-1 \\t/usr/bin/vim\n'''\n\n\n@pytest.mark.skipif(not getattr(pacman, 'enabled_by_default', True),\n                    reason='Skip if pacman is not available')\n@pytest.mark.parametrize('command', [\n    Command(script='vim', stderr='vim: command not found')])\ndef test_match(command):\n    assert match(command, None)\n\n\n@pytest.mark.parametrize('command, return_value', [\n    (Command(script='vim', stderr='vim: command not found'), PKGFILE_OUTPUT_VIM)])\n@patch('thefuck.rules.pacman.subprocess')\n@patch.multiple(pacman, create=True, pacman=pacman_cmd)\ndef test_match_mocked(subp_mock, command, return_value):\n    subp_mock.check_output.return_value = return_value\n    assert match(command, None)\n    assert subp_mock.check_output.called\n\n\n@pytest.mark.parametrize('command', [\n    Command(script='vim', stderr=''), Command()])\ndef test_not_match(command):\n    assert not match(command, None)\n\n\n@pytest.mark.skipif(not getattr(pacman, 'enabled_by_default', True),\n                    reason='Skip if pacman is not available')\n@pytest.mark.parametrize('command, new_command', [\n    (Command('vim'), '{} -S extra/gvim && vim'.format(pacman_cmd)),\n    (Command('convert'), '{} -S extra/imagemagick && convert'.format(pacman_cmd))])\ndef test_get_new_command(command, new_command, mocker):\n    assert get_new_command(command, None) == new_command\n\n\n@pytest.mark.parametrize('command, new_command, return_value', [\n    (Command('vim'), '{} -S extra/gvim && vim'.format(pacman_cmd),\n        PKGFILE_OUTPUT_VIM),\n    (Command('convert'), '{} -S extra/imagemagick && convert'.format(pacman_cmd),\n        PKGFILE_OUTPUT_CONVERT)])\n@patch('thefuck.rules.pacman.subprocess')\n@patch.multiple(pacman, create=True, pacman=pacman_cmd)\ndef test_get_new_command_mocked(subp_mock, command, new_command, return_value):\n    subp_mock.check_output.return_value = return_value\n    assert get_new_command(command, None) == new_command\n    assert subp_mock.check_output.called\n""]","[[<pydriller.domain.commit.Method object at 0x7f19828e6790>, <pydriller.domain.commit.Method object at 0x7f19828e65b0>, <pydriller.domain.commit.Method object at 0x7f19828e6250>, <pydriller.domain.commit.Method object at 0x7f19828e62e0>, <pydriller.domain.commit.Method object at 0x7f19828e67c0>]]",[[]]
thefuck,6590da623fb85c262fb8efe30f4ddbfed1ead376,#205 Fix import in `cd_correction`,2015-05-19 15:46:23+03:00,nvbn,8,4,12,1,['cd_correction.py'],"['#!/usr/bin/env python\n__author__ = ""mmussomele""\n\n""""""Attempts to spellcheck and correct failed cd commands""""""\n\nimport os\nimport cd_mkdir\nfrom difflib import get_close_matches\nfrom thefuck.utils import sudo_support\n\nMAX_ALLOWED_DIFF = 0.6\n\ndef _get_sub_dirs(parent):\n    """"""Returns a list of the child directories of the given parent directory""""""\n    return [child for child in os.listdir(parent) if os.path.isdir(os.path.join(parent, child))]\n\n@sudo_support\ndef match(command, settings):\n    """"""Match function copied from cd_mkdir.py""""""\n    return (command.script.startswith(\'cd \')\n        and (\'no such file or directory\' in command.stderr.lower()\n            or \'cd: can\\\'t cd to\' in command.stderr.lower()))\n\n@sudo_support\ndef get_new_command(command, settings):\n    """"""\n    Attempt to rebuild the path string by spellchecking the directories.\n    If it fails (i.e. no directories are a close enough match), then it \n    defaults to the rules of cd_mkdir. \n    Change sensitivity by changing MAX_ALLOWED_DIFF. Default value is 0.6\n    """"""\n    dest = command.script.split()[1].split(os.sep)\n    if dest[-1] == \'\':\n        dest = dest[:-1]\n    cwd = os.getcwd()\n    for directory in dest:\n        if directory == ""."":\n            continue\n        elif directory == "".."":\n            cwd = os.path.split(cwd)[0]\n            continue\n        best_matches = get_close_matches(directory, _get_sub_dirs(cwd), cutoff=MAX_ALLOWED_DIFF)\n        if best_matches:\n            cwd = os.path.join(cwd, best_matches[0])\n        else:\n            return cd_mkdir.get_new_command(command, settings)\n    return ""cd {0}"".format(cwd) \n\nenabled_by_default = True\n']","['#!/usr/bin/env python\n__author__ = ""mmussomele""\n\n""""""Attempts to spellcheck and correct failed cd commands""""""\n\nimport os\nfrom difflib import get_close_matches\nfrom thefuck.utils import sudo_support\nfrom thefuck.rules import cd_mkdir\n\nMAX_ALLOWED_DIFF = 0.6\n\n\ndef _get_sub_dirs(parent):\n    """"""Returns a list of the child directories of the given parent directory""""""\n    return [child for child in os.listdir(parent) if os.path.isdir(os.path.join(parent, child))]\n\n\n@sudo_support\ndef match(command, settings):\n    """"""Match function copied from cd_mkdir.py""""""\n    return (command.script.startswith(\'cd \')\n            and (\'no such file or directory\' in command.stderr.lower()\n                 or \'cd: can\\\'t cd to\' in command.stderr.lower()))\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    """"""\n    Attempt to rebuild the path string by spellchecking the directories.\n    If it fails (i.e. no directories are a close enough match), then it \n    defaults to the rules of cd_mkdir. \n    Change sensitivity by changing MAX_ALLOWED_DIFF. Default value is 0.6\n    """"""\n    dest = command.script.split()[1].split(os.sep)\n    if dest[-1] == \'\':\n        dest = dest[:-1]\n    cwd = os.getcwd()\n    for directory in dest:\n        if directory == ""."":\n            continue\n        elif directory == "".."":\n            cwd = os.path.split(cwd)[0]\n            continue\n        best_matches = get_close_matches(directory, _get_sub_dirs(cwd), cutoff=MAX_ALLOWED_DIFF)\n        if best_matches:\n            cwd = os.path.join(cwd, best_matches[0])\n        else:\n            return cd_mkdir.get_new_command(command, settings)\n    return ""cd {0}"".format(cwd)\n\n\nenabled_by_default = True\n']","[[<pydriller.domain.commit.Method object at 0x7f19828e6a90>, <pydriller.domain.commit.Method object at 0x7f19828e6940>, <pydriller.domain.commit.Method object at 0x7f19828e69d0>]]","[[<pydriller.domain.commit.Method object at 0x7f19828e61f0>, <pydriller.domain.commit.Method object at 0x7f19828e64c0>]]"
thefuck,051f5fcb8900c5e04dfd2c4876879a3628cdf933,Bump to 1.41,2015-05-19 15:48:17+03:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nVERSION = \'1.40\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\',\n          \'thefuck-alias = thefuck.shells:app_alias\']})\n']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.41\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\',\n          \'thefuck-alias = thefuck.shells:app_alias\']})\n']",[[]],[[]]
thefuck,ce6855fd97bda2fd456cd2842f50d44cb111995e,Add `git_pull` rule,2015-05-20 02:40:36+03:00,nvbn,42,0,42,3,"['README.md', 'test_git_pull.py', 'git_pull.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run the changed command, there is a `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to the `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\n```\n\nIf you are using `tcsh`:\n```tcsh\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match a rule for the previous command, creates a new command\nusing the matched rule and runs it. Rules enabled by default are as follows:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cpp11` &ndash; add missing `-std=c++11` to `g++` or `clang++`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `dry` &ndash; fix repetitions like ""git git push"";\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_add` &ndash; fix *""Did you forget to \'git add\'?""*;\n* `git_checkout` &ndash; creates the branch before checking-out;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `git_stash` &ndash; stashes you local modifications before rebasing or switching branch;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `no_such_file` &ndash; creates missing directories with `mv` and `cp` commands;\n* `man_no_space` &ndash; fixes man commands without spaces, for example `mandiff`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `whois` &ndash; fixes `whois` command;\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `composer_not_command` &ndash; fixes composer command name.\n\nBundled, but not enabled by default:\n\n* `ls_lah` &ndash; adds -lah to ls;\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n\n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call(\'chmod 777 .\', shell=True)\n\npriority = 1000  # Lower first\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters which can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; requires confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output;\n* `priority` &ndash; dict with rules priorities, rule with lower `priority` will be matched first.\n\nExample of `settings.py`:\n\n```python\nrules = [\'sudo\', \'no_command\']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\npriority = {\'sudo\': 100, \'no_command\': 9999}\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`;\n* `THEFUCK_PRIORITY` &ndash; priority of the rules, like `no_command=9999:apt_get=100`,\nrule with lower `priority` will be matched first.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES=\'sudo:no_command\'\nexport THEFUCK_REQUIRE_CONFIRMATION=\'true\'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS=\'false\'\nexport THEFUCK_PRIORITY=\'no_command=9999:apt_get=100\'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', None, None]","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run the changed command, there is a `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to the `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\n```\n\nIf you are using `tcsh`:\n```tcsh\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match a rule for the previous command, creates a new command\nusing the matched rule and runs it. Rules enabled by default are as follows:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cpp11` &ndash; add missing `-std=c++11` to `g++` or `clang++`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `dry` &ndash; fix repetitions like ""git git push"";\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_add` &ndash; fix *""Did you forget to \'git add\'?""*;\n* `git_checkout` &ndash; creates the branch before checking-out;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `git_pull` &ndash; sets upstream before executing previous `git pull`;\n* `git_stash` &ndash; stashes you local modifications before rebasing or switching branch;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `no_such_file` &ndash; creates missing directories with `mv` and `cp` commands;\n* `man_no_space` &ndash; fixes man commands without spaces, for example `mandiff`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `whois` &ndash; fixes `whois` command;\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `composer_not_command` &ndash; fixes composer command name.\n\nBundled, but not enabled by default:\n\n* `ls_lah` &ndash; adds -lah to ls;\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n\n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call(\'chmod 777 .\', shell=True)\n\npriority = 1000  # Lower first\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters which can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; requires confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output;\n* `priority` &ndash; dict with rules priorities, rule with lower `priority` will be matched first.\n\nExample of `settings.py`:\n\n```python\nrules = [\'sudo\', \'no_command\']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\npriority = {\'sudo\': 100, \'no_command\': 9999}\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`;\n* `THEFUCK_PRIORITY` &ndash; priority of the rules, like `no_command=9999:apt_get=100`,\nrule with lower `priority` will be matched first.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES=\'sudo:no_command\'\nexport THEFUCK_REQUIRE_CONFIRMATION=\'true\'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS=\'false\'\nexport THEFUCK_PRIORITY=\'no_command=9999:apt_get=100\'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', 'import pytest\nfrom thefuck.rules.git_pull import match, get_new_command\nfrom tests.utils import Command\n\n\n@pytest.fixture\ndef stderr():\n    return \'\'\'There is no tracking information for the current branch.\nPlease specify which branch you want to merge with.\nSee git-pull(1) for details\n\n    git pull <remote> <branch>\n\nIf you wish to set tracking information for this branch you can do so with:\n\n    git branch --set-upstream-to=<remote>/<branch> master\n\n\'\'\'\n\n\ndef test_match(stderr):\n    assert match(Command(\'git pull\', stderr=stderr), None)\n    assert not match(Command(\'git pull\'), None)\n    assert not match(Command(\'ls\', stderr=stderr), None)\n\n\ndef test_get_new_command(stderr):\n    assert get_new_command(Command(\'git pull\', stderr=stderr), None) \\\n           == ""git branch --set-upstream-to=origin/master master && git pull""\n', ""def match(command, settings):\n    return ('git' in command.script\n            and 'pull' in command.script\n            and 'set-upstream' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    line = command.stderr.split('\\n')[-3].strip()\n    branch = line.split(' ')[-1]\n    set_upstream = line.replace('<remote>', 'origin')\\\n                       .replace('<branch>', branch)\n    return u'{} && {}'.format(set_upstream, command.script)\n""]","[[], [], []]","[[], [<pydriller.domain.commit.Method object at 0x7f19828e68e0>, <pydriller.domain.commit.Method object at 0x7f19828e6700>, <pydriller.domain.commit.Method object at 0x7f19828e6760>], [<pydriller.domain.commit.Method object at 0x7f19828e6610>, <pydriller.domain.commit.Method object at 0x7f19828e6430>]]"
thefuck,b63ce26853c1f6e1c62bfe7be5778a453a89836a,Reorganize list of rules in readme,2015-05-20 02:50:08+03:00,nvbn,16,14,30,3,"['README.md', 'grep_recursive.py', 'ls_lah.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run the changed command, there is a `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to the `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\n```\n\nIf you are using `tcsh`:\n```tcsh\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match a rule for the previous command, creates a new command\nusing the matched rule and runs it. Rules enabled by default are as follows:\n\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `cpp11` &ndash; add missing `-std=c++11` to `g++` or `clang++`;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `dry` &ndash; fix repetitions like ""git git push"";\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_add` &ndash; fix *""Did you forget to \'git add\'?""*;\n* `git_checkout` &ndash; creates the branch before checking-out;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `git_pull` &ndash; sets upstream before executing previous `git pull`;\n* `git_stash` &ndash; stashes you local modifications before rebasing or switching branch;\n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `no_such_file` &ndash; creates missing directories with `mv` and `cp` commands;\n* `man_no_space` &ndash; fixes man commands without spaces, for example `mandiff`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `whois` &ndash; fixes `whois` command;\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `composer_not_command` &ndash; fixes composer command name.\n\nBundled, but not enabled by default:\n\n* `ls_lah` &ndash; adds -lah to ls;\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n\n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call(\'chmod 777 .\', shell=True)\n\npriority = 1000  # Lower first\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters which can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; requires confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output;\n* `priority` &ndash; dict with rules priorities, rule with lower `priority` will be matched first.\n\nExample of `settings.py`:\n\n```python\nrules = [\'sudo\', \'no_command\']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\npriority = {\'sudo\': 100, \'no_command\': 9999}\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`;\n* `THEFUCK_PRIORITY` &ndash; priority of the rules, like `no_command=9999:apt_get=100`,\nrule with lower `priority` will be matched first.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES=\'sudo:no_command\'\nexport THEFUCK_REQUIRE_CONFIRMATION=\'true\'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS=\'false\'\nexport THEFUCK_PRIORITY=\'no_command=9999:apt_get=100\'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""def match(command, settings):\n\treturn (command.script.startswith('grep')\n            and 'is a directory' in command.stderr.lower())\n\n\ndef get_new_command(command, settings):\n    return 'grep -r {}'.format(command.script[5:])\n"", ""enabled_by_default = False\n\n\ndef match(command, settings):\n    return 'ls' in command.script and not ('ls -' in command.script)\n\n\ndef get_new_command(command, settings):\n    command = command.script.split(' ')\n    command[0] = 'ls -lah'\n    return ' '.join(command)\n""]","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run the changed command, there is a `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to the `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\n```\n\nIf you are using `tcsh`:\n```tcsh\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match a rule for the previous command, creates a new command\nusing the matched rule and runs it. Rules enabled by default are as follows:\n\n* `cd_correction` &ndash; spellchecks and correct failed cd commands;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `composer_not_command` &ndash; fixes composer command name;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `cpp11` &ndash; add missing `-std=c++11` to `g++` or `clang++`;\n* `dry` &ndash; fix repetitions like ""git git push"";\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_add` &ndash; fix *""Did you forget to \'git add\'?""*;\n* `git_checkout` &ndash; creates the branch before checking-out;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_pull` &ndash; sets upstream before executing previous `git pull`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `git_stash` &ndash; stashes you local modifications before rebasing or switching branch;\n* `grep_recursive` &ndash; adds `-r` when you trying to grep directory; \n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `ls_lah` &ndash; adds -lah to ls;\n* `man_no_space` &ndash; fixes man commands without spaces, for example `mandiff`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `no_such_file` &ndash; creates missing directories with `mv` and `cp` commands;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `whois` &ndash; fixes `whois` command.\n\nEnabled by default only on specific platforms:\n\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n\n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call(\'chmod 777 .\', shell=True)\n\npriority = 1000  # Lower first\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters which can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; requires confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output;\n* `priority` &ndash; dict with rules priorities, rule with lower `priority` will be matched first.\n\nExample of `settings.py`:\n\n```python\nrules = [\'sudo\', \'no_command\']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\npriority = {\'sudo\': 100, \'no_command\': 9999}\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`;\n* `THEFUCK_PRIORITY` &ndash; priority of the rules, like `no_command=9999:apt_get=100`,\nrule with lower `priority` will be matched first.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES=\'sudo:no_command\'\nexport THEFUCK_REQUIRE_CONFIRMATION=\'true\'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS=\'false\'\nexport THEFUCK_PRIORITY=\'no_command=9999:apt_get=100\'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""def match(command, settings):\n    return (command.script.startswith('grep')\n            and 'is a directory' in command.stderr.lower())\n\n\ndef get_new_command(command, settings):\n    return 'grep -r {}'.format(command.script[5:])\n"", ""def match(command, settings):\n    return 'ls' in command.script and not ('ls -' in command.script)\n\n\ndef get_new_command(command, settings):\n    command = command.script.split(' ')\n    command[0] = 'ls -lah'\n    return ' '.join(command)\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f19828b9b50>, <pydriller.domain.commit.Method object at 0x7f19828b9e50>], [<pydriller.domain.commit.Method object at 0x7f1983f6b550>, <pydriller.domain.commit.Method object at 0x7f1983f6b0a0>]]","[[], [<pydriller.domain.commit.Method object at 0x7f1983f71040>], []]"
thefuck,02d961361874a272da9370af82c5526282689c84,Bump to 1.42,2015-05-20 02:50:43+03:00,nvbn,1,1,2,1,['setup.py'],"['from setuptools import setup, find_packages\n\n\nVERSION = \'1.41\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\',\n          \'thefuck-alias = thefuck.shells:app_alias\']})\n']","['from setuptools import setup, find_packages\n\n\nVERSION = \'1.42\'\n\n\nsetup(name=\'thefuck\',\n      version=VERSION,\n      description=""Magnificent app which corrects your previous console command"",\n      author=\'Vladimir Iakovlev\',\n      author_email=\'nvbn.rm@gmail.com\',\n      url=\'https://github.com/nvbn/thefuck\',\n      license=\'MIT\',\n      packages=find_packages(exclude=[\'ez_setup\', \'examples\',\n                                      \'tests\', \'release\']),\n      include_package_data=True,\n      zip_safe=False,\n      install_requires=[\'pathlib\', \'psutil\', \'colorama\', \'six\'],\n      entry_points={\'console_scripts\': [\n          \'thefuck = thefuck.main:main\',\n          \'thefuck-alias = thefuck.shells:app_alias\']})\n']",[[]],[[]]
thefuck,17b9104939b9d6899562b45975dc6afd356b0d6a,better way to get shell,2015-05-20 15:30:20+08:00,Tevin Zhang,4,4,8,1,['shells.py'],"['""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias` and `put_to_history`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\nfrom .utils import DEVNULL\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n    def and_(self, *commands):\n        return \' && \'.join(commands)\n\n\nclass Bash(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Fish(Generic):\n    def app_alias(self):\n        return (""function fuck -d \'Correct your previous console command\'\\n""\n                ""    set -l exit_code $status\\n""\n                ""    set -l eval_script""\n                "" (mktemp 2>/dev/null ; or mktemp -t \'thefuck\')\\n""\n                ""    set -l fucked_up_commandd $history[1]\\n""\n                ""    thefuck $fucked_up_commandd > $eval_script\\n""\n                ""    . $eval_script\\n""\n                ""    rm $eval_script\\n""\n                ""    if test $exit_code -ne 0\\n""\n                ""        history --delete $fucked_up_commandd\\n""\n                ""    end\\n""\n                ""end"")\n\n    def _get_history_file_name(self):\n        return os.path.expanduser(\'~/.config/fish/fish_history\')\n\n    def _get_history_line(self, command_script):\n        return u\'- cmd: {}\\n   when: {}\\n\'.format(command_script, int(time()))\n\n    def and_(self, *commands):\n        return \'; and \'.join(commands)\n\n\nclass Zsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nclass Tcsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(""\\t"", 1)\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'tcsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'\\t\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'#+{}\\n{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'fish\': Fish(),\n    \'zsh\': Zsh(),\n    \'-csh\': Tcsh(),\n    \'tcsh\': Tcsh()})\n\n\ndef _get_shell():\n    try:\n        shell = Process(os.getpid()).parent().cmdline()[0]\n    except TypeError:\n        shell = Process(os.getpid()).parent.cmdline[0]\n    return shells[os.path.basename(shell)]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    print(_get_shell().app_alias())\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n\n\ndef and_(*commands):\n    return _get_shell().and_(*commands)\n']","['""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias` and `put_to_history`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\nfrom .utils import DEVNULL\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n    def and_(self, *commands):\n        return \' && \'.join(commands)\n\n\nclass Bash(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Fish(Generic):\n    def app_alias(self):\n        return (""function fuck -d \'Correct your previous console command\'\\n""\n                ""    set -l exit_code $status\\n""\n                ""    set -l eval_script""\n                "" (mktemp 2>/dev/null ; or mktemp -t \'thefuck\')\\n""\n                ""    set -l fucked_up_commandd $history[1]\\n""\n                ""    thefuck $fucked_up_commandd > $eval_script\\n""\n                ""    . $eval_script\\n""\n                ""    rm $eval_script\\n""\n                ""    if test $exit_code -ne 0\\n""\n                ""        history --delete $fucked_up_commandd\\n""\n                ""    end\\n""\n                ""end"")\n\n    def _get_history_file_name(self):\n        return os.path.expanduser(\'~/.config/fish/fish_history\')\n\n    def _get_history_line(self, command_script):\n        return u\'- cmd: {}\\n   when: {}\\n\'.format(command_script, int(time()))\n\n    def and_(self, *commands):\n        return \'; and \'.join(commands)\n\n\nclass Zsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nclass Tcsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(""\\t"", 1)\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'tcsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'\\t\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'#+{}\\n{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'fish\': Fish(),\n    \'zsh\': Zsh(),\n    \'csh\': Tcsh(),\n    \'tcsh\': Tcsh()})\n\n\ndef _get_shell():\n    try:\n        shell = Process(os.getpid()).parent().name()\n    except TypeError:\n        shell = Process(os.getpid()).parent.name()\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    print(_get_shell().app_alias())\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n\n\ndef and_(*commands):\n    return _get_shell().and_(*commands)\n']","[[<pydriller.domain.commit.Method object at 0x7f19828cbd60>, <pydriller.domain.commit.Method object at 0x7f19828cb9d0>, <pydriller.domain.commit.Method object at 0x7f19828cbbe0>, <pydriller.domain.commit.Method object at 0x7f1983f6bd00>, <pydriller.domain.commit.Method object at 0x7f1983f4ed00>, <pydriller.domain.commit.Method object at 0x7f1983f4e3a0>, <pydriller.domain.commit.Method object at 0x7f1983f4eb80>, <pydriller.domain.commit.Method object at 0x7f1983f4ea30>, <pydriller.domain.commit.Method object at 0x7f1983f60c70>, <pydriller.domain.commit.Method object at 0x7f1983f608b0>, <pydriller.domain.commit.Method object at 0x7f1983f60a90>, <pydriller.domain.commit.Method object at 0x7f1983f60f40>, <pydriller.domain.commit.Method object at 0x7f1983f60c40>, <pydriller.domain.commit.Method object at 0x7f1983f60940>, <pydriller.domain.commit.Method object at 0x7f1983f60be0>, <pydriller.domain.commit.Method object at 0x7f1983f60610>, <pydriller.domain.commit.Method object at 0x7f1983f60700>, <pydriller.domain.commit.Method object at 0x7f1983f607f0>, <pydriller.domain.commit.Method object at 0x7f1983f60550>, <pydriller.domain.commit.Method object at 0x7f1983f60850>, <pydriller.domain.commit.Method object at 0x7f1983f60880>, <pydriller.domain.commit.Method object at 0x7f1983f60ca0>, <pydriller.domain.commit.Method object at 0x7f19828b9c70>, <pydriller.domain.commit.Method object at 0x7f19828b9a30>, <pydriller.domain.commit.Method object at 0x7f19828b9d60>, <pydriller.domain.commit.Method object at 0x7f19828b9430>, <pydriller.domain.commit.Method object at 0x7f1983f71970>, <pydriller.domain.commit.Method object at 0x7f1983f71d60>, <pydriller.domain.commit.Method object at 0x7f1983f71730>, <pydriller.domain.commit.Method object at 0x7f1983f71e80>, <pydriller.domain.commit.Method object at 0x7f1983f71d30>, <pydriller.domain.commit.Method object at 0x7f1983f71370>, <pydriller.domain.commit.Method object at 0x7f1983f717f0>, <pydriller.domain.commit.Method object at 0x7f1983f71d90>]]",[[<pydriller.domain.commit.Method object at 0x7f198647b370>]]
thefuck,d6ce5e1e62f9e18e28cd35be57ab9e0fbab09ad9,#208 `.name` isn't callable in specific psutil,2015-05-20 16:41:11+03:00,nvbn,1,1,2,1,['shells.py'],"['""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias` and `put_to_history`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\nfrom .utils import DEVNULL\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n    def and_(self, *commands):\n        return \' && \'.join(commands)\n\n\nclass Bash(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Fish(Generic):\n    def app_alias(self):\n        return (""function fuck -d \'Correct your previous console command\'\\n""\n                ""    set -l exit_code $status\\n""\n                ""    set -l eval_script""\n                "" (mktemp 2>/dev/null ; or mktemp -t \'thefuck\')\\n""\n                ""    set -l fucked_up_commandd $history[1]\\n""\n                ""    thefuck $fucked_up_commandd > $eval_script\\n""\n                ""    . $eval_script\\n""\n                ""    rm $eval_script\\n""\n                ""    if test $exit_code -ne 0\\n""\n                ""        history --delete $fucked_up_commandd\\n""\n                ""    end\\n""\n                ""end"")\n\n    def _get_history_file_name(self):\n        return os.path.expanduser(\'~/.config/fish/fish_history\')\n\n    def _get_history_line(self, command_script):\n        return u\'- cmd: {}\\n   when: {}\\n\'.format(command_script, int(time()))\n\n    def and_(self, *commands):\n        return \'; and \'.join(commands)\n\n\nclass Zsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nclass Tcsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(""\\t"", 1)\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'tcsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'\\t\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'#+{}\\n{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'fish\': Fish(),\n    \'zsh\': Zsh(),\n    \'csh\': Tcsh(),\n    \'tcsh\': Tcsh()})\n\n\ndef _get_shell():\n    try:\n        shell = Process(os.getpid()).parent().name()\n    except TypeError:\n        shell = Process(os.getpid()).parent.name()\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    print(_get_shell().app_alias())\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n\n\ndef and_(*commands):\n    return _get_shell().and_(*commands)\n']","['""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias` and `put_to_history`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\nfrom .utils import DEVNULL\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n    def and_(self, *commands):\n        return \' && \'.join(commands)\n\n\nclass Bash(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Fish(Generic):\n    def app_alias(self):\n        return (""function fuck -d \'Correct your previous console command\'\\n""\n                ""    set -l exit_code $status\\n""\n                ""    set -l eval_script""\n                "" (mktemp 2>/dev/null ; or mktemp -t \'thefuck\')\\n""\n                ""    set -l fucked_up_commandd $history[1]\\n""\n                ""    thefuck $fucked_up_commandd > $eval_script\\n""\n                ""    . $eval_script\\n""\n                ""    rm $eval_script\\n""\n                ""    if test $exit_code -ne 0\\n""\n                ""        history --delete $fucked_up_commandd\\n""\n                ""    end\\n""\n                ""end"")\n\n    def _get_history_file_name(self):\n        return os.path.expanduser(\'~/.config/fish/fish_history\')\n\n    def _get_history_line(self, command_script):\n        return u\'- cmd: {}\\n   when: {}\\n\'.format(command_script, int(time()))\n\n    def and_(self, *commands):\n        return \'; and \'.join(commands)\n\n\nclass Zsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nclass Tcsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(""\\t"", 1)\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'tcsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'\\t\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'#+{}\\n{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'fish\': Fish(),\n    \'zsh\': Zsh(),\n    \'csh\': Tcsh(),\n    \'tcsh\': Tcsh()})\n\n\ndef _get_shell():\n    try:\n        shell = Process(os.getpid()).parent().name()\n    except TypeError:\n        shell = Process(os.getpid()).parent.name\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    print(_get_shell().app_alias())\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n\n\ndef and_(*commands):\n    return _get_shell().and_(*commands)\n']","[[<pydriller.domain.commit.Method object at 0x7f1983f76970>, <pydriller.domain.commit.Method object at 0x7f1983f76940>, <pydriller.domain.commit.Method object at 0x7f1983f768b0>, <pydriller.domain.commit.Method object at 0x7f1983f769a0>, <pydriller.domain.commit.Method object at 0x7f19828e6af0>, <pydriller.domain.commit.Method object at 0x7f19828e6460>, <pydriller.domain.commit.Method object at 0x7f19828e60d0>, <pydriller.domain.commit.Method object at 0x7f19828e6d30>, <pydriller.domain.commit.Method object at 0x7f19828e61c0>, <pydriller.domain.commit.Method object at 0x7f19828e69a0>, <pydriller.domain.commit.Method object at 0x7f19828e66a0>, <pydriller.domain.commit.Method object at 0x7f19828e6d90>, <pydriller.domain.commit.Method object at 0x7f19828e6c40>, <pydriller.domain.commit.Method object at 0x7f19828e6640>, <pydriller.domain.commit.Method object at 0x7f19828e60a0>, <pydriller.domain.commit.Method object at 0x7f19828e6670>, <pydriller.domain.commit.Method object at 0x7f19828e6e80>, <pydriller.domain.commit.Method object at 0x7f19828e62b0>, <pydriller.domain.commit.Method object at 0x7f19828e6220>, <pydriller.domain.commit.Method object at 0x7f19828e6730>, <pydriller.domain.commit.Method object at 0x7f19828e6be0>, <pydriller.domain.commit.Method object at 0x7f19828e6ee0>, <pydriller.domain.commit.Method object at 0x7f19828e6f40>, <pydriller.domain.commit.Method object at 0x7f19828e6a60>, <pydriller.domain.commit.Method object at 0x7f19828e6dc0>, <pydriller.domain.commit.Method object at 0x7f19828e6910>, <pydriller.domain.commit.Method object at 0x7f19828e6ca0>, <pydriller.domain.commit.Method object at 0x7f19828e6d60>, <pydriller.domain.commit.Method object at 0x7f19828e6e20>, <pydriller.domain.commit.Method object at 0x7f19828e6b50>, <pydriller.domain.commit.Method object at 0x7f19828e6c10>, <pydriller.domain.commit.Method object at 0x7f19828e6c70>, <pydriller.domain.commit.Method object at 0x7f19828e6d00>, <pydriller.domain.commit.Method object at 0x7f19828e6b20>]]",[[<pydriller.domain.commit.Method object at 0x7f1983f76ac0>]]
thefuck,53198713265b8b8039e6c572286ea5913c67b37c,#209 add `get_aliases` to shells,2015-05-20 16:56:42+03:00,nvbn,77,32,109,2,"['test_shells.py', 'shells.py']","[""import pytest\nfrom thefuck import shells\n\n\n@pytest.fixture\ndef builtins_open(mocker):\n    return mocker.patch('six.moves.builtins.open')\n\n\n@pytest.fixture\ndef isfile(mocker):\n    return mocker.patch('os.path.isfile', return_value=True)\n\n\nclass TestGeneric(object):\n    def test_from_shell(self):\n        assert shells.Generic().from_shell('pwd') == 'pwd'\n\n    def test_to_shell(self):\n        assert shells.Generic().to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open):\n        assert shells.Generic().put_to_history('ls') is None\n        assert builtins_open.call_count == 0\n\n\n@pytest.mark.usefixtures('isfile')\nclass TestBash(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, mocker):\n        mock = mocker.patch('thefuck.shells.Popen')\n        mock.return_value.stdout.read.return_value = (\n            b'alias l=\\'ls -CF\\'\\n'\n            b'alias la=\\'ls -A\\'\\n'\n            b'alias ll=\\'ls -alF\\'')\n        return mock\n\n    @pytest.mark.parametrize('before, after', [\n        ('pwd', 'pwd'),\n        ('ll', 'ls -alF')])\n    def test_from_shell(self, before, after):\n        assert shells.Bash().from_shell(before) == after\n\n    def test_to_shell(self):\n        assert shells.Bash().to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open):\n        shells.Bash().put_to_history('ls')\n        builtins_open.return_value.__enter__.return_value. \\\n            write.assert_called_once_with('ls\\n')\n\n\n@pytest.mark.usefixtures('isfile')\nclass TestFish(object):\n    @pytest.mark.parametrize('before, after', [\n        ('pwd', 'pwd'),\n        ('ll', 'll')])  # Fish has no aliases but functions\n    def test_from_shell(self, before, after):\n        assert shells.Fish().from_shell(before) == after\n\n    def test_to_shell(self):\n        assert shells.Fish().to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open, mocker):\n        mocker.patch('thefuck.shells.time',\n                     return_value=1430707243.3517463)\n        shells.Fish().put_to_history('ls')\n        builtins_open.return_value.__enter__.return_value. \\\n            write.assert_called_once_with('- cmd: ls\\n   when: 1430707243\\n')\n\n    def test_and_(self):\n        assert shells.Fish().and_('foo', 'bar') == 'foo; and bar'\n\n\n@pytest.mark.usefixtures('isfile')\nclass TestZsh(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, mocker):\n        mock = mocker.patch('thefuck.shells.Popen')\n        mock.return_value.stdout.read.return_value = (\n            b'l=\\'ls -CF\\'\\n'\n            b'la=\\'ls -A\\'\\n'\n            b'll=\\'ls -alF\\'')\n        return mock\n\n    @pytest.mark.parametrize('before, after', [\n        ('pwd', 'pwd'),\n        ('ll', 'ls -alF')])\n    def test_from_shell(self, before, after):\n        assert shells.Zsh().from_shell(before) == after\n\n    def test_to_shell(self):\n        assert shells.Zsh().to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open, mocker):\n        mocker.patch('thefuck.shells.time',\n                     return_value=1430707243.3517463)\n        shells.Zsh().put_to_history('ls')\n        builtins_open.return_value.__enter__.return_value. \\\n            write.assert_called_once_with(': 1430707243:0;ls\\n')\n"", '""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias` and `put_to_history`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\nfrom .utils import DEVNULL\n\n\nclass Generic(object):\n    def _get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self._get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n    def and_(self, *commands):\n        return \' && \'.join(commands)\n\n\nclass Bash(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Fish(Generic):\n    def app_alias(self):\n        return (""function fuck -d \'Correct your previous console command\'\\n""\n                ""    set -l exit_code $status\\n""\n                ""    set -l eval_script""\n                "" (mktemp 2>/dev/null ; or mktemp -t \'thefuck\')\\n""\n                ""    set -l fucked_up_commandd $history[1]\\n""\n                ""    thefuck $fucked_up_commandd > $eval_script\\n""\n                ""    . $eval_script\\n""\n                ""    rm $eval_script\\n""\n                ""    if test $exit_code -ne 0\\n""\n                ""        history --delete $fucked_up_commandd\\n""\n                ""    end\\n""\n                ""end"")\n\n    def _get_history_file_name(self):\n        return os.path.expanduser(\'~/.config/fish/fish_history\')\n\n    def _get_history_line(self, command_script):\n        return u\'- cmd: {}\\n   when: {}\\n\'.format(command_script, int(time()))\n\n    def and_(self, *commands):\n        return \'; and \'.join(commands)\n\n\nclass Zsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nclass Tcsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(""\\t"", 1)\n        return name, value\n\n    def _get_aliases(self):\n        proc = Popen(\'tcsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'\\t\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'#+{}\\n{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'fish\': Fish(),\n    \'zsh\': Zsh(),\n    \'csh\': Tcsh(),\n    \'tcsh\': Tcsh()})\n\n\ndef _get_shell():\n    try:\n        shell = Process(os.getpid()).parent().name()\n    except TypeError:\n        shell = Process(os.getpid()).parent.name\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    print(_get_shell().app_alias())\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n\n\ndef and_(*commands):\n    return _get_shell().and_(*commands)\n']","[""import pytest\nfrom thefuck import shells\n\n\n@pytest.fixture\ndef builtins_open(mocker):\n    return mocker.patch('six.moves.builtins.open')\n\n\n@pytest.fixture\ndef isfile(mocker):\n    return mocker.patch('os.path.isfile', return_value=True)\n\n\nclass TestGeneric(object):\n    @pytest.fixture\n    def shell(self):\n        return shells.Generic()\n\n    def test_from_shell(self, shell):\n        assert shell.from_shell('pwd') == 'pwd'\n\n    def test_to_shell(self, shell):\n        assert shell.to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open, shell):\n        assert shell.put_to_history('ls') is None\n        assert builtins_open.call_count == 0\n\n    def test_and_(self, shell):\n        assert shell.and_('ls', 'cd') == 'ls && cd'\n\n    def test_get_aliases(self, shell):\n        assert shell.get_aliases() == {}\n\n\n@pytest.mark.usefixtures('isfile')\nclass TestBash(object):\n    @pytest.fixture\n    def shell(self):\n        return shells.Bash()\n\n    @pytest.fixture(autouse=True)\n    def Popen(self, mocker):\n        mock = mocker.patch('thefuck.shells.Popen')\n        mock.return_value.stdout.read.return_value = (\n            b'alias l=\\'ls -CF\\'\\n'\n            b'alias la=\\'ls -A\\'\\n'\n            b'alias ll=\\'ls -alF\\'')\n        return mock\n\n    @pytest.mark.parametrize('before, after', [\n        ('pwd', 'pwd'),\n        ('ll', 'ls -alF')])\n    def test_from_shell(self, before, after, shell):\n        assert shell.from_shell(before) == after\n\n    def test_to_shell(self, shell):\n        assert shell.to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open, shell):\n        shell.put_to_history('ls')\n        builtins_open.return_value.__enter__.return_value. \\\n            write.assert_called_once_with('ls\\n')\n\n    def test_and_(self, shell):\n        assert shell.and_('ls', 'cd') == 'ls && cd'\n\n    def test_get_aliases(self, shell):\n        assert shell.get_aliases() == {'l': 'ls -CF',\n                                       'la': 'ls -A',\n                                       'll': 'ls -alF'}\n\n\n@pytest.mark.usefixtures('isfile')\nclass TestFish(object):\n    @pytest.fixture\n    def shell(self):\n        return shells.Fish()\n\n    @pytest.mark.parametrize('before, after', [\n        ('pwd', 'pwd'),\n        ('ll', 'll')])  # Fish has no aliases but functions\n    def test_from_shell(self, before, after, shell):\n        assert shell.from_shell(before) == after\n\n    def test_to_shell(self, shell):\n        assert shell.to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open, mocker, shell):\n        mocker.patch('thefuck.shells.time',\n                     return_value=1430707243.3517463)\n        shell.put_to_history('ls')\n        builtins_open.return_value.__enter__.return_value. \\\n            write.assert_called_once_with('- cmd: ls\\n   when: 1430707243\\n')\n\n    def test_and_(self, shell):\n        assert shell.and_('foo', 'bar') == 'foo; and bar'\n\n    def test_get_aliases(self, shell):\n        assert shell.get_aliases() == {}\n\n\n@pytest.mark.usefixtures('isfile')\nclass TestZsh(object):\n    @pytest.fixture\n    def shell(self):\n        return shells.Zsh()\n\n    @pytest.fixture(autouse=True)\n    def Popen(self, mocker):\n        mock = mocker.patch('thefuck.shells.Popen')\n        mock.return_value.stdout.read.return_value = (\n            b'l=\\'ls -CF\\'\\n'\n            b'la=\\'ls -A\\'\\n'\n            b'll=\\'ls -alF\\'')\n        return mock\n\n    @pytest.mark.parametrize('before, after', [\n        ('pwd', 'pwd'),\n        ('ll', 'ls -alF')])\n    def test_from_shell(self, before, after, shell):\n        assert shell.from_shell(before) == after\n\n    def test_to_shell(self, shell):\n        assert shell.to_shell('pwd') == 'pwd'\n\n    def test_put_to_history(self, builtins_open, mocker, shell):\n        mocker.patch('thefuck.shells.time',\n                     return_value=1430707243.3517463)\n        shell.put_to_history('ls')\n        builtins_open.return_value.__enter__.return_value. \\\n            write.assert_called_once_with(': 1430707243:0;ls\\n')\n\n    def test_and_(self, shell):\n        assert shell.and_('ls', 'cd') == 'ls && cd'\n\n    def test_get_aliases(self, shell):\n        assert shell.get_aliases() == {'l': 'ls -CF',\n                                       'la': 'ls -A',\n                                       'll': 'ls -alF'}\n"", '""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias`, `put_to_history` and `get_aliases`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\nfrom .utils import DEVNULL\n\n\nclass Generic(object):\n    def get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self.get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n    def and_(self, *commands):\n        return \' && \'.join(commands)\n\n\nclass Bash(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Fish(Generic):\n    def app_alias(self):\n        return (""function fuck -d \'Correct your previous console command\'\\n""\n                ""    set -l exit_code $status\\n""\n                ""    set -l eval_script""\n                "" (mktemp 2>/dev/null ; or mktemp -t \'thefuck\')\\n""\n                ""    set -l fucked_up_commandd $history[1]\\n""\n                ""    thefuck $fucked_up_commandd > $eval_script\\n""\n                ""    . $eval_script\\n""\n                ""    rm $eval_script\\n""\n                ""    if test $exit_code -ne 0\\n""\n                ""        history --delete $fucked_up_commandd\\n""\n                ""    end\\n""\n                ""end"")\n\n    def _get_history_file_name(self):\n        return os.path.expanduser(\'~/.config/fish/fish_history\')\n\n    def _get_history_line(self, command_script):\n        return u\'- cmd: {}\\n   when: {}\\n\'.format(command_script, int(time()))\n\n    def and_(self, *commands):\n        return \'; and \'.join(commands)\n\n\nclass Zsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nclass Tcsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(""\\t"", 1)\n        return name, value\n\n    def get_aliases(self):\n        proc = Popen(\'tcsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'\\t\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'#+{}\\n{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'fish\': Fish(),\n    \'zsh\': Zsh(),\n    \'csh\': Tcsh(),\n    \'tcsh\': Tcsh()})\n\n\ndef _get_shell():\n    try:\n        shell = Process(os.getpid()).parent().name()\n    except TypeError:\n        shell = Process(os.getpid()).parent.name\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    print(_get_shell().app_alias())\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n\n\ndef and_(*commands):\n    return _get_shell().and_(*commands)\n\n\ndef get_aliases():\n    return _get_shell().get_aliases().keys()\n']","[[<pydriller.domain.commit.Method object at 0x7f198647be80>, <pydriller.domain.commit.Method object at 0x7f198647be20>, <pydriller.domain.commit.Method object at 0x7f198647beb0>, <pydriller.domain.commit.Method object at 0x7f198647b790>, <pydriller.domain.commit.Method object at 0x7f198647bf70>, <pydriller.domain.commit.Method object at 0x7f198647bfa0>, <pydriller.domain.commit.Method object at 0x7f198647bfd0>, <pydriller.domain.commit.Method object at 0x7f198648c040>, <pydriller.domain.commit.Method object at 0x7f198648c070>, <pydriller.domain.commit.Method object at 0x7f198648c0a0>, <pydriller.domain.commit.Method object at 0x7f198648c0d0>, <pydriller.domain.commit.Method object at 0x7f198648c100>, <pydriller.domain.commit.Method object at 0x7f198648c130>, <pydriller.domain.commit.Method object at 0x7f198648c160>, <pydriller.domain.commit.Method object at 0x7f198648c190>, <pydriller.domain.commit.Method object at 0x7f198648c1c0>, <pydriller.domain.commit.Method object at 0x7f198648c1f0>], [<pydriller.domain.commit.Method object at 0x7f19828e6df0>, <pydriller.domain.commit.Method object at 0x7f19828e6f10>, <pydriller.domain.commit.Method object at 0x7f19828e6130>, <pydriller.domain.commit.Method object at 0x7f19828e64f0>, <pydriller.domain.commit.Method object at 0x7f198290cac0>, <pydriller.domain.commit.Method object at 0x7f198290c9a0>, <pydriller.domain.commit.Method object at 0x7f198290c2b0>, <pydriller.domain.commit.Method object at 0x7f198290c340>, <pydriller.domain.commit.Method object at 0x7f198290c9d0>, <pydriller.domain.commit.Method object at 0x7f198290c160>, <pydriller.domain.commit.Method object at 0x7f198290cbb0>, <pydriller.domain.commit.Method object at 0x7f198290c220>, <pydriller.domain.commit.Method object at 0x7f198290c370>, <pydriller.domain.commit.Method object at 0x7f198290c850>, <pydriller.domain.commit.Method object at 0x7f198290cd60>, <pydriller.domain.commit.Method object at 0x7f198290c040>, <pydriller.domain.commit.Method object at 0x7f198290cee0>, <pydriller.domain.commit.Method object at 0x7f198290cd90>, <pydriller.domain.commit.Method object at 0x7f198290cf10>, <pydriller.domain.commit.Method object at 0x7f198290c970>, <pydriller.domain.commit.Method object at 0x7f198290c550>, <pydriller.domain.commit.Method object at 0x7f19828cbfd0>, <pydriller.domain.commit.Method object at 0x7f19828cbf70>, <pydriller.domain.commit.Method object at 0x7f19828cbc10>, <pydriller.domain.commit.Method object at 0x7f19828cbee0>, <pydriller.domain.commit.Method object at 0x7f19828cb910>, <pydriller.domain.commit.Method object at 0x7f19828cbe20>, <pydriller.domain.commit.Method object at 0x7f19828cbd90>, <pydriller.domain.commit.Method object at 0x7f19828cbca0>, <pydriller.domain.commit.Method object at 0x7f19828cbb80>, <pydriller.domain.commit.Method object at 0x7f19828cb730>, <pydriller.domain.commit.Method object at 0x7f19828cbbb0>, <pydriller.domain.commit.Method object at 0x7f1983ea8130>, <pydriller.domain.commit.Method object at 0x7f19828b00a0>]]","[[<pydriller.domain.commit.Method object at 0x7f198647b790>, <pydriller.domain.commit.Method object at 0x7f1983f71c70>, <pydriller.domain.commit.Method object at 0x7f198647bf70>, <pydriller.domain.commit.Method object at 0x7f198647beb0>, <pydriller.domain.commit.Method object at 0x7f198647bfd0>, <pydriller.domain.commit.Method object at 0x7f198648c100>, <pydriller.domain.commit.Method object at 0x7f198647bb50>, <pydriller.domain.commit.Method object at 0x7f198647bb80>, <pydriller.domain.commit.Method object at 0x7f198648c130>, <pydriller.domain.commit.Method object at 0x7f1983f71880>, <pydriller.domain.commit.Method object at 0x7f198647baf0>, <pydriller.domain.commit.Method object at 0x7f198647bb20>, <pydriller.domain.commit.Method object at 0x7f198647bc10>, <pydriller.domain.commit.Method object at 0x7f198647bd90>], [<pydriller.domain.commit.Method object at 0x7f198647b070>, <pydriller.domain.commit.Method object at 0x7f1983f76370>, <pydriller.domain.commit.Method object at 0x7f19828e6df0>, <pydriller.domain.commit.Method object at 0x7f198647ba60>]]"
thefuck,2c3df1ad47f56eea63c931d6df5abb44e5a7b837,#209 add support of aliases to `no_command`,2015-05-20 16:58:05+03:00,nvbn,8,7,15,3,"['test_no_command.py', 'no_command.py', 'shells.py']","[""from mock import patch, Mock\nfrom thefuck.rules.no_command import match, get_new_command\n\n\ndef test_match():\n    with patch('thefuck.rules.no_command._get_all_bins',\n               return_value=['vim', 'apt-get']):\n        assert match(Mock(stderr='vom: not found', script='vom file.py'), None)\n        assert not match(Mock(stderr='qweqwe: not found', script='qweqwe'), None)\n        assert not match(Mock(stderr='some text', script='vom file.py'), None)\n\n\ndef test_get_new_command():\n    with patch('thefuck.rules.no_command._get_all_bins',\n               return_value=['vim', 'apt-get']):\n        assert get_new_command(\n            Mock(stderr='vom: not found',\n                 script='vom file.py'),\n            None) == 'vim file.py'\n"", ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\nfrom thefuck.utils import sudo_support\n\n\ndef _safe(fn, fallback):\n    try:\n        return fn()\n    except OSError:\n        return fallback\n\n\ndef _get_all_bins():\n    return [exe.name\n            for path in os.environ.get('PATH', '').split(':')\n            for exe in _safe(lambda: list(Path(path).iterdir()), [])\n            if not _safe(exe.is_dir, True)]\n\n\n@sudo_support\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_bins()))\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_bins())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n\n\npriority = 3000\n"", '""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias`, `put_to_history` and `get_aliases`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\nfrom .utils import DEVNULL\n\n\nclass Generic(object):\n    def get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self.get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n    def and_(self, *commands):\n        return \' && \'.join(commands)\n\n\nclass Bash(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Fish(Generic):\n    def app_alias(self):\n        return (""function fuck -d \'Correct your previous console command\'\\n""\n                ""    set -l exit_code $status\\n""\n                ""    set -l eval_script""\n                "" (mktemp 2>/dev/null ; or mktemp -t \'thefuck\')\\n""\n                ""    set -l fucked_up_commandd $history[1]\\n""\n                ""    thefuck $fucked_up_commandd > $eval_script\\n""\n                ""    . $eval_script\\n""\n                ""    rm $eval_script\\n""\n                ""    if test $exit_code -ne 0\\n""\n                ""        history --delete $fucked_up_commandd\\n""\n                ""    end\\n""\n                ""end"")\n\n    def _get_history_file_name(self):\n        return os.path.expanduser(\'~/.config/fish/fish_history\')\n\n    def _get_history_line(self, command_script):\n        return u\'- cmd: {}\\n   when: {}\\n\'.format(command_script, int(time()))\n\n    def and_(self, *commands):\n        return \'; and \'.join(commands)\n\n\nclass Zsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nclass Tcsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(""\\t"", 1)\n        return name, value\n\n    def get_aliases(self):\n        proc = Popen(\'tcsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'\\t\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'#+{}\\n{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'fish\': Fish(),\n    \'zsh\': Zsh(),\n    \'csh\': Tcsh(),\n    \'tcsh\': Tcsh()})\n\n\ndef _get_shell():\n    try:\n        shell = Process(os.getpid()).parent().name()\n    except TypeError:\n        shell = Process(os.getpid()).parent.name\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    print(_get_shell().app_alias())\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n\n\ndef and_(*commands):\n    return _get_shell().and_(*commands)\n\n\ndef get_aliases():\n    return _get_shell().get_aliases().keys()\n']","[""from mock import patch, Mock\nfrom thefuck.rules.no_command import match, get_new_command\n\n\ndef test_match():\n    with patch('thefuck.rules.no_command._get_all_callables',\n               return_value=['vim', 'apt-get']):\n        assert match(Mock(stderr='vom: not found', script='vom file.py'), None)\n        assert not match(Mock(stderr='qweqwe: not found', script='qweqwe'), None)\n        assert not match(Mock(stderr='some text', script='vom file.py'), None)\n\n\ndef test_get_new_command():\n    with patch('thefuck.rules.no_command._get_all_callables',\n               return_value=['vim', 'apt-get']):\n        assert get_new_command(\n            Mock(stderr='vom: not found',\n                 script='vom file.py'),\n            None) == 'vim file.py'\n"", ""from difflib import get_close_matches\nimport os\nfrom pathlib import Path\nfrom thefuck.utils import sudo_support\nfrom thefuck.shells import get_aliases\n\n\ndef _safe(fn, fallback):\n    try:\n        return fn()\n    except OSError:\n        return fallback\n\n\ndef _get_all_callables():\n    return [exe.name\n            for path in os.environ.get('PATH', '').split(':')\n            for exe in _safe(lambda: list(Path(path).iterdir()), [])\n            if not _safe(exe.is_dir, True)] + get_aliases()\n\n\n@sudo_support\ndef match(command, settings):\n    return 'not found' in command.stderr and \\\n           bool(get_close_matches(command.script.split(' ')[0],\n                                  _get_all_callables()))\n\n\n@sudo_support\ndef get_new_command(command, settings):\n    old_command = command.script.split(' ')[0]\n    new_command = get_close_matches(old_command,\n                                    _get_all_callables())[0]\n    return ' '.join([new_command] + command.script.split(' ')[1:])\n\n\npriority = 3000\n"", '""""""Module with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias`, `put_to_history` and `get_aliases`\nmethods.\n\n""""""\nfrom collections import defaultdict\nfrom subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom psutil import Process\nfrom .utils import DEVNULL\n\n\nclass Generic(object):\n    def get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self.get_aliases()\n        binary = command_script.split(\' \')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        """"""Prepares command before running in app.""""""\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        """"""Prepares command for running in shell.""""""\n        return command_script\n\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1))\'\\n""\n\n    def _get_history_file_name(self):\n        return \'\'\n\n    def _get_history_line(self, command_script):\n        return \'\'\n\n    def put_to_history(self, command_script):\n        """"""Puts command script to shell history.""""""\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, \'a\') as history:\n                history.write(self._get_history_line(command_script))\n\n    def and_(self, *commands):\n        return \' && \'.join(commands)\n\n\nclass Bash(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.replace(\'alias \', \'\', 1).split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def get_aliases(self):\n        proc = Popen(\'bash -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.bash_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'{}\\n\'.format(command_script)\n\n\nclass Fish(Generic):\n    def app_alias(self):\n        return (""function fuck -d \'Correct your previous console command\'\\n""\n                ""    set -l exit_code $status\\n""\n                ""    set -l eval_script""\n                "" (mktemp 2>/dev/null ; or mktemp -t \'thefuck\')\\n""\n                ""    set -l fucked_up_commandd $history[1]\\n""\n                ""    thefuck $fucked_up_commandd > $eval_script\\n""\n                ""    . $eval_script\\n""\n                ""    rm $eval_script\\n""\n                ""    if test $exit_code -ne 0\\n""\n                ""        history --delete $fucked_up_commandd\\n""\n                ""    end\\n""\n                ""end"")\n\n    def _get_history_file_name(self):\n        return os.path.expanduser(\'~/.config/fish/fish_history\')\n\n    def _get_history_line(self, command_script):\n        return u\'- cmd: {}\\n   when: {}\\n\'.format(command_script, int(time()))\n\n    def and_(self, *commands):\n        return \'; and \'.join(commands)\n\n\nclass Zsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(\'=\', 1)\n        if value[0] == value[-1] == \'""\' or value[0] == value[-1] == ""\'"":\n            value = value[1:-1]\n        return name, value\n\n    def get_aliases(self):\n        proc = Popen(\'zsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'=\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.zsh_history\'))\n\n    def _get_history_line(self, command_script):\n        return u\': {}:0;{}\\n\'.format(int(time()), command_script)\n\n\nclass Tcsh(Generic):\n    def app_alias(self):\n        return ""\\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\\n""\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(""\\t"", 1)\n        return name, value\n\n    def get_aliases(self):\n        proc = Popen(\'tcsh -ic alias\', stdout=PIPE, stderr=DEVNULL, shell=True)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode(\'utf-8\').split(\'\\n\')\n            if alias and \'\\t\' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(""HISTFILE"",\n                              os.path.expanduser(\'~/.history\'))\n\n    def _get_history_line(self, command_script):\n        return u\'#+{}\\n{}\\n\'.format(int(time()), command_script)\n\n\nshells = defaultdict(lambda: Generic(), {\n    \'bash\': Bash(),\n    \'fish\': Fish(),\n    \'zsh\': Zsh(),\n    \'csh\': Tcsh(),\n    \'tcsh\': Tcsh()})\n\n\ndef _get_shell():\n    try:\n        shell = Process(os.getpid()).parent().name()\n    except TypeError:\n        shell = Process(os.getpid()).parent.name\n    return shells[shell]\n\n\ndef from_shell(command):\n    return _get_shell().from_shell(command)\n\n\ndef to_shell(command):\n    return _get_shell().to_shell(command)\n\n\ndef app_alias():\n    print(_get_shell().app_alias())\n\n\ndef put_to_history(command):\n    return _get_shell().put_to_history(command)\n\n\ndef and_(*commands):\n    return _get_shell().and_(*commands)\n\n\ndef get_aliases():\n    return list(_get_shell().get_aliases().keys())\n']","[[<pydriller.domain.commit.Method object at 0x7f1983f76610>, <pydriller.domain.commit.Method object at 0x7f1983f76820>], [<pydriller.domain.commit.Method object at 0x7f198648caf0>, <pydriller.domain.commit.Method object at 0x7f198648ca90>, <pydriller.domain.commit.Method object at 0x7f198648c910>, <pydriller.domain.commit.Method object at 0x7f198648c610>], [<pydriller.domain.commit.Method object at 0x7f198648cb80>, <pydriller.domain.commit.Method object at 0x7f198648cb20>, <pydriller.domain.commit.Method object at 0x7f198648c7c0>, <pydriller.domain.commit.Method object at 0x7f1983f71160>, <pydriller.domain.commit.Method object at 0x7f1983f71310>, <pydriller.domain.commit.Method object at 0x7f1983f71c40>, <pydriller.domain.commit.Method object at 0x7f1983f71ca0>, <pydriller.domain.commit.Method object at 0x7f1983f712e0>, <pydriller.domain.commit.Method object at 0x7f1983f71190>, <pydriller.domain.commit.Method object at 0x7f1983f71220>, <pydriller.domain.commit.Method object at 0x7f1983f71ac0>, <pydriller.domain.commit.Method object at 0x7f1983f71dc0>, <pydriller.domain.commit.Method object at 0x7f1983f71b50>, <pydriller.domain.commit.Method object at 0x7f1983f711c0>, <pydriller.domain.commit.Method object at 0x7f1983f711f0>, <pydriller.domain.commit.Method object at 0x7f1983f71eb0>, <pydriller.domain.commit.Method object at 0x7f1983f71940>, <pydriller.domain.commit.Method object at 0x7f1983f71ee0>, <pydriller.domain.commit.Method object at 0x7f1983f71c10>, <pydriller.domain.commit.Method object at 0x7f1983f71f40>, <pydriller.domain.commit.Method object at 0x7f1983f71700>, <pydriller.domain.commit.Method object at 0x7f1983f719d0>, <pydriller.domain.commit.Method object at 0x7f1983f71850>, <pydriller.domain.commit.Method object at 0x7f1983f71df0>, <pydriller.domain.commit.Method object at 0x7f1983f71460>, <pydriller.domain.commit.Method object at 0x7f1983f71af0>, <pydriller.domain.commit.Method object at 0x7f1983f71fd0>, <pydriller.domain.commit.Method object at 0x7f1983f710d0>, <pydriller.domain.commit.Method object at 0x7f1983f71f10>, <pydriller.domain.commit.Method object at 0x7f1983f719a0>, <pydriller.domain.commit.Method object at 0x7f1983f715b0>, <pydriller.domain.commit.Method object at 0x7f1983fc98b0>, <pydriller.domain.commit.Method object at 0x7f1983fc91f0>, <pydriller.domain.commit.Method object at 0x7f198647bd30>, <pydriller.domain.commit.Method object at 0x7f198647b340>]]","[[<pydriller.domain.commit.Method object at 0x7f1983f76be0>, <pydriller.domain.commit.Method object at 0x7f1983f76ca0>], [<pydriller.domain.commit.Method object at 0x7f198648c820>, <pydriller.domain.commit.Method object at 0x7f198648c8e0>, <pydriller.domain.commit.Method object at 0x7f198648ca90>, <pydriller.domain.commit.Method object at 0x7f198648c850>], [<pydriller.domain.commit.Method object at 0x7f1986493910>]]"
thefuck,1f48d5e12a4e103dfea7ce33b82ef3b25565346d,Add a rule to change man section,2015-05-20 18:08:15+02:00,mcarton,40,0,40,3,"['README.md', 'test_man.py', 'man.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run the changed command, there is a `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to the `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\n```\n\nIf you are using `tcsh`:\n```tcsh\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match a rule for the previous command, creates a new command\nusing the matched rule and runs it. Rules enabled by default are as follows:\n\n* `cd_correction` &ndash; spellchecks and correct failed cd commands;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `composer_not_command` &ndash; fixes composer command name;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `cpp11` &ndash; add missing `-std=c++11` to `g++` or `clang++`;\n* `dry` &ndash; fix repetitions like ""git git push"";\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_add` &ndash; fix *""Did you forget to \'git add\'?""*;\n* `git_checkout` &ndash; creates the branch before checking-out;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_pull` &ndash; sets upstream before executing previous `git pull`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `git_stash` &ndash; stashes you local modifications before rebasing or switching branch;\n* `grep_recursive` &ndash; adds `-r` when you trying to grep directory; \n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `ls_lah` &ndash; adds -lah to ls;\n* `man_no_space` &ndash; fixes man commands without spaces, for example `mandiff`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `no_such_file` &ndash; creates missing directories with `mv` and `cp` commands;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `whois` &ndash; fixes `whois` command.\n\nEnabled by default only on specific platforms:\n\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n\n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call(\'chmod 777 .\', shell=True)\n\npriority = 1000  # Lower first\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters which can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; requires confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output;\n* `priority` &ndash; dict with rules priorities, rule with lower `priority` will be matched first.\n\nExample of `settings.py`:\n\n```python\nrules = [\'sudo\', \'no_command\']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\npriority = {\'sudo\': 100, \'no_command\': 9999}\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`;\n* `THEFUCK_PRIORITY` &ndash; priority of the rules, like `no_command=9999:apt_get=100`,\nrule with lower `priority` will be matched first.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES=\'sudo:no_command\'\nexport THEFUCK_REQUIRE_CONFIRMATION=\'true\'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS=\'false\'\nexport THEFUCK_PRIORITY=\'no_command=9999:apt_get=100\'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', None, None]","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run the changed command, there is a `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to the `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\n```\n\nIf you are using `tcsh`:\n```tcsh\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match a rule for the previous command, creates a new command\nusing the matched rule and runs it. Rules enabled by default are as follows:\n\n* `cd_correction` &ndash; spellchecks and correct failed cd commands;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `composer_not_command` &ndash; fixes composer command name;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `cpp11` &ndash; add missing `-std=c++11` to `g++` or `clang++`;\n* `dry` &ndash; fix repetitions like ""git git push"";\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_add` &ndash; fix *""Did you forget to \'git add\'?""*;\n* `git_checkout` &ndash; creates the branch before checking-out;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_pull` &ndash; sets upstream before executing previous `git pull`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `git_stash` &ndash; stashes you local modifications before rebasing or switching branch;\n* `grep_recursive` &ndash; adds `-r` when you trying to grep directory; \n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `ls_lah` &ndash; adds -lah to ls;\n* `man` &ndash; change manual section;\n* `man_no_space` &ndash; fixes man commands without spaces, for example `mandiff`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `no_such_file` &ndash; creates missing directories with `mv` and `cp` commands;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `whois` &ndash; fixes `whois` command.\n\nEnabled by default only on specific platforms:\n\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n\n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call(\'chmod 777 .\', shell=True)\n\npriority = 1000  # Lower first\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters which can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; requires confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output;\n* `priority` &ndash; dict with rules priorities, rule with lower `priority` will be matched first.\n\nExample of `settings.py`:\n\n```python\nrules = [\'sudo\', \'no_command\']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\npriority = {\'sudo\': 100, \'no_command\': 9999}\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`;\n* `THEFUCK_PRIORITY` &ndash; priority of the rules, like `no_command=9999:apt_get=100`,\nrule with lower `priority` will be matched first.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES=\'sudo:no_command\'\nexport THEFUCK_REQUIRE_CONFIRMATION=\'true\'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS=\'false\'\nexport THEFUCK_PRIORITY=\'no_command=9999:apt_get=100\'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', ""import pytest\nfrom thefuck.rules.man import match, get_new_command\nfrom tests.utils import Command\n\n@pytest.mark.parametrize('command', [\n    Command('man read'),\n    Command('man 2 read'),\n    Command('man 3 read'),\n    Command('man -s2 read'),\n    Command('man -s3 read'),\n    Command('man -s 2 read'),\n    Command('man -s 3 read')])\ndef test_match(command):\n    assert match(command, None)\n\n\n@pytest.mark.parametrize('command, new_command', [\n    (Command('man read'), 'man 3 read'),\n    (Command('man 2 read'), 'man 3 read'),\n    (Command('man 3 read'), 'man 2 read'),\n    (Command('man -s2 read'), 'man -s3 read'),\n    (Command('man -s3 read'), 'man -s2 read'),\n    (Command('man -s 2 read'), 'man -s 3 read'),\n    (Command('man -s 3 read'), 'man -s 2 read')])\ndef test_get_new_command(command, new_command):\n    assert get_new_command(command, None) == new_command\n"", 'def match(command, settings):\n    return command.script.startswith(\'man\')\n\n\ndef get_new_command(command, settings):\n    if \'3\' in command.script:\n        return command.script.replace(""3"", ""2"")\n    if \'2\' in command.script:\n        return command.script.replace(""2"", ""3"")\n\n    split_cmd = command.script.split()\n    split_cmd.insert(1, \' 3 \')\n    return """".join(split_cmd)\n']","[[], [], []]","[[], [<pydriller.domain.commit.Method object at 0x7f1983f7d040>, <pydriller.domain.commit.Method object at 0x7f1983f7d1c0>], [<pydriller.domain.commit.Method object at 0x7f198647b250>, <pydriller.domain.commit.Method object at 0x7f198647bdc0>]]"
thefuck,44c06c483ef779a56d3de2899264cf1355e456e4,"fix(whois): check if there's at least one argument to `whois`

This avoids thefuck failing when there's no arguments. It fails with:

```
  ...
  File ""thefuck/rules/whois.py"", line 26, in get_new_command
    url = command.script.split()[1]
IndexError: list index out of range
```

Signed-off-by: Pablo Santiago Blum de Aguiar <scorphus@gmail.com>",2015-05-20 13:54:33-03:00,Pablo Santiago Blum de Aguiar,5,1,6,2,"['test_whois.py', 'whois.py']","[""import pytest\nfrom thefuck.rules.whois import match, get_new_command\nfrom tests.utils import Command\n\n\n@pytest.mark.parametrize('command', [\n    Command(script='whois https://en.wikipedia.org/wiki/Main_Page'),\n    Command(script='whois https://en.wikipedia.org/'),\n    Command(script='whois en.wikipedia.org')])\ndef test_match(command):\n    assert match(command, None)\n\n\n@pytest.mark.parametrize('command, new_command', [\n    (Command('whois https://en.wikipedia.org/wiki/Main_Page'), 'whois en.wikipedia.org'),\n    (Command('whois https://en.wikipedia.org/'), 'whois en.wikipedia.org'),\n    (Command('whois en.wikipedia.org'), 'whois wikipedia.org')])\ndef test_get_new_command(command, new_command):\n    assert get_new_command(command, None) == new_command\n"", '# -*- encoding: utf-8 -*-\nfrom six.moves.urllib.parse import urlparse\n\n\ndef match(command, settings):\n    """"""\n    What the `whois` command returns depends on the \'Whois server\' it contacted\n    and is not consistent through different servers. But there can be only two\n    types of errors I can think of with `whois`:\n        - `whois https://en.wikipedia.org/` → `whois en.wikipedia.org`;\n        - `whois en.wikipedia.org` → `whois wikipedia.org`.\n    So we match any `whois` command and then:\n        - if there is a slash: keep only the FQDN;\n        - if there is no slash but there is a point: removes the left-most\n          subdomain.\n\n    We cannot either remove all subdomains because we cannot know which part is\n    the subdomains and which is the domain, consider:\n        - www.google.fr → subdomain: www, domain: \'google.fr\';\n        - google.co.uk → subdomain: None, domain; \'google.co.uk\'.\n    """"""\n    return \'whois\' in command.script\n\n\ndef get_new_command(command, settings):\n    url = command.script.split()[1]\n\n    if \'/\' in command.script:\n        return \'whois \' + urlparse(url).netloc\n    elif \'.\' in command.script:\n        return \'whois \' + \'.\'.join(urlparse(url).path.split(\'.\')[1:])\n']","[""import pytest\nfrom thefuck.rules.whois import match, get_new_command\nfrom tests.utils import Command\n\n\n@pytest.mark.parametrize('command', [\n    Command(script='whois https://en.wikipedia.org/wiki/Main_Page'),\n    Command(script='whois https://en.wikipedia.org/'),\n    Command(script='whois en.wikipedia.org')])\ndef test_match(command):\n    assert match(command, None)\n\n\ndef test_not_match():\n    assert not match(Command(script='whois'), None)\n\n\n@pytest.mark.parametrize('command, new_command', [\n    (Command('whois https://en.wikipedia.org/wiki/Main_Page'), 'whois en.wikipedia.org'),\n    (Command('whois https://en.wikipedia.org/'), 'whois en.wikipedia.org'),\n    (Command('whois en.wikipedia.org'), 'whois wikipedia.org')])\ndef test_get_new_command(command, new_command):\n    assert get_new_command(command, None) == new_command\n"", '# -*- encoding: utf-8 -*-\nfrom six.moves.urllib.parse import urlparse\n\n\ndef match(command, settings):\n    """"""\n    What the `whois` command returns depends on the \'Whois server\' it contacted\n    and is not consistent through different servers. But there can be only two\n    types of errors I can think of with `whois`:\n        - `whois https://en.wikipedia.org/` → `whois en.wikipedia.org`;\n        - `whois en.wikipedia.org` → `whois wikipedia.org`.\n    So we match any `whois` command and then:\n        - if there is a slash: keep only the FQDN;\n        - if there is no slash but there is a point: removes the left-most\n          subdomain.\n\n    We cannot either remove all subdomains because we cannot know which part is\n    the subdomains and which is the domain, consider:\n        - www.google.fr → subdomain: www, domain: \'google.fr\';\n        - google.co.uk → subdomain: None, domain; \'google.co.uk\'.\n    """"""\n    return \'whois\' in command.script and len(command.script.split()) > 1\n\n\ndef get_new_command(command, settings):\n    url = command.script.split()[1]\n\n    if \'/\' in command.script:\n        return \'whois \' + urlparse(url).netloc\n    elif \'.\' in command.script:\n        return \'whois \' + \'.\'.join(urlparse(url).path.split(\'.\')[1:])\n']","[[<pydriller.domain.commit.Method object at 0x7f198647b3d0>, <pydriller.domain.commit.Method object at 0x7f198647b910>], [<pydriller.domain.commit.Method object at 0x7f1983f76d30>, <pydriller.domain.commit.Method object at 0x7f1983f76ee0>]]","[[<pydriller.domain.commit.Method object at 0x7f198647b1c0>], [<pydriller.domain.commit.Method object at 0x7f1983f76c40>]]"
thefuck,e7d7b80c09baa6dd7ba747f5223f29ea0473d1c9,Add rule for django south ghost migrations,2015-05-21 00:49:56+03:00,nvbn,62,0,62,3,"['README.md', 'test_django_south_ghost.py', 'django_south_ghost.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run the changed command, there is a `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to the `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\n```\n\nIf you are using `tcsh`:\n```tcsh\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match a rule for the previous command, creates a new command\nusing the matched rule and runs it. Rules enabled by default are as follows:\n\n* `cd_correction` &ndash; spellchecks and correct failed cd commands;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `composer_not_command` &ndash; fixes composer command name;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `cpp11` &ndash; add missing `-std=c++11` to `g++` or `clang++`;\n* `dry` &ndash; fix repetitions like ""git git push"";\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_add` &ndash; fix *""Did you forget to \'git add\'?""*;\n* `git_checkout` &ndash; creates the branch before checking-out;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_pull` &ndash; sets upstream before executing previous `git pull`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `git_stash` &ndash; stashes you local modifications before rebasing or switching branch;\n* `grep_recursive` &ndash; adds `-r` when you trying to grep directory; \n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `ls_lah` &ndash; adds -lah to ls;\n* `man` &ndash; change manual section;\n* `man_no_space` &ndash; fixes man commands without spaces, for example `mandiff`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `no_such_file` &ndash; creates missing directories with `mv` and `cp` commands;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `whois` &ndash; fixes `whois` command.\n\nEnabled by default only on specific platforms:\n\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n\n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call(\'chmod 777 .\', shell=True)\n\npriority = 1000  # Lower first\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters which can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; requires confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output;\n* `priority` &ndash; dict with rules priorities, rule with lower `priority` will be matched first.\n\nExample of `settings.py`:\n\n```python\nrules = [\'sudo\', \'no_command\']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\npriority = {\'sudo\': 100, \'no_command\': 9999}\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`;\n* `THEFUCK_PRIORITY` &ndash; priority of the rules, like `no_command=9999:apt_get=100`,\nrule with lower `priority` will be matched first.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES=\'sudo:no_command\'\nexport THEFUCK_REQUIRE_CONFIRMATION=\'true\'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS=\'false\'\nexport THEFUCK_PRIORITY=\'no_command=9999:apt_get=100\'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', None, None]","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run the changed command, there is a `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to the `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\n```\n\nIf you are using `tcsh`:\n```tcsh\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match a rule for the previous command, creates a new command\nusing the matched rule and runs it. Rules enabled by default are as follows:\n\n* `cd_correction` &ndash; spellchecks and correct failed cd commands;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `composer_not_command` &ndash; fixes composer command name;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `cpp11` &ndash; add missing `-std=c++11` to `g++` or `clang++`;\n* `dry` &ndash; fix repetitions like ""git git push"";\n* `django_south_ghost` &ndash; adds `--delete-ghost-migrations` to failed because ghosts django south migration;\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_add` &ndash; fix *""Did you forget to \'git add\'?""*;\n* `git_checkout` &ndash; creates the branch before checking-out;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_pull` &ndash; sets upstream before executing previous `git pull`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `git_stash` &ndash; stashes you local modifications before rebasing or switching branch;\n* `grep_recursive` &ndash; adds `-r` when you trying to grep directory; \n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `ls_lah` &ndash; adds -lah to ls;\n* `man` &ndash; change manual section;\n* `man_no_space` &ndash; fixes man commands without spaces, for example `mandiff`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `no_such_file` &ndash; creates missing directories with `mv` and `cp` commands;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `whois` &ndash; fixes `whois` command.\n\nEnabled by default only on specific platforms:\n\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n\n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call(\'chmod 777 .\', shell=True)\n\npriority = 1000  # Lower first\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters which can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; requires confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output;\n* `priority` &ndash; dict with rules priorities, rule with lower `priority` will be matched first.\n\nExample of `settings.py`:\n\n```python\nrules = [\'sudo\', \'no_command\']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\npriority = {\'sudo\': 100, \'no_command\': 9999}\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`;\n* `THEFUCK_PRIORITY` &ndash; priority of the rules, like `no_command=9999:apt_get=100`,\nrule with lower `priority` will be matched first.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES=\'sudo:no_command\'\nexport THEFUCK_REQUIRE_CONFIRMATION=\'true\'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS=\'false\'\nexport THEFUCK_PRIORITY=\'no_command=9999:apt_get=100\'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', 'import pytest\nfrom thefuck.rules.django_south_ghost import match, get_new_command\nfrom tests.utils import Command\n\n\n@pytest.fixture\ndef stderr():\n    return \'\'\'Traceback (most recent call last):\n  File ""/home/nvbn/work/.../bin/python"", line 42, in <module>\n    exec(compile(__file__f.read(), __file__, ""exec""))\n  File ""/home/nvbn/work/.../app/manage.py"", line 34, in <module>\n    execute_from_command_line(sys.argv)\n  File ""/home/nvbn/work/.../lib/django/core/management/__init__.py"", line 443, in execute_from_command_line\n    utility.execute()\n  File ""/home/nvbn/work/.../lib/django/core/management/__init__.py"", line 382, in execute\n    self.fetch_command(subcommand).run_from_argv(self.argv)\n  File ""/home/nvbn/work/.../lib/django/core/management/base.py"", line 196, in run_from_argv\n    self.execute(*args, **options.__dict__)\n  File ""/home/nvbn/work/.../lib/django/core/management/base.py"", line 232, in execute\n    output = self.handle(*args, **options)\n  File ""/home/nvbn/work/.../app/lib/south/management/commands/migrate.py"", line 108, in handle\n    ignore_ghosts = ignore_ghosts,\n  File ""/home/nvbn/work/.../app/lib/south/migration/__init__.py"", line 193, in migrate_app\n    applied_all = check_migration_histories(applied_all, delete_ghosts, ignore_ghosts)\n  File ""/home/nvbn/work/.../app/lib/south/migration/__init__.py"", line 88, in check_migration_histories\n    raise exceptions.GhostMigrations(ghosts)\nsouth.exceptions.GhostMigrations: \n\n ! These migrations are in the database but not on disk:\n    <tracker: 0033_auto__...>\n    <tracker: 0034_fill_...>\n    <tracker: 0035_rename_...>\n    <qm_auth: 0003_add_...>\n    <qm_auth: 0004_denormalize_...>\n    <tracker: 0033_auto....>\n    <tracker: 0034_fill...>\n ! I\'m not trusting myself; either fix this yourself by fiddling\n ! with the south_migrationhistory table, or pass --delete-ghost-migrations\n ! to South to have it delete ALL of these records (this may not be good).\n\'\'\'\n\n\ndef test_match(stderr):\n    assert match(Command(\'./manage.py migrate\', stderr=stderr), None)\n    assert match(Command(\'python manage.py migrate\', stderr=stderr), None)\n    assert not match(Command(\'./manage.py migrate\'), None)\n    assert not match(Command(\'app migrate\', stderr=stderr), None)\n    assert not match(Command(\'./manage.py test\', stderr=stderr), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command(\'./manage.py migrate auth\'), None)\\\n        == \'./manage.py migrate auth --delete-ghost-migrations\'\n', ""def match(command, settings):\n    return 'manage.py' in command.script and \\\n           'migrate' in command.script \\\n           and 'or pass --delete-ghost-migrations' in command.stderr\n\n\ndef get_new_command(command, settings):\n    return u'{} --delete-ghost-migrations'.format(command.script)\n""]","[[], [], []]","[[], [<pydriller.domain.commit.Method object at 0x7f1983f76af0>, <pydriller.domain.commit.Method object at 0x7f1983f76eb0>, <pydriller.domain.commit.Method object at 0x7f1983f76580>], [<pydriller.domain.commit.Method object at 0x7f1986493640>, <pydriller.domain.commit.Method object at 0x7f1986493400>]]"
thefuck,c65fdd0f814689729867c7f0ae4025ee3615a5c5,Add rule for django south inconsistent migrations,2015-05-21 00:55:23+03:00,nvbn,59,7,66,4,"['README.md', 'test_django_south_ghost.py', 'test_django_south_merge.py', 'django_south_merge.py']","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run the changed command, there is a `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to the `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\n```\n\nIf you are using `tcsh`:\n```tcsh\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match a rule for the previous command, creates a new command\nusing the matched rule and runs it. Rules enabled by default are as follows:\n\n* `cd_correction` &ndash; spellchecks and correct failed cd commands;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `composer_not_command` &ndash; fixes composer command name;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `cpp11` &ndash; add missing `-std=c++11` to `g++` or `clang++`;\n* `dry` &ndash; fix repetitions like ""git git push"";\n* `django_south_ghost` &ndash; adds `--delete-ghost-migrations` to failed because ghosts django south migration;\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_add` &ndash; fix *""Did you forget to \'git add\'?""*;\n* `git_checkout` &ndash; creates the branch before checking-out;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_pull` &ndash; sets upstream before executing previous `git pull`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `git_stash` &ndash; stashes you local modifications before rebasing or switching branch;\n* `grep_recursive` &ndash; adds `-r` when you trying to grep directory; \n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `ls_lah` &ndash; adds -lah to ls;\n* `man` &ndash; change manual section;\n* `man_no_space` &ndash; fixes man commands without spaces, for example `mandiff`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `no_such_file` &ndash; creates missing directories with `mv` and `cp` commands;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `whois` &ndash; fixes `whois` command.\n\nEnabled by default only on specific platforms:\n\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n\n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call(\'chmod 777 .\', shell=True)\n\npriority = 1000  # Lower first\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters which can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; requires confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output;\n* `priority` &ndash; dict with rules priorities, rule with lower `priority` will be matched first.\n\nExample of `settings.py`:\n\n```python\nrules = [\'sudo\', \'no_command\']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\npriority = {\'sudo\': 100, \'no_command\': 9999}\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`;\n* `THEFUCK_PRIORITY` &ndash; priority of the rules, like `no_command=9999:apt_get=100`,\nrule with lower `priority` will be matched first.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES=\'sudo:no_command\'\nexport THEFUCK_REQUIRE_CONFIRMATION=\'true\'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS=\'false\'\nexport THEFUCK_PRIORITY=\'no_command=9999:apt_get=100\'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', 'import pytest\nfrom thefuck.rules.django_south_ghost import match, get_new_command\nfrom tests.utils import Command\n\n\n@pytest.fixture\ndef stderr():\n    return \'\'\'Traceback (most recent call last):\n  File ""/home/nvbn/work/.../bin/python"", line 42, in <module>\n    exec(compile(__file__f.read(), __file__, ""exec""))\n  File ""/home/nvbn/work/.../app/manage.py"", line 34, in <module>\n    execute_from_command_line(sys.argv)\n  File ""/home/nvbn/work/.../lib/django/core/management/__init__.py"", line 443, in execute_from_command_line\n    utility.execute()\n  File ""/home/nvbn/work/.../lib/django/core/management/__init__.py"", line 382, in execute\n    self.fetch_command(subcommand).run_from_argv(self.argv)\n  File ""/home/nvbn/work/.../lib/django/core/management/base.py"", line 196, in run_from_argv\n    self.execute(*args, **options.__dict__)\n  File ""/home/nvbn/work/.../lib/django/core/management/base.py"", line 232, in execute\n    output = self.handle(*args, **options)\n  File ""/home/nvbn/work/.../app/lib/south/management/commands/migrate.py"", line 108, in handle\n    ignore_ghosts = ignore_ghosts,\n  File ""/home/nvbn/work/.../app/lib/south/migration/__init__.py"", line 193, in migrate_app\n    applied_all = check_migration_histories(applied_all, delete_ghosts, ignore_ghosts)\n  File ""/home/nvbn/work/.../app/lib/south/migration/__init__.py"", line 88, in check_migration_histories\n    raise exceptions.GhostMigrations(ghosts)\nsouth.exceptions.GhostMigrations: \n\n ! These migrations are in the database but not on disk:\n    <tracker: 0033_auto__...>\n    <tracker: 0034_fill_...>\n    <tracker: 0035_rename_...>\n    <qm_auth: 0003_add_...>\n    <qm_auth: 0004_denormalize_...>\n    <tracker: 0033_auto....>\n    <tracker: 0034_fill...>\n ! I\'m not trusting myself; either fix this yourself by fiddling\n ! with the south_migrationhistory table, or pass --delete-ghost-migrations\n ! to South to have it delete ALL of these records (this may not be good).\n\'\'\'\n\n\ndef test_match(stderr):\n    assert match(Command(\'./manage.py migrate\', stderr=stderr), None)\n    assert match(Command(\'python manage.py migrate\', stderr=stderr), None)\n    assert not match(Command(\'./manage.py migrate\'), None)\n    assert not match(Command(\'app migrate\', stderr=stderr), None)\n    assert not match(Command(\'./manage.py test\', stderr=stderr), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command(\'./manage.py migrate auth\'), None)\\\n        == \'./manage.py migrate auth --delete-ghost-migrations\'\n', None, None]","['# The Fuck [![Build Status](https://travis-ci.org/nvbn/thefuck.svg)](https://travis-ci.org/nvbn/thefuck)\n\n**Aliases changed in 1.34.**\n\nMagnificent app which corrects your previous console command,\ninspired by a [@liamosaur](https://twitter.com/liamosaur/)\n[tweet](https://twitter.com/liamosaur/status/506975850596536320).\n\nFew examples:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n```bash\n➜ git push\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin master\n\n\n➜ fuck\ngit push --set-upstream origin master\nCounting objects: 9, done.\n...\n```\n\n```bash\n➜ puthon\nNo command \'puthon\' found, did you mean:\n Command \'python\' from package \'python-minimal\' (main)\n Command \'python\' from package \'python3\' (main)\nzsh: command not found: puthon\n\n➜ fuck\npython\nPython 3.4.2 (default, Oct  8 2014, 13:08:17)\n...\n```\n\n```bash\n➜ git brnch\ngit: \'brnch\' is not a git command. See \'git --help\'.\n\nDid you mean this?\n\tbranch\n\n➜ fuck\ngit branch\n* master\n```\n\n```bash\n➜ lein rpl\n\'rpl\' is not a task. See \'lein help\'.\n\nDid you mean this?\n         repl\n\n➜ fuck\nlein repl\nnREPL server started on port 54848 on host 127.0.0.1 - nrepl://127.0.0.1:54848\nREPL-y 0.3.1\n...\n```\n\nIf you are scared to blindly run the changed command, there is a `require_confirmation`\n[settings](#settings) option:\n\n```bash\n➜ apt-get install vim\nE: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)\nE: Unable to lock the administration directory (/var/lib/dpkg/), are you root?\n\n➜ fuck\nsudo apt-get install vim [Enter/Ctrl+C]\n[sudo] password for nvbn:\nReading package lists... Done\n...\n```\n\n## Requirements\n\n- python (2.7+ or 3.3+)\n- pip\n- python-dev\n\n## Installation\n\nInstall `The Fuck` with `pip`:\n\n```bash\nsudo pip install thefuck\n```\n\n[Or using an OS package manager (OS X, Ubuntu, Arch).](https://github.com/nvbn/thefuck/wiki/Installation)\n\nAnd add to the `.bashrc` or `.bash_profile`(for OSX):\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1)); history -r\'\n# You can use whatever you want as an alias, like for Mondays:\nalias FUCK=\'fuck\'\n```\n\nOr in your `.zshrc`:\n\n```bash\nalias fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R\'\n```\n\nIf you are using `tcsh`:\n```tcsh\nalias fuck \'set fucked_cmd=`history -h 2 | head -n 1` && eval `thefuck ${fucked_cmd}`\'\n```\n\nAlternatively, you can redirect the output of `thefuck-alias`:\n\n```bash\nthefuck-alias >> ~/.bashrc\n```\n\n[Or in your shell config (Bash, Zsh, Fish, Powershell).](https://github.com/nvbn/thefuck/wiki/Shell-aliases)\n\nChanges will be available only in a new shell session.\n\n\n## Update\n\n```bash\nsudo pip install thefuck --upgrade\n```\n\n## How it works\n\nThe Fuck tries to match a rule for the previous command, creates a new command\nusing the matched rule and runs it. Rules enabled by default are as follows:\n\n* `cd_correction` &ndash; spellchecks and correct failed cd commands;\n* `cd_mkdir` &ndash; creates directories before cd\'ing into them;\n* `cd_parent` &ndash; changes `cd..` to `cd ..`;\n* `composer_not_command` &ndash; fixes composer command name;\n* `cp_omitting_directory` &ndash; adds `-a` when you `cp` directory;\n* `cpp11` &ndash; add missing `-std=c++11` to `g++` or `clang++`;\n* `dry` &ndash; fix repetitions like ""git git push"";\n* `django_south_ghost` &ndash; adds `--delete-ghost-migrations` to failed because ghosts django south migration;\n* `django_south_merge` &ndash; adds `--merge` to inconsistent django south migration;\n* `fix_alt_space` &ndash; replaces Alt+Space with Space character;\n* `git_add` &ndash; fix *""Did you forget to \'git add\'?""*;\n* `git_checkout` &ndash; creates the branch before checking-out;\n* `git_no_command` &ndash; fixes wrong git commands like `git brnch`;\n* `git_pull` &ndash; sets upstream before executing previous `git pull`;\n* `git_push` &ndash; adds `--set-upstream origin $branch` to previous failed `git push`;\n* `git_stash` &ndash; stashes you local modifications before rebasing or switching branch;\n* `grep_recursive` &ndash; adds `-r` when you trying to grep directory; \n* `has_exists_script` &ndash; prepends `./` when script/binary exists;\n* `lein_not_task` &ndash; fixes wrong `lein` tasks like `lein rpl`;\n* `ls_lah` &ndash; adds -lah to ls;\n* `man` &ndash; change manual section;\n* `man_no_space` &ndash; fixes man commands without spaces, for example `mandiff`;\n* `mkdir_p` &ndash; adds `-p` when you trying to create directory without parent;\n* `no_command` &ndash; fixes wrong console commands, for example `vom/vim`;\n* `no_such_file` &ndash; creates missing directories with `mv` and `cp` commands;\n* `pip_unknown_command` &ndash; fixes wrong pip commands, for example `pip instatl/pip install`;\n* `python_command` &ndash; prepends `python` when you trying to run not executable/without `./` python script;\n* `rm_dir` &ndash; adds `-rf` when you trying to remove directory;\n* `sl_ls` &ndash; changes `sl` to `ls`;\n* `ssh_known_hosts` &ndash; removes host from `known_hosts` on warning;\n* `sudo` &ndash; prepends `sudo` to previous command if it failed because of permissions;\n* `switch_layout` &ndash; switches command from your local layout to en;\n* `whois` &ndash; fixes `whois` command.\n\nEnabled by default only on specific platforms:\n\n* `apt_get` &ndash; installs app from apt if it not installed;\n* `brew_install` &ndash; fixes formula name for `brew install`;\n* `brew_unknown_command` &ndash; fixes wrong brew commands, for example `brew docto/brew doctor`;\n* `pacman` &ndash; installs app with `pacman` or `yaourt` if it is not installed.\n\nBundled, but not enabled by default:\n\n* `rm_root` &ndash; adds `--no-preserve-root` to `rm -rf /` command.\n\n## Creating your own rules\n\nFor adding your own rule you should create `your-rule-name.py`\nin `~/.thefuck/rules`. Rule should contain two functions:\n`match(command: Command, settings: Settings) -> bool`\nand `get_new_command(command: Command, settings: Settings) -> str`.\nAlso the rule can contain optional function\n`side_effect(command: Command, settings: Settings) -> None` and\noptional boolean `enabled_by_default`\n\n`Command` has three attributes: `script`, `stdout` and `stderr`.\n\n`Settings` is a special object filled with `~/.thefuck/settings.py` and values from env, [more](#settings).\n\nSimple example of the rule for running script with `sudo`:\n\n```python\ndef match(command, settings):\n    return (\'permission denied\' in command.stderr.lower()\n            or \'EACCES\' in command.stderr)\n\n\ndef get_new_command(command, settings):\n    return \'sudo {}\'.format(command.script)\n\n# Optional:\nenabled_by_default = True\n\ndef side_effect(command, settings):\n    subprocess.call(\'chmod 777 .\', shell=True)\n\npriority = 1000  # Lower first\n```\n\n[More examples of rules](https://github.com/nvbn/thefuck/tree/master/thefuck/rules),\n[utility functions for rules](https://github.com/nvbn/thefuck/tree/master/thefuck/utils.py).\n\n## Settings\n\nThe Fuck has a few settings parameters which can be changed in `~/.thefuck/settings.py`:\n\n* `rules` &ndash; list of enabled rules, by default `thefuck.conf.DEFAULT_RULES`;\n* `require_confirmation` &ndash; requires confirmation before running new command, by default `False`;\n* `wait_command` &ndash; max amount of time in seconds for getting previous command output;\n* `no_colors` &ndash; disable colored output;\n* `priority` &ndash; dict with rules priorities, rule with lower `priority` will be matched first.\n\nExample of `settings.py`:\n\n```python\nrules = [\'sudo\', \'no_command\']\nrequire_confirmation = True\nwait_command = 10\nno_colors = False\npriority = {\'sudo\': 100, \'no_command\': 9999}\n```\n\nOr via environment variables:\n\n* `THEFUCK_RULES` &ndash; list of enabled rules, like `DEFAULT_RULES:rm_root` or `sudo:no_command`;\n* `THEFUCK_REQUIRE_CONFIRMATION` &ndash; require confirmation before running new command, `true/false`;\n* `THEFUCK_WAIT_COMMAND` &ndash; max amount of time in seconds for getting previous command output;\n* `THEFUCK_NO_COLORS` &ndash; disable colored output, `true/false`;\n* `THEFUCK_PRIORITY` &ndash; priority of the rules, like `no_command=9999:apt_get=100`,\nrule with lower `priority` will be matched first.\n\nFor example:\n\n```bash\nexport THEFUCK_RULES=\'sudo:no_command\'\nexport THEFUCK_REQUIRE_CONFIRMATION=\'true\'\nexport THEFUCK_WAIT_COMMAND=10\nexport THEFUCK_NO_COLORS=\'false\'\nexport THEFUCK_PRIORITY=\'no_command=9999:apt_get=100\'\n```\n\n## Developing\n\nInstall `The Fuck` for development:\n\n```bash\npip install -r requirements.txt\npython setup.py develop\n```\n\nRun tests:\n\n```bash\npy.test\n```\n\n## License MIT\nProject License can be found [here](LICENSE.md).\n', 'import pytest\nfrom thefuck.rules.django_south_ghost import match, get_new_command\nfrom tests.utils import Command\n\n\n@pytest.fixture\ndef stderr():\n    return \'\'\'Traceback (most recent call last):\n  File ""/home/nvbn/work/.../bin/python"", line 42, in <module>\n    exec(compile(__file__f.read(), __file__, ""exec""))\n  File ""/home/nvbn/work/.../app/manage.py"", line 34, in <module>\n    execute_from_command_line(sys.argv)\n  File ""/home/nvbn/work/.../lib/django/core/management/__init__.py"", line 443, in execute_from_command_line\n    utility.execute()\n  File ""/home/nvbn/work/.../lib/django/core/management/__init__.py"", line 382, in execute\n    self.fetch_command(subcommand).run_from_argv(self.argv)\n  File ""/home/nvbn/work/.../lib/django/core/management/base.py"", line 196, in run_from_argv\n    self.execute(*args, **options.__dict__)\n  File ""/home/nvbn/work/.../lib/django/core/management/base.py"", line 232, in execute\n    output = self.handle(*args, **options)\n  File ""/home/nvbn/work/.../app/lib/south/management/commands/migrate.py"", line 108, in handle\n    ignore_ghosts = ignore_ghosts,\n  File ""/home/nvbn/work/.../app/lib/south/migration/__init__.py"", line 193, in migrate_app\n    applied_all = check_migration_histories(applied_all, delete_ghosts, ignore_ghosts)\n  File ""/home/nvbn/work/.../app/lib/south/migration/__init__.py"", line 88, in check_migration_histories\n    raise exceptions.GhostMigrations(ghosts)\nsouth.exceptions.GhostMigrations: \n\n ! These migrations are in the database but not on disk:\n    <app1: 0033_auto__...>\n    <app1: 0034_fill_...>\n    <app1: 0035_rename_...>\n    <app2: 0003_add_...>\n    <app2: 0004_denormalize_...>\n    <app1: 0033_auto....>\n    <app1: 0034_fill...>\n ! I\'m not trusting myself; either fix this yourself by fiddling\n ! with the south_migrationhistory table, or pass --delete-ghost-migrations\n ! to South to have it delete ALL of these records (this may not be good).\n\'\'\'\n\n\ndef test_match(stderr):\n    assert match(Command(\'./manage.py migrate\', stderr=stderr), None)\n    assert match(Command(\'python manage.py migrate\', stderr=stderr), None)\n    assert not match(Command(\'./manage.py migrate\'), None)\n    assert not match(Command(\'app migrate\', stderr=stderr), None)\n    assert not match(Command(\'./manage.py test\', stderr=stderr), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command(\'./manage.py migrate auth\'), None)\\\n        == \'./manage.py migrate auth --delete-ghost-migrations\'\n', 'import pytest\nfrom thefuck.rules.django_south_merge import match, get_new_command\nfrom tests.utils import Command\n\n\n@pytest.fixture\ndef stderr():\n    return \'\'\'Running migrations for app:\n ! Migration app:0003_auto... should not have been applied before app:0002_auto__add_field_query_due_date_ but was.\nTraceback (most recent call last):\n  File ""/home/nvbn/work/.../bin/python"", line 42, in <module>\n    exec(compile(__file__f.read(), __file__, ""exec""))\n  File ""/home/nvbn/work/.../app/manage.py"", line 34, in <module>\n    execute_from_command_line(sys.argv)\n  File ""/home/nvbn/work/.../lib/django/core/management/__init__.py"", line 443, in execute_from_command_line\n    utility.execute()\n  File ""/home/nvbn/work/.../lib/django/core/management/__init__.py"", line 382, in execute\n    self.fetch_command(subcommand).run_from_argv(self.argv)\n  File ""/home/nvbn/work/.../lib/django/core/management/base.py"", line 196, in run_from_argv\n    self.execute(*args, **options.__dict__)\n  File ""/home/nvbn/work/.../lib/django/core/management/base.py"", line 232, in execute\n    output = self.handle(*args, **options)\n  File ""/home/nvbn/work/.../app/lib/south/management/commands/migrate.py"", line 108, in handle\n    ignore_ghosts = ignore_ghosts,\n  File ""/home/nvbn/work/.../app/lib/south/migration/__init__.py"", line 207, in migrate_app\n    raise exceptions.InconsistentMigrationHistory(problems)\nsouth.exceptions.InconsistentMigrationHistory: Inconsistent migration history\nThe following options are available:\n    --merge: will just attempt the migration ignoring any potential dependency conflicts.\n\'\'\'\n\n\ndef test_match(stderr):\n    assert match(Command(\'./manage.py migrate\', stderr=stderr), None)\n    assert match(Command(\'python manage.py migrate\', stderr=stderr), None)\n    assert not match(Command(\'./manage.py migrate\'), None)\n    assert not match(Command(\'app migrate\', stderr=stderr), None)\n    assert not match(Command(\'./manage.py test\', stderr=stderr), None)\n\n\ndef test_get_new_command():\n    assert get_new_command(Command(\'./manage.py migrate auth\'), None) \\\n           == \'./manage.py migrate auth --merge\'\n', ""def match(command, settings):\n    return 'manage.py' in command.script and \\\n           'migrate' in command.script \\\n           and '--merge: will just attempt the migration' in command.stderr\n\n\ndef get_new_command(command, settings):\n    return u'{} --merge'.format(command.script)\n""]","[[], [<pydriller.domain.commit.Method object at 0x7f19864931c0>, <pydriller.domain.commit.Method object at 0x7f1986493700>, <pydriller.domain.commit.Method object at 0x7f1986493310>], [], []]","[[], [<pydriller.domain.commit.Method object at 0x7f1986493820>], [<pydriller.domain.commit.Method object at 0x7f1986493f40>, <pydriller.domain.commit.Method object at 0x7f1986493eb0>, <pydriller.domain.commit.Method object at 0x7f1986493f10>], [<pydriller.domain.commit.Method object at 0x7f198649c2e0>, <pydriller.domain.commit.Method object at 0x7f198649c340>]]"
