Project Name,Commit Hash,Message,Commit Date,Author Name,Additions,Deletions,Lines changed,Files Changed,Modified files,Original Code,Modified Code,Methods Before,Methods After
Python,6e894ba3e8bab4e9e0515b91e685904ec828cf43,"Odd-Even Transposition Sort (#769)

* -Added a single-threaded implementation of odd-even transposition sort.

This is a modified bubble sort meant to work with multiple processors.
Since this is running on a single thread, it has the same running time
as bubble sort.

* -Added a parallel implementation of Odd-Even Transposition sort

This implementation uses multiprocessing to perform the swaps
at each step of the algorithm simultaneously.",2019-06-07 23:38:43+08:00,CharlesRitter,159,0,159,2,['Odd-Even_transposition_parallel.py'],[None],"['""""""\nThis is an implementation of odd-even transposition sort.\n\nIt works by performing a series of parallel swaps between odd and even pairs of\nvariables in the list.\n\nThis implementation represents each variable in the list with a process and\neach process communicates with its neighboring processes in the list to perform\ncomparisons.\nThey are synchronized with locks and message passing but other forms of\nsynchronization could be used.\n""""""\nfrom multiprocessing import Process, Pipe, Lock\n\n#lock used to ensure that two processes do not access a pipe at the same time\nprocessLock = Lock()\n\n""""""\nThe function run by the processes that sorts the list\n\nposition = the position in the list the prcoess represents, used to know which\n            neighbor we pass our value to\nvalue = the initial value at list[position]\nLSend, RSend = the pipes we use to send to our left and right neighbors\nLRcv, RRcv = the pipes we use to receive from our left and right neighbors\nresultPipe = the pipe used to send results back to main\n""""""\ndef oeProcess(position, value, LSend, RSend, LRcv, RRcv, resultPipe):\n    global processLock\n\n    #we perform n swaps since after n swaps we know we are sorted\n    #we *could* stop early if we are sorted already, but it takes as long to\n    #find out we are sorted as it does to sort the list with this algorithm\n    for i in range(0, 10):\n\n        if( (i + position) % 2 == 0 and RSend != None):\n            #send your value to your right neighbor\n            processLock.acquire()\n            RSend[1].send(value)\n            processLock.release()\n\n            #receive your right neighbor\'s value\n            processLock.acquire()\n            temp = RRcv[0].recv()\n            processLock.release()\n\n            #take the lower value since you are on the left\n            value = min(value, temp)\n        elif( (i + position) % 2 != 0 and LSend != None):\n            #send your value to your left neighbor\n            processLock.acquire()\n            LSend[1].send(value)\n            processLock.release()\n\n            #receive your left neighbor\'s value\n            processLock.acquire()\n            temp = LRcv[0].recv()\n            processLock.release()\n\n            #take the higher value since you are on the right\n            value = max(value, temp)\n    #after all swaps are performed, send the values back to main\n    resultPipe[1].send(value)\n\n""""""\nthe function which creates the processes that perform the parallel swaps\n\narr = the list to be sorted\n""""""\ndef OddEvenTransposition(arr):\n\n    processArray = []\n    tempRrcv = None\n    tempLrcv = None\n\n    resultPipe = []\n\n    #initialize the list of pipes where the values will be retrieved\n    for a in arr:\n        resultPipe.append(Pipe())\n\n    #creates the processes\n    #the first and last process only have one neighbor so they are made outside\n    #of the loop\n    tempRs = Pipe()\n    tempRr = Pipe()\n    processArray.append(Process(target = oeProcess, args = (0, arr[0], None, tempRs, None, tempRr, resultPipe[0])))\n    tempLr = tempRs\n    tempLs = tempRr\n\n    for i in range(1, len(arr) - 1):\n        tempRs = Pipe()\n        tempRr = Pipe()\n        processArray.append(Process(target = oeProcess, args = (i, arr[i], tempLs, tempRs, tempLr, tempRr, resultPipe[i])))\n        tempLr = tempRs\n        tempLs = tempRr\n\n    processArray.append(Process(target = oeProcess, args = (len(arr) - 1, arr[len(arr) - 1], tempLs, None, tempLr, None, resultPipe[len(arr) - 1])))\n\n    #start the processes\n    for p in processArray:\n        p.start()\n\n    #wait for the processes to end and write their values to the list\n    for p in range(0, len(resultPipe)):\n        arr[p] = resultPipe[p][0].recv()\n        processArray[p].join()\n\n    return(arr)\n\n\n#creates a reverse sorted list and sorts it\ndef main():\n    arr = []\n\n    for i in range(10, 0, -1):\n        arr.append(i)\n    print(""Initial List"")\n    print(*arr)\n\n    list = OddEvenTransposition(arr)\n\n    print(""Sorted List\\n"")\n    print(*arr)\n\nif __name__ == ""__main__"":\n    main()\n']",[[]],"[[<pydriller.domain.commit.Method object at 0x7f40daab72e0>, <pydriller.domain.commit.Method object at 0x7f40daab7be0>, <pydriller.domain.commit.Method object at 0x7f40daab7190>]]"
Python,02b717e364cd6623e303d4cc2378d1448779dc2b,"Update odd_even_transposition_parallel.py (#1458)

* Update odd_even_transposition_parallel.py

* arr = OddEvenTransposition(arr)",2019-12-08 23:43:56+01:00,Samarth Sehgal,3,13,16,1,['odd_even_transposition_parallel.py'],"['""""""\nThis is an implementation of odd-even transposition sort.\n\nIt works by performing a series of parallel swaps between odd and even pairs of\nvariables in the list.\n\nThis implementation represents each variable in the list with a process and\neach process communicates with its neighboring processes in the list to perform\ncomparisons.\nThey are synchronized with locks and message passing but other forms of\nsynchronization could be used.\n""""""\nfrom multiprocessing import Process, Pipe, Lock\n\n# lock used to ensure that two processes do not access a pipe at the same time\nprocessLock = Lock()\n\n""""""\nThe function run by the processes that sorts the list\n\nposition = the position in the list the prcoess represents, used to know which\n            neighbor we pass our value to\nvalue = the initial value at list[position]\nLSend, RSend = the pipes we use to send to our left and right neighbors\nLRcv, RRcv = the pipes we use to receive from our left and right neighbors\nresultPipe = the pipe used to send results back to main\n""""""\n\n\ndef oeProcess(position, value, LSend, RSend, LRcv, RRcv, resultPipe):\n    global processLock\n\n    # we perform n swaps since after n swaps we know we are sorted\n    # we *could* stop early if we are sorted already, but it takes as long to\n    # find out we are sorted as it does to sort the list with this algorithm\n    for i in range(0, 10):\n\n        if (i + position) % 2 == 0 and RSend != None:\n            # send your value to your right neighbor\n            processLock.acquire()\n            RSend[1].send(value)\n            processLock.release()\n\n            # receive your right neighbor\'s value\n            processLock.acquire()\n            temp = RRcv[0].recv()\n            processLock.release()\n\n            # take the lower value since you are on the left\n            value = min(value, temp)\n        elif (i + position) % 2 != 0 and LSend != None:\n            # send your value to your left neighbor\n            processLock.acquire()\n            LSend[1].send(value)\n            processLock.release()\n\n            # receive your left neighbor\'s value\n            processLock.acquire()\n            temp = LRcv[0].recv()\n            processLock.release()\n\n            # take the higher value since you are on the right\n            value = max(value, temp)\n    # after all swaps are performed, send the values back to main\n    resultPipe[1].send(value)\n\n\n""""""\nthe function which creates the processes that perform the parallel swaps\n\narr = the list to be sorted\n""""""\n\n\ndef OddEvenTransposition(arr):\n\n    processArray = []\n\n    resultPipe = []\n\n    # initialize the list of pipes where the values will be retrieved\n    for _ in arr:\n        resultPipe.append(Pipe())\n\n    # creates the processes\n    # the first and last process only have one neighbor so they are made outside\n    # of the loop\n    tempRs = Pipe()\n    tempRr = Pipe()\n    processArray.append(\n        Process(\n            target=oeProcess,\n            args=(0, arr[0], None, tempRs, None, tempRr, resultPipe[0]),\n        )\n    )\n    tempLr = tempRs\n    tempLs = tempRr\n\n    for i in range(1, len(arr) - 1):\n        tempRs = Pipe()\n        tempRr = Pipe()\n        processArray.append(\n            Process(\n                target=oeProcess,\n                args=(i, arr[i], tempLs, tempRs, tempLr, tempRr, resultPipe[i]),\n            )\n        )\n        tempLr = tempRs\n        tempLs = tempRr\n\n    processArray.append(\n        Process(\n            target=oeProcess,\n            args=(\n                len(arr) - 1,\n                arr[len(arr) - 1],\n                tempLs,\n                None,\n                tempLr,\n                None,\n                resultPipe[len(arr) - 1],\n            ),\n        )\n    )\n\n    # start the processes\n    for p in processArray:\n        p.start()\n\n    # wait for the processes to end and write their values to the list\n    for p in range(0, len(resultPipe)):\n        arr[p] = resultPipe[p][0].recv()\n        processArray[p].join()\n\n    return arr\n\n\n# creates a reverse sorted list and sorts it\ndef main():\n    arr = []\n\n    for i in range(10, 0, -1):\n        arr.append(i)\n    print(""Initial List"")\n    print(*arr)\n\n    list = OddEvenTransposition(arr)\n\n    print(""Sorted List\\n"")\n    print(*arr)\n\n\nif __name__ == ""__main__"":\n    main()\n']","['""""""\nThis is an implementation of odd-even transposition sort.\n\nIt works by performing a series of parallel swaps between odd and even pairs of\nvariables in the list.\n\nThis implementation represents each variable in the list with a process and\neach process communicates with its neighboring processes in the list to perform\ncomparisons.\nThey are synchronized with locks and message passing but other forms of\nsynchronization could be used.\n""""""\nfrom multiprocessing import Lock, Pipe, Process\n\n# lock used to ensure that two processes do not access a pipe at the same time\nprocessLock = Lock()\n\n""""""\nThe function run by the processes that sorts the list\n\nposition = the position in the list the prcoess represents, used to know which\n            neighbor we pass our value to\nvalue = the initial value at list[position]\nLSend, RSend = the pipes we use to send to our left and right neighbors\nLRcv, RRcv = the pipes we use to receive from our left and right neighbors\nresultPipe = the pipe used to send results back to main\n""""""\n\n\ndef oeProcess(position, value, LSend, RSend, LRcv, RRcv, resultPipe):\n    global processLock\n\n    # we perform n swaps since after n swaps we know we are sorted\n    # we *could* stop early if we are sorted already, but it takes as long to\n    # find out we are sorted as it does to sort the list with this algorithm\n    for i in range(0, 10):\n\n        if (i + position) % 2 == 0 and RSend != None:\n            # send your value to your right neighbor\n            processLock.acquire()\n            RSend[1].send(value)\n            processLock.release()\n\n            # receive your right neighbor\'s value\n            processLock.acquire()\n            temp = RRcv[0].recv()\n            processLock.release()\n\n            # take the lower value since you are on the left\n            value = min(value, temp)\n        elif (i + position) % 2 != 0 and LSend != None:\n            # send your value to your left neighbor\n            processLock.acquire()\n            LSend[1].send(value)\n            processLock.release()\n\n            # receive your left neighbor\'s value\n            processLock.acquire()\n            temp = LRcv[0].recv()\n            processLock.release()\n\n            # take the higher value since you are on the right\n            value = max(value, temp)\n    # after all swaps are performed, send the values back to main\n    resultPipe[1].send(value)\n\n\n""""""\nthe function which creates the processes that perform the parallel swaps\n\narr = the list to be sorted\n""""""\n\n\ndef OddEvenTransposition(arr):\n    processArray = []\n    resultPipe = []\n    # initialize the list of pipes where the values will be retrieved\n    for _ in arr:\n        resultPipe.append(Pipe())\n    # creates the processes\n    # the first and last process only have one neighbor so they are made outside\n    # of the loop\n    tempRs = Pipe()\n    tempRr = Pipe()\n    processArray.append(\n        Process(\n            target=oeProcess,\n            args=(0, arr[0], None, tempRs, None, tempRr, resultPipe[0]),\n        )\n    )\n    tempLr = tempRs\n    tempLs = tempRr\n\n    for i in range(1, len(arr) - 1):\n        tempRs = Pipe()\n        tempRr = Pipe()\n        processArray.append(\n            Process(\n                target=oeProcess,\n                args=(i, arr[i], tempLs, tempRs, tempLr, tempRr, resultPipe[i]),\n            )\n        )\n        tempLr = tempRs\n        tempLs = tempRr\n\n    processArray.append(\n        Process(\n            target=oeProcess,\n            args=(\n                len(arr) - 1,\n                arr[len(arr) - 1],\n                tempLs,\n                None,\n                tempLr,\n                None,\n                resultPipe[len(arr) - 1],\n            ),\n        )\n    )\n\n    # start the processes\n    for p in processArray:\n        p.start()\n\n    # wait for the processes to end and write their values to the list\n    for p in range(0, len(resultPipe)):\n        arr[p] = resultPipe[p][0].recv()\n        processArray[p].join()\n    return arr\n\n\n# creates a reverse sorted list and sorts it\ndef main():\n    arr = list(range(10, 0, -1))\n    print(""Initial List"")\n    print(*arr)\n    arr = OddEvenTransposition(arr)\n    print(""Sorted List\\n"")\n    print(*arr)\n\n\nif __name__ == ""__main__"":\n    main()\n']","[[<pydriller.domain.commit.Method object at 0x7f40db7e5c40>, <pydriller.domain.commit.Method object at 0x7f40db7e55b0>, <pydriller.domain.commit.Method object at 0x7f40db7e5760>]]","[[<pydriller.domain.commit.Method object at 0x7f40db7e5640>, <pydriller.domain.commit.Method object at 0x7f40db7e55b0>]]"
